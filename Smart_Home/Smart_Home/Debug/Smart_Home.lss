
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000298c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000062e  00800060  0000298c  00002a20  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000083  0080068e  0080068e  0000304e  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000304e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000030ac  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000538  00000000  00000000  000030e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005923  00000000  00000000  00003620  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001700  00000000  00000000  00008f43  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003949  00000000  00000000  0000a643  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c90  00000000  00000000  0000df8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000012ad  00000000  00000000  0000ec1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003013  00000000  00000000  0000fec9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000418  00000000  00000000  00012edc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 84 00 	jmp	0x108	; 0x108 <__ctors_end>
       4:	0c 94 0e 0d 	jmp	0x1a1c	; 0x1a1c <__vector_1>
       8:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
       c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      10:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      14:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      18:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      1c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      20:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      24:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      28:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      2c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      30:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      34:	0c 94 93 0c 	jmp	0x1926	; 0x1926 <__vector_13>
      38:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      3c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      40:	0c 94 32 0d 	jmp	0x1a64	; 0x1a64 <__vector_16>
      44:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      48:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      4c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      50:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      54:	d6 04       	cpc	r13, r6
      56:	ea 04       	cpc	r14, r10
      58:	ea 04       	cpc	r14, r10
      5a:	ea 04       	cpc	r14, r10
      5c:	ea 04       	cpc	r14, r10
      5e:	ea 04       	cpc	r14, r10
      60:	ea 04       	cpc	r14, r10
      62:	ea 04       	cpc	r14, r10
      64:	ec 04       	cpc	r14, r12
      66:	ea 04       	cpc	r14, r10
      68:	ea 04       	cpc	r14, r10
      6a:	ea 04       	cpc	r14, r10
      6c:	ea 04       	cpc	r14, r10
      6e:	ea 04       	cpc	r14, r10
      70:	ea 04       	cpc	r14, r10
      72:	ea 04       	cpc	r14, r10
      74:	d8 04       	cpc	r13, r8
      76:	ea 04       	cpc	r14, r10
      78:	ea 04       	cpc	r14, r10
      7a:	ea 04       	cpc	r14, r10
      7c:	ea 04       	cpc	r14, r10
      7e:	ea 04       	cpc	r14, r10
      80:	ea 04       	cpc	r14, r10
      82:	ea 04       	cpc	r14, r10
      84:	da 04       	cpc	r13, r10
      86:	ea 04       	cpc	r14, r10
      88:	ea 04       	cpc	r14, r10
      8a:	ea 04       	cpc	r14, r10
      8c:	ea 04       	cpc	r14, r10
      8e:	ea 04       	cpc	r14, r10
      90:	ea 04       	cpc	r14, r10
      92:	ea 04       	cpc	r14, r10
      94:	dc 04       	cpc	r13, r12
      96:	ea 04       	cpc	r14, r10
      98:	ea 04       	cpc	r14, r10
      9a:	ea 04       	cpc	r14, r10
      9c:	ea 04       	cpc	r14, r10
      9e:	ea 04       	cpc	r14, r10
      a0:	ea 04       	cpc	r14, r10
      a2:	ea 04       	cpc	r14, r10
      a4:	de 04       	cpc	r13, r14
      a6:	ea 04       	cpc	r14, r10
      a8:	ea 04       	cpc	r14, r10
      aa:	ea 04       	cpc	r14, r10
      ac:	ea 04       	cpc	r14, r10
      ae:	ea 04       	cpc	r14, r10
      b0:	ea 04       	cpc	r14, r10
      b2:	ea 04       	cpc	r14, r10
      b4:	e0 04       	cpc	r14, r0
      b6:	ea 04       	cpc	r14, r10
      b8:	ea 04       	cpc	r14, r10
      ba:	ea 04       	cpc	r14, r10
      bc:	ea 04       	cpc	r14, r10
      be:	ea 04       	cpc	r14, r10
      c0:	ea 04       	cpc	r14, r10
      c2:	ea 04       	cpc	r14, r10
      c4:	e2 04       	cpc	r14, r2
      c6:	ea 04       	cpc	r14, r10
      c8:	ea 04       	cpc	r14, r10
      ca:	ea 04       	cpc	r14, r10
      cc:	ea 04       	cpc	r14, r10
      ce:	ea 04       	cpc	r14, r10
      d0:	ea 04       	cpc	r14, r10
      d2:	ea 04       	cpc	r14, r10
      d4:	e4 04       	cpc	r14, r4
      d6:	ea 04       	cpc	r14, r10
      d8:	ea 04       	cpc	r14, r10
      da:	ea 04       	cpc	r14, r10
      dc:	ea 04       	cpc	r14, r10
      de:	ea 04       	cpc	r14, r10
      e0:	ea 04       	cpc	r14, r10
      e2:	ea 04       	cpc	r14, r10
      e4:	e6 04       	cpc	r14, r6
      e6:	ea 04       	cpc	r14, r10
      e8:	ea 04       	cpc	r14, r10
      ea:	ea 04       	cpc	r14, r10
      ec:	ea 04       	cpc	r14, r10
      ee:	ea 04       	cpc	r14, r10
      f0:	ea 04       	cpc	r14, r10
      f2:	ea 04       	cpc	r14, r10
      f4:	e8 04       	cpc	r14, r8
      f6:	d6 08       	sbc	r13, r6
      f8:	dd 08       	sbc	r13, r13
      fa:	e4 08       	sbc	r14, r4
      fc:	eb 08       	sbc	r14, r11
      fe:	f2 08       	sbc	r15, r2
     100:	f9 08       	sbc	r15, r9
     102:	00 09       	sbc	r16, r0
     104:	07 09       	sbc	r16, r7
     106:	0e 09       	sbc	r16, r14

00000108 <__ctors_end>:
     108:	11 24       	eor	r1, r1
     10a:	1f be       	out	0x3f, r1	; 63
     10c:	cf e5       	ldi	r28, 0x5F	; 95
     10e:	d8 e0       	ldi	r29, 0x08	; 8
     110:	de bf       	out	0x3e, r29	; 62
     112:	cd bf       	out	0x3d, r28	; 61

00000114 <__do_copy_data>:
     114:	16 e0       	ldi	r17, 0x06	; 6
     116:	a0 e6       	ldi	r26, 0x60	; 96
     118:	b0 e0       	ldi	r27, 0x00	; 0
     11a:	ec e8       	ldi	r30, 0x8C	; 140
     11c:	f9 e2       	ldi	r31, 0x29	; 41
     11e:	02 c0       	rjmp	.+4      	; 0x124 <__do_copy_data+0x10>
     120:	05 90       	lpm	r0, Z+
     122:	0d 92       	st	X+, r0
     124:	ae 38       	cpi	r26, 0x8E	; 142
     126:	b1 07       	cpc	r27, r17
     128:	d9 f7       	brne	.-10     	; 0x120 <__do_copy_data+0xc>

0000012a <__do_clear_bss>:
     12a:	27 e0       	ldi	r18, 0x07	; 7
     12c:	ae e8       	ldi	r26, 0x8E	; 142
     12e:	b6 e0       	ldi	r27, 0x06	; 6
     130:	01 c0       	rjmp	.+2      	; 0x134 <.do_clear_bss_start>

00000132 <.do_clear_bss_loop>:
     132:	1d 92       	st	X+, r1

00000134 <.do_clear_bss_start>:
     134:	a1 31       	cpi	r26, 0x11	; 17
     136:	b2 07       	cpc	r27, r18
     138:	e1 f7       	brne	.-8      	; 0x132 <.do_clear_bss_loop>
     13a:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <main>
     13e:	0c 94 c4 14 	jmp	0x2988	; 0x2988 <_exit>

00000142 <__bad_interrupt>:
     142:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000146 <Buzzer_on>:
  // Return error code to indicate that the buzzer initialization failed
  return BUZZER_ERROR_INIT;
  }

// Turn on the buzzer
EN_BuzzerError_t Buzzer_on(u8 buzzerPort, u8 buzzerPin) {
     146:	98 2f       	mov	r25, r24
     148:	86 2f       	mov	r24, r22
  if (DIO_write(buzzerPin, buzzerPort, HIGH) == DIO_OK) {
     14a:	41 e0       	ldi	r20, 0x01	; 1
     14c:	69 2f       	mov	r22, r25
     14e:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>
     152:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that attempting to turn on the buzzer has failed
  return BUZZER_ERROR_ON;
     154:	82 e0       	ldi	r24, 0x02	; 2
  }
     156:	08 95       	ret

00000158 <EEPROM_read_byte>:

void EEPROM_init() {
  I2C_init();
  }

void EEPROM_read_byte(u8 page, u8 address, s8* data) {
     158:	0f 93       	push	r16
     15a:	1f 93       	push	r17
     15c:	cf 93       	push	r28
     15e:	df 93       	push	r29
     160:	c8 2f       	mov	r28, r24
     162:	d6 2f       	mov	r29, r22
     164:	8a 01       	movw	r16, r20
  I2C_start();
     166:	0e 94 ee 04 	call	0x9dc	; 0x9dc <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     16a:	cc 0f       	add	r28, r28
     16c:	80 ea       	ldi	r24, 0xA0	; 160
     16e:	8c 0f       	add	r24, r28
     170:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  I2C_write(address);
     174:	8d 2f       	mov	r24, r29
     176:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  I2C_start();
     17a:	0e 94 ee 04 	call	0x9dc	; 0x9dc <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     17e:	81 ea       	ldi	r24, 0xA1	; 161
     180:	8c 0f       	add	r24, r28
     182:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  // read_Ack will halt the reading here, because it will send the next byte, which will not be received and wait for ack, which will not be sent. 
  // Nack must be sent after the arrival of the last requested byte. It's used basically to indicate that no further data transmission is required and then the stop condition is sent
  I2C_read_Nack(data);
     186:	c8 01       	movw	r24, r16
     188:	0e 94 0a 05 	call	0xa14	; 0xa14 <I2C_read_Nack>
  I2C_stop();
     18c:	0e 94 15 05 	call	0xa2a	; 0xa2a <I2C_stop>
  }
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	1f 91       	pop	r17
     196:	0f 91       	pop	r16
     198:	08 95       	ret

0000019a <EEPROM_read_block>:

void EEPROM_read_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     19a:	ef 92       	push	r14
     19c:	ff 92       	push	r15
     19e:	0f 93       	push	r16
     1a0:	1f 93       	push	r17
     1a2:	cf 93       	push	r28
     1a4:	df 93       	push	r29
     1a6:	c8 2f       	mov	r28, r24
     1a8:	d6 2f       	mov	r29, r22
     1aa:	7a 01       	movw	r14, r20
     1ac:	89 01       	movw	r16, r18
  u16 i;
  for (i = 0;i < bytes_number;i++) {
    EEPROM_read_byte(page, address + i, &data[i]);
    }
#elif READ_BLOCK_METHOD == MULTIBYTE
  I2C_start();
     1ae:	0e 94 ee 04 	call	0x9dc	; 0x9dc <I2C_start>
  I2C_write(0xA0 + (page << 1));
     1b2:	cc 0f       	add	r28, r28
     1b4:	80 ea       	ldi	r24, 0xA0	; 160
     1b6:	8c 0f       	add	r24, r28
     1b8:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  I2C_write(address);
     1bc:	8d 2f       	mov	r24, r29
     1be:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  I2C_start();
     1c2:	0e 94 ee 04 	call	0x9dc	; 0x9dc <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     1c6:	81 ea       	ldi	r24, 0xA1	; 161
     1c8:	8c 0f       	add	r24, r28
     1ca:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1ce:	c0 e0       	ldi	r28, 0x00	; 0
     1d0:	d0 e0       	ldi	r29, 0x00	; 0
     1d2:	06 c0       	rjmp	.+12     	; 0x1e0 <EEPROM_read_block+0x46>
    I2C_read_Ack(&data[i]);
     1d4:	c8 01       	movw	r24, r16
     1d6:	8c 0f       	add	r24, r28
     1d8:	9d 1f       	adc	r25, r29
     1da:	0e 94 ff 04 	call	0x9fe	; 0x9fe <I2C_read_Ack>
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  I2C_start();
  I2C_write(0xA0 + (page << 1) + 1);
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1de:	21 96       	adiw	r28, 0x01	; 1
     1e0:	c7 01       	movw	r24, r14
     1e2:	01 97       	sbiw	r24, 0x01	; 1
     1e4:	c8 17       	cp	r28, r24
     1e6:	d9 07       	cpc	r29, r25
     1e8:	a8 f3       	brcs	.-22     	; 0x1d4 <EEPROM_read_block+0x3a>
    I2C_read_Ack(&data[i]);
    }
  I2C_read_Nack(&data[i]);
     1ea:	c8 01       	movw	r24, r16
     1ec:	8c 0f       	add	r24, r28
     1ee:	9d 1f       	adc	r25, r29
     1f0:	0e 94 0a 05 	call	0xa14	; 0xa14 <I2C_read_Nack>
  I2C_stop();
     1f4:	0e 94 15 05 	call	0xa2a	; 0xa2a <I2C_stop>
#endif
  }
     1f8:	df 91       	pop	r29
     1fa:	cf 91       	pop	r28
     1fc:	1f 91       	pop	r17
     1fe:	0f 91       	pop	r16
     200:	ff 90       	pop	r15
     202:	ef 90       	pop	r14
     204:	08 95       	ret

00000206 <EEPROM_write_byte>:

void EEPROM_write_byte(u8 page, u8 address, s8 data) {
     206:	1f 93       	push	r17
     208:	cf 93       	push	r28
     20a:	df 93       	push	r29
     20c:	c8 2f       	mov	r28, r24
     20e:	16 2f       	mov	r17, r22
     210:	d4 2f       	mov	r29, r20
  I2C_start();
     212:	0e 94 ee 04 	call	0x9dc	; 0x9dc <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     216:	8c 2f       	mov	r24, r28
     218:	88 0f       	add	r24, r24
     21a:	80 56       	subi	r24, 0x60	; 96
     21c:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  I2C_write(address);
     220:	81 2f       	mov	r24, r17
     222:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  I2C_write(data);
     226:	8d 2f       	mov	r24, r29
     228:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  I2C_stop();
     22c:	0e 94 15 05 	call	0xa2a	; 0xa2a <I2C_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     230:	8f e3       	ldi	r24, 0x3F	; 63
     232:	9c e9       	ldi	r25, 0x9C	; 156
     234:	01 97       	sbiw	r24, 0x01	; 1
     236:	f1 f7       	brne	.-4      	; 0x234 <EEPROM_write_byte+0x2e>
     238:	00 c0       	rjmp	.+0      	; 0x23a <EEPROM_write_byte+0x34>
     23a:	00 00       	nop

#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
  }
     23c:	df 91       	pop	r29
     23e:	cf 91       	pop	r28
     240:	1f 91       	pop	r17
     242:	08 95       	ret

00000244 <EEPROM_write_block>:

// bytes_number must be within page size (256 bytes)
void EEPROM_write_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     244:	6f 92       	push	r6
     246:	7f 92       	push	r7
     248:	8f 92       	push	r8
     24a:	9f 92       	push	r9
     24c:	af 92       	push	r10
     24e:	bf 92       	push	r11
     250:	cf 92       	push	r12
     252:	df 92       	push	r13
     254:	ef 92       	push	r14
     256:	ff 92       	push	r15
     258:	0f 93       	push	r16
     25a:	1f 93       	push	r17
     25c:	cf 93       	push	r28
     25e:	df 93       	push	r29
     260:	78 2e       	mov	r7, r24
     262:	66 2e       	mov	r6, r22
     264:	6a 01       	movw	r12, r20
     266:	89 01       	movw	r16, r18
  //! If data is required to be written in the first 16 bytes starting from byte 10 for example, the data will be stored starting from bytes 10, 
  //! and if the data exceeds the row limit ** IT WILL ROLL OVER AND OVERWRITE THE ROW **. Therefore, in a single multibyte write cycle, we can't write more than 16 bytes at maximum if starting from the first byte in the row
  //! or the remaining bytes till the end of the row from the starting position. The remaining bytes must be written in another write cycle to avoind the roll over problem.

  u16 dataIndex, blockNumber, i;
  u16 first_block_size = 16 - (address % 16);
     268:	86 2f       	mov	r24, r22
     26a:	8f 70       	andi	r24, 0x0F	; 15
     26c:	20 e1       	ldi	r18, 0x10	; 16
     26e:	30 e0       	ldi	r19, 0x00	; 0
     270:	79 01       	movw	r14, r18
     272:	e8 1a       	sub	r14, r24
     274:	f1 08       	sbc	r15, r1
  if (16 - (address % 16) > bytes_number) first_block_size = bytes_number;
     276:	4e 15       	cp	r20, r14
     278:	5f 05       	cpc	r21, r15
     27a:	08 f4       	brcc	.+2      	; 0x27e <EEPROM_write_block+0x3a>
     27c:	7a 01       	movw	r14, r20

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
     27e:	0e 94 ee 04 	call	0x9dc	; 0x9dc <I2C_start>
  I2C_write(0xA0 + (page << 1));
     282:	87 2d       	mov	r24, r7
     284:	88 0f       	add	r24, r24
     286:	0f 2e       	mov	r0, r31
     288:	f0 ea       	ldi	r31, 0xA0	; 160
     28a:	7f 2e       	mov	r7, r31
     28c:	f0 2d       	mov	r31, r0
     28e:	78 0e       	add	r7, r24
     290:	87 2d       	mov	r24, r7
     292:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  I2C_write(address);
     296:	86 2d       	mov	r24, r6
     298:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     29c:	c0 e0       	ldi	r28, 0x00	; 0
     29e:	d0 e0       	ldi	r29, 0x00	; 0
     2a0:	07 c0       	rjmp	.+14     	; 0x2b0 <EEPROM_write_block+0x6c>
    I2C_write(data[dataIndex]);
     2a2:	f8 01       	movw	r30, r16
     2a4:	ec 0f       	add	r30, r28
     2a6:	fd 1f       	adc	r31, r29
     2a8:	80 81       	ld	r24, Z
     2aa:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2ae:	21 96       	adiw	r28, 0x01	; 1
     2b0:	ce 15       	cp	r28, r14
     2b2:	df 05       	cpc	r29, r15
     2b4:	b0 f3       	brcs	.-20     	; 0x2a2 <EEPROM_write_block+0x5e>
    I2C_write(data[dataIndex]);
    }
  I2C_stop();
     2b6:	0e 94 15 05 	call	0xa2a	; 0xa2a <I2C_stop>
     2ba:	8f e3       	ldi	r24, 0x3F	; 63
     2bc:	9c e9       	ldi	r25, 0x9C	; 156
     2be:	01 97       	sbiw	r24, 0x01	; 1
     2c0:	f1 f7       	brne	.-4      	; 0x2be <EEPROM_write_block+0x7a>
     2c2:	00 c0       	rjmp	.+0      	; 0x2c4 <EEPROM_write_block+0x80>
     2c4:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif

  // Return if the data fits in the row (data fits in a single row or the remaining part of it after the address)
  if (first_block_size == bytes_number) return;
     2c6:	ec 14       	cp	r14, r12
     2c8:	fd 04       	cpc	r15, r13
     2ca:	09 f4       	brne	.+2      	; 0x2ce <EEPROM_write_block+0x8a>
     2cc:	61 c0       	rjmp	.+194    	; 0x390 <EEPROM_write_block+0x14c>

  u16 last_block_size = (address + bytes_number) % 16;
     2ce:	56 01       	movw	r10, r12
     2d0:	a6 0c       	add	r10, r6
     2d2:	b1 1c       	adc	r11, r1
     2d4:	9f e0       	ldi	r25, 0x0F	; 15
     2d6:	a9 22       	and	r10, r25
     2d8:	bb 24       	eor	r11, r11
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
     2da:	ce 18       	sub	r12, r14
     2dc:	df 08       	sbc	r13, r15
     2de:	ca 18       	sub	r12, r10
     2e0:	db 08       	sbc	r13, r11
     2e2:	d6 94       	lsr	r13
     2e4:	c7 94       	ror	r12
     2e6:	d6 94       	lsr	r13
     2e8:	c7 94       	ror	r12
     2ea:	d6 94       	lsr	r13
     2ec:	c7 94       	ror	r12
     2ee:	d6 94       	lsr	r13
     2f0:	c7 94       	ror	r12
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     2f2:	e1 2c       	mov	r14, r1
     2f4:	f1 2c       	mov	r15, r1
     2f6:	27 c0       	rjmp	.+78     	; 0x346 <EEPROM_write_block+0x102>
    I2C_start();
     2f8:	0e 94 ee 04 	call	0x9dc	; 0x9dc <I2C_start>
    I2C_write(0xA0 + (page << 1));
     2fc:	87 2d       	mov	r24, r7
     2fe:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
    I2C_write(address + dataIndex);
     302:	8c 2f       	mov	r24, r28
     304:	86 0d       	add	r24, r6
     306:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
    for (i = 0;i < 16;i++) {
     30a:	81 2c       	mov	r8, r1
     30c:	91 2c       	mov	r9, r1
     30e:	0b c0       	rjmp	.+22     	; 0x326 <EEPROM_write_block+0xe2>
      I2C_write(data[dataIndex + i]);
     310:	fe 01       	movw	r30, r28
     312:	e8 0d       	add	r30, r8
     314:	f9 1d       	adc	r31, r9
     316:	e0 0f       	add	r30, r16
     318:	f1 1f       	adc	r31, r17
     31a:	80 81       	ld	r24, Z
     31c:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
    I2C_start();
    I2C_write(0xA0 + (page << 1));
    I2C_write(address + dataIndex);
    for (i = 0;i < 16;i++) {
     320:	8f ef       	ldi	r24, 0xFF	; 255
     322:	88 1a       	sub	r8, r24
     324:	98 0a       	sbc	r9, r24
     326:	90 e1       	ldi	r25, 0x10	; 16
     328:	89 16       	cp	r8, r25
     32a:	91 04       	cpc	r9, r1
     32c:	88 f3       	brcs	.-30     	; 0x310 <EEPROM_write_block+0xcc>
      I2C_write(data[dataIndex + i]);
      }
    dataIndex += 16;
     32e:	60 96       	adiw	r28, 0x10	; 16
    I2C_stop();
     330:	0e 94 15 05 	call	0xa2a	; 0xa2a <I2C_stop>
     334:	8f e3       	ldi	r24, 0x3F	; 63
     336:	9c e9       	ldi	r25, 0x9C	; 156
     338:	01 97       	sbiw	r24, 0x01	; 1
     33a:	f1 f7       	brne	.-4      	; 0x338 <EEPROM_write_block+0xf4>
     33c:	00 c0       	rjmp	.+0      	; 0x33e <EEPROM_write_block+0xfa>
     33e:	00 00       	nop
  if (first_block_size == bytes_number) return;

  u16 last_block_size = (address + bytes_number) % 16;
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     340:	9f ef       	ldi	r25, 0xFF	; 255
     342:	e9 1a       	sub	r14, r25
     344:	f9 0a       	sbc	r15, r25
     346:	ec 14       	cp	r14, r12
     348:	fd 04       	cpc	r15, r13
     34a:	b0 f2       	brcs	.-84     	; 0x2f8 <EEPROM_write_block+0xb4>
    _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
    }

  // Write the last part of the data
  I2C_start();
     34c:	0e 94 ee 04 	call	0x9dc	; 0x9dc <I2C_start>
  I2C_write(0xA0 + (page << 1));
     350:	87 2d       	mov	r24, r7
     352:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  I2C_write(address + dataIndex);
     356:	8c 2f       	mov	r24, r28
     358:	86 0d       	add	r24, r6
     35a:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>
  for (i = 0;i < last_block_size;i++) {
     35e:	e1 2c       	mov	r14, r1
     360:	f1 2c       	mov	r15, r1
     362:	0b c0       	rjmp	.+22     	; 0x37a <EEPROM_write_block+0x136>
    I2C_write(data[dataIndex + i]);
     364:	fe 01       	movw	r30, r28
     366:	ee 0d       	add	r30, r14
     368:	ff 1d       	adc	r31, r15
     36a:	e0 0f       	add	r30, r16
     36c:	f1 1f       	adc	r31, r17
     36e:	80 81       	ld	r24, Z
     370:	0e 94 f6 04 	call	0x9ec	; 0x9ec <I2C_write>

  // Write the last part of the data
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address + dataIndex);
  for (i = 0;i < last_block_size;i++) {
     374:	8f ef       	ldi	r24, 0xFF	; 255
     376:	e8 1a       	sub	r14, r24
     378:	f8 0a       	sbc	r15, r24
     37a:	ea 14       	cp	r14, r10
     37c:	fb 04       	cpc	r15, r11
     37e:	90 f3       	brcs	.-28     	; 0x364 <EEPROM_write_block+0x120>
    I2C_write(data[dataIndex + i]);
    }
  I2C_stop();
     380:	0e 94 15 05 	call	0xa2a	; 0xa2a <I2C_stop>
     384:	8f e3       	ldi	r24, 0x3F	; 63
     386:	9c e9       	ldi	r25, 0x9C	; 156
     388:	01 97       	sbiw	r24, 0x01	; 1
     38a:	f1 f7       	brne	.-4      	; 0x388 <EEPROM_write_block+0x144>
     38c:	00 c0       	rjmp	.+0      	; 0x38e <EEPROM_write_block+0x14a>
     38e:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
#endif
     390:	df 91       	pop	r29
     392:	cf 91       	pop	r28
     394:	1f 91       	pop	r17
     396:	0f 91       	pop	r16
     398:	ff 90       	pop	r15
     39a:	ef 90       	pop	r14
     39c:	df 90       	pop	r13
     39e:	cf 90       	pop	r12
     3a0:	bf 90       	pop	r11
     3a2:	af 90       	pop	r10
     3a4:	9f 90       	pop	r9
     3a6:	8f 90       	pop	r8
     3a8:	7f 90       	pop	r7
     3aa:	6f 90       	pop	r6
     3ac:	08 95       	ret

000003ae <BT_sendChar>:
  DIO_init(HC_05_STATUS_PIN, HC_05_STATUS_PORT, IN);
  UART_init(baudRate);
  }

void BT_sendChar(s8 data) {
  UART_sendChar(data);
     3ae:	0e 94 fe 07 	call	0xffc	; 0xffc <UART_sendChar>
     3b2:	08 95       	ret

000003b4 <BT_sendString>:
  }

void BT_sendString(s8* str) {
  UART_sendString(str);
     3b4:	0e 94 04 08 	call	0x1008	; 0x1008 <UART_sendString>
     3b8:	08 95       	ret

000003ba <LCD_sendEnablePulse>:
#include "lcd.h"

 // TODO: implement the eight bit mode

void LCD_sendEnablePulse(void) {
  DIO_write(EN, LCD_CTRL_PORT, HIGH);
     3ba:	41 e0       	ldi	r20, 0x01	; 1
     3bc:	61 e4       	ldi	r22, 0x41	; 65
     3be:	86 e0       	ldi	r24, 0x06	; 6
     3c0:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3c4:	8a e1       	ldi	r24, 0x1A	; 26
     3c6:	8a 95       	dec	r24
     3c8:	f1 f7       	brne	.-4      	; 0x3c6 <LCD_sendEnablePulse+0xc>
     3ca:	00 c0       	rjmp	.+0      	; 0x3cc <LCD_sendEnablePulse+0x12>
  _delay_us(5);
  DIO_write(EN, LCD_CTRL_PORT, LOW);
     3cc:	40 e0       	ldi	r20, 0x00	; 0
     3ce:	61 e4       	ldi	r22, 0x41	; 65
     3d0:	86 e0       	ldi	r24, 0x06	; 6
     3d2:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>
     3d6:	08 95       	ret

000003d8 <LCD_write_4bits>:
  }

void LCD_write_4bits(u8 data) {
     3d8:	cf 93       	push	r28
     3da:	c8 2f       	mov	r28, r24
  DIO_write(LCD_DATA_PIN4, LCD_DATA_PORT, read_bit(data, 0));
     3dc:	48 2f       	mov	r20, r24
     3de:	41 70       	andi	r20, 0x01	; 1
     3e0:	61 e4       	ldi	r22, 0x41	; 65
     3e2:	80 e0       	ldi	r24, 0x00	; 0
     3e4:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>
  DIO_write(LCD_DATA_PIN5, LCD_DATA_PORT, read_bit(data, 1));
     3e8:	c1 fb       	bst	r28, 1
     3ea:	44 27       	eor	r20, r20
     3ec:	40 f9       	bld	r20, 0
     3ee:	61 e4       	ldi	r22, 0x41	; 65
     3f0:	81 e0       	ldi	r24, 0x01	; 1
     3f2:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>
  DIO_write(LCD_DATA_PIN6, LCD_DATA_PORT, read_bit(data, 2));
     3f6:	c2 fb       	bst	r28, 2
     3f8:	44 27       	eor	r20, r20
     3fa:	40 f9       	bld	r20, 0
     3fc:	61 e4       	ldi	r22, 0x41	; 65
     3fe:	82 e0       	ldi	r24, 0x02	; 2
     400:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>
  DIO_write(LCD_DATA_PIN7, LCD_DATA_PORT, read_bit(data, 3));
     404:	c3 fb       	bst	r28, 3
     406:	44 27       	eor	r20, r20
     408:	40 f9       	bld	r20, 0
     40a:	61 e4       	ldi	r22, 0x41	; 65
     40c:	83 e0       	ldi	r24, 0x03	; 3
     40e:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>
  }
     412:	cf 91       	pop	r28
     414:	08 95       	ret

00000416 <LCD_sendData>:

void LCD_sendData(u8 data) {
     416:	cf 93       	push	r28
     418:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(data >> 4);
     41a:	82 95       	swap	r24
     41c:	8f 70       	andi	r24, 0x0F	; 15
     41e:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, HIGH); // To indicate that this data
     422:	41 e0       	ldi	r20, 0x01	; 1
     424:	61 e4       	ldi	r22, 0x41	; 65
     426:	84 e0       	ldi	r24, 0x04	; 4
     428:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>

  LCD_sendEnablePulse();
     42c:	0e 94 dd 01 	call	0x3ba	; 0x3ba <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the data to be sent

  LCD_write_4bits(data);
     430:	8c 2f       	mov	r24, r28
     432:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <LCD_write_4bits>

  LCD_sendEnablePulse();
     436:	0e 94 dd 01 	call	0x3ba	; 0x3ba <LCD_sendEnablePulse>
     43a:	85 e0       	ldi	r24, 0x05	; 5
     43c:	8a 95       	dec	r24
     43e:	f1 f7       	brne	.-4      	; 0x43c <LCD_sendData+0x26>
     440:	00 00       	nop

  _delay_us(1); // wait for the data to be processed
#else

#endif
  }
     442:	cf 91       	pop	r28
     444:	08 95       	ret

00000446 <LCD_sendCommand>:

void LCD_sendCommand(u8 cmd) {
     446:	cf 93       	push	r28
     448:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(cmd >> 4);
     44a:	82 95       	swap	r24
     44c:	8f 70       	andi	r24, 0x0F	; 15
     44e:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, LOW); // To indicate that this a command
     452:	40 e0       	ldi	r20, 0x00	; 0
     454:	61 e4       	ldi	r22, 0x41	; 65
     456:	84 e0       	ldi	r24, 0x04	; 4
     458:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>

  LCD_sendEnablePulse();
     45c:	0e 94 dd 01 	call	0x3ba	; 0x3ba <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the command to be sent

  LCD_write_4bits(cmd);
     460:	8c 2f       	mov	r24, r28
     462:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <LCD_write_4bits>

  LCD_sendEnablePulse();
     466:	0e 94 dd 01 	call	0x3ba	; 0x3ba <LCD_sendEnablePulse>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     46a:	8f ed       	ldi	r24, 0xDF	; 223
     46c:	9e e2       	ldi	r25, 0x2E	; 46
     46e:	01 97       	sbiw	r24, 0x01	; 1
     470:	f1 f7       	brne	.-4      	; 0x46e <LCD_sendCommand+0x28>
     472:	00 c0       	rjmp	.+0      	; 0x474 <LCD_sendCommand+0x2e>
     474:	00 00       	nop

  _delay_ms(3); // wait for the command to be executed
#else

#endif
  }
     476:	cf 91       	pop	r28
     478:	08 95       	ret

0000047a <LCD_clear_screen>:

void LCD_clear_screen() {
  LCD_sendCommand(0x01);
     47a:	81 e0       	ldi	r24, 0x01	; 1
     47c:	0e 94 23 02 	call	0x446	; 0x446 <LCD_sendCommand>
     480:	08 95       	ret

00000482 <LCD_init>:
     482:	2f ef       	ldi	r18, 0xFF	; 255
     484:	89 ef       	ldi	r24, 0xF9	; 249
     486:	90 e0       	ldi	r25, 0x00	; 0
     488:	21 50       	subi	r18, 0x01	; 1
     48a:	80 40       	sbci	r24, 0x00	; 0
     48c:	90 40       	sbci	r25, 0x00	; 0
     48e:	e1 f7       	brne	.-8      	; 0x488 <LCD_init+0x6>
     490:	00 c0       	rjmp	.+0      	; 0x492 <LCD_init+0x10>
     492:	00 00       	nop

void LCD_init(void) {
  _delay_ms(20); // wait for the LCD to start up.

#if LCD_MODE == FOUR_BIT_MODE
  DIO_init(LCD_DATA_PIN4, LCD_DATA_PORT, OUT);
     494:	41 e0       	ldi	r20, 0x01	; 1
     496:	61 e4       	ldi	r22, 0x41	; 65
     498:	80 e0       	ldi	r24, 0x00	; 0
     49a:	0e 94 3e 03 	call	0x67c	; 0x67c <DIO_init>
  DIO_init(LCD_DATA_PIN5, LCD_DATA_PORT, OUT);
     49e:	41 e0       	ldi	r20, 0x01	; 1
     4a0:	61 e4       	ldi	r22, 0x41	; 65
     4a2:	81 e0       	ldi	r24, 0x01	; 1
     4a4:	0e 94 3e 03 	call	0x67c	; 0x67c <DIO_init>
  DIO_init(LCD_DATA_PIN6, LCD_DATA_PORT, OUT);
     4a8:	41 e0       	ldi	r20, 0x01	; 1
     4aa:	61 e4       	ldi	r22, 0x41	; 65
     4ac:	82 e0       	ldi	r24, 0x02	; 2
     4ae:	0e 94 3e 03 	call	0x67c	; 0x67c <DIO_init>
  DIO_init(LCD_DATA_PIN7, LCD_DATA_PORT, OUT);
     4b2:	41 e0       	ldi	r20, 0x01	; 1
     4b4:	61 e4       	ldi	r22, 0x41	; 65
     4b6:	83 e0       	ldi	r24, 0x03	; 3
     4b8:	0e 94 3e 03 	call	0x67c	; 0x67c <DIO_init>

  DIO_init(RS, LCD_CTRL_PORT, OUT);
     4bc:	41 e0       	ldi	r20, 0x01	; 1
     4be:	61 e4       	ldi	r22, 0x41	; 65
     4c0:	84 e0       	ldi	r24, 0x04	; 4
     4c2:	0e 94 3e 03 	call	0x67c	; 0x67c <DIO_init>
  DIO_init(RW, LCD_CTRL_PORT, OUT);
     4c6:	41 e0       	ldi	r20, 0x01	; 1
     4c8:	61 e4       	ldi	r22, 0x41	; 65
     4ca:	85 e0       	ldi	r24, 0x05	; 5
     4cc:	0e 94 3e 03 	call	0x67c	; 0x67c <DIO_init>
  DIO_init(EN, LCD_CTRL_PORT, OUT);
     4d0:	41 e0       	ldi	r20, 0x01	; 1
     4d2:	61 e4       	ldi	r22, 0x41	; 65
     4d4:	86 e0       	ldi	r24, 0x06	; 6
     4d6:	0e 94 3e 03 	call	0x67c	; 0x67c <DIO_init>

  DIO_write(RW, LCD_CTRL_PORT, LOW);
     4da:	40 e0       	ldi	r20, 0x00	; 0
     4dc:	61 e4       	ldi	r22, 0x41	; 65
     4de:	85 e0       	ldi	r24, 0x05	; 5
     4e0:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>

  LCD_sendCommand(0x02);  // return home 
     4e4:	82 e0       	ldi	r24, 0x02	; 2
     4e6:	0e 94 23 02 	call	0x446	; 0x446 <LCD_sendCommand>
  LCD_sendCommand(0x28);  // 2 line  and 4 bit mode
     4ea:	88 e2       	ldi	r24, 0x28	; 40
     4ec:	0e 94 23 02 	call	0x446	; 0x446 <LCD_sendCommand>
  LCD_sendCommand(0x0C);  // display on 
     4f0:	8c e0       	ldi	r24, 0x0C	; 12
     4f2:	0e 94 23 02 	call	0x446	; 0x446 <LCD_sendCommand>
  LCD_sendCommand(0x06);  // auto increment 
     4f6:	86 e0       	ldi	r24, 0x06	; 6
     4f8:	0e 94 23 02 	call	0x446	; 0x446 <LCD_sendCommand>
  LCD_clear_screen();
     4fc:	0e 94 3d 02 	call	0x47a	; 0x47a <LCD_clear_screen>
     500:	08 95       	ret

00000502 <LCD_sendString>:
#else

#endif
  }

void LCD_sendString(s8* str) {
     502:	cf 92       	push	r12
     504:	df 92       	push	r13
     506:	ef 92       	push	r14
     508:	ff 92       	push	r15
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	ec 01       	movw	r28, r24
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     510:	c1 2c       	mov	r12, r1
     512:	d1 2c       	mov	r13, r1
     514:	76 01       	movw	r14, r12
     516:	07 c0       	rjmp	.+14     	; 0x526 <LCD_sendString+0x24>
    LCD_sendData(str[i]);
     518:	0e 94 0b 02 	call	0x416	; 0x416 <LCD_sendData>
#endif
  }

void LCD_sendString(s8* str) {
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     51c:	8f ef       	ldi	r24, 0xFF	; 255
     51e:	c8 1a       	sub	r12, r24
     520:	d8 0a       	sbc	r13, r24
     522:	e8 0a       	sbc	r14, r24
     524:	f8 0a       	sbc	r15, r24
     526:	fe 01       	movw	r30, r28
     528:	ec 0d       	add	r30, r12
     52a:	fd 1d       	adc	r31, r13
     52c:	80 81       	ld	r24, Z
     52e:	81 11       	cpse	r24, r1
     530:	f3 cf       	rjmp	.-26     	; 0x518 <LCD_sendString+0x16>
    LCD_sendData(str[i]);
    }
  }
     532:	df 91       	pop	r29
     534:	cf 91       	pop	r28
     536:	ff 90       	pop	r15
     538:	ef 90       	pop	r14
     53a:	df 90       	pop	r13
     53c:	cf 90       	pop	r12
     53e:	08 95       	ret

00000540 <LCD_writeString_xy>:

void LCD_writeString_xy(u8 x, u8 y, s8* str) {
     540:	cf 93       	push	r28
     542:	df 93       	push	r29
     544:	ea 01       	movw	r28, r20
  switch (y) {
     546:	66 23       	and	r22, r22
     548:	19 f0       	breq	.+6      	; 0x550 <LCD_writeString_xy+0x10>
     54a:	61 30       	cpi	r22, 0x01	; 1
     54c:	29 f0       	breq	.+10     	; 0x558 <LCD_writeString_xy+0x18>
     54e:	07 c0       	rjmp	.+14     	; 0x55e <LCD_writeString_xy+0x1e>
      case 0:
        LCD_sendCommand(0x80 + x);
     550:	80 58       	subi	r24, 0x80	; 128
     552:	0e 94 23 02 	call	0x446	; 0x446 <LCD_sendCommand>
        break;
     556:	03 c0       	rjmp	.+6      	; 0x55e <LCD_writeString_xy+0x1e>
      case 1:
        LCD_sendCommand(0xC0 + x);
     558:	80 54       	subi	r24, 0x40	; 64
     55a:	0e 94 23 02 	call	0x446	; 0x446 <LCD_sendCommand>
        break;
    }
  LCD_sendString(str);
     55e:	ce 01       	movw	r24, r28
     560:	0e 94 81 02 	call	0x502	; 0x502 <LCD_sendString>
  // TODO: Input validation
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	08 95       	ret

0000056a <LED_init>:
 */

#include "led.h"

 // Initialize the LED
EN_ledError_t LED_init(u8 ledPort, u8 ledPin) {
     56a:	98 2f       	mov	r25, r24
     56c:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(ledPin, ledPort, OUT) == DIO_OK) {
     56e:	41 e0       	ldi	r20, 0x01	; 1
     570:	69 2f       	mov	r22, r25
     572:	0e 94 3e 03 	call	0x67c	; 0x67c <DIO_init>
     576:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that the led initialization failed
  return LED_ERROR_INIT;
     578:	81 e0       	ldi	r24, 0x01	; 1
  }
     57a:	08 95       	ret

0000057c <LED_on>:

// Turn on the LED
EN_ledError_t LED_on(u8 ledPort, u8 ledPin) {
     57c:	98 2f       	mov	r25, r24
     57e:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, HIGH) == DIO_OK) {
     580:	41 e0       	ldi	r20, 0x01	; 1
     582:	69 2f       	mov	r22, r25
     584:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>
     588:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn on the led has failed
  return LED_ERROR_ON;
     58a:	82 e0       	ldi	r24, 0x02	; 2
  }
     58c:	08 95       	ret

0000058e <LED_off>:

// Turn off the LED
EN_ledError_t LED_off(u8 ledPort, u8 ledPin) {
     58e:	98 2f       	mov	r25, r24
     590:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, LOW) == DIO_OK) {
     592:	40 e0       	ldi	r20, 0x00	; 0
     594:	69 2f       	mov	r22, r25
     596:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>
     59a:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn off the led has failed
  return LED_ERROR_OFF;
     59c:	83 e0       	ldi	r24, 0x03	; 3
  }
     59e:	08 95       	ret

000005a0 <Servo_move_to_angle>:
  Timer_start(TIMER_1, 8);
  }

// Moves the servo to a specific angle (relative to the 0 angle position, not the previous one).
void Servo_move_to_angle(u8 angle) {
  PWM_set_DC(SERVO_PWM_PIN, ((double)angle / ((SERVO_MAX_ANGLE - SERVO_MIN_ANGLE) * (SERVO_PULSE_PERIODIC_TIME_mS / (SERVO_MAX_HIGH_PULSE_DURATION_mS - SERVO_MIN_HIGH_PULSE_DURATION_mS)))) + (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS));
     5a0:	68 2f       	mov	r22, r24
     5a2:	70 e0       	ldi	r23, 0x00	; 0
     5a4:	80 e0       	ldi	r24, 0x00	; 0
     5a6:	90 e0       	ldi	r25, 0x00	; 0
     5a8:	0e 94 c9 10 	call	0x2192	; 0x2192 <__floatunsisf>
     5ac:	20 e0       	ldi	r18, 0x00	; 0
     5ae:	30 e0       	ldi	r19, 0x00	; 0
     5b0:	41 ee       	ldi	r20, 0xE1	; 225
     5b2:	54 e4       	ldi	r21, 0x44	; 68
     5b4:	0e 94 28 10 	call	0x2050	; 0x2050 <__divsf3>
     5b8:	2d ec       	ldi	r18, 0xCD	; 205
     5ba:	3c ec       	ldi	r19, 0xCC	; 204
     5bc:	4c ec       	ldi	r20, 0xCC	; 204
     5be:	5c e3       	ldi	r21, 0x3C	; 60
     5c0:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <__addsf3>
     5c4:	ab 01       	movw	r20, r22
     5c6:	bc 01       	movw	r22, r24
     5c8:	81 e0       	ldi	r24, 0x01	; 1
     5ca:	0e 94 bf 07 	call	0xf7e	; 0xf7e <PWM_set_DC>
     5ce:	08 95       	ret

000005d0 <main>:
 */

#include "Application/app.h"

int main(void) {
	LCD_init();
     5d0:	0e 94 41 02 	call	0x482	; 0x482 <LCD_init>
	Lamps_init();
     5d4:	0e 94 2d 08 	call	0x105a	; 0x105a <Lamps_init>
	Lamp_on(3);
     5d8:	83 e0       	ldi	r24, 0x03	; 3
     5da:	0e 94 52 08 	call	0x10a4	; 0x10a4 <Lamp_on>
	Get_running_devices();
     5de:	0e 94 ae 08 	call	0x115c	; 0x115c <Get_running_devices>
	Show_running_devices(1);
     5e2:	81 e0       	ldi	r24, 0x01	; 1
     5e4:	0e 94 15 09 	call	0x122a	; 0x122a <Show_running_devices>
     5e8:	2f ef       	ldi	r18, 0xFF	; 255
     5ea:	89 e6       	ldi	r24, 0x69	; 105
     5ec:	98 e1       	ldi	r25, 0x18	; 24
     5ee:	21 50       	subi	r18, 0x01	; 1
     5f0:	80 40       	sbci	r24, 0x00	; 0
     5f2:	90 40       	sbci	r25, 0x00	; 0
     5f4:	e1 f7       	brne	.-8      	; 0x5ee <main+0x1e>
     5f6:	00 c0       	rjmp	.+0      	; 0x5f8 <main+0x28>
     5f8:	00 00       	nop
	_delay_ms(500);
	Show_running_devices(2);
     5fa:	82 e0       	ldi	r24, 0x02	; 2
     5fc:	0e 94 15 09 	call	0x122a	; 0x122a <Show_running_devices>
     600:	2f ef       	ldi	r18, 0xFF	; 255
     602:	89 e6       	ldi	r24, 0x69	; 105
     604:	98 e1       	ldi	r25, 0x18	; 24
     606:	21 50       	subi	r18, 0x01	; 1
     608:	80 40       	sbci	r24, 0x00	; 0
     60a:	90 40       	sbci	r25, 0x00	; 0
     60c:	e1 f7       	brne	.-8      	; 0x606 <main+0x36>
     60e:	00 c0       	rjmp	.+0      	; 0x610 <main+0x40>
     610:	00 00       	nop
	_delay_ms(500);
	Show_running_devices(3);
     612:	83 e0       	ldi	r24, 0x03	; 3
     614:	0e 94 15 09 	call	0x122a	; 0x122a <Show_running_devices>
     618:	2f ef       	ldi	r18, 0xFF	; 255
     61a:	89 e6       	ldi	r24, 0x69	; 105
     61c:	98 e1       	ldi	r25, 0x18	; 24
     61e:	21 50       	subi	r18, 0x01	; 1
     620:	80 40       	sbci	r24, 0x00	; 0
     622:	90 40       	sbci	r25, 0x00	; 0
     624:	e1 f7       	brne	.-8      	; 0x61e <main+0x4e>
     626:	00 c0       	rjmp	.+0      	; 0x628 <main+0x58>
     628:	00 00       	nop
	_delay_ms(500);
	Show_running_devices(4);
     62a:	84 e0       	ldi	r24, 0x04	; 4
     62c:	0e 94 15 09 	call	0x122a	; 0x122a <Show_running_devices>
     630:	2f ef       	ldi	r18, 0xFF	; 255
     632:	89 e6       	ldi	r24, 0x69	; 105
     634:	98 e1       	ldi	r25, 0x18	; 24
     636:	21 50       	subi	r18, 0x01	; 1
     638:	80 40       	sbci	r24, 0x00	; 0
     63a:	90 40       	sbci	r25, 0x00	; 0
     63c:	e1 f7       	brne	.-8      	; 0x636 <main+0x66>
     63e:	00 c0       	rjmp	.+0      	; 0x640 <main+0x70>
     640:	00 00       	nop
	_delay_ms(500);
	Show_running_devices(7);
     642:	87 e0       	ldi	r24, 0x07	; 7
     644:	0e 94 15 09 	call	0x122a	; 0x122a <Show_running_devices>
     648:	ff cf       	rjmp	.-2      	; 0x648 <main+0x78>

0000064a <isValidPinNumber>:
 */

#include "dio.h"

bool isValidPinNumber(u8 pinNumber) {
	if (pinNumber < 8) {
     64a:	88 30       	cpi	r24, 0x08	; 8
     64c:	10 f4       	brcc	.+4      	; 0x652 <isValidPinNumber+0x8>
		return true;
     64e:	81 e0       	ldi	r24, 0x01	; 1
     650:	08 95       	ret
		}
	return false;
     652:	80 e0       	ldi	r24, 0x00	; 0
	}
     654:	08 95       	ret

00000656 <isValidPortNumber>:

bool isValidPortNumber(u8 portNumber) {
	if (portNumber == PORT_A || portNumber == PORT_B || portNumber == PORT_C || portNumber == PORT_D) {
     656:	81 54       	subi	r24, 0x41	; 65
     658:	84 30       	cpi	r24, 0x04	; 4
     65a:	10 f4       	brcc	.+4      	; 0x660 <isValidPortNumber+0xa>
		return true;
     65c:	81 e0       	ldi	r24, 0x01	; 1
     65e:	08 95       	ret
		}
	return false;
     660:	80 e0       	ldi	r24, 0x00	; 0
	}
     662:	08 95       	ret

00000664 <isValidDirection>:

bool isValidDirection(u8 direction) {
	if (direction == IN || direction == OUT) {
     664:	82 30       	cpi	r24, 0x02	; 2
     666:	10 f4       	brcc	.+4      	; 0x66c <isValidDirection+0x8>
		return true;
     668:	81 e0       	ldi	r24, 0x01	; 1
     66a:	08 95       	ret
		}
	return false;
     66c:	80 e0       	ldi	r24, 0x00	; 0
	}
     66e:	08 95       	ret

00000670 <isValidState>:

bool isValidState(u8 state) {
	if (state == HIGH || state == LOW) {
     670:	82 30       	cpi	r24, 0x02	; 2
     672:	10 f4       	brcc	.+4      	; 0x678 <isValidState+0x8>
		return true;
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	08 95       	ret
		}
	return false;
     678:	80 e0       	ldi	r24, 0x00	; 0
	}
     67a:	08 95       	ret

0000067c <DIO_init>:

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
     67c:	1f 93       	push	r17
     67e:	cf 93       	push	r28
     680:	df 93       	push	r29
     682:	c8 2f       	mov	r28, r24
     684:	d6 2f       	mov	r29, r22
     686:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     688:	0e 94 25 03 	call	0x64a	; 0x64a <isValidPinNumber>
     68c:	88 23       	and	r24, r24
     68e:	09 f4       	brne	.+2      	; 0x692 <DIO_init+0x16>
     690:	84 c0       	rjmp	.+264    	; 0x79a <DIO_init+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     692:	8d 2f       	mov	r24, r29
     694:	0e 94 2b 03 	call	0x656	; 0x656 <isValidPortNumber>
     698:	88 23       	and	r24, r24
     69a:	09 f4       	brne	.+2      	; 0x69e <DIO_init+0x22>
     69c:	80 c0       	rjmp	.+256    	; 0x79e <DIO_init+0x122>
		return WRONG_PORT;
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
     69e:	81 2f       	mov	r24, r17
     6a0:	0e 94 32 03 	call	0x664	; 0x664 <isValidDirection>
     6a4:	88 23       	and	r24, r24
     6a6:	09 f4       	brne	.+2      	; 0x6aa <DIO_init+0x2e>
     6a8:	7c c0       	rjmp	.+248    	; 0x7a2 <DIO_init+0x126>
		return WRONG_DIRECTION;
		}
	switch (portNumber) {
     6aa:	d2 34       	cpi	r29, 0x42	; 66
     6ac:	29 f1       	breq	.+74     	; 0x6f8 <DIO_init+0x7c>
     6ae:	18 f4       	brcc	.+6      	; 0x6b6 <DIO_init+0x3a>
     6b0:	d1 34       	cpi	r29, 0x41	; 65
     6b2:	39 f0       	breq	.+14     	; 0x6c2 <DIO_init+0x46>
     6b4:	78 c0       	rjmp	.+240    	; 0x7a6 <DIO_init+0x12a>
     6b6:	d3 34       	cpi	r29, 0x43	; 67
     6b8:	d1 f1       	breq	.+116    	; 0x72e <DIO_init+0xb2>
     6ba:	d4 34       	cpi	r29, 0x44	; 68
     6bc:	09 f4       	brne	.+2      	; 0x6c0 <DIO_init+0x44>
     6be:	52 c0       	rjmp	.+164    	; 0x764 <DIO_init+0xe8>
     6c0:	72 c0       	rjmp	.+228    	; 0x7a6 <DIO_init+0x12a>
			case PORT_A:
				if (direction == OUT) {
     6c2:	11 30       	cpi	r17, 0x01	; 1
     6c4:	61 f4       	brne	.+24     	; 0x6de <DIO_init+0x62>
					set_bit(DDRA, pinNumber);
     6c6:	2a b3       	in	r18, 0x1a	; 26
     6c8:	81 e0       	ldi	r24, 0x01	; 1
     6ca:	90 e0       	ldi	r25, 0x00	; 0
     6cc:	02 c0       	rjmp	.+4      	; 0x6d2 <DIO_init+0x56>
     6ce:	88 0f       	add	r24, r24
     6d0:	99 1f       	adc	r25, r25
     6d2:	ca 95       	dec	r28
     6d4:	e2 f7       	brpl	.-8      	; 0x6ce <DIO_init+0x52>
     6d6:	82 2b       	or	r24, r18
     6d8:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     6da:	80 e0       	ldi	r24, 0x00	; 0
     6dc:	65 c0       	rjmp	.+202    	; 0x7a8 <DIO_init+0x12c>
			case PORT_A:
				if (direction == OUT) {
					set_bit(DDRA, pinNumber);
					}
				else {
					clear_bit(DDRA, pinNumber);
     6de:	2a b3       	in	r18, 0x1a	; 26
     6e0:	81 e0       	ldi	r24, 0x01	; 1
     6e2:	90 e0       	ldi	r25, 0x00	; 0
     6e4:	02 c0       	rjmp	.+4      	; 0x6ea <DIO_init+0x6e>
     6e6:	88 0f       	add	r24, r24
     6e8:	99 1f       	adc	r25, r25
     6ea:	ca 95       	dec	r28
     6ec:	e2 f7       	brpl	.-8      	; 0x6e6 <DIO_init+0x6a>
     6ee:	80 95       	com	r24
     6f0:	82 23       	and	r24, r18
     6f2:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     6f4:	80 e0       	ldi	r24, 0x00	; 0
     6f6:	58 c0       	rjmp	.+176    	; 0x7a8 <DIO_init+0x12c>
				else {
					clear_bit(DDRA, pinNumber);
					}
				break;
			case PORT_B:
				if (direction == OUT) {
     6f8:	11 30       	cpi	r17, 0x01	; 1
     6fa:	61 f4       	brne	.+24     	; 0x714 <DIO_init+0x98>
					set_bit(DDRB, pinNumber);
     6fc:	27 b3       	in	r18, 0x17	; 23
     6fe:	81 e0       	ldi	r24, 0x01	; 1
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	02 c0       	rjmp	.+4      	; 0x708 <DIO_init+0x8c>
     704:	88 0f       	add	r24, r24
     706:	99 1f       	adc	r25, r25
     708:	ca 95       	dec	r28
     70a:	e2 f7       	brpl	.-8      	; 0x704 <DIO_init+0x88>
     70c:	82 2b       	or	r24, r18
     70e:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     710:	80 e0       	ldi	r24, 0x00	; 0
     712:	4a c0       	rjmp	.+148    	; 0x7a8 <DIO_init+0x12c>
			case PORT_B:
				if (direction == OUT) {
					set_bit(DDRB, pinNumber);
					}
				else {
					clear_bit(DDRB, pinNumber);
     714:	27 b3       	in	r18, 0x17	; 23
     716:	81 e0       	ldi	r24, 0x01	; 1
     718:	90 e0       	ldi	r25, 0x00	; 0
     71a:	02 c0       	rjmp	.+4      	; 0x720 <DIO_init+0xa4>
     71c:	88 0f       	add	r24, r24
     71e:	99 1f       	adc	r25, r25
     720:	ca 95       	dec	r28
     722:	e2 f7       	brpl	.-8      	; 0x71c <DIO_init+0xa0>
     724:	80 95       	com	r24
     726:	82 23       	and	r24, r18
     728:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     72a:	80 e0       	ldi	r24, 0x00	; 0
     72c:	3d c0       	rjmp	.+122    	; 0x7a8 <DIO_init+0x12c>
				else {
					clear_bit(DDRB, pinNumber);
					}
				break;
			case PORT_C:
				if (direction == OUT) {
     72e:	11 30       	cpi	r17, 0x01	; 1
     730:	61 f4       	brne	.+24     	; 0x74a <DIO_init+0xce>
					set_bit(DDRC, pinNumber);
     732:	24 b3       	in	r18, 0x14	; 20
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	90 e0       	ldi	r25, 0x00	; 0
     738:	02 c0       	rjmp	.+4      	; 0x73e <DIO_init+0xc2>
     73a:	88 0f       	add	r24, r24
     73c:	99 1f       	adc	r25, r25
     73e:	ca 95       	dec	r28
     740:	e2 f7       	brpl	.-8      	; 0x73a <DIO_init+0xbe>
     742:	82 2b       	or	r24, r18
     744:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     746:	80 e0       	ldi	r24, 0x00	; 0
     748:	2f c0       	rjmp	.+94     	; 0x7a8 <DIO_init+0x12c>
			case PORT_C:
				if (direction == OUT) {
					set_bit(DDRC, pinNumber);
					}
				else {
					clear_bit(DDRC, pinNumber);
     74a:	24 b3       	in	r18, 0x14	; 20
     74c:	81 e0       	ldi	r24, 0x01	; 1
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	02 c0       	rjmp	.+4      	; 0x756 <DIO_init+0xda>
     752:	88 0f       	add	r24, r24
     754:	99 1f       	adc	r25, r25
     756:	ca 95       	dec	r28
     758:	e2 f7       	brpl	.-8      	; 0x752 <DIO_init+0xd6>
     75a:	80 95       	com	r24
     75c:	82 23       	and	r24, r18
     75e:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     760:	80 e0       	ldi	r24, 0x00	; 0
     762:	22 c0       	rjmp	.+68     	; 0x7a8 <DIO_init+0x12c>
				else {
					clear_bit(DDRC, pinNumber);
					}
				break;
			case PORT_D:
				if (direction == OUT) {
     764:	11 30       	cpi	r17, 0x01	; 1
     766:	61 f4       	brne	.+24     	; 0x780 <DIO_init+0x104>
					set_bit(DDRD, pinNumber);
     768:	21 b3       	in	r18, 0x11	; 17
     76a:	81 e0       	ldi	r24, 0x01	; 1
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	02 c0       	rjmp	.+4      	; 0x774 <DIO_init+0xf8>
     770:	88 0f       	add	r24, r24
     772:	99 1f       	adc	r25, r25
     774:	ca 95       	dec	r28
     776:	e2 f7       	brpl	.-8      	; 0x770 <DIO_init+0xf4>
     778:	82 2b       	or	r24, r18
     77a:	81 bb       	out	0x11, r24	; 17
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     77c:	80 e0       	ldi	r24, 0x00	; 0
     77e:	14 c0       	rjmp	.+40     	; 0x7a8 <DIO_init+0x12c>
			case PORT_D:
				if (direction == OUT) {
					set_bit(DDRD, pinNumber);
					}
				else {
					clear_bit(DDRD, pinNumber);
     780:	21 b3       	in	r18, 0x11	; 17
     782:	81 e0       	ldi	r24, 0x01	; 1
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	02 c0       	rjmp	.+4      	; 0x78c <DIO_init+0x110>
     788:	88 0f       	add	r24, r24
     78a:	99 1f       	adc	r25, r25
     78c:	ca 95       	dec	r28
     78e:	e2 f7       	brpl	.-8      	; 0x788 <DIO_init+0x10c>
     790:	80 95       	com	r24
     792:	82 23       	and	r24, r18
     794:	81 bb       	out	0x11, r24	; 17
					}
				break;
		}
	return DIO_OK;
     796:	80 e0       	ldi	r24, 0x00	; 0
     798:	07 c0       	rjmp	.+14     	; 0x7a8 <DIO_init+0x12c>

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     79a:	81 e0       	ldi	r24, 0x01	; 1
     79c:	05 c0       	rjmp	.+10     	; 0x7a8 <DIO_init+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     79e:	82 e0       	ldi	r24, 0x02	; 2
     7a0:	03 c0       	rjmp	.+6      	; 0x7a8 <DIO_init+0x12c>
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
		return WRONG_DIRECTION;
     7a2:	83 e0       	ldi	r24, 0x03	; 3
     7a4:	01 c0       	rjmp	.+2      	; 0x7a8 <DIO_init+0x12c>
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     7a6:	80 e0       	ldi	r24, 0x00	; 0
	}
     7a8:	df 91       	pop	r29
     7aa:	cf 91       	pop	r28
     7ac:	1f 91       	pop	r17
     7ae:	08 95       	ret

000007b0 <DIO_write>:

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
     7b0:	1f 93       	push	r17
     7b2:	cf 93       	push	r28
     7b4:	df 93       	push	r29
     7b6:	c8 2f       	mov	r28, r24
     7b8:	d6 2f       	mov	r29, r22
     7ba:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     7bc:	0e 94 25 03 	call	0x64a	; 0x64a <isValidPinNumber>
     7c0:	88 23       	and	r24, r24
     7c2:	09 f4       	brne	.+2      	; 0x7c6 <DIO_write+0x16>
     7c4:	84 c0       	rjmp	.+264    	; 0x8ce <__stack+0x6f>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     7c6:	8d 2f       	mov	r24, r29
     7c8:	0e 94 2b 03 	call	0x656	; 0x656 <isValidPortNumber>
     7cc:	88 23       	and	r24, r24
     7ce:	09 f4       	brne	.+2      	; 0x7d2 <DIO_write+0x22>
     7d0:	80 c0       	rjmp	.+256    	; 0x8d2 <__stack+0x73>
		return WRONG_PORT;
		}
	// Validate the pin state
	if (!isValidState(state)) {
     7d2:	81 2f       	mov	r24, r17
     7d4:	0e 94 38 03 	call	0x670	; 0x670 <isValidState>
     7d8:	88 23       	and	r24, r24
     7da:	09 f4       	brne	.+2      	; 0x7de <DIO_write+0x2e>
     7dc:	7c c0       	rjmp	.+248    	; 0x8d6 <__stack+0x77>
		return WRONG_STATE;
		}
	switch (portNumber) {
     7de:	d2 34       	cpi	r29, 0x42	; 66
     7e0:	29 f1       	breq	.+74     	; 0x82c <__DATA_REGION_LENGTH__+0x2c>
     7e2:	18 f4       	brcc	.+6      	; 0x7ea <DIO_write+0x3a>
     7e4:	d1 34       	cpi	r29, 0x41	; 65
     7e6:	39 f0       	breq	.+14     	; 0x7f6 <DIO_write+0x46>
     7e8:	78 c0       	rjmp	.+240    	; 0x8da <__stack+0x7b>
     7ea:	d3 34       	cpi	r29, 0x43	; 67
     7ec:	d1 f1       	breq	.+116    	; 0x862 <__stack+0x3>
     7ee:	d4 34       	cpi	r29, 0x44	; 68
     7f0:	09 f4       	brne	.+2      	; 0x7f4 <DIO_write+0x44>
     7f2:	52 c0       	rjmp	.+164    	; 0x898 <__stack+0x39>
     7f4:	72 c0       	rjmp	.+228    	; 0x8da <__stack+0x7b>
			case PORT_A:
				if (state == HIGH) {
     7f6:	11 30       	cpi	r17, 0x01	; 1
     7f8:	61 f4       	brne	.+24     	; 0x812 <__DATA_REGION_LENGTH__+0x12>
					set_bit(PORTA, pinNumber);
     7fa:	2b b3       	in	r18, 0x1b	; 27
     7fc:	81 e0       	ldi	r24, 0x01	; 1
     7fe:	90 e0       	ldi	r25, 0x00	; 0
     800:	02 c0       	rjmp	.+4      	; 0x806 <__DATA_REGION_LENGTH__+0x6>
     802:	88 0f       	add	r24, r24
     804:	99 1f       	adc	r25, r25
     806:	ca 95       	dec	r28
     808:	e2 f7       	brpl	.-8      	; 0x802 <__DATA_REGION_LENGTH__+0x2>
     80a:	82 2b       	or	r24, r18
     80c:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     80e:	80 e0       	ldi	r24, 0x00	; 0
     810:	65 c0       	rjmp	.+202    	; 0x8dc <__stack+0x7d>
			case PORT_A:
				if (state == HIGH) {
					set_bit(PORTA, pinNumber);
					}
				else {
					clear_bit(PORTA, pinNumber);
     812:	2b b3       	in	r18, 0x1b	; 27
     814:	81 e0       	ldi	r24, 0x01	; 1
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	02 c0       	rjmp	.+4      	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
     81a:	88 0f       	add	r24, r24
     81c:	99 1f       	adc	r25, r25
     81e:	ca 95       	dec	r28
     820:	e2 f7       	brpl	.-8      	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
     822:	80 95       	com	r24
     824:	82 23       	and	r24, r18
     826:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     828:	80 e0       	ldi	r24, 0x00	; 0
     82a:	58 c0       	rjmp	.+176    	; 0x8dc <__stack+0x7d>
				else {
					clear_bit(PORTA, pinNumber);
					}
				break;
			case PORT_B:
				if (state == HIGH) {
     82c:	11 30       	cpi	r17, 0x01	; 1
     82e:	61 f4       	brne	.+24     	; 0x848 <__DATA_REGION_LENGTH__+0x48>
					set_bit(PORTB, pinNumber);
     830:	28 b3       	in	r18, 0x18	; 24
     832:	81 e0       	ldi	r24, 0x01	; 1
     834:	90 e0       	ldi	r25, 0x00	; 0
     836:	02 c0       	rjmp	.+4      	; 0x83c <__DATA_REGION_LENGTH__+0x3c>
     838:	88 0f       	add	r24, r24
     83a:	99 1f       	adc	r25, r25
     83c:	ca 95       	dec	r28
     83e:	e2 f7       	brpl	.-8      	; 0x838 <__DATA_REGION_LENGTH__+0x38>
     840:	82 2b       	or	r24, r18
     842:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     844:	80 e0       	ldi	r24, 0x00	; 0
     846:	4a c0       	rjmp	.+148    	; 0x8dc <__stack+0x7d>
			case PORT_B:
				if (state == HIGH) {
					set_bit(PORTB, pinNumber);
					}
				else {
					clear_bit(PORTB, pinNumber);
     848:	28 b3       	in	r18, 0x18	; 24
     84a:	81 e0       	ldi	r24, 0x01	; 1
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	02 c0       	rjmp	.+4      	; 0x854 <__DATA_REGION_LENGTH__+0x54>
     850:	88 0f       	add	r24, r24
     852:	99 1f       	adc	r25, r25
     854:	ca 95       	dec	r28
     856:	e2 f7       	brpl	.-8      	; 0x850 <__DATA_REGION_LENGTH__+0x50>
     858:	80 95       	com	r24
     85a:	82 23       	and	r24, r18
     85c:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     85e:	80 e0       	ldi	r24, 0x00	; 0
     860:	3d c0       	rjmp	.+122    	; 0x8dc <__stack+0x7d>
				else {
					clear_bit(PORTB, pinNumber);
					}
				break;
			case PORT_C:
				if (state == HIGH) {
     862:	11 30       	cpi	r17, 0x01	; 1
     864:	61 f4       	brne	.+24     	; 0x87e <__stack+0x1f>
					set_bit(PORTC, pinNumber);
     866:	25 b3       	in	r18, 0x15	; 21
     868:	81 e0       	ldi	r24, 0x01	; 1
     86a:	90 e0       	ldi	r25, 0x00	; 0
     86c:	02 c0       	rjmp	.+4      	; 0x872 <__stack+0x13>
     86e:	88 0f       	add	r24, r24
     870:	99 1f       	adc	r25, r25
     872:	ca 95       	dec	r28
     874:	e2 f7       	brpl	.-8      	; 0x86e <__stack+0xf>
     876:	82 2b       	or	r24, r18
     878:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     87a:	80 e0       	ldi	r24, 0x00	; 0
     87c:	2f c0       	rjmp	.+94     	; 0x8dc <__stack+0x7d>
			case PORT_C:
				if (state == HIGH) {
					set_bit(PORTC, pinNumber);
					}
				else {
					clear_bit(PORTC, pinNumber);
     87e:	25 b3       	in	r18, 0x15	; 21
     880:	81 e0       	ldi	r24, 0x01	; 1
     882:	90 e0       	ldi	r25, 0x00	; 0
     884:	02 c0       	rjmp	.+4      	; 0x88a <__stack+0x2b>
     886:	88 0f       	add	r24, r24
     888:	99 1f       	adc	r25, r25
     88a:	ca 95       	dec	r28
     88c:	e2 f7       	brpl	.-8      	; 0x886 <__stack+0x27>
     88e:	80 95       	com	r24
     890:	82 23       	and	r24, r18
     892:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     894:	80 e0       	ldi	r24, 0x00	; 0
     896:	22 c0       	rjmp	.+68     	; 0x8dc <__stack+0x7d>
				else {
					clear_bit(PORTC, pinNumber);
					}
				break;
			case PORT_D:
				if (state == HIGH) {
     898:	11 30       	cpi	r17, 0x01	; 1
     89a:	61 f4       	brne	.+24     	; 0x8b4 <__stack+0x55>
					set_bit(PORTD, pinNumber);
     89c:	22 b3       	in	r18, 0x12	; 18
     89e:	81 e0       	ldi	r24, 0x01	; 1
     8a0:	90 e0       	ldi	r25, 0x00	; 0
     8a2:	02 c0       	rjmp	.+4      	; 0x8a8 <__stack+0x49>
     8a4:	88 0f       	add	r24, r24
     8a6:	99 1f       	adc	r25, r25
     8a8:	ca 95       	dec	r28
     8aa:	e2 f7       	brpl	.-8      	; 0x8a4 <__stack+0x45>
     8ac:	82 2b       	or	r24, r18
     8ae:	82 bb       	out	0x12, r24	; 18
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	14 c0       	rjmp	.+40     	; 0x8dc <__stack+0x7d>
			case PORT_D:
				if (state == HIGH) {
					set_bit(PORTD, pinNumber);
					}
				else {
					clear_bit(PORTD, pinNumber);
     8b4:	22 b3       	in	r18, 0x12	; 18
     8b6:	81 e0       	ldi	r24, 0x01	; 1
     8b8:	90 e0       	ldi	r25, 0x00	; 0
     8ba:	02 c0       	rjmp	.+4      	; 0x8c0 <__stack+0x61>
     8bc:	88 0f       	add	r24, r24
     8be:	99 1f       	adc	r25, r25
     8c0:	ca 95       	dec	r28
     8c2:	e2 f7       	brpl	.-8      	; 0x8bc <__stack+0x5d>
     8c4:	80 95       	com	r24
     8c6:	82 23       	and	r24, r18
     8c8:	82 bb       	out	0x12, r24	; 18
					}
				break;
		}
	return DIO_OK;
     8ca:	80 e0       	ldi	r24, 0x00	; 0
     8cc:	07 c0       	rjmp	.+14     	; 0x8dc <__stack+0x7d>

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	05 c0       	rjmp	.+10     	; 0x8dc <__stack+0x7d>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     8d2:	82 e0       	ldi	r24, 0x02	; 2
     8d4:	03 c0       	rjmp	.+6      	; 0x8dc <__stack+0x7d>
		}
	// Validate the pin state
	if (!isValidState(state)) {
		return WRONG_STATE;
     8d6:	84 e0       	ldi	r24, 0x04	; 4
     8d8:	01 c0       	rjmp	.+2      	; 0x8dc <__stack+0x7d>
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     8da:	80 e0       	ldi	r24, 0x00	; 0
	}
     8dc:	df 91       	pop	r29
     8de:	cf 91       	pop	r28
     8e0:	1f 91       	pop	r17
     8e2:	08 95       	ret

000008e4 <DIO_Read>:

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
     8e4:	0f 93       	push	r16
     8e6:	1f 93       	push	r17
     8e8:	cf 93       	push	r28
     8ea:	df 93       	push	r29
     8ec:	d8 2f       	mov	r29, r24
     8ee:	c6 2f       	mov	r28, r22
     8f0:	8a 01       	movw	r16, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     8f2:	0e 94 25 03 	call	0x64a	; 0x64a <isValidPinNumber>
     8f6:	88 23       	and	r24, r24
     8f8:	09 f4       	brne	.+2      	; 0x8fc <DIO_Read+0x18>
     8fa:	40 c0       	rjmp	.+128    	; 0x97c <DIO_Read+0x98>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     8fc:	8c 2f       	mov	r24, r28
     8fe:	0e 94 2b 03 	call	0x656	; 0x656 <isValidPortNumber>
     902:	88 23       	and	r24, r24
     904:	e9 f1       	breq	.+122    	; 0x980 <DIO_Read+0x9c>
		return WRONG_PORT;
		}
	switch (portNumber) {
     906:	c2 34       	cpi	r28, 0x42	; 66
     908:	a9 f0       	breq	.+42     	; 0x934 <DIO_Read+0x50>
     90a:	18 f4       	brcc	.+6      	; 0x912 <DIO_Read+0x2e>
     90c:	c1 34       	cpi	r28, 0x41	; 65
     90e:	31 f0       	breq	.+12     	; 0x91c <DIO_Read+0x38>
     910:	39 c0       	rjmp	.+114    	; 0x984 <DIO_Read+0xa0>
     912:	c3 34       	cpi	r28, 0x43	; 67
     914:	d9 f0       	breq	.+54     	; 0x94c <DIO_Read+0x68>
     916:	c4 34       	cpi	r28, 0x44	; 68
     918:	29 f1       	breq	.+74     	; 0x964 <DIO_Read+0x80>
     91a:	34 c0       	rjmp	.+104    	; 0x984 <DIO_Read+0xa0>
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
     91c:	89 b3       	in	r24, 0x19	; 25
     91e:	90 e0       	ldi	r25, 0x00	; 0
     920:	02 c0       	rjmp	.+4      	; 0x926 <DIO_Read+0x42>
     922:	95 95       	asr	r25
     924:	87 95       	ror	r24
     926:	da 95       	dec	r29
     928:	e2 f7       	brpl	.-8      	; 0x922 <DIO_Read+0x3e>
     92a:	81 70       	andi	r24, 0x01	; 1
     92c:	f8 01       	movw	r30, r16
     92e:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     930:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
     932:	29 c0       	rjmp	.+82     	; 0x986 <DIO_Read+0xa2>
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
     934:	86 b3       	in	r24, 0x16	; 22
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	02 c0       	rjmp	.+4      	; 0x93e <DIO_Read+0x5a>
     93a:	95 95       	asr	r25
     93c:	87 95       	ror	r24
     93e:	da 95       	dec	r29
     940:	e2 f7       	brpl	.-8      	; 0x93a <DIO_Read+0x56>
     942:	81 70       	andi	r24, 0x01	; 1
     944:	f8 01       	movw	r30, r16
     946:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     948:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
     94a:	1d c0       	rjmp	.+58     	; 0x986 <DIO_Read+0xa2>
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
     94c:	83 b3       	in	r24, 0x13	; 19
     94e:	90 e0       	ldi	r25, 0x00	; 0
     950:	02 c0       	rjmp	.+4      	; 0x956 <DIO_Read+0x72>
     952:	95 95       	asr	r25
     954:	87 95       	ror	r24
     956:	da 95       	dec	r29
     958:	e2 f7       	brpl	.-8      	; 0x952 <DIO_Read+0x6e>
     95a:	81 70       	andi	r24, 0x01	; 1
     95c:	f8 01       	movw	r30, r16
     95e:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     960:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
     962:	11 c0       	rjmp	.+34     	; 0x986 <DIO_Read+0xa2>
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
     964:	80 b3       	in	r24, 0x10	; 16
     966:	90 e0       	ldi	r25, 0x00	; 0
     968:	02 c0       	rjmp	.+4      	; 0x96e <DIO_Read+0x8a>
     96a:	95 95       	asr	r25
     96c:	87 95       	ror	r24
     96e:	da 95       	dec	r29
     970:	e2 f7       	brpl	.-8      	; 0x96a <DIO_Read+0x86>
     972:	81 70       	andi	r24, 0x01	; 1
     974:	f8 01       	movw	r30, r16
     976:	80 83       	st	Z, r24
				break;
		}
	return DIO_OK;
     978:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
     97a:	05 c0       	rjmp	.+10     	; 0x986 <DIO_Read+0xa2>

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     97c:	81 e0       	ldi	r24, 0x01	; 1
     97e:	03 c0       	rjmp	.+6      	; 0x986 <DIO_Read+0xa2>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     980:	82 e0       	ldi	r24, 0x02	; 2
     982:	01 c0       	rjmp	.+2      	; 0x986 <DIO_Read+0xa2>
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     984:	80 e0       	ldi	r24, 0x00	; 0
	}
     986:	df 91       	pop	r29
     988:	cf 91       	pop	r28
     98a:	1f 91       	pop	r17
     98c:	0f 91       	pop	r16
     98e:	08 95       	ret

00000990 <getCurrentStatus>:

EN_I2CMasterStatusCode_t I2C_repeatedStart() {   // Same as start, just a different name
  TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  while (read_bit(TWCR, TWINT) == 0);
  return getCurrentStatus();
  }
     990:	81 b1       	in	r24, 0x01	; 1
     992:	e8 2f       	mov	r30, r24
     994:	e8 7f       	andi	r30, 0xF8	; 248
     996:	8e 2f       	mov	r24, r30
     998:	90 e0       	ldi	r25, 0x00	; 0
     99a:	fc 01       	movw	r30, r24
     99c:	38 97       	sbiw	r30, 0x08	; 8
     99e:	e1 35       	cpi	r30, 0x51	; 81
     9a0:	f1 05       	cpc	r31, r1
     9a2:	c0 f4       	brcc	.+48     	; 0x9d4 <getCurrentStatus+0x44>
     9a4:	e6 5d       	subi	r30, 0xD6	; 214
     9a6:	ff 4f       	sbci	r31, 0xFF	; 255
     9a8:	0c 94 c4 11 	jmp	0x2388	; 0x2388 <__tablejump2__>
     9ac:	80 e0       	ldi	r24, 0x00	; 0
     9ae:	08 95       	ret
     9b0:	82 e0       	ldi	r24, 0x02	; 2
     9b2:	08 95       	ret
     9b4:	83 e0       	ldi	r24, 0x03	; 3
     9b6:	08 95       	ret
     9b8:	84 e0       	ldi	r24, 0x04	; 4
     9ba:	08 95       	ret
     9bc:	85 e0       	ldi	r24, 0x05	; 5
     9be:	08 95       	ret
     9c0:	86 e0       	ldi	r24, 0x06	; 6
     9c2:	08 95       	ret
     9c4:	87 e0       	ldi	r24, 0x07	; 7
     9c6:	08 95       	ret
     9c8:	88 e0       	ldi	r24, 0x08	; 8
     9ca:	08 95       	ret
     9cc:	89 e0       	ldi	r24, 0x09	; 9
     9ce:	08 95       	ret
     9d0:	8a e0       	ldi	r24, 0x0A	; 10
     9d2:	08 95       	ret
     9d4:	8b e0       	ldi	r24, 0x0B	; 11
     9d6:	08 95       	ret
     9d8:	81 e0       	ldi	r24, 0x01	; 1
     9da:	08 95       	ret

000009dc <I2C_start>:
     9dc:	84 ea       	ldi	r24, 0xA4	; 164
     9de:	86 bf       	out	0x36, r24	; 54
     9e0:	06 b6       	in	r0, 0x36	; 54
     9e2:	07 fe       	sbrs	r0, 7
     9e4:	fd cf       	rjmp	.-6      	; 0x9e0 <I2C_start+0x4>
     9e6:	0e 94 c8 04 	call	0x990	; 0x990 <getCurrentStatus>
     9ea:	08 95       	ret

000009ec <I2C_write>:

EN_I2CMasterStatusCode_t I2C_write(u8 data) {
  TWDR = data;
     9ec:	83 b9       	out	0x03, r24	; 3
  TWCR = (1 << TWEN) | (1 << TWINT);
     9ee:	84 e8       	ldi	r24, 0x84	; 132
     9f0:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWINT) == 0);
     9f2:	06 b6       	in	r0, 0x36	; 54
     9f4:	07 fe       	sbrs	r0, 7
     9f6:	fd cf       	rjmp	.-6      	; 0x9f2 <I2C_write+0x6>
  return getCurrentStatus();
     9f8:	0e 94 c8 04 	call	0x990	; 0x990 <getCurrentStatus>
  }
     9fc:	08 95       	ret

000009fe <I2C_read_Ack>:

EN_I2CMasterStatusCode_t I2C_read_Ack(u8* data) {
  TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWINT);
     9fe:	24 ec       	ldi	r18, 0xC4	; 196
     a00:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     a02:	06 b6       	in	r0, 0x36	; 54
     a04:	07 fe       	sbrs	r0, 7
     a06:	fd cf       	rjmp	.-6      	; 0xa02 <I2C_read_Ack+0x4>
  *data = TWDR;
     a08:	23 b1       	in	r18, 0x03	; 3
     a0a:	fc 01       	movw	r30, r24
     a0c:	20 83       	st	Z, r18
  return getCurrentStatus();
     a0e:	0e 94 c8 04 	call	0x990	; 0x990 <getCurrentStatus>
  }
     a12:	08 95       	ret

00000a14 <I2C_read_Nack>:

EN_I2CMasterStatusCode_t I2C_read_Nack(u8* data) {
  TWCR = (1 << TWEN) | (1 << TWINT);
     a14:	24 e8       	ldi	r18, 0x84	; 132
     a16:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     a18:	06 b6       	in	r0, 0x36	; 54
     a1a:	07 fe       	sbrs	r0, 7
     a1c:	fd cf       	rjmp	.-6      	; 0xa18 <I2C_read_Nack+0x4>
  *data = TWDR;
     a1e:	23 b1       	in	r18, 0x03	; 3
     a20:	fc 01       	movw	r30, r24
     a22:	20 83       	st	Z, r18
  return getCurrentStatus();
     a24:	0e 94 c8 04 	call	0x990	; 0x990 <getCurrentStatus>
  }
     a28:	08 95       	ret

00000a2a <I2C_stop>:

void I2C_stop(void) {
  TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
     a2a:	84 e9       	ldi	r24, 0x94	; 148
     a2c:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWSTO));	// Wait until stop condition finishes
     a2e:	06 b6       	in	r0, 0x36	; 54
     a30:	04 fc       	sbrc	r0, 4
     a32:	fd cf       	rjmp	.-6      	; 0xa2e <I2C_stop+0x4>
  }
     a34:	08 95       	ret

00000a36 <isValidTimer>:
        clear_bit(TCCR2, COM21);
        set_prescalar(TIMER_2, 0);
        break;
    }
  return TIMER_OK;
  }
     a36:	83 30       	cpi	r24, 0x03	; 3
     a38:	10 f4       	brcc	.+4      	; 0xa3e <isValidTimer+0x8>
     a3a:	81 e0       	ldi	r24, 0x01	; 1
     a3c:	08 95       	ret
     a3e:	80 e0       	ldi	r24, 0x00	; 0
     a40:	08 95       	ret

00000a42 <set_prescalar>:
     a42:	1f 93       	push	r17
     a44:	cf 93       	push	r28
     a46:	df 93       	push	r29
     a48:	18 2f       	mov	r17, r24
     a4a:	eb 01       	movw	r28, r22
     a4c:	0e 94 1b 05 	call	0xa36	; 0xa36 <isValidTimer>
     a50:	88 23       	and	r24, r24
     a52:	09 f4       	brne	.+2      	; 0xa56 <set_prescalar+0x14>
     a54:	6a c1       	rjmp	.+724    	; 0xd2a <set_prescalar+0x2e8>
     a56:	11 30       	cpi	r17, 0x01	; 1
     a58:	09 f4       	brne	.+2      	; 0xa5c <set_prescalar+0x1a>
     a5a:	6f c0       	rjmp	.+222    	; 0xb3a <set_prescalar+0xf8>
     a5c:	20 f0       	brcs	.+8      	; 0xa66 <set_prescalar+0x24>
     a5e:	12 30       	cpi	r17, 0x02	; 2
     a60:	09 f4       	brne	.+2      	; 0xa64 <set_prescalar+0x22>
     a62:	d5 c0       	rjmp	.+426    	; 0xc0e <set_prescalar+0x1cc>
     a64:	64 c1       	rjmp	.+712    	; 0xd2e <set_prescalar+0x2ec>
     a66:	c2 30       	cpi	r28, 0x02	; 2
     a68:	d1 05       	cpc	r29, r1
     a6a:	78 f0       	brcs	.+30     	; 0xa8a <set_prescalar+0x48>
     a6c:	c8 30       	cpi	r28, 0x08	; 8
     a6e:	d1 05       	cpc	r29, r1
     a70:	61 f0       	breq	.+24     	; 0xa8a <set_prescalar+0x48>
     a72:	c0 34       	cpi	r28, 0x40	; 64
     a74:	d1 05       	cpc	r29, r1
     a76:	49 f0       	breq	.+18     	; 0xa8a <set_prescalar+0x48>
     a78:	c1 15       	cp	r28, r1
     a7a:	81 e0       	ldi	r24, 0x01	; 1
     a7c:	d8 07       	cpc	r29, r24
     a7e:	29 f0       	breq	.+10     	; 0xa8a <set_prescalar+0x48>
     a80:	c1 15       	cp	r28, r1
     a82:	84 e0       	ldi	r24, 0x04	; 4
     a84:	d8 07       	cpc	r29, r24
     a86:	09 f0       	breq	.+2      	; 0xa8a <set_prescalar+0x48>
     a88:	54 c1       	rjmp	.+680    	; 0xd32 <set_prescalar+0x2f0>
     a8a:	c8 30       	cpi	r28, 0x08	; 8
     a8c:	d1 05       	cpc	r29, r1
     a8e:	49 f1       	breq	.+82     	; 0xae2 <set_prescalar+0xa0>
     a90:	28 f4       	brcc	.+10     	; 0xa9c <set_prescalar+0x5a>
     a92:	20 97       	sbiw	r28, 0x00	; 0
     a94:	81 f0       	breq	.+32     	; 0xab6 <set_prescalar+0x74>
     a96:	21 97       	sbiw	r28, 0x01	; 1
     a98:	c9 f0       	breq	.+50     	; 0xacc <set_prescalar+0x8a>
     a9a:	4d c1       	rjmp	.+666    	; 0xd36 <set_prescalar+0x2f4>
     a9c:	c1 15       	cp	r28, r1
     a9e:	81 e0       	ldi	r24, 0x01	; 1
     aa0:	d8 07       	cpc	r29, r24
     aa2:	a9 f1       	breq	.+106    	; 0xb0e <set_prescalar+0xcc>
     aa4:	c1 15       	cp	r28, r1
     aa6:	84 e0       	ldi	r24, 0x04	; 4
     aa8:	d8 07       	cpc	r29, r24
     aaa:	e1 f1       	breq	.+120    	; 0xb24 <set_prescalar+0xe2>
     aac:	c0 34       	cpi	r28, 0x40	; 64
     aae:	d1 05       	cpc	r29, r1
     ab0:	09 f0       	breq	.+2      	; 0xab4 <set_prescalar+0x72>
     ab2:	41 c1       	rjmp	.+642    	; 0xd36 <set_prescalar+0x2f4>
     ab4:	21 c0       	rjmp	.+66     	; 0xaf8 <set_prescalar+0xb6>
     ab6:	83 b7       	in	r24, 0x33	; 51
     ab8:	8e 7f       	andi	r24, 0xFE	; 254
     aba:	83 bf       	out	0x33, r24	; 51
     abc:	83 b7       	in	r24, 0x33	; 51
     abe:	8d 7f       	andi	r24, 0xFD	; 253
     ac0:	83 bf       	out	0x33, r24	; 51
     ac2:	83 b7       	in	r24, 0x33	; 51
     ac4:	8b 7f       	andi	r24, 0xFB	; 251
     ac6:	83 bf       	out	0x33, r24	; 51
     ac8:	80 e0       	ldi	r24, 0x00	; 0
     aca:	3e c1       	rjmp	.+636    	; 0xd48 <set_prescalar+0x306>
     acc:	83 b7       	in	r24, 0x33	; 51
     ace:	81 60       	ori	r24, 0x01	; 1
     ad0:	83 bf       	out	0x33, r24	; 51
     ad2:	83 b7       	in	r24, 0x33	; 51
     ad4:	8d 7f       	andi	r24, 0xFD	; 253
     ad6:	83 bf       	out	0x33, r24	; 51
     ad8:	83 b7       	in	r24, 0x33	; 51
     ada:	8b 7f       	andi	r24, 0xFB	; 251
     adc:	83 bf       	out	0x33, r24	; 51
     ade:	80 e0       	ldi	r24, 0x00	; 0
     ae0:	33 c1       	rjmp	.+614    	; 0xd48 <set_prescalar+0x306>
     ae2:	83 b7       	in	r24, 0x33	; 51
     ae4:	8e 7f       	andi	r24, 0xFE	; 254
     ae6:	83 bf       	out	0x33, r24	; 51
     ae8:	83 b7       	in	r24, 0x33	; 51
     aea:	82 60       	ori	r24, 0x02	; 2
     aec:	83 bf       	out	0x33, r24	; 51
     aee:	83 b7       	in	r24, 0x33	; 51
     af0:	8b 7f       	andi	r24, 0xFB	; 251
     af2:	83 bf       	out	0x33, r24	; 51
     af4:	80 e0       	ldi	r24, 0x00	; 0
     af6:	28 c1       	rjmp	.+592    	; 0xd48 <set_prescalar+0x306>
     af8:	83 b7       	in	r24, 0x33	; 51
     afa:	81 60       	ori	r24, 0x01	; 1
     afc:	83 bf       	out	0x33, r24	; 51
     afe:	83 b7       	in	r24, 0x33	; 51
     b00:	82 60       	ori	r24, 0x02	; 2
     b02:	83 bf       	out	0x33, r24	; 51
     b04:	83 b7       	in	r24, 0x33	; 51
     b06:	8b 7f       	andi	r24, 0xFB	; 251
     b08:	83 bf       	out	0x33, r24	; 51
     b0a:	80 e0       	ldi	r24, 0x00	; 0
     b0c:	1d c1       	rjmp	.+570    	; 0xd48 <set_prescalar+0x306>
     b0e:	83 b7       	in	r24, 0x33	; 51
     b10:	8e 7f       	andi	r24, 0xFE	; 254
     b12:	83 bf       	out	0x33, r24	; 51
     b14:	83 b7       	in	r24, 0x33	; 51
     b16:	8d 7f       	andi	r24, 0xFD	; 253
     b18:	83 bf       	out	0x33, r24	; 51
     b1a:	83 b7       	in	r24, 0x33	; 51
     b1c:	84 60       	ori	r24, 0x04	; 4
     b1e:	83 bf       	out	0x33, r24	; 51
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	12 c1       	rjmp	.+548    	; 0xd48 <set_prescalar+0x306>
     b24:	83 b7       	in	r24, 0x33	; 51
     b26:	81 60       	ori	r24, 0x01	; 1
     b28:	83 bf       	out	0x33, r24	; 51
     b2a:	83 b7       	in	r24, 0x33	; 51
     b2c:	8d 7f       	andi	r24, 0xFD	; 253
     b2e:	83 bf       	out	0x33, r24	; 51
     b30:	83 b7       	in	r24, 0x33	; 51
     b32:	84 60       	ori	r24, 0x04	; 4
     b34:	83 bf       	out	0x33, r24	; 51
     b36:	80 e0       	ldi	r24, 0x00	; 0
     b38:	07 c1       	rjmp	.+526    	; 0xd48 <set_prescalar+0x306>
     b3a:	c2 30       	cpi	r28, 0x02	; 2
     b3c:	d1 05       	cpc	r29, r1
     b3e:	78 f0       	brcs	.+30     	; 0xb5e <set_prescalar+0x11c>
     b40:	c8 30       	cpi	r28, 0x08	; 8
     b42:	d1 05       	cpc	r29, r1
     b44:	61 f0       	breq	.+24     	; 0xb5e <set_prescalar+0x11c>
     b46:	c0 34       	cpi	r28, 0x40	; 64
     b48:	d1 05       	cpc	r29, r1
     b4a:	49 f0       	breq	.+18     	; 0xb5e <set_prescalar+0x11c>
     b4c:	c1 15       	cp	r28, r1
     b4e:	81 e0       	ldi	r24, 0x01	; 1
     b50:	d8 07       	cpc	r29, r24
     b52:	29 f0       	breq	.+10     	; 0xb5e <set_prescalar+0x11c>
     b54:	c1 15       	cp	r28, r1
     b56:	84 e0       	ldi	r24, 0x04	; 4
     b58:	d8 07       	cpc	r29, r24
     b5a:	09 f0       	breq	.+2      	; 0xb5e <set_prescalar+0x11c>
     b5c:	ee c0       	rjmp	.+476    	; 0xd3a <set_prescalar+0x2f8>
     b5e:	c8 30       	cpi	r28, 0x08	; 8
     b60:	d1 05       	cpc	r29, r1
     b62:	49 f1       	breq	.+82     	; 0xbb6 <set_prescalar+0x174>
     b64:	28 f4       	brcc	.+10     	; 0xb70 <set_prescalar+0x12e>
     b66:	20 97       	sbiw	r28, 0x00	; 0
     b68:	81 f0       	breq	.+32     	; 0xb8a <set_prescalar+0x148>
     b6a:	21 97       	sbiw	r28, 0x01	; 1
     b6c:	c9 f0       	breq	.+50     	; 0xba0 <set_prescalar+0x15e>
     b6e:	e7 c0       	rjmp	.+462    	; 0xd3e <set_prescalar+0x2fc>
     b70:	c1 15       	cp	r28, r1
     b72:	81 e0       	ldi	r24, 0x01	; 1
     b74:	d8 07       	cpc	r29, r24
     b76:	a9 f1       	breq	.+106    	; 0xbe2 <set_prescalar+0x1a0>
     b78:	c1 15       	cp	r28, r1
     b7a:	84 e0       	ldi	r24, 0x04	; 4
     b7c:	d8 07       	cpc	r29, r24
     b7e:	e1 f1       	breq	.+120    	; 0xbf8 <set_prescalar+0x1b6>
     b80:	c0 34       	cpi	r28, 0x40	; 64
     b82:	d1 05       	cpc	r29, r1
     b84:	09 f0       	breq	.+2      	; 0xb88 <set_prescalar+0x146>
     b86:	db c0       	rjmp	.+438    	; 0xd3e <set_prescalar+0x2fc>
     b88:	21 c0       	rjmp	.+66     	; 0xbcc <set_prescalar+0x18a>
     b8a:	8e b5       	in	r24, 0x2e	; 46
     b8c:	8e 7f       	andi	r24, 0xFE	; 254
     b8e:	8e bd       	out	0x2e, r24	; 46
     b90:	8e b5       	in	r24, 0x2e	; 46
     b92:	8d 7f       	andi	r24, 0xFD	; 253
     b94:	8e bd       	out	0x2e, r24	; 46
     b96:	8e b5       	in	r24, 0x2e	; 46
     b98:	8b 7f       	andi	r24, 0xFB	; 251
     b9a:	8e bd       	out	0x2e, r24	; 46
     b9c:	80 e0       	ldi	r24, 0x00	; 0
     b9e:	d4 c0       	rjmp	.+424    	; 0xd48 <set_prescalar+0x306>
     ba0:	8e b5       	in	r24, 0x2e	; 46
     ba2:	81 60       	ori	r24, 0x01	; 1
     ba4:	8e bd       	out	0x2e, r24	; 46
     ba6:	8e b5       	in	r24, 0x2e	; 46
     ba8:	8d 7f       	andi	r24, 0xFD	; 253
     baa:	8e bd       	out	0x2e, r24	; 46
     bac:	8e b5       	in	r24, 0x2e	; 46
     bae:	8b 7f       	andi	r24, 0xFB	; 251
     bb0:	8e bd       	out	0x2e, r24	; 46
     bb2:	80 e0       	ldi	r24, 0x00	; 0
     bb4:	c9 c0       	rjmp	.+402    	; 0xd48 <set_prescalar+0x306>
     bb6:	8e b5       	in	r24, 0x2e	; 46
     bb8:	8e 7f       	andi	r24, 0xFE	; 254
     bba:	8e bd       	out	0x2e, r24	; 46
     bbc:	8e b5       	in	r24, 0x2e	; 46
     bbe:	82 60       	ori	r24, 0x02	; 2
     bc0:	8e bd       	out	0x2e, r24	; 46
     bc2:	8e b5       	in	r24, 0x2e	; 46
     bc4:	8b 7f       	andi	r24, 0xFB	; 251
     bc6:	8e bd       	out	0x2e, r24	; 46
     bc8:	80 e0       	ldi	r24, 0x00	; 0
     bca:	be c0       	rjmp	.+380    	; 0xd48 <set_prescalar+0x306>
     bcc:	8e b5       	in	r24, 0x2e	; 46
     bce:	81 60       	ori	r24, 0x01	; 1
     bd0:	8e bd       	out	0x2e, r24	; 46
     bd2:	8e b5       	in	r24, 0x2e	; 46
     bd4:	82 60       	ori	r24, 0x02	; 2
     bd6:	8e bd       	out	0x2e, r24	; 46
     bd8:	8e b5       	in	r24, 0x2e	; 46
     bda:	8b 7f       	andi	r24, 0xFB	; 251
     bdc:	8e bd       	out	0x2e, r24	; 46
     bde:	80 e0       	ldi	r24, 0x00	; 0
     be0:	b3 c0       	rjmp	.+358    	; 0xd48 <set_prescalar+0x306>
     be2:	8e b5       	in	r24, 0x2e	; 46
     be4:	8e 7f       	andi	r24, 0xFE	; 254
     be6:	8e bd       	out	0x2e, r24	; 46
     be8:	8e b5       	in	r24, 0x2e	; 46
     bea:	8d 7f       	andi	r24, 0xFD	; 253
     bec:	8e bd       	out	0x2e, r24	; 46
     bee:	8e b5       	in	r24, 0x2e	; 46
     bf0:	84 60       	ori	r24, 0x04	; 4
     bf2:	8e bd       	out	0x2e, r24	; 46
     bf4:	80 e0       	ldi	r24, 0x00	; 0
     bf6:	a8 c0       	rjmp	.+336    	; 0xd48 <set_prescalar+0x306>
     bf8:	8e b5       	in	r24, 0x2e	; 46
     bfa:	81 60       	ori	r24, 0x01	; 1
     bfc:	8e bd       	out	0x2e, r24	; 46
     bfe:	8e b5       	in	r24, 0x2e	; 46
     c00:	8d 7f       	andi	r24, 0xFD	; 253
     c02:	8e bd       	out	0x2e, r24	; 46
     c04:	8e b5       	in	r24, 0x2e	; 46
     c06:	84 60       	ori	r24, 0x04	; 4
     c08:	8e bd       	out	0x2e, r24	; 46
     c0a:	80 e0       	ldi	r24, 0x00	; 0
     c0c:	9d c0       	rjmp	.+314    	; 0xd48 <set_prescalar+0x306>
     c0e:	c2 30       	cpi	r28, 0x02	; 2
     c10:	d1 05       	cpc	r29, r1
     c12:	a8 f0       	brcs	.+42     	; 0xc3e <set_prescalar+0x1fc>
     c14:	c8 30       	cpi	r28, 0x08	; 8
     c16:	d1 05       	cpc	r29, r1
     c18:	91 f0       	breq	.+36     	; 0xc3e <set_prescalar+0x1fc>
     c1a:	c0 32       	cpi	r28, 0x20	; 32
     c1c:	d1 05       	cpc	r29, r1
     c1e:	79 f0       	breq	.+30     	; 0xc3e <set_prescalar+0x1fc>
     c20:	c0 34       	cpi	r28, 0x40	; 64
     c22:	d1 05       	cpc	r29, r1
     c24:	61 f0       	breq	.+24     	; 0xc3e <set_prescalar+0x1fc>
     c26:	c0 38       	cpi	r28, 0x80	; 128
     c28:	d1 05       	cpc	r29, r1
     c2a:	49 f0       	breq	.+18     	; 0xc3e <set_prescalar+0x1fc>
     c2c:	c1 15       	cp	r28, r1
     c2e:	81 e0       	ldi	r24, 0x01	; 1
     c30:	d8 07       	cpc	r29, r24
     c32:	29 f0       	breq	.+10     	; 0xc3e <set_prescalar+0x1fc>
     c34:	c1 15       	cp	r28, r1
     c36:	84 e0       	ldi	r24, 0x04	; 4
     c38:	d8 07       	cpc	r29, r24
     c3a:	09 f0       	breq	.+2      	; 0xc3e <set_prescalar+0x1fc>
     c3c:	82 c0       	rjmp	.+260    	; 0xd42 <set_prescalar+0x300>
     c3e:	c0 32       	cpi	r28, 0x20	; 32
     c40:	d1 05       	cpc	r29, r1
     c42:	e1 f1       	breq	.+120    	; 0xcbc <set_prescalar+0x27a>
     c44:	38 f4       	brcc	.+14     	; 0xc54 <set_prescalar+0x212>
     c46:	c1 30       	cpi	r28, 0x01	; 1
     c48:	d1 05       	cpc	r29, r1
     c4a:	11 f1       	breq	.+68     	; 0xc90 <set_prescalar+0x24e>
     c4c:	b0 f0       	brcs	.+44     	; 0xc7a <set_prescalar+0x238>
     c4e:	28 97       	sbiw	r28, 0x08	; 8
     c50:	51 f1       	breq	.+84     	; 0xca6 <set_prescalar+0x264>
     c52:	79 c0       	rjmp	.+242    	; 0xd46 <set_prescalar+0x304>
     c54:	c0 38       	cpi	r28, 0x80	; 128
     c56:	d1 05       	cpc	r29, r1
     c58:	09 f4       	brne	.+2      	; 0xc5c <set_prescalar+0x21a>
     c5a:	46 c0       	rjmp	.+140    	; 0xce8 <set_prescalar+0x2a6>
     c5c:	20 f4       	brcc	.+8      	; 0xc66 <set_prescalar+0x224>
     c5e:	c0 34       	cpi	r28, 0x40	; 64
     c60:	d1 05       	cpc	r29, r1
     c62:	b9 f1       	breq	.+110    	; 0xcd2 <set_prescalar+0x290>
     c64:	70 c0       	rjmp	.+224    	; 0xd46 <set_prescalar+0x304>
     c66:	c1 15       	cp	r28, r1
     c68:	81 e0       	ldi	r24, 0x01	; 1
     c6a:	d8 07       	cpc	r29, r24
     c6c:	09 f4       	brne	.+2      	; 0xc70 <set_prescalar+0x22e>
     c6e:	47 c0       	rjmp	.+142    	; 0xcfe <set_prescalar+0x2bc>
     c70:	c1 15       	cp	r28, r1
     c72:	d4 40       	sbci	r29, 0x04	; 4
     c74:	09 f4       	brne	.+2      	; 0xc78 <set_prescalar+0x236>
     c76:	4e c0       	rjmp	.+156    	; 0xd14 <set_prescalar+0x2d2>
     c78:	66 c0       	rjmp	.+204    	; 0xd46 <set_prescalar+0x304>
     c7a:	85 b5       	in	r24, 0x25	; 37
     c7c:	8e 7f       	andi	r24, 0xFE	; 254
     c7e:	85 bd       	out	0x25, r24	; 37
     c80:	85 b5       	in	r24, 0x25	; 37
     c82:	8d 7f       	andi	r24, 0xFD	; 253
     c84:	85 bd       	out	0x25, r24	; 37
     c86:	85 b5       	in	r24, 0x25	; 37
     c88:	8b 7f       	andi	r24, 0xFB	; 251
     c8a:	85 bd       	out	0x25, r24	; 37
     c8c:	80 e0       	ldi	r24, 0x00	; 0
     c8e:	5c c0       	rjmp	.+184    	; 0xd48 <set_prescalar+0x306>
     c90:	85 b5       	in	r24, 0x25	; 37
     c92:	81 60       	ori	r24, 0x01	; 1
     c94:	85 bd       	out	0x25, r24	; 37
     c96:	85 b5       	in	r24, 0x25	; 37
     c98:	8d 7f       	andi	r24, 0xFD	; 253
     c9a:	85 bd       	out	0x25, r24	; 37
     c9c:	85 b5       	in	r24, 0x25	; 37
     c9e:	8b 7f       	andi	r24, 0xFB	; 251
     ca0:	85 bd       	out	0x25, r24	; 37
     ca2:	80 e0       	ldi	r24, 0x00	; 0
     ca4:	51 c0       	rjmp	.+162    	; 0xd48 <set_prescalar+0x306>
     ca6:	85 b5       	in	r24, 0x25	; 37
     ca8:	8e 7f       	andi	r24, 0xFE	; 254
     caa:	85 bd       	out	0x25, r24	; 37
     cac:	85 b5       	in	r24, 0x25	; 37
     cae:	82 60       	ori	r24, 0x02	; 2
     cb0:	85 bd       	out	0x25, r24	; 37
     cb2:	85 b5       	in	r24, 0x25	; 37
     cb4:	8b 7f       	andi	r24, 0xFB	; 251
     cb6:	85 bd       	out	0x25, r24	; 37
     cb8:	80 e0       	ldi	r24, 0x00	; 0
     cba:	46 c0       	rjmp	.+140    	; 0xd48 <set_prescalar+0x306>
     cbc:	85 b5       	in	r24, 0x25	; 37
     cbe:	81 60       	ori	r24, 0x01	; 1
     cc0:	85 bd       	out	0x25, r24	; 37
     cc2:	85 b5       	in	r24, 0x25	; 37
     cc4:	82 60       	ori	r24, 0x02	; 2
     cc6:	85 bd       	out	0x25, r24	; 37
     cc8:	85 b5       	in	r24, 0x25	; 37
     cca:	8b 7f       	andi	r24, 0xFB	; 251
     ccc:	85 bd       	out	0x25, r24	; 37
     cce:	80 e0       	ldi	r24, 0x00	; 0
     cd0:	3b c0       	rjmp	.+118    	; 0xd48 <set_prescalar+0x306>
     cd2:	85 b5       	in	r24, 0x25	; 37
     cd4:	8e 7f       	andi	r24, 0xFE	; 254
     cd6:	85 bd       	out	0x25, r24	; 37
     cd8:	85 b5       	in	r24, 0x25	; 37
     cda:	8d 7f       	andi	r24, 0xFD	; 253
     cdc:	85 bd       	out	0x25, r24	; 37
     cde:	85 b5       	in	r24, 0x25	; 37
     ce0:	84 60       	ori	r24, 0x04	; 4
     ce2:	85 bd       	out	0x25, r24	; 37
     ce4:	80 e0       	ldi	r24, 0x00	; 0
     ce6:	30 c0       	rjmp	.+96     	; 0xd48 <set_prescalar+0x306>
     ce8:	85 b5       	in	r24, 0x25	; 37
     cea:	81 60       	ori	r24, 0x01	; 1
     cec:	85 bd       	out	0x25, r24	; 37
     cee:	85 b5       	in	r24, 0x25	; 37
     cf0:	8d 7f       	andi	r24, 0xFD	; 253
     cf2:	85 bd       	out	0x25, r24	; 37
     cf4:	85 b5       	in	r24, 0x25	; 37
     cf6:	84 60       	ori	r24, 0x04	; 4
     cf8:	85 bd       	out	0x25, r24	; 37
     cfa:	80 e0       	ldi	r24, 0x00	; 0
     cfc:	25 c0       	rjmp	.+74     	; 0xd48 <set_prescalar+0x306>
     cfe:	85 b5       	in	r24, 0x25	; 37
     d00:	8e 7f       	andi	r24, 0xFE	; 254
     d02:	85 bd       	out	0x25, r24	; 37
     d04:	85 b5       	in	r24, 0x25	; 37
     d06:	82 60       	ori	r24, 0x02	; 2
     d08:	85 bd       	out	0x25, r24	; 37
     d0a:	85 b5       	in	r24, 0x25	; 37
     d0c:	84 60       	ori	r24, 0x04	; 4
     d0e:	85 bd       	out	0x25, r24	; 37
     d10:	80 e0       	ldi	r24, 0x00	; 0
     d12:	1a c0       	rjmp	.+52     	; 0xd48 <set_prescalar+0x306>
     d14:	85 b5       	in	r24, 0x25	; 37
     d16:	81 60       	ori	r24, 0x01	; 1
     d18:	85 bd       	out	0x25, r24	; 37
     d1a:	85 b5       	in	r24, 0x25	; 37
     d1c:	82 60       	ori	r24, 0x02	; 2
     d1e:	85 bd       	out	0x25, r24	; 37
     d20:	85 b5       	in	r24, 0x25	; 37
     d22:	84 60       	ori	r24, 0x04	; 4
     d24:	85 bd       	out	0x25, r24	; 37
     d26:	80 e0       	ldi	r24, 0x00	; 0
     d28:	0f c0       	rjmp	.+30     	; 0xd48 <set_prescalar+0x306>
     d2a:	81 e0       	ldi	r24, 0x01	; 1
     d2c:	0d c0       	rjmp	.+26     	; 0xd48 <set_prescalar+0x306>
     d2e:	80 e0       	ldi	r24, 0x00	; 0
     d30:	0b c0       	rjmp	.+22     	; 0xd48 <set_prescalar+0x306>
     d32:	82 e0       	ldi	r24, 0x02	; 2
     d34:	09 c0       	rjmp	.+18     	; 0xd48 <set_prescalar+0x306>
     d36:	80 e0       	ldi	r24, 0x00	; 0
     d38:	07 c0       	rjmp	.+14     	; 0xd48 <set_prescalar+0x306>
     d3a:	82 e0       	ldi	r24, 0x02	; 2
     d3c:	05 c0       	rjmp	.+10     	; 0xd48 <set_prescalar+0x306>
     d3e:	80 e0       	ldi	r24, 0x00	; 0
     d40:	03 c0       	rjmp	.+6      	; 0xd48 <set_prescalar+0x306>
     d42:	82 e0       	ldi	r24, 0x02	; 2
     d44:	01 c0       	rjmp	.+2      	; 0xd48 <set_prescalar+0x306>
     d46:	80 e0       	ldi	r24, 0x00	; 0
     d48:	df 91       	pop	r29
     d4a:	cf 91       	pop	r28
     d4c:	1f 91       	pop	r17
     d4e:	08 95       	ret

00000d50 <Timer_start>:
     d50:	0f 93       	push	r16
     d52:	1f 93       	push	r17
     d54:	cf 93       	push	r28
     d56:	c8 2f       	mov	r28, r24
     d58:	8b 01       	movw	r16, r22
     d5a:	0e 94 1b 05 	call	0xa36	; 0xa36 <isValidTimer>
     d5e:	88 23       	and	r24, r24
     d60:	31 f0       	breq	.+12     	; 0xd6e <Timer_start+0x1e>
     d62:	b8 01       	movw	r22, r16
     d64:	8c 2f       	mov	r24, r28
     d66:	0e 94 21 05 	call	0xa42	; 0xa42 <set_prescalar>
     d6a:	80 e0       	ldi	r24, 0x00	; 0
     d6c:	01 c0       	rjmp	.+2      	; 0xd70 <Timer_start+0x20>
     d6e:	81 e0       	ldi	r24, 0x01	; 1
     d70:	cf 91       	pop	r28
     d72:	1f 91       	pop	r17
     d74:	0f 91       	pop	r16
     d76:	08 95       	ret

00000d78 <PWM_OCP_disconnect>:

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
     d78:	84 30       	cpi	r24, 0x04	; 4
     d7a:	40 f5       	brcc	.+80     	; 0xdcc <PWM_OCP_disconnect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
     d7c:	81 30       	cpi	r24, 0x01	; 1
     d7e:	71 f0       	breq	.+28     	; 0xd9c <PWM_OCP_disconnect+0x24>
     d80:	28 f0       	brcs	.+10     	; 0xd8c <PWM_OCP_disconnect+0x14>
     d82:	82 30       	cpi	r24, 0x02	; 2
     d84:	99 f0       	breq	.+38     	; 0xdac <PWM_OCP_disconnect+0x34>
     d86:	83 30       	cpi	r24, 0x03	; 3
     d88:	c9 f0       	breq	.+50     	; 0xdbc <PWM_OCP_disconnect+0x44>
     d8a:	22 c0       	rjmp	.+68     	; 0xdd0 <PWM_OCP_disconnect+0x58>
      case OC_0:
        clear_bit(TCCR0, COM00);
     d8c:	83 b7       	in	r24, 0x33	; 51
     d8e:	8f 7e       	andi	r24, 0xEF	; 239
     d90:	83 bf       	out	0x33, r24	; 51
        clear_bit(TCCR0, COM01);
     d92:	83 b7       	in	r24, 0x33	; 51
     d94:	8f 7d       	andi	r24, 0xDF	; 223
     d96:	83 bf       	out	0x33, r24	; 51
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
     d98:	80 e0       	ldi	r24, 0x00	; 0
    }
  switch (pwmPin) {
      case OC_0:
        clear_bit(TCCR0, COM00);
        clear_bit(TCCR0, COM01);
        break;
     d9a:	08 95       	ret
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
     d9c:	8f b5       	in	r24, 0x2f	; 47
     d9e:	8f 7b       	andi	r24, 0xBF	; 191
     da0:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1A1);
     da2:	8f b5       	in	r24, 0x2f	; 47
     da4:	8f 77       	andi	r24, 0x7F	; 127
     da6:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
     da8:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR0, COM01);
        break;
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
        clear_bit(TCCR1A, COM1A1);
        break;
     daa:	08 95       	ret
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
     dac:	8f b5       	in	r24, 0x2f	; 47
     dae:	8f 7e       	andi	r24, 0xEF	; 239
     db0:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1B1);
     db2:	8f b5       	in	r24, 0x2f	; 47
     db4:	8f 7d       	andi	r24, 0xDF	; 223
     db6:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
     db8:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1A1);
        break;
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
        clear_bit(TCCR1A, COM1B1);
        break;
     dba:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
     dbc:	85 b5       	in	r24, 0x25	; 37
     dbe:	8f 7e       	andi	r24, 0xEF	; 239
     dc0:	85 bd       	out	0x25, r24	; 37
        clear_bit(TCCR2, COM21);
     dc2:	85 b5       	in	r24, 0x25	; 37
     dc4:	8f 7d       	andi	r24, 0xDF	; 223
     dc6:	85 bd       	out	0x25, r24	; 37
        break;
    }
  return TIMER_OK;
     dc8:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1B1);
        break;
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
     dca:	08 95       	ret
  }

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
     dcc:	87 e0       	ldi	r24, 0x07	; 7
     dce:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
     dd0:	80 e0       	ldi	r24, 0x00	; 0
  }
     dd2:	08 95       	ret

00000dd4 <PWM_OCP_connect>:

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
     dd4:	84 30       	cpi	r24, 0x04	; 4
     dd6:	40 f5       	brcc	.+80     	; 0xe28 <PWM_OCP_connect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
     dd8:	81 30       	cpi	r24, 0x01	; 1
     dda:	71 f0       	breq	.+28     	; 0xdf8 <PWM_OCP_connect+0x24>
     ddc:	28 f0       	brcs	.+10     	; 0xde8 <PWM_OCP_connect+0x14>
     dde:	82 30       	cpi	r24, 0x02	; 2
     de0:	99 f0       	breq	.+38     	; 0xe08 <PWM_OCP_connect+0x34>
     de2:	83 30       	cpi	r24, 0x03	; 3
     de4:	c9 f0       	breq	.+50     	; 0xe18 <PWM_OCP_connect+0x44>
     de6:	22 c0       	rjmp	.+68     	; 0xe2c <PWM_OCP_connect+0x58>
      case OC_0:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR0, COM00);
     de8:	83 b7       	in	r24, 0x33	; 51
     dea:	8f 7e       	andi	r24, 0xEF	; 239
     dec:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR0, COM01);
     dee:	83 b7       	in	r24, 0x33	; 51
     df0:	80 62       	ori	r24, 0x20	; 32
     df2:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
     df4:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR0, COM01);
#else 
        set_bit(TCCR0, COM00);
        set_bit(TCCR0, COM01);
#endif
        break;
     df6:	08 95       	ret
      case OC_1A:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1A0);
     df8:	8f b5       	in	r24, 0x2f	; 47
     dfa:	8f 7b       	andi	r24, 0xBF	; 191
     dfc:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1A1);
     dfe:	8f b5       	in	r24, 0x2f	; 47
     e00:	80 68       	ori	r24, 0x80	; 128
     e02:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
     e04:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1A1);
#else 
        set_bit(TCCR1A, COM1A0);
        set_bit(TCCR1A, COM1A1);
#endif
        break;
     e06:	08 95       	ret
      case OC_1B:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1B0);
     e08:	8f b5       	in	r24, 0x2f	; 47
     e0a:	8f 7e       	andi	r24, 0xEF	; 239
     e0c:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1B1);
     e0e:	8f b5       	in	r24, 0x2f	; 47
     e10:	80 62       	ori	r24, 0x20	; 32
     e12:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
     e14:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1B1);
#else 
        set_bit(TCCR1A, COM1B0);
        set_bit(TCCR1A, COM1B1);
#endif
        break;
     e16:	08 95       	ret
      case OC_2:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR2, COM20);
     e18:	85 b5       	in	r24, 0x25	; 37
     e1a:	8f 7e       	andi	r24, 0xEF	; 239
     e1c:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM21);
     e1e:	85 b5       	in	r24, 0x25	; 37
     e20:	80 62       	ori	r24, 0x20	; 32
     e22:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
     e24:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR2, COM21);
#else 
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
     e26:	08 95       	ret
  }

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
     e28:	87 e0       	ldi	r24, 0x07	; 7
     e2a:	08 95       	ret
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
     e2c:	80 e0       	ldi	r24, 0x00	; 0
  }
     e2e:	08 95       	ret

00000e30 <PWM_init>:
  return TIMER_OK;
  }

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
     e30:	cf 92       	push	r12
     e32:	df 92       	push	r13
     e34:	ef 92       	push	r14
     e36:	ff 92       	push	r15
     e38:	cf 93       	push	r28
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
     e3a:	84 30       	cpi	r24, 0x04	; 4
     e3c:	08 f0       	brcs	.+2      	; 0xe40 <PWM_init+0x10>
     e3e:	96 c0       	rjmp	.+300    	; 0xf6c <PWM_init+0x13c>
    return WRONG_PWM_PIN;
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
     e40:	9f ef       	ldi	r25, 0xFF	; 255
     e42:	92 0f       	add	r25, r18
     e44:	92 30       	cpi	r25, 0x02	; 2
     e46:	08 f0       	brcs	.+2      	; 0xe4a <PWM_init+0x1a>
     e48:	93 c0       	rjmp	.+294    	; 0xf70 <PWM_init+0x140>
     e4a:	6a 01       	movw	r12, r20
     e4c:	7b 01       	movw	r14, r22
     e4e:	c8 2f       	mov	r28, r24
    return WRONG_PWM_MODE;
    }
  switch (pwmPin) {
     e50:	83 30       	cpi	r24, 0x03	; 3
     e52:	18 f4       	brcc	.+6      	; 0xe5a <PWM_init+0x2a>
     e54:	81 30       	cpi	r24, 0x01	; 1
     e56:	28 f0       	brcs	.+10     	; 0xe62 <PWM_init+0x32>
     e58:	22 c0       	rjmp	.+68     	; 0xe9e <PWM_init+0x6e>
     e5a:	83 30       	cpi	r24, 0x03	; 3
     e5c:	09 f4       	brne	.+2      	; 0xe60 <PWM_init+0x30>
     e5e:	64 c0       	rjmp	.+200    	; 0xf28 <PWM_init+0xf8>
     e60:	80 c0       	rjmp	.+256    	; 0xf62 <PWM_init+0x132>
      case OC_0:
        switch (mode) {
     e62:	21 30       	cpi	r18, 0x01	; 1
     e64:	19 f0       	breq	.+6      	; 0xe6c <PWM_init+0x3c>
     e66:	22 30       	cpi	r18, 0x02	; 2
     e68:	41 f0       	breq	.+16     	; 0xe7a <PWM_init+0x4a>
     e6a:	0d c0       	rjmp	.+26     	; 0xe86 <PWM_init+0x56>
            case PWM_FAST:
              set_bit(TCCR0, WGM00);
     e6c:	83 b7       	in	r24, 0x33	; 51
     e6e:	80 64       	ori	r24, 0x40	; 64
     e70:	83 bf       	out	0x33, r24	; 51
              set_bit(TCCR0, WGM01);
     e72:	83 b7       	in	r24, 0x33	; 51
     e74:	88 60       	ori	r24, 0x08	; 8
     e76:	83 bf       	out	0x33, r24	; 51
              break;
     e78:	06 c0       	rjmp	.+12     	; 0xe86 <PWM_init+0x56>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR0, WGM00);
     e7a:	83 b7       	in	r24, 0x33	; 51
     e7c:	80 64       	ori	r24, 0x40	; 64
     e7e:	83 bf       	out	0x33, r24	; 51
              clear_bit(TCCR0, WGM01);
     e80:	83 b7       	in	r24, 0x33	; 51
     e82:	87 7f       	andi	r24, 0xF7	; 247
     e84:	83 bf       	out	0x33, r24	; 51
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR0 = (u8)(dutyCycle * 255);
     e86:	20 e0       	ldi	r18, 0x00	; 0
     e88:	30 e0       	ldi	r19, 0x00	; 0
     e8a:	4f e7       	ldi	r20, 0x7F	; 127
     e8c:	53 e4       	ldi	r21, 0x43	; 67
     e8e:	c7 01       	movw	r24, r14
     e90:	b6 01       	movw	r22, r12
     e92:	0e 94 57 11 	call	0x22ae	; 0x22ae <__mulsf3>
     e96:	0e 94 9a 10 	call	0x2134	; 0x2134 <__fixunssfsi>
     e9a:	6c bf       	out	0x3c, r22	; 60
        break;
     e9c:	62 c0       	rjmp	.+196    	; 0xf62 <PWM_init+0x132>
        //? The fix for this issue is to use ICR1 as TOP instead (mode 14 in fast pwm), thus allowing OCR1A and OCR1B to be used to set the duty cycle while ICR1 is used tyo set the frequency.
        //? Mode 15 can be used at the cost of disabling PWM on OC1A, but we get more glitch-free variable frequency PWM signal on OC1B due to the double buffering of OC1A, which ICR1 doesn't have.
        //? Since I don't need a variable frequency pwm signal, ICR1 will be used as TOP by default and set to MAX.
      case OC_1A:
      case OC_1B:
        switch (mode) {
     e9e:	21 30       	cpi	r18, 0x01	; 1
     ea0:	19 f0       	breq	.+6      	; 0xea8 <PWM_init+0x78>
     ea2:	22 30       	cpi	r18, 0x02	; 2
     ea4:	91 f0       	breq	.+36     	; 0xeca <PWM_init+0x9a>
     ea6:	21 c0       	rjmp	.+66     	; 0xeea <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
     ea8:	8f b5       	in	r24, 0x2f	; 47
     eaa:	8e 7f       	andi	r24, 0xFE	; 254
     eac:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
     eae:	8f b5       	in	r24, 0x2f	; 47
     eb0:	82 60       	ori	r24, 0x02	; 2
     eb2:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1B, WGM12);
     eb4:	8e b5       	in	r24, 0x2e	; 46
     eb6:	88 60       	ori	r24, 0x08	; 8
     eb8:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
     eba:	8e b5       	in	r24, 0x2e	; 46
     ebc:	80 61       	ori	r24, 0x10	; 16
     ebe:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
     ec0:	80 e2       	ldi	r24, 0x20	; 32
     ec2:	9e e4       	ldi	r25, 0x4E	; 78
     ec4:	97 bd       	out	0x27, r25	; 39
     ec6:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              set_bit(TCCR1B, WGM13);
#endif
              break;
     ec8:	10 c0       	rjmp	.+32     	; 0xeea <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              clear_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
     eca:	8f b5       	in	r24, 0x2f	; 47
     ecc:	8e 7f       	andi	r24, 0xFE	; 254
     ece:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
     ed0:	8f b5       	in	r24, 0x2f	; 47
     ed2:	82 60       	ori	r24, 0x02	; 2
     ed4:	8f bd       	out	0x2f, r24	; 47
              clear_bit(TCCR1B, WGM12);
     ed6:	8e b5       	in	r24, 0x2e	; 46
     ed8:	87 7f       	andi	r24, 0xF7	; 247
     eda:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
     edc:	8e b5       	in	r24, 0x2e	; 46
     ede:	80 61       	ori	r24, 0x10	; 16
     ee0:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
     ee2:	80 e2       	ldi	r24, 0x20	; 32
     ee4:	9e e4       	ldi	r25, 0x4E	; 78
     ee6:	97 bd       	out	0x27, r25	; 39
     ee8:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1B, WGM13);
#endif
              break;
          }
        // Enable the PWM function of the OC pin.
        switch (pwmPin) {
     eea:	c1 30       	cpi	r28, 0x01	; 1
     eec:	19 f0       	breq	.+6      	; 0xef4 <PWM_init+0xc4>
     eee:	c2 30       	cpi	r28, 0x02	; 2
     ef0:	71 f0       	breq	.+28     	; 0xf0e <PWM_init+0xde>
     ef2:	37 c0       	rjmp	.+110    	; 0xf62 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     ef4:	20 e0       	ldi	r18, 0x00	; 0
     ef6:	30 e4       	ldi	r19, 0x40	; 64
     ef8:	4c e9       	ldi	r20, 0x9C	; 156
     efa:	56 e4       	ldi	r21, 0x46	; 70
     efc:	c7 01       	movw	r24, r14
     efe:	b6 01       	movw	r22, r12
     f00:	0e 94 57 11 	call	0x22ae	; 0x22ae <__mulsf3>
     f04:	0e 94 9a 10 	call	0x2134	; 0x2134 <__fixunssfsi>
     f08:	7b bd       	out	0x2b, r23	; 43
     f0a:	6a bd       	out	0x2a, r22	; 42
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1A = (u16)(dutyCycle * 65535);
#endif
              break;
     f0c:	2a c0       	rjmp	.+84     	; 0xf62 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     f0e:	20 e0       	ldi	r18, 0x00	; 0
     f10:	30 e4       	ldi	r19, 0x40	; 64
     f12:	4c e9       	ldi	r20, 0x9C	; 156
     f14:	56 e4       	ldi	r21, 0x46	; 70
     f16:	c7 01       	movw	r24, r14
     f18:	b6 01       	movw	r22, r12
     f1a:	0e 94 57 11 	call	0x22ae	; 0x22ae <__mulsf3>
     f1e:	0e 94 9a 10 	call	0x2134	; 0x2134 <__fixunssfsi>
     f22:	79 bd       	out	0x29, r23	; 41
     f24:	68 bd       	out	0x28, r22	; 40
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1B = (u16)(dutyCycle * 65535);
#endif
              break;
     f26:	1d c0       	rjmp	.+58     	; 0xf62 <PWM_init+0x132>
          }
        break;
      case OC_2:
        switch (mode) {
     f28:	21 30       	cpi	r18, 0x01	; 1
     f2a:	19 f0       	breq	.+6      	; 0xf32 <PWM_init+0x102>
     f2c:	22 30       	cpi	r18, 0x02	; 2
     f2e:	41 f0       	breq	.+16     	; 0xf40 <PWM_init+0x110>
     f30:	0d c0       	rjmp	.+26     	; 0xf4c <PWM_init+0x11c>
            case PWM_FAST:
              set_bit(TCCR2, WGM20);
     f32:	85 b5       	in	r24, 0x25	; 37
     f34:	80 64       	ori	r24, 0x40	; 64
     f36:	85 bd       	out	0x25, r24	; 37
              set_bit(TCCR2, WGM21);
     f38:	85 b5       	in	r24, 0x25	; 37
     f3a:	88 60       	ori	r24, 0x08	; 8
     f3c:	85 bd       	out	0x25, r24	; 37
              break;
     f3e:	06 c0       	rjmp	.+12     	; 0xf4c <PWM_init+0x11c>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR2, WGM20);
     f40:	85 b5       	in	r24, 0x25	; 37
     f42:	80 64       	ori	r24, 0x40	; 64
     f44:	85 bd       	out	0x25, r24	; 37
              clear_bit(TCCR2, WGM21);
     f46:	85 b5       	in	r24, 0x25	; 37
     f48:	87 7f       	andi	r24, 0xF7	; 247
     f4a:	85 bd       	out	0x25, r24	; 37
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR2 = (u8)(dutyCycle * 255);
     f4c:	20 e0       	ldi	r18, 0x00	; 0
     f4e:	30 e0       	ldi	r19, 0x00	; 0
     f50:	4f e7       	ldi	r20, 0x7F	; 127
     f52:	53 e4       	ldi	r21, 0x43	; 67
     f54:	c7 01       	movw	r24, r14
     f56:	b6 01       	movw	r22, r12
     f58:	0e 94 57 11 	call	0x22ae	; 0x22ae <__mulsf3>
     f5c:	0e 94 9a 10 	call	0x2134	; 0x2134 <__fixunssfsi>
     f60:	63 bd       	out	0x23, r22	; 35
        break;
    }
  PWM_OCP_connect(pwmPin);
     f62:	8c 2f       	mov	r24, r28
     f64:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <PWM_OCP_connect>
  return TIMER_OK;
     f68:	80 e0       	ldi	r24, 0x00	; 0
     f6a:	03 c0       	rjmp	.+6      	; 0xf72 <PWM_init+0x142>

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
     f6c:	87 e0       	ldi	r24, 0x07	; 7
     f6e:	01 c0       	rjmp	.+2      	; 0xf72 <PWM_init+0x142>
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    return WRONG_PWM_MODE;
     f70:	86 e0       	ldi	r24, 0x06	; 6
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  PWM_OCP_connect(pwmPin);
  return TIMER_OK;
  }
     f72:	cf 91       	pop	r28
     f74:	ff 90       	pop	r15
     f76:	ef 90       	pop	r14
     f78:	df 90       	pop	r13
     f7a:	cf 90       	pop	r12
     f7c:	08 95       	ret

00000f7e <PWM_set_DC>:
    }
  return TIMER_OK;
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
     f7e:	28 2f       	mov	r18, r24
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
     f80:	84 30       	cpi	r24, 0x04	; 4
     f82:	c0 f5       	brcc	.+112    	; 0xff4 <PWM_set_DC+0x76>
     f84:	cb 01       	movw	r24, r22
     f86:	ba 01       	movw	r22, r20
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
     f88:	21 30       	cpi	r18, 0x01	; 1
     f8a:	89 f0       	breq	.+34     	; 0xfae <PWM_set_DC+0x30>
     f8c:	28 f0       	brcs	.+10     	; 0xf98 <PWM_set_DC+0x1a>
     f8e:	22 30       	cpi	r18, 0x02	; 2
     f90:	d1 f0       	breq	.+52     	; 0xfc6 <PWM_set_DC+0x48>
     f92:	23 30       	cpi	r18, 0x03	; 3
     f94:	21 f1       	breq	.+72     	; 0xfde <PWM_set_DC+0x60>
     f96:	30 c0       	rjmp	.+96     	; 0xff8 <PWM_set_DC+0x7a>
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
     f98:	20 e0       	ldi	r18, 0x00	; 0
     f9a:	30 e0       	ldi	r19, 0x00	; 0
     f9c:	4f e7       	ldi	r20, 0x7F	; 127
     f9e:	53 e4       	ldi	r21, 0x43	; 67
     fa0:	0e 94 57 11 	call	0x22ae	; 0x22ae <__mulsf3>
     fa4:	0e 94 9a 10 	call	0x2134	; 0x2134 <__fixunssfsi>
     fa8:	6c bf       	out	0x3c, r22	; 60
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     faa:	80 e0       	ldi	r24, 0x00	; 0
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
        break;
     fac:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     fae:	20 e0       	ldi	r18, 0x00	; 0
     fb0:	30 e4       	ldi	r19, 0x40	; 64
     fb2:	4c e9       	ldi	r20, 0x9C	; 156
     fb4:	56 e4       	ldi	r21, 0x46	; 70
     fb6:	0e 94 57 11 	call	0x22ae	; 0x22ae <__mulsf3>
     fba:	0e 94 9a 10 	call	0x2134	; 0x2134 <__fixunssfsi>
     fbe:	7b bd       	out	0x2b, r23	; 43
     fc0:	6a bd       	out	0x2a, r22	; 42
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     fc2:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1A = (u16)(dutyCycle * 65535);
#endif
        break;
     fc4:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     fc6:	20 e0       	ldi	r18, 0x00	; 0
     fc8:	30 e4       	ldi	r19, 0x40	; 64
     fca:	4c e9       	ldi	r20, 0x9C	; 156
     fcc:	56 e4       	ldi	r21, 0x46	; 70
     fce:	0e 94 57 11 	call	0x22ae	; 0x22ae <__mulsf3>
     fd2:	0e 94 9a 10 	call	0x2134	; 0x2134 <__fixunssfsi>
     fd6:	79 bd       	out	0x29, r23	; 41
     fd8:	68 bd       	out	0x28, r22	; 40
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     fda:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
     fdc:	08 95       	ret
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
     fde:	20 e0       	ldi	r18, 0x00	; 0
     fe0:	30 e0       	ldi	r19, 0x00	; 0
     fe2:	4f e7       	ldi	r20, 0x7F	; 127
     fe4:	53 e4       	ldi	r21, 0x43	; 67
     fe6:	0e 94 57 11 	call	0x22ae	; 0x22ae <__mulsf3>
     fea:	0e 94 9a 10 	call	0x2134	; 0x2134 <__fixunssfsi>
     fee:	63 bd       	out	0x23, r22	; 35
        break;
    }
  return TIMER_OK;
     ff0:	80 e0       	ldi	r24, 0x00	; 0
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
     ff2:	08 95       	ret
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
     ff4:	87 e0       	ldi	r24, 0x07	; 7
     ff6:	08 95       	ret
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     ff8:	80 e0       	ldi	r24, 0x00	; 0
  }
     ffa:	08 95       	ret

00000ffc <UART_sendChar>:
  }

// Receive a Char using UART
void UART_receiveChar(s8* x) {
  while (!read_bit(UCSRA, RXC)); // Wait for the data to be received.
  *x = UDR;
     ffc:	5d 9b       	sbis	0x0b, 5	; 11
     ffe:	fe cf       	rjmp	.-4      	; 0xffc <UART_sendChar>
    1000:	8c b9       	out	0x0c, r24	; 12
    1002:	5e 9b       	sbis	0x0b, 6	; 11
    1004:	fe cf       	rjmp	.-4      	; 0x1002 <UART_sendChar+0x6>
    1006:	08 95       	ret

00001008 <UART_sendString>:
  }

void UART_sendString(s8* str) {
    1008:	cf 92       	push	r12
    100a:	df 92       	push	r13
    100c:	ef 92       	push	r14
    100e:	ff 92       	push	r15
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	ec 01       	movw	r28, r24
  u32 i = 0;
    1016:	c1 2c       	mov	r12, r1
    1018:	d1 2c       	mov	r13, r1
    101a:	76 01       	movw	r14, r12
  while (str[i] != 0) {
    101c:	07 c0       	rjmp	.+14     	; 0x102c <UART_sendString+0x24>
    UART_sendChar(str[i]);
    101e:	0e 94 fe 07 	call	0xffc	; 0xffc <UART_sendChar>
    i++;
    1022:	8f ef       	ldi	r24, 0xFF	; 255
    1024:	c8 1a       	sub	r12, r24
    1026:	d8 0a       	sbc	r13, r24
    1028:	e8 0a       	sbc	r14, r24
    102a:	f8 0a       	sbc	r15, r24
  *x = UDR;
  }

void UART_sendString(s8* str) {
  u32 i = 0;
  while (str[i] != 0) {
    102c:	fe 01       	movw	r30, r28
    102e:	ec 0d       	add	r30, r12
    1030:	fd 1d       	adc	r31, r13
    1032:	80 81       	ld	r24, Z
    1034:	81 11       	cpse	r24, r1
    1036:	f3 cf       	rjmp	.-26     	; 0x101e <UART_sendString+0x16>
    UART_sendChar(str[i]);
    i++;
    }
  UART_sendChar(0); // Send null to terminate the string
    1038:	0e 94 fe 07 	call	0xffc	; 0xffc <UART_sendChar>
  }
    103c:	df 91       	pop	r29
    103e:	cf 91       	pop	r28
    1040:	ff 90       	pop	r15
    1042:	ef 90       	pop	r14
    1044:	df 90       	pop	r13
    1046:	cf 90       	pop	r12
    1048:	08 95       	ret

0000104a <Door_open>:
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
  }

// Open the door by moving the servo to the open angle
void Door_open(void) {
  Servo_move_to_angle(DOOR_OPEN_ANGLE);
    104a:	84 eb       	ldi	r24, 0xB4	; 180
    104c:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <Servo_move_to_angle>
    1050:	08 95       	ret

00001052 <Door_close>:
  }

// Close the door by moving the servo to the close angle
void Door_close(void) {
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    1052:	80 e0       	ldi	r24, 0x00	; 0
    1054:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <Servo_move_to_angle>
    1058:	08 95       	ret

0000105a <Lamps_init>:
      case LAMP_6:
        if (read_bit(TCCR2, COM21)) { // OC pin is connected and lamp6 is on
          Lamp_off(6);
          }
        else {
          Lamp_on(6);
    105a:	62 e0       	ldi	r22, 0x02	; 2
    105c:	83 e4       	ldi	r24, 0x43	; 67
    105e:	0e 94 b5 02 	call	0x56a	; 0x56a <LED_init>
    1062:	63 e0       	ldi	r22, 0x03	; 3
    1064:	83 e4       	ldi	r24, 0x43	; 67
    1066:	0e 94 b5 02 	call	0x56a	; 0x56a <LED_init>
    106a:	64 e0       	ldi	r22, 0x04	; 4
    106c:	83 e4       	ldi	r24, 0x43	; 67
    106e:	0e 94 b5 02 	call	0x56a	; 0x56a <LED_init>
    1072:	65 e0       	ldi	r22, 0x05	; 5
    1074:	83 e4       	ldi	r24, 0x43	; 67
    1076:	0e 94 b5 02 	call	0x56a	; 0x56a <LED_init>
    107a:	66 e0       	ldi	r22, 0x06	; 6
    107c:	83 e4       	ldi	r24, 0x43	; 67
    107e:	0e 94 b5 02 	call	0x56a	; 0x56a <LED_init>
    1082:	67 e0       	ldi	r22, 0x07	; 7
    1084:	84 e4       	ldi	r24, 0x44	; 68
    1086:	0e 94 b5 02 	call	0x56a	; 0x56a <LED_init>
    108a:	21 e0       	ldi	r18, 0x01	; 1
    108c:	40 e0       	ldi	r20, 0x00	; 0
    108e:	50 e0       	ldi	r21, 0x00	; 0
    1090:	ba 01       	movw	r22, r20
    1092:	83 e0       	ldi	r24, 0x03	; 3
    1094:	0e 94 18 07 	call	0xe30	; 0xe30 <PWM_init>
    1098:	60 e0       	ldi	r22, 0x00	; 0
    109a:	71 e0       	ldi	r23, 0x01	; 1
    109c:	82 e0       	ldi	r24, 0x02	; 2
    109e:	0e 94 a8 06 	call	0xd50	; 0xd50 <Timer_start>
    10a2:	08 95       	ret

000010a4 <Lamp_on>:
    10a4:	83 30       	cpi	r24, 0x03	; 3
    10a6:	b1 f0       	breq	.+44     	; 0x10d4 <Lamp_on+0x30>
    10a8:	28 f4       	brcc	.+10     	; 0x10b4 <Lamp_on+0x10>
    10aa:	81 30       	cpi	r24, 0x01	; 1
    10ac:	49 f0       	breq	.+18     	; 0x10c0 <Lamp_on+0x1c>
    10ae:	82 30       	cpi	r24, 0x02	; 2
    10b0:	61 f0       	breq	.+24     	; 0x10ca <Lamp_on+0x26>
    10b2:	08 95       	ret
    10b4:	85 30       	cpi	r24, 0x05	; 5
    10b6:	c1 f0       	breq	.+48     	; 0x10e8 <Lamp_on+0x44>
    10b8:	90 f0       	brcs	.+36     	; 0x10de <Lamp_on+0x3a>
    10ba:	86 30       	cpi	r24, 0x06	; 6
    10bc:	d1 f0       	breq	.+52     	; 0x10f2 <Lamp_on+0x4e>
    10be:	08 95       	ret
    10c0:	62 e0       	ldi	r22, 0x02	; 2
    10c2:	83 e4       	ldi	r24, 0x43	; 67
    10c4:	0e 94 be 02 	call	0x57c	; 0x57c <LED_on>
    10c8:	08 95       	ret
    10ca:	63 e0       	ldi	r22, 0x03	; 3
    10cc:	83 e4       	ldi	r24, 0x43	; 67
    10ce:	0e 94 be 02 	call	0x57c	; 0x57c <LED_on>
    10d2:	08 95       	ret
    10d4:	64 e0       	ldi	r22, 0x04	; 4
    10d6:	83 e4       	ldi	r24, 0x43	; 67
    10d8:	0e 94 be 02 	call	0x57c	; 0x57c <LED_on>
    10dc:	08 95       	ret
    10de:	65 e0       	ldi	r22, 0x05	; 5
    10e0:	83 e4       	ldi	r24, 0x43	; 67
    10e2:	0e 94 be 02 	call	0x57c	; 0x57c <LED_on>
    10e6:	08 95       	ret
    10e8:	66 e0       	ldi	r22, 0x06	; 6
    10ea:	83 e4       	ldi	r24, 0x43	; 67
    10ec:	0e 94 be 02 	call	0x57c	; 0x57c <LED_on>
    10f0:	08 95       	ret
    10f2:	83 e0       	ldi	r24, 0x03	; 3
    10f4:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <PWM_OCP_connect>
    10f8:	08 95       	ret

000010fa <Lamp_off>:
    10fa:	83 30       	cpi	r24, 0x03	; 3
    10fc:	b1 f0       	breq	.+44     	; 0x112a <Lamp_off+0x30>
    10fe:	28 f4       	brcc	.+10     	; 0x110a <Lamp_off+0x10>
    1100:	81 30       	cpi	r24, 0x01	; 1
    1102:	49 f0       	breq	.+18     	; 0x1116 <Lamp_off+0x1c>
    1104:	82 30       	cpi	r24, 0x02	; 2
    1106:	61 f0       	breq	.+24     	; 0x1120 <Lamp_off+0x26>
    1108:	08 95       	ret
    110a:	85 30       	cpi	r24, 0x05	; 5
    110c:	c1 f0       	breq	.+48     	; 0x113e <Lamp_off+0x44>
    110e:	90 f0       	brcs	.+36     	; 0x1134 <Lamp_off+0x3a>
    1110:	86 30       	cpi	r24, 0x06	; 6
    1112:	d1 f0       	breq	.+52     	; 0x1148 <Lamp_off+0x4e>
    1114:	08 95       	ret
    1116:	62 e0       	ldi	r22, 0x02	; 2
    1118:	83 e4       	ldi	r24, 0x43	; 67
    111a:	0e 94 c7 02 	call	0x58e	; 0x58e <LED_off>
    111e:	08 95       	ret
    1120:	63 e0       	ldi	r22, 0x03	; 3
    1122:	83 e4       	ldi	r24, 0x43	; 67
    1124:	0e 94 c7 02 	call	0x58e	; 0x58e <LED_off>
    1128:	08 95       	ret
    112a:	64 e0       	ldi	r22, 0x04	; 4
    112c:	83 e4       	ldi	r24, 0x43	; 67
    112e:	0e 94 c7 02 	call	0x58e	; 0x58e <LED_off>
    1132:	08 95       	ret
    1134:	65 e0       	ldi	r22, 0x05	; 5
    1136:	83 e4       	ldi	r24, 0x43	; 67
    1138:	0e 94 c7 02 	call	0x58e	; 0x58e <LED_off>
    113c:	08 95       	ret
    113e:	66 e0       	ldi	r22, 0x06	; 6
    1140:	83 e4       	ldi	r24, 0x43	; 67
    1142:	0e 94 c7 02 	call	0x58e	; 0x58e <LED_off>
    1146:	08 95       	ret
    1148:	83 e0       	ldi	r24, 0x03	; 3
    114a:	0e 94 bc 06 	call	0xd78	; 0xd78 <PWM_OCP_disconnect>
    114e:	08 95       	ret

00001150 <Lamp_dimmable_set_brightness>:
        break;
    }
  }

// Adjust the brightness of the dimmable lamp
void Lamp_dimmable_set_brightness(double brightness) {
    1150:	ab 01       	movw	r20, r22
    1152:	bc 01       	movw	r22, r24
  PWM_set_DC(LAMP_6_DIMMABLE_PWM_PIN, brightness);
    1154:	83 e0       	ldi	r24, 0x03	; 3
    1156:	0e 94 bf 07 	call	0xf7e	; 0xf7e <PWM_set_DC>
    115a:	08 95       	ret

0000115c <Get_running_devices>:
    }
  }

void Show_side_options_menu(u8 menu) {
  LCD_writeString_xy(12, 0, BACKSPACE_OPTION);
  LCD_writeString_xy(12, 1, ENTER_OPTION);
    115c:	cf 93       	push	r28
    115e:	c0 e0       	ldi	r28, 0x00	; 0
    1160:	0a c0       	rjmp	.+20     	; 0x1176 <Get_running_devices+0x1a>
    1162:	4c 2f       	mov	r20, r28
    1164:	50 e0       	ldi	r21, 0x00	; 0
    1166:	4f 55       	subi	r20, 0x5F	; 95
    1168:	59 4f       	sbci	r21, 0xF9	; 249
    116a:	63 e4       	ldi	r22, 0x43	; 67
    116c:	82 e0       	ldi	r24, 0x02	; 2
    116e:	8c 0f       	add	r24, r28
    1170:	0e 94 72 04 	call	0x8e4	; 0x8e4 <DIO_Read>
    1174:	cf 5f       	subi	r28, 0xFF	; 255
    1176:	c5 30       	cpi	r28, 0x05	; 5
    1178:	a0 f3       	brcs	.-24     	; 0x1162 <Get_running_devices+0x6>
    117a:	85 b5       	in	r24, 0x25	; 37
    117c:	85 fb       	bst	r24, 5
    117e:	88 27       	eor	r24, r24
    1180:	80 f9       	bld	r24, 0
    1182:	80 93 a6 06 	sts	0x06A6, r24	; 0x8006a6 <running_devices+0x5>
    1186:	47 ea       	ldi	r20, 0xA7	; 167
    1188:	56 e0       	ldi	r21, 0x06	; 6
    118a:	64 e4       	ldi	r22, 0x44	; 68
    118c:	87 e0       	ldi	r24, 0x07	; 7
    118e:	0e 94 72 04 	call	0x8e4	; 0x8e4 <DIO_Read>
    1192:	cf 91       	pop	r28
    1194:	08 95       	ret

00001196 <Show_bottom_options_menu>:
    1196:	90 e0       	ldi	r25, 0x00	; 0
    1198:	fc 01       	movw	r30, r24
    119a:	31 97       	sbiw	r30, 0x01	; 1
    119c:	e9 30       	cpi	r30, 0x09	; 9
    119e:	f1 05       	cpc	r31, r1
    11a0:	08 f0       	brcs	.+2      	; 0x11a4 <Show_bottom_options_menu+0xe>
    11a2:	42 c0       	rjmp	.+132    	; 0x1228 <Show_bottom_options_menu+0x92>
    11a4:	e5 58       	subi	r30, 0x85	; 133
    11a6:	ff 4f       	sbci	r31, 0xFF	; 255
    11a8:	0c 94 c4 11 	jmp	0x2388	; 0x2388 <__tablejump2__>
    11ac:	41 e6       	ldi	r20, 0x61	; 97
    11ae:	50 e0       	ldi	r21, 0x00	; 0
    11b0:	61 e0       	ldi	r22, 0x01	; 1
    11b2:	80 e0       	ldi	r24, 0x00	; 0
    11b4:	0e 94 a0 02 	call	0x540	; 0x540 <LCD_writeString_xy>
    11b8:	08 95       	ret
    11ba:	42 e7       	ldi	r20, 0x72	; 114
    11bc:	50 e0       	ldi	r21, 0x00	; 0
    11be:	61 e0       	ldi	r22, 0x01	; 1
    11c0:	80 e0       	ldi	r24, 0x00	; 0
    11c2:	0e 94 a0 02 	call	0x540	; 0x540 <LCD_writeString_xy>
    11c6:	08 95       	ret
    11c8:	43 e8       	ldi	r20, 0x83	; 131
    11ca:	50 e0       	ldi	r21, 0x00	; 0
    11cc:	61 e0       	ldi	r22, 0x01	; 1
    11ce:	80 e0       	ldi	r24, 0x00	; 0
    11d0:	0e 94 a0 02 	call	0x540	; 0x540 <LCD_writeString_xy>
    11d4:	08 95       	ret
    11d6:	44 e9       	ldi	r20, 0x94	; 148
    11d8:	50 e0       	ldi	r21, 0x00	; 0
    11da:	61 e0       	ldi	r22, 0x01	; 1
    11dc:	80 e0       	ldi	r24, 0x00	; 0
    11de:	0e 94 a0 02 	call	0x540	; 0x540 <LCD_writeString_xy>
    11e2:	08 95       	ret
    11e4:	45 ea       	ldi	r20, 0xA5	; 165
    11e6:	50 e0       	ldi	r21, 0x00	; 0
    11e8:	61 e0       	ldi	r22, 0x01	; 1
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    11ec:	0e 94 a0 02 	call	0x540	; 0x540 <LCD_writeString_xy>
    11f0:	08 95       	ret
    11f2:	46 eb       	ldi	r20, 0xB6	; 182
    11f4:	50 e0       	ldi	r21, 0x00	; 0
    11f6:	61 e0       	ldi	r22, 0x01	; 1
    11f8:	80 e0       	ldi	r24, 0x00	; 0
    11fa:	0e 94 a0 02 	call	0x540	; 0x540 <LCD_writeString_xy>
    11fe:	08 95       	ret
    1200:	47 ec       	ldi	r20, 0xC7	; 199
    1202:	50 e0       	ldi	r21, 0x00	; 0
    1204:	61 e0       	ldi	r22, 0x01	; 1
    1206:	80 e0       	ldi	r24, 0x00	; 0
    1208:	0e 94 a0 02 	call	0x540	; 0x540 <LCD_writeString_xy>
    120c:	08 95       	ret
    120e:	48 ed       	ldi	r20, 0xD8	; 216
    1210:	50 e0       	ldi	r21, 0x00	; 0
    1212:	61 e0       	ldi	r22, 0x01	; 1
    1214:	80 e0       	ldi	r24, 0x00	; 0
    1216:	0e 94 a0 02 	call	0x540	; 0x540 <LCD_writeString_xy>
    121a:	08 95       	ret
    121c:	49 ee       	ldi	r20, 0xE9	; 233
    121e:	50 e0       	ldi	r21, 0x00	; 0
    1220:	61 e0       	ldi	r22, 0x01	; 1
    1222:	80 e0       	ldi	r24, 0x00	; 0
    1224:	0e 94 a0 02 	call	0x540	; 0x540 <LCD_writeString_xy>
    1228:	08 95       	ret

0000122a <Show_running_devices>:
  }

void Show_running_devices(u8 screen) {
    122a:	cf 93       	push	r28
    122c:	c8 2f       	mov	r28, r24
  LCD_clear_screen();
    122e:	0e 94 3d 02 	call	0x47a	; 0x47a <LCD_clear_screen>
  // Write device name
  switch (screen) {
    1232:	c7 30       	cpi	r28, 0x07	; 7
    1234:	39 f4       	brne	.+14     	; 0x1244 <Show_running_devices+0x1a>
      case 7:
        LCD_writeString_xy(0, 0, "AC: ");
    1236:	44 e0       	ldi	r20, 0x04	; 4
    1238:	51 e0       	ldi	r21, 0x01	; 1
    123a:	60 e0       	ldi	r22, 0x00	; 0
    123c:	80 e0       	ldi	r24, 0x00	; 0
    123e:	0e 94 a0 02 	call	0x540	; 0x540 <LCD_writeString_xy>
        break;
    1242:	0e c0       	rjmp	.+28     	; 0x1260 <Show_running_devices+0x36>
      default:
        LCD_writeString_xy(0, 0, "Lamp");
    1244:	49 e0       	ldi	r20, 0x09	; 9
    1246:	51 e0       	ldi	r21, 0x01	; 1
    1248:	60 e0       	ldi	r22, 0x00	; 0
    124a:	80 e0       	ldi	r24, 0x00	; 0
    124c:	0e 94 a0 02 	call	0x540	; 0x540 <LCD_writeString_xy>
        LCD_sendData(screen + 48);
    1250:	80 e3       	ldi	r24, 0x30	; 48
    1252:	8c 0f       	add	r24, r28
    1254:	0e 94 0b 02 	call	0x416	; 0x416 <LCD_sendData>
        LCD_sendString(": ");
    1258:	87 ea       	ldi	r24, 0xA7	; 167
    125a:	95 e0       	ldi	r25, 0x05	; 5
    125c:	0e 94 81 02 	call	0x502	; 0x502 <LCD_sendString>
        break;
    }
  // Write the device state
  if (running_devices[screen - 1])
    1260:	ec 2f       	mov	r30, r28
    1262:	f0 e0       	ldi	r31, 0x00	; 0
    1264:	e0 56       	subi	r30, 0x60	; 96
    1266:	f9 4f       	sbci	r31, 0xF9	; 249
    1268:	80 81       	ld	r24, Z
    126a:	88 23       	and	r24, r24
    126c:	29 f0       	breq	.+10     	; 0x1278 <Show_running_devices+0x4e>
    LCD_sendString("On");
    126e:	8e e0       	ldi	r24, 0x0E	; 14
    1270:	91 e0       	ldi	r25, 0x01	; 1
    1272:	0e 94 81 02 	call	0x502	; 0x502 <LCD_sendString>
    1276:	04 c0       	rjmp	.+8      	; 0x1280 <Show_running_devices+0x56>
  else
    LCD_sendString("Off");
    1278:	81 e1       	ldi	r24, 0x11	; 17
    127a:	91 e0       	ldi	r25, 0x01	; 1
    127c:	0e 94 81 02 	call	0x502	; 0x502 <LCD_sendString>
  // Show the options menu
  switch (screen) {
    1280:	c1 30       	cpi	r28, 0x01	; 1
    1282:	19 f0       	breq	.+6      	; 0x128a <Show_running_devices+0x60>
    1284:	c7 30       	cpi	r28, 0x07	; 7
    1286:	29 f0       	breq	.+10     	; 0x1292 <Show_running_devices+0x68>
    1288:	08 c0       	rjmp	.+16     	; 0x129a <Show_running_devices+0x70>
      case 1:
        Show_bottom_options_menu(3);
    128a:	83 e0       	ldi	r24, 0x03	; 3
    128c:	0e 94 cb 08 	call	0x1196	; 0x1196 <Show_bottom_options_menu>
        break;
    1290:	07 c0       	rjmp	.+14     	; 0x12a0 <Show_running_devices+0x76>
      case 7:
        Show_bottom_options_menu(2);
    1292:	82 e0       	ldi	r24, 0x02	; 2
    1294:	0e 94 cb 08 	call	0x1196	; 0x1196 <Show_bottom_options_menu>
        break;
    1298:	03 c0       	rjmp	.+6      	; 0x12a0 <Show_running_devices+0x76>
      default:
        Show_bottom_options_menu(1);
    129a:	81 e0       	ldi	r24, 0x01	; 1
    129c:	0e 94 cb 08 	call	0x1196	; 0x1196 <Show_bottom_options_menu>
        break;
    }
  }
    12a0:	cf 91       	pop	r28
    12a2:	08 95       	ret

000012a4 <callFunWhenBufferReady>:
void Remote_init(u32 baudRate) {
  BT_init(baudRate);
  }

void callFunWhenBufferReady(void) {
  requesting_function();
    12a4:	e0 91 0f 07 	lds	r30, 0x070F	; 0x80070f <requesting_function>
    12a8:	f0 91 10 07 	lds	r31, 0x0710	; 0x800710 <requesting_function+0x1>
    12ac:	09 95       	icall
    12ae:	08 95       	ret

000012b0 <println_msg>:
  }

void println_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    12b0:	0e 94 da 01 	call	0x3b4	; 0x3b4 <BT_sendString>
  // Send CRLF - carriage return + new line
  BT_sendString("\r\n");
    12b4:	85 e1       	ldi	r24, 0x15	; 21
    12b6:	91 e0       	ldi	r25, 0x01	; 1
    12b8:	0e 94 da 01 	call	0x3b4	; 0x3b4 <BT_sendString>
    12bc:	08 95       	ret

000012be <print_msg>:
  }

void print_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    12be:	0e 94 da 01 	call	0x3b4	; 0x3b4 <BT_sendString>
    12c2:	08 95       	ret

000012c4 <request_user_input>:
  }

void request_user_input(void (*requestingFunction)(void), u8 msgLength) {
  requesting_function = requestingFunction;
    12c4:	90 93 10 07 	sts	0x0710, r25	; 0x800710 <requesting_function+0x1>
    12c8:	80 93 0f 07 	sts	0x070F, r24	; 0x80070f <requesting_function>
  msg_length = msgLength;
    12cc:	60 93 a0 06 	sts	0x06A0, r22	; 0x8006a0 <msg_length>
    12d0:	08 95       	ret

000012d2 <print_remote_control_menu>:
      }
    }
  }

void print_remote_control_menu(void) {
  println_msg("Select one of the following devices to control:\t");
    12d2:	88 e1       	ldi	r24, 0x18	; 24
    12d4:	91 e0       	ldi	r25, 0x01	; 1
    12d6:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
  println_msg("[1] Lamp 1");
    12da:	89 e4       	ldi	r24, 0x49	; 73
    12dc:	91 e0       	ldi	r25, 0x01	; 1
    12de:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
  println_msg("[2] Lamp 2");
    12e2:	84 e5       	ldi	r24, 0x54	; 84
    12e4:	91 e0       	ldi	r25, 0x01	; 1
    12e6:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
  println_msg("[3] Lamp 3");
    12ea:	8f e5       	ldi	r24, 0x5F	; 95
    12ec:	91 e0       	ldi	r25, 0x01	; 1
    12ee:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
  println_msg("[4] Lamp 4");
    12f2:	8a e6       	ldi	r24, 0x6A	; 106
    12f4:	91 e0       	ldi	r25, 0x01	; 1
    12f6:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
  println_msg("[5] Lamp 5");
    12fa:	85 e7       	ldi	r24, 0x75	; 117
    12fc:	91 e0       	ldi	r25, 0x01	; 1
    12fe:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
  println_msg("[6] Lamp 6");
    1302:	80 e8       	ldi	r24, 0x80	; 128
    1304:	91 e0       	ldi	r25, 0x01	; 1
    1306:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
  if (remote_user.isAdmin) {
    130a:	80 91 a9 06 	lds	r24, 0x06A9	; 0x8006a9 <remote_user>
    130e:	88 23       	and	r24, r24
    1310:	21 f0       	breq	.+8      	; 0x131a <print_remote_control_menu+0x48>
    println_msg("[7] The Door");
    1312:	8b e8       	ldi	r24, 0x8B	; 139
    1314:	91 e0       	ldi	r25, 0x01	; 1
    1316:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    131a:	08 95       	ret

0000131c <control_device>:
  }

// TODO: Send the status of each device to the user instead of just asking him to switch the device on or off.

void control_device(void) {
  u8 option = msg_buffer[0];
    131c:	60 91 91 06 	lds	r22, 0x0691	; 0x800691 <msg_buffer>
  if (invalid_user_input || option < '0' || option > '9') {
    1320:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <invalid_user_input>
    1324:	81 11       	cpse	r24, r1
    1326:	04 c0       	rjmp	.+8      	; 0x1330 <control_device+0x14>
    1328:	60 33       	cpi	r22, 0x30	; 48
    132a:	10 f0       	brcs	.+4      	; 0x1330 <control_device+0x14>
    132c:	6a 33       	cpi	r22, 0x3A	; 58
    132e:	60 f0       	brcs	.+24     	; 0x1348 <control_device+0x2c>
    println_msg("\r\nInvalid input!!\t");
    1330:	88 e9       	ldi	r24, 0x98	; 152
    1332:	91 e0       	ldi	r25, 0x01	; 1
    1334:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    print_remote_control_menu();
    1338:	0e 94 69 09 	call	0x12d2	; 0x12d2 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    133c:	62 e0       	ldi	r22, 0x02	; 2
    133e:	87 ee       	ldi	r24, 0xE7	; 231
    1340:	99 e0       	ldi	r25, 0x09	; 9
    1342:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1346:	08 95       	ret
    }
  else {
    if (device_number < 6) {
    1348:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <device_number>
    134c:	86 30       	cpi	r24, 0x06	; 6
    134e:	80 f4       	brcc	.+32     	; 0x1370 <control_device+0x54>
      if (option == '1') {
    1350:	61 33       	cpi	r22, 0x31	; 49
    1352:	39 f4       	brne	.+14     	; 0x1362 <control_device+0x46>
        Lamp_on(device_number);
    1354:	0e 94 52 08 	call	0x10a4	; 0x10a4 <Lamp_on>
        println_msg("The device has been turned on!");
    1358:	8b ea       	ldi	r24, 0xAB	; 171
    135a:	91 e0       	ldi	r25, 0x01	; 1
    135c:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    1360:	2e c0       	rjmp	.+92     	; 0x13be <control_device+0xa2>
        }
      else {
        Lamp_off(device_number);
    1362:	0e 94 7d 08 	call	0x10fa	; 0x10fa <Lamp_off>
        println_msg("The device has been turned off!");
    1366:	8a ec       	ldi	r24, 0xCA	; 202
    1368:	91 e0       	ldi	r25, 0x01	; 1
    136a:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    136e:	27 c0       	rjmp	.+78     	; 0x13be <control_device+0xa2>
        }
      }
    else if (device_number == 6) { // Dimmable led
    1370:	86 30       	cpi	r24, 0x06	; 6
    1372:	b1 f4       	brne	.+44     	; 0x13a0 <control_device+0x84>
      Lamp_dimmable_set_brightness(((double)(option - 48) / 9.0));
    1374:	70 e0       	ldi	r23, 0x00	; 0
    1376:	60 53       	subi	r22, 0x30	; 48
    1378:	71 09       	sbc	r23, r1
    137a:	07 2e       	mov	r0, r23
    137c:	00 0c       	add	r0, r0
    137e:	88 0b       	sbc	r24, r24
    1380:	99 0b       	sbc	r25, r25
    1382:	0e 94 cb 10 	call	0x2196	; 0x2196 <__floatsisf>
    1386:	20 e0       	ldi	r18, 0x00	; 0
    1388:	30 e0       	ldi	r19, 0x00	; 0
    138a:	40 e1       	ldi	r20, 0x10	; 16
    138c:	51 e4       	ldi	r21, 0x41	; 65
    138e:	0e 94 28 10 	call	0x2050	; 0x2050 <__divsf3>
    1392:	0e 94 a8 08 	call	0x1150	; 0x1150 <Lamp_dimmable_set_brightness>
      println_msg("The brightness has been adjusted!");
    1396:	8a ee       	ldi	r24, 0xEA	; 234
    1398:	91 e0       	ldi	r25, 0x01	; 1
    139a:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    139e:	0f c0       	rjmp	.+30     	; 0x13be <control_device+0xa2>
      }
    else {
      if (option == '1') {
    13a0:	61 33       	cpi	r22, 0x31	; 49
    13a2:	39 f4       	brne	.+14     	; 0x13b2 <control_device+0x96>
        Door_open();
    13a4:	0e 94 25 08 	call	0x104a	; 0x104a <Door_open>
        println_msg("The Door is open now.");
    13a8:	8c e0       	ldi	r24, 0x0C	; 12
    13aa:	92 e0       	ldi	r25, 0x02	; 2
    13ac:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    13b0:	06 c0       	rjmp	.+12     	; 0x13be <control_device+0xa2>
        }
      else {
        Door_close();
    13b2:	0e 94 29 08 	call	0x1052	; 0x1052 <Door_close>
        println_msg("The Door is closed now.");
    13b6:	82 e2       	ldi	r24, 0x22	; 34
    13b8:	92 e0       	ldi	r25, 0x02	; 2
    13ba:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
        }
      }
    print_remote_control_menu();
    13be:	0e 94 69 09 	call	0x12d2	; 0x12d2 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    13c2:	62 e0       	ldi	r22, 0x02	; 2
    13c4:	87 ee       	ldi	r24, 0xE7	; 231
    13c6:	99 e0       	ldi	r25, 0x09	; 9
    13c8:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    13cc:	08 95       	ret

000013ce <remote_control>:
    }
  }

void remote_control(void) {
    13ce:	cf 93       	push	r28
  u8 option = msg_buffer[0];
    13d0:	c0 91 91 06 	lds	r28, 0x0691	; 0x800691 <msg_buffer>
  if (remote_user.isAdmin) {
    13d4:	80 91 a9 06 	lds	r24, 0x06A9	; 0x8006a9 <remote_user>
    13d8:	88 23       	and	r24, r24
    13da:	49 f1       	breq	.+82     	; 0x142e <remote_control+0x60>
    if (invalid_user_input || option < '1' || option > '7') {
    13dc:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <invalid_user_input>
    13e0:	81 11       	cpse	r24, r1
    13e2:	04 c0       	rjmp	.+8      	; 0x13ec <remote_control+0x1e>
    13e4:	c1 33       	cpi	r28, 0x31	; 49
    13e6:	10 f0       	brcs	.+4      	; 0x13ec <remote_control+0x1e>
    13e8:	c8 33       	cpi	r28, 0x38	; 56
    13ea:	60 f0       	brcs	.+24     	; 0x1404 <remote_control+0x36>
      println_msg("Invalid option!\t");
    13ec:	8a e3       	ldi	r24, 0x3A	; 58
    13ee:	92 e0       	ldi	r25, 0x02	; 2
    13f0:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      print_remote_control_menu();
    13f4:	0e 94 69 09 	call	0x12d2	; 0x12d2 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    13f8:	62 e0       	ldi	r22, 0x02	; 2
    13fa:	87 ee       	ldi	r24, 0xE7	; 231
    13fc:	99 e0       	ldi	r25, 0x09	; 9
    13fe:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1402:	3d c0       	rjmp	.+122    	; 0x147e <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    1404:	8b e4       	ldi	r24, 0x4B	; 75
    1406:	92 e0       	ldi	r25, 0x02	; 2
    1408:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    140c:	81 ea       	ldi	r24, 0xA1	; 161
    140e:	92 e0       	ldi	r25, 0x02	; 2
    1410:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    1414:	8a ed       	ldi	r24, 0xDA	; 218
    1416:	92 e0       	ldi	r25, 0x02	; 2
    1418:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      request_user_input(control_device, 2);
    141c:	62 e0       	ldi	r22, 0x02	; 2
    141e:	8e e8       	ldi	r24, 0x8E	; 142
    1420:	99 e0       	ldi	r25, 0x09	; 9
    1422:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
      device_number = option - 48;
    1426:	c0 53       	subi	r28, 0x30	; 48
    1428:	c0 93 ee 06 	sts	0x06EE, r28	; 0x8006ee <device_number>
    142c:	28 c0       	rjmp	.+80     	; 0x147e <remote_control+0xb0>
      }
    }
  else {
    if (invalid_user_input || option < '1' || option > '6') {
    142e:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <invalid_user_input>
    1432:	81 11       	cpse	r24, r1
    1434:	04 c0       	rjmp	.+8      	; 0x143e <remote_control+0x70>
    1436:	c1 33       	cpi	r28, 0x31	; 49
    1438:	10 f0       	brcs	.+4      	; 0x143e <remote_control+0x70>
    143a:	c7 33       	cpi	r28, 0x37	; 55
    143c:	60 f0       	brcs	.+24     	; 0x1456 <remote_control+0x88>
      println_msg("Invalid option!\t");
    143e:	8a e3       	ldi	r24, 0x3A	; 58
    1440:	92 e0       	ldi	r25, 0x02	; 2
    1442:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      print_remote_control_menu();
    1446:	0e 94 69 09 	call	0x12d2	; 0x12d2 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    144a:	62 e0       	ldi	r22, 0x02	; 2
    144c:	87 ee       	ldi	r24, 0xE7	; 231
    144e:	99 e0       	ldi	r25, 0x09	; 9
    1450:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1454:	14 c0       	rjmp	.+40     	; 0x147e <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    1456:	8b e4       	ldi	r24, 0x4B	; 75
    1458:	92 e0       	ldi	r25, 0x02	; 2
    145a:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    145e:	81 ea       	ldi	r24, 0xA1	; 161
    1460:	92 e0       	ldi	r25, 0x02	; 2
    1462:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    1466:	8a ed       	ldi	r24, 0xDA	; 218
    1468:	92 e0       	ldi	r25, 0x02	; 2
    146a:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      request_user_input(control_device, 2);
    146e:	62 e0       	ldi	r22, 0x02	; 2
    1470:	8e e8       	ldi	r24, 0x8E	; 142
    1472:	99 e0       	ldi	r25, 0x09	; 9
    1474:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
      device_number = option - 48;
    1478:	c0 53       	subi	r28, 0x30	; 48
    147a:	c0 93 ee 06 	sts	0x06EE, r28	; 0x8006ee <device_number>
      }
    }
  }
    147e:	cf 91       	pop	r28
    1480:	08 95       	ret

00001482 <print_initial_options_menu>:

void print_initial_options_menu(void) {
  if (remote_user.isAdmin) {
    1482:	80 91 a9 06 	lds	r24, 0x06A9	; 0x8006a9 <remote_user>
    1486:	88 23       	and	r24, r24
    1488:	a9 f0       	breq	.+42     	; 0x14b4 <print_initial_options_menu+0x32>
    println_msg("Select one of the following options(by entering its number):\t");
    148a:	82 e1       	ldi	r24, 0x12	; 18
    148c:	93 e0       	ldi	r25, 0x03	; 3
    148e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    println_msg("[1] Add user\t");
    1492:	80 e5       	ldi	r24, 0x50	; 80
    1494:	93 e0       	ldi	r25, 0x03	; 3
    1496:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    println_msg("[2] Delete user\t");
    149a:	8e e5       	ldi	r24, 0x5E	; 94
    149c:	93 e0       	ldi	r25, 0x03	; 3
    149e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    println_msg("[3] Control a device\t");
    14a2:	8f e6       	ldi	r24, 0x6F	; 111
    14a4:	93 e0       	ldi	r25, 0x03	; 3
    14a6:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    println_msg("[4] Log out\t");
    14aa:	85 e8       	ldi	r24, 0x85	; 133
    14ac:	93 e0       	ldi	r25, 0x03	; 3
    14ae:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    14b2:	08 95       	ret
    }
  else {
    println_msg("Select one of the following options(by entering its number):\t");
    14b4:	82 e1       	ldi	r24, 0x12	; 18
    14b6:	93 e0       	ldi	r25, 0x03	; 3
    14b8:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    println_msg("[1] Control a device\t");
    14bc:	82 e9       	ldi	r24, 0x92	; 146
    14be:	93 e0       	ldi	r25, 0x03	; 3
    14c0:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    println_msg("[2] Log out\t");
    14c4:	88 ea       	ldi	r24, 0xA8	; 168
    14c6:	93 e0       	ldi	r25, 0x03	; 3
    14c8:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    14cc:	08 95       	ret

000014ce <delete_user_prompt>:
  requesting_function = requestingFunction;
  msg_length = msgLength;
  }

void delete_user_prompt(void) {
  if (invalid_user_input) {
    14ce:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <invalid_user_input>
    14d2:	88 23       	and	r24, r24
    14d4:	61 f0       	breq	.+24     	; 0x14ee <delete_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    14d6:	85 eb       	ldi	r24, 0xB5	; 181
    14d8:	93 e0       	ldi	r25, 0x03	; 3
    14da:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    14de:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    14e2:	62 e0       	ldi	r22, 0x02	; 2
    14e4:	8b e9       	ldi	r24, 0x9B	; 155
    14e6:	9a e0       	ldi	r25, 0x0A	; 10
    14e8:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    14ec:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    14ee:	69 ec       	ldi	r22, 0xC9	; 201
    14f0:	76 e0       	ldi	r23, 0x06	; 6
    14f2:	81 e9       	ldi	r24, 0x91	; 145
    14f4:	96 e0       	ldi	r25, 0x06	; 6
    14f6:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    14fa:	83 30       	cpi	r24, 0x03	; 3
    14fc:	61 f4       	brne	.+24     	; 0x1516 <delete_user_prompt+0x48>
      println_msg("\rError! User not found. Returning to the main menu...");
    14fe:	8b ec       	ldi	r24, 0xCB	; 203
    1500:	93 e0       	ldi	r25, 0x03	; 3
    1502:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      print_initial_options_menu();
    1506:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    150a:	62 e0       	ldi	r22, 0x02	; 2
    150c:	8b e9       	ldi	r24, 0x9B	; 155
    150e:	9a e0       	ldi	r25, 0x0A	; 10
    1510:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1514:	08 95       	ret
      }
    else {
      // Delete the user
      delete_user(&temp_user);
    1516:	89 ec       	ldi	r24, 0xC9	; 201
    1518:	96 e0       	ldi	r25, 0x06	; 6
    151a:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <delete_user>
      println_msg("The user has been deleted successfully!\t");
    151e:	81 e0       	ldi	r24, 0x01	; 1
    1520:	94 e0       	ldi	r25, 0x04	; 4
    1522:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1526:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    152a:	62 e0       	ldi	r22, 0x02	; 2
    152c:	8b e9       	ldi	r24, 0x9B	; 155
    152e:	9a e0       	ldi	r25, 0x0A	; 10
    1530:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1534:	08 95       	ret

00001536 <initial_options_menu>:
    println_msg("[2] Log out\t");
    }
  }

void initial_options_menu() {
  if (remote_user.isAdmin) {
    1536:	80 91 a9 06 	lds	r24, 0x06A9	; 0x8006a9 <remote_user>
    153a:	88 23       	and	r24, r24
    153c:	09 f4       	brne	.+2      	; 0x1540 <initial_options_menu+0xa>
    153e:	4b c0       	rjmp	.+150    	; 0x15d6 <initial_options_menu+0xa0>
    u8 option = msg_buffer[0];
    1540:	80 91 91 06 	lds	r24, 0x0691	; 0x800691 <msg_buffer>
    if (invalid_user_input || option < '1' || option > '4') {
    1544:	90 91 a8 06 	lds	r25, 0x06A8	; 0x8006a8 <invalid_user_input>
    1548:	91 11       	cpse	r25, r1
    154a:	04 c0       	rjmp	.+8      	; 0x1554 <initial_options_menu+0x1e>
    154c:	81 33       	cpi	r24, 0x31	; 49
    154e:	10 f0       	brcs	.+4      	; 0x1554 <initial_options_menu+0x1e>
    1550:	85 33       	cpi	r24, 0x35	; 53
    1552:	60 f0       	brcs	.+24     	; 0x156c <initial_options_menu+0x36>
      println_msg("Invalid option!\t");
    1554:	8a e3       	ldi	r24, 0x3A	; 58
    1556:	92 e0       	ldi	r25, 0x02	; 2
    1558:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      print_initial_options_menu();
    155c:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1560:	62 e0       	ldi	r22, 0x02	; 2
    1562:	8b e9       	ldi	r24, 0x9B	; 155
    1564:	9a e0       	ldi	r25, 0x0A	; 10
    1566:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    156a:	08 95       	ret
      }
    else {
      switch (option) {
    156c:	82 33       	cpi	r24, 0x32	; 50
    156e:	99 f0       	breq	.+38     	; 0x1596 <initial_options_menu+0x60>
    1570:	18 f4       	brcc	.+6      	; 0x1578 <initial_options_menu+0x42>
    1572:	81 33       	cpi	r24, 0x31	; 49
    1574:	31 f0       	breq	.+12     	; 0x1582 <initial_options_menu+0x4c>
    1576:	08 95       	ret
    1578:	83 33       	cpi	r24, 0x33	; 51
    157a:	b9 f0       	breq	.+46     	; 0x15aa <initial_options_menu+0x74>
    157c:	84 33       	cpi	r24, 0x34	; 52
    157e:	e9 f0       	breq	.+58     	; 0x15ba <initial_options_menu+0x84>
    1580:	08 95       	ret
          case '1':
            print_msg("Enter the user name: ");
    1582:	8a e2       	ldi	r24, 0x2A	; 42
    1584:	94 e0       	ldi	r25, 0x04	; 4
    1586:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
            request_user_input(add_user_prompt, 13);
    158a:	6d e0       	ldi	r22, 0x0D	; 13
    158c:	8d e9       	ldi	r24, 0x9D	; 157
    158e:	9b e0       	ldi	r25, 0x0B	; 11
    1590:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
            break;
    1594:	08 95       	ret
          case '2':
            print_msg("Enter the user name: ");
    1596:	8a e2       	ldi	r24, 0x2A	; 42
    1598:	94 e0       	ldi	r25, 0x04	; 4
    159a:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
            request_user_input(delete_user_prompt, 13);
    159e:	6d e0       	ldi	r22, 0x0D	; 13
    15a0:	87 e6       	ldi	r24, 0x67	; 103
    15a2:	9a e0       	ldi	r25, 0x0A	; 10
    15a4:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
            break;
    15a8:	08 95       	ret
          case '3':
            print_remote_control_menu();
    15aa:	0e 94 69 09 	call	0x12d2	; 0x12d2 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    15ae:	62 e0       	ldi	r22, 0x02	; 2
    15b0:	87 ee       	ldi	r24, 0xE7	; 231
    15b2:	99 e0       	ldi	r25, 0x09	; 9
    15b4:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
            break;
    15b8:	08 95       	ret
          case '4':
            remote_user_loggedin = true;
    15ba:	81 e0       	ldi	r24, 0x01	; 1
    15bc:	80 93 8f 06 	sts	0x068F, r24	; 0x80068f <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    15c0:	80 e4       	ldi	r24, 0x40	; 64
    15c2:	94 e0       	ldi	r25, 0x04	; 4
    15c4:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
            println_msg("You have successfully logged out...");
    15c8:	88 e8       	ldi	r24, 0x88	; 136
    15ca:	94 e0       	ldi	r25, 0x04	; 4
    15cc:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
            msg_length = 0;
    15d0:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <msg_length>
            break;
    15d4:	08 95       	ret
        }
      }
    }
  else {
    u8 option = msg_buffer[0];
    15d6:	80 91 91 06 	lds	r24, 0x0691	; 0x800691 <msg_buffer>
    if (invalid_user_input || option < '1' || option > '2') {
    15da:	90 91 a8 06 	lds	r25, 0x06A8	; 0x8006a8 <invalid_user_input>
    15de:	91 11       	cpse	r25, r1
    15e0:	04 c0       	rjmp	.+8      	; 0x15ea <initial_options_menu+0xb4>
    15e2:	81 33       	cpi	r24, 0x31	; 49
    15e4:	10 f0       	brcs	.+4      	; 0x15ea <initial_options_menu+0xb4>
    15e6:	83 33       	cpi	r24, 0x33	; 51
    15e8:	60 f0       	brcs	.+24     	; 0x1602 <initial_options_menu+0xcc>
      println_msg("Invalid option!\t");
    15ea:	8a e3       	ldi	r24, 0x3A	; 58
    15ec:	92 e0       	ldi	r25, 0x02	; 2
    15ee:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      print_initial_options_menu();
    15f2:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    15f6:	62 e0       	ldi	r22, 0x02	; 2
    15f8:	8b e9       	ldi	r24, 0x9B	; 155
    15fa:	9a e0       	ldi	r25, 0x0A	; 10
    15fc:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1600:	08 95       	ret
      }
    else {
      switch (option) {
    1602:	81 33       	cpi	r24, 0x31	; 49
    1604:	19 f0       	breq	.+6      	; 0x160c <initial_options_menu+0xd6>
    1606:	82 33       	cpi	r24, 0x32	; 50
    1608:	49 f0       	breq	.+18     	; 0x161c <initial_options_menu+0xe6>
    160a:	08 95       	ret
          case '1':
            print_remote_control_menu();
    160c:	0e 94 69 09 	call	0x12d2	; 0x12d2 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    1610:	62 e0       	ldi	r22, 0x02	; 2
    1612:	87 ee       	ldi	r24, 0xE7	; 231
    1614:	99 e0       	ldi	r25, 0x09	; 9
    1616:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
            break;
    161a:	08 95       	ret
          case '2':
            remote_user_loggedin = true;
    161c:	81 e0       	ldi	r24, 0x01	; 1
    161e:	80 93 8f 06 	sts	0x068F, r24	; 0x80068f <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    1622:	80 e4       	ldi	r24, 0x40	; 64
    1624:	94 e0       	ldi	r25, 0x04	; 4
    1626:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
            println_msg("You have successfully logged out...");
    162a:	88 e8       	ldi	r24, 0x88	; 136
    162c:	94 e0       	ldi	r25, 0x04	; 4
    162e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
            msg_length = 0;
    1632:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <msg_length>
    1636:	08 95       	ret

00001638 <add_user_isAdmin_prompt>:
      }
    }
  }

void add_user_isAdmin_prompt(void) {
  if (invalid_user_input) {
    1638:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <invalid_user_input>
    163c:	88 23       	and	r24, r24
    163e:	61 f0       	breq	.+24     	; 0x1658 <add_user_isAdmin_prompt+0x20>
    println_msg("\r\nInvalid input!!\t");
    1640:	88 e9       	ldi	r24, 0x98	; 152
    1642:	91 e0       	ldi	r25, 0x01	; 1
    1644:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    //! The system should ask the user wether he wants to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1648:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    164c:	62 e0       	ldi	r22, 0x02	; 2
    164e:	8b e9       	ldi	r24, 0x9B	; 155
    1650:	9a e0       	ldi	r25, 0x0A	; 10
    1652:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1656:	08 95       	ret
    }
  else {
    new_user.isAdmin = (msg_buffer[0] == 'y' || msg_buffer[0] == 'Y');
    1658:	80 91 91 06 	lds	r24, 0x0691	; 0x800691 <msg_buffer>
    165c:	89 37       	cpi	r24, 0x79	; 121
    165e:	21 f0       	breq	.+8      	; 0x1668 <add_user_isAdmin_prompt+0x30>
    1660:	89 35       	cpi	r24, 0x59	; 89
    1662:	21 f4       	brne	.+8      	; 0x166c <add_user_isAdmin_prompt+0x34>
    1664:	81 e0       	ldi	r24, 0x01	; 1
    1666:	03 c0       	rjmp	.+6      	; 0x166e <add_user_isAdmin_prompt+0x36>
    1668:	81 e0       	ldi	r24, 0x01	; 1
    166a:	01 c0       	rjmp	.+2      	; 0x166e <add_user_isAdmin_prompt+0x36>
    166c:	80 e0       	ldi	r24, 0x00	; 0
    166e:	80 93 ef 06 	sts	0x06EF, r24	; 0x8006ef <new_user>
    add_user(&new_user);
    1672:	8f ee       	ldi	r24, 0xEF	; 239
    1674:	96 e0       	ldi	r25, 0x06	; 6
    1676:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <add_user>
    println_msg("User has been added successfully!");
    167a:	8c ea       	ldi	r24, 0xAC	; 172
    167c:	94 e0       	ldi	r25, 0x04	; 4
    167e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    //! Return to the main menu
    print_initial_options_menu();
    1682:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1686:	62 e0       	ldi	r22, 0x02	; 2
    1688:	8b e9       	ldi	r24, 0x9B	; 155
    168a:	9a e0       	ldi	r25, 0x0A	; 10
    168c:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1690:	08 95       	ret

00001692 <add_user_password_prompt>:
    }
  }

void add_user_password_prompt(void) {
  if (invalid_user_input) {
    1692:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <invalid_user_input>
    1696:	88 23       	and	r24, r24
    1698:	61 f0       	breq	.+24     	; 0x16b2 <add_user_password_prompt+0x20>
    println_msg("\r\nPassword too long!!\t");
    169a:	8e ec       	ldi	r24, 0xCE	; 206
    169c:	94 e0       	ldi	r25, 0x04	; 4
    169e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    16a2:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    16a6:	62 e0       	ldi	r22, 0x02	; 2
    16a8:	8b e9       	ldi	r24, 0x9B	; 155
    16aa:	9a e0       	ldi	r25, 0x0A	; 10
    16ac:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    16b0:	08 95       	ret
    }
  else {
    strcpy(new_user.password, msg_buffer);
    16b2:	61 e9       	ldi	r22, 0x91	; 145
    16b4:	76 e0       	ldi	r23, 0x06	; 6
    16b6:	84 e0       	ldi	r24, 0x04	; 4
    16b8:	97 e0       	ldi	r25, 0x07	; 7
    16ba:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <strcpy>
    print_msg("Do you want to make the new user an admin? (y/n) ");
    16be:	85 ee       	ldi	r24, 0xE5	; 229
    16c0:	94 e0       	ldi	r25, 0x04	; 4
    16c2:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
    request_user_input(add_user_isAdmin_prompt, 2);
    16c6:	62 e0       	ldi	r22, 0x02	; 2
    16c8:	8c e1       	ldi	r24, 0x1C	; 28
    16ca:	9b e0       	ldi	r25, 0x0B	; 11
    16cc:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    16d0:	08 95       	ret

000016d2 <add_user_code_prompt>:
    }
  }

void add_user_code_prompt(void) {
  if (invalid_user_input) {
    16d2:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <invalid_user_input>
    16d6:	88 23       	and	r24, r24
    16d8:	61 f0       	breq	.+24     	; 0x16f2 <add_user_code_prompt+0x20>
    println_msg("\r\nInvalid user code!\t");
    16da:	87 e1       	ldi	r24, 0x17	; 23
    16dc:	95 e0       	ldi	r25, 0x05	; 5
    16de:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    16e2:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    16e6:	62 e0       	ldi	r22, 0x02	; 2
    16e8:	8b e9       	ldi	r24, 0x9B	; 155
    16ea:	9a e0       	ldi	r25, 0x0A	; 10
    16ec:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    16f0:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByCode(msg_buffer, &temp_user);
    16f2:	69 ec       	ldi	r22, 0xC9	; 201
    16f4:	76 e0       	ldi	r23, 0x06	; 6
    16f6:	81 e9       	ldi	r24, 0x91	; 145
    16f8:	96 e0       	ldi	r25, 0x06	; 6
    16fa:	0e 94 0b 0e 	call	0x1c16	; 0x1c16 <getUserByCode>
    if (userExists == USER_NOT_FOUND) {
    16fe:	83 30       	cpi	r24, 0x03	; 3
    1700:	81 f4       	brne	.+32     	; 0x1722 <add_user_code_prompt+0x50>
      strcpy(new_user.code, msg_buffer);
    1702:	61 e9       	ldi	r22, 0x91	; 145
    1704:	76 e0       	ldi	r23, 0x06	; 6
    1706:	8d ef       	ldi	r24, 0xFD	; 253
    1708:	96 e0       	ldi	r25, 0x06	; 6
    170a:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <strcpy>
      print_msg("Enter the new user's password: ");
    170e:	8d e2       	ldi	r24, 0x2D	; 45
    1710:	95 e0       	ldi	r25, 0x05	; 5
    1712:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
      request_user_input(add_user_password_prompt, 11);
    1716:	6b e0       	ldi	r22, 0x0B	; 11
    1718:	89 e4       	ldi	r24, 0x49	; 73
    171a:	9b e0       	ldi	r25, 0x0B	; 11
    171c:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1720:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      println_msg("\rThe user code already exists!\t");
    1722:	8d e4       	ldi	r24, 0x4D	; 77
    1724:	95 e0       	ldi	r25, 0x05	; 5
    1726:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    172a:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    172e:	62 e0       	ldi	r22, 0x02	; 2
    1730:	8b e9       	ldi	r24, 0x9B	; 155
    1732:	9a e0       	ldi	r25, 0x0A	; 10
    1734:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1738:	08 95       	ret

0000173a <add_user_prompt>:
      }
    }
  }

void add_user_prompt(void) {
  if (invalid_user_input) {
    173a:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <invalid_user_input>
    173e:	88 23       	and	r24, r24
    1740:	61 f0       	breq	.+24     	; 0x175a <add_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    1742:	85 eb       	ldi	r24, 0xB5	; 181
    1744:	93 e0       	ldi	r25, 0x03	; 3
    1746:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    174a:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    174e:	62 e0       	ldi	r22, 0x02	; 2
    1750:	8b e9       	ldi	r24, 0x9B	; 155
    1752:	9a e0       	ldi	r25, 0x0A	; 10
    1754:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1758:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    175a:	69 ec       	ldi	r22, 0xC9	; 201
    175c:	76 e0       	ldi	r23, 0x06	; 6
    175e:	81 e9       	ldi	r24, 0x91	; 145
    1760:	96 e0       	ldi	r25, 0x06	; 6
    1762:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    1766:	83 30       	cpi	r24, 0x03	; 3
    1768:	81 f4       	brne	.+32     	; 0x178a <add_user_prompt+0x50>
      strcpy(new_user.name, msg_buffer);
    176a:	61 e9       	ldi	r22, 0x91	; 145
    176c:	76 e0       	ldi	r23, 0x06	; 6
    176e:	80 ef       	ldi	r24, 0xF0	; 240
    1770:	96 e0       	ldi	r25, 0x06	; 6
    1772:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <strcpy>
      print_msg("Enter the new user's code(must be a unique six digit code): ");
    1776:	8d e6       	ldi	r24, 0x6D	; 109
    1778:	95 e0       	ldi	r25, 0x05	; 5
    177a:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
      request_user_input(add_user_code_prompt, 7);
    177e:	67 e0       	ldi	r22, 0x07	; 7
    1780:	89 e6       	ldi	r24, 0x69	; 105
    1782:	9b e0       	ldi	r25, 0x0B	; 11
    1784:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1788:	08 95       	ret
      }
    else {
      // Prompt the user to enter the user code
      println_msg("\rThe user already exists!\t");
    178a:	8a ea       	ldi	r24, 0xAA	; 170
    178c:	95 e0       	ldi	r25, 0x05	; 5
    178e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1792:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1796:	62 e0       	ldi	r22, 0x02	; 2
    1798:	8b e9       	ldi	r24, 0x9B	; 155
    179a:	9a e0       	ldi	r25, 0x0A	; 10
    179c:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    17a0:	08 95       	ret

000017a2 <invalid_remote_login_attempt>:
      }
    }
  }

void invalid_remote_login_attempt(void) {
    17a2:	0f 93       	push	r16
    17a4:	1f 93       	push	r17
    17a6:	cf 93       	push	r28
    17a8:	df 93       	push	r29
    17aa:	cd b7       	in	r28, 0x3d	; 61
    17ac:	de b7       	in	r29, 0x3e	; 62
    17ae:	e2 97       	sbiw	r28, 0x32	; 50
    17b0:	0f b6       	in	r0, 0x3f	; 63
    17b2:	f8 94       	cli
    17b4:	de bf       	out	0x3e, r29	; 62
    17b6:	0f be       	out	0x3f, r0	; 63
    17b8:	cd bf       	out	0x3d, r28	; 61
  invalid_trails++;
    17ba:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__data_end>
    17be:	8f 5f       	subi	r24, 0xFF	; 255
    17c0:	80 93 8e 06 	sts	0x068E, r24	; 0x80068e <__data_end>
  if (invalid_trails < 3) {
    17c4:	83 30       	cpi	r24, 0x03	; 3
    17c6:	e8 f4       	brcc	.+58     	; 0x1802 <invalid_remote_login_attempt+0x60>
    s8 msg[50];
    sprintf(msg, "\r\nInvalid login attempt! \r\n%d attempts remaining.", 3 - invalid_trails);
    17c8:	23 e0       	ldi	r18, 0x03	; 3
    17ca:	30 e0       	ldi	r19, 0x00	; 0
    17cc:	a9 01       	movw	r20, r18
    17ce:	48 1b       	sub	r20, r24
    17d0:	51 09       	sbc	r21, r1
    17d2:	ca 01       	movw	r24, r20
    17d4:	9f 93       	push	r25
    17d6:	4f 93       	push	r20
    17d8:	85 ec       	ldi	r24, 0xC5	; 197
    17da:	95 e0       	ldi	r25, 0x05	; 5
    17dc:	9f 93       	push	r25
    17de:	8f 93       	push	r24
    17e0:	8e 01       	movw	r16, r28
    17e2:	0f 5f       	subi	r16, 0xFF	; 255
    17e4:	1f 4f       	sbci	r17, 0xFF	; 255
    17e6:	1f 93       	push	r17
    17e8:	0f 93       	push	r16
    17ea:	0e 94 da 11 	call	0x23b4	; 0x23b4 <sprintf>
    println_msg(msg);
    17ee:	c8 01       	movw	r24, r16
    17f0:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
    17f4:	0f 90       	pop	r0
    17f6:	0f 90       	pop	r0
    17f8:	0f 90       	pop	r0
    17fa:	0f 90       	pop	r0
    17fc:	0f 90       	pop	r0
    17fe:	0f 90       	pop	r0
    1800:	04 c0       	rjmp	.+8      	; 0x180a <invalid_remote_login_attempt+0x68>
    return;
    }
  set_alarm();
    1802:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <set_alarm>
  run_system = false;
    1806:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__data_start>
  }
    180a:	e2 96       	adiw	r28, 0x32	; 50
    180c:	0f b6       	in	r0, 0x3f	; 63
    180e:	f8 94       	cli
    1810:	de bf       	out	0x3e, r29	; 62
    1812:	0f be       	out	0x3f, r0	; 63
    1814:	cd bf       	out	0x3d, r28	; 61
    1816:	df 91       	pop	r29
    1818:	cf 91       	pop	r28
    181a:	1f 91       	pop	r17
    181c:	0f 91       	pop	r16
    181e:	08 95       	ret

00001820 <userPassword_prompt_handler>:

void userPassword_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    1820:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <invalid_user_input>
    1824:	88 23       	and	r24, r24
    1826:	61 f0       	breq	.+24     	; 0x1840 <userPassword_prompt_handler+0x20>
    invalid_remote_login_attempt();
    1828:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <invalid_remote_login_attempt>
    print_msg("Enter your password:\t");
    182c:	87 ef       	ldi	r24, 0xF7	; 247
    182e:	95 e0       	ldi	r25, 0x05	; 5
    1830:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
    request_user_input(userPassword_prompt_handler, 11);
    1834:	6b e0       	ldi	r22, 0x0B	; 11
    1836:	80 e1       	ldi	r24, 0x10	; 16
    1838:	9c e0       	ldi	r25, 0x0C	; 12
    183a:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    183e:	08 95       	ret
    }
  else {
    if (strcmp(remote_user.password, msg_buffer)) { // Wrong password
    1840:	61 e9       	ldi	r22, 0x91	; 145
    1842:	76 e0       	ldi	r23, 0x06	; 6
    1844:	8e eb       	ldi	r24, 0xBE	; 190
    1846:	96 e0       	ldi	r25, 0x06	; 6
    1848:	0e 94 ca 11 	call	0x2394	; 0x2394 <strcmp>
    184c:	89 2b       	or	r24, r25
    184e:	81 f0       	breq	.+32     	; 0x1870 <userPassword_prompt_handler+0x50>
      print_msg("Wrong password!");
    1850:	8d e0       	ldi	r24, 0x0D	; 13
    1852:	96 e0       	ldi	r25, 0x06	; 6
    1854:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
      invalid_remote_login_attempt();
    1858:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <invalid_remote_login_attempt>
      print_msg("Enter your password:\t");
    185c:	87 ef       	ldi	r24, 0xF7	; 247
    185e:	95 e0       	ldi	r25, 0x05	; 5
    1860:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    1864:	6b e0       	ldi	r22, 0x0B	; 11
    1866:	80 e1       	ldi	r24, 0x10	; 16
    1868:	9c e0       	ldi	r25, 0x0C	; 12
    186a:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    186e:	08 95       	ret
      }
    else {
      remote_user_loggedin = true;
    1870:	81 e0       	ldi	r24, 0x01	; 1
    1872:	80 93 8f 06 	sts	0x068F, r24	; 0x80068f <remote_user_loggedin>
      print_msg("Welcome ");
    1876:	8d e1       	ldi	r24, 0x1D	; 29
    1878:	96 e0       	ldi	r25, 0x06	; 6
    187a:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
      print_msg(remote_user.name);
    187e:	8a ea       	ldi	r24, 0xAA	; 170
    1880:	96 e0       	ldi	r25, 0x06	; 6
    1882:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
      println_msg("!");
    1886:	8a e0       	ldi	r24, 0x0A	; 10
    1888:	92 e0       	ldi	r25, 0x02	; 2
    188a:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
      // Show the options menu
      print_initial_options_menu();
    188e:	0e 94 41 0a 	call	0x1482	; 0x1482 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1892:	62 e0       	ldi	r22, 0x02	; 2
    1894:	8b e9       	ldi	r24, 0x9B	; 155
    1896:	9a e0       	ldi	r25, 0x0A	; 10
    1898:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    189c:	08 95       	ret

0000189e <userName_prompt_handler>:
    }
  }

void userName_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    189e:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <invalid_user_input>
    18a2:	88 23       	and	r24, r24
    18a4:	61 f0       	breq	.+24     	; 0x18be <userName_prompt_handler+0x20>
    invalid_remote_login_attempt();
    18a6:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <invalid_remote_login_attempt>
    print_msg("Enter your user name:\t");
    18aa:	86 e2       	ldi	r24, 0x26	; 38
    18ac:	96 e0       	ldi	r25, 0x06	; 6
    18ae:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
    request_user_input(userName_prompt_handler, 13);
    18b2:	6d e0       	ldi	r22, 0x0D	; 13
    18b4:	8f e4       	ldi	r24, 0x4F	; 79
    18b6:	9c e0       	ldi	r25, 0x0C	; 12
    18b8:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    18bc:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &remote_user);
    18be:	69 ea       	ldi	r22, 0xA9	; 169
    18c0:	76 e0       	ldi	r23, 0x06	; 6
    18c2:	81 e9       	ldi	r24, 0x91	; 145
    18c4:	96 e0       	ldi	r25, 0x06	; 6
    18c6:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    18ca:	83 30       	cpi	r24, 0x03	; 3
    18cc:	81 f4       	brne	.+32     	; 0x18ee <userName_prompt_handler+0x50>
      print_msg("User doesn't exist!");
    18ce:	8d e3       	ldi	r24, 0x3D	; 61
    18d0:	96 e0       	ldi	r25, 0x06	; 6
    18d2:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
      invalid_remote_login_attempt();
    18d6:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <invalid_remote_login_attempt>
      print_msg("Enter your user name:\t");
    18da:	86 e2       	ldi	r24, 0x26	; 38
    18dc:	96 e0       	ldi	r25, 0x06	; 6
    18de:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
      request_user_input(userName_prompt_handler, 13);
    18e2:	6d e0       	ldi	r22, 0x0D	; 13
    18e4:	8f e4       	ldi	r24, 0x4F	; 79
    18e6:	9c e0       	ldi	r25, 0x0C	; 12
    18e8:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    18ec:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      print_msg("Enter your password:\t");
    18ee:	87 ef       	ldi	r24, 0xF7	; 247
    18f0:	95 e0       	ldi	r25, 0x05	; 5
    18f2:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    18f6:	6b e0       	ldi	r22, 0x0B	; 11
    18f8:	80 e1       	ldi	r24, 0x10	; 16
    18fa:	9c e0       	ldi	r25, 0x0C	; 12
    18fc:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1900:	08 95       	ret

00001902 <remote_login_prompt>:
      }
    }
  }

void remote_login_prompt(void) {
  println_msg("Welcome to the Smart Home System!");
    1902:	81 e5       	ldi	r24, 0x51	; 81
    1904:	96 e0       	ldi	r25, 0x06	; 6
    1906:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
  println_msg("To proceed, please login.");
    190a:	83 e7       	ldi	r24, 0x73	; 115
    190c:	96 e0       	ldi	r25, 0x06	; 6
    190e:	0e 94 58 09 	call	0x12b0	; 0x12b0 <println_msg>
  print_msg("Enter your user name:\t");
    1912:	86 e2       	ldi	r24, 0x26	; 38
    1914:	96 e0       	ldi	r25, 0x06	; 6
    1916:	0e 94 5f 09 	call	0x12be	; 0x12be <print_msg>
  request_user_input(userName_prompt_handler, 13);
    191a:	6d e0       	ldi	r22, 0x0D	; 13
    191c:	8f e4       	ldi	r24, 0x4F	; 79
    191e:	9c e0       	ldi	r25, 0x0C	; 12
    1920:	0e 94 62 09 	call	0x12c4	; 0x12c4 <request_user_input>
    1924:	08 95       	ret

00001926 <__vector_13>:
  }

// Handles the user input asynchronously.
ISR(USART_RXC_vect) {
    1926:	1f 92       	push	r1
    1928:	0f 92       	push	r0
    192a:	0f b6       	in	r0, 0x3f	; 63
    192c:	0f 92       	push	r0
    192e:	11 24       	eor	r1, r1
    1930:	2f 93       	push	r18
    1932:	3f 93       	push	r19
    1934:	4f 93       	push	r20
    1936:	5f 93       	push	r21
    1938:	6f 93       	push	r22
    193a:	7f 93       	push	r23
    193c:	8f 93       	push	r24
    193e:	9f 93       	push	r25
    1940:	af 93       	push	r26
    1942:	bf 93       	push	r27
    1944:	ef 93       	push	r30
    1946:	ff 93       	push	r31
#if UART_COMMUNICATION_INTERFACE ==  PROTEUS_VIRTUAL_TERMINAL
  // Read the UDR to clear the RXC bit
  udr_temp = UDR;
    1948:	8c b1       	in	r24, 0x0c	; 12
    194a:	80 93 ed 06 	sts	0x06ED, r24	; 0x8006ed <udr_temp>

  // If no input requested, ignore the input. No input requested is indicated by msg length of zero
  if (msg_length == 0) return;
    194e:	90 91 a0 06 	lds	r25, 0x06A0	; 0x8006a0 <msg_length>
    1952:	99 23       	and	r25, r25
    1954:	09 f4       	brne	.+2      	; 0x1958 <__vector_13+0x32>
    1956:	51 c0       	rjmp	.+162    	; 0x19fa <__vector_13+0xd4>

  // Handling backspaces
  if (udr_temp == '\b') {
    1958:	88 30       	cpi	r24, 0x08	; 8
    195a:	59 f4       	brne	.+22     	; 0x1972 <__vector_13+0x4c>
    if (msg_buffer_pointer > 0) {
    195c:	90 91 90 06 	lds	r25, 0x0690	; 0x800690 <msg_buffer_pointer>
    1960:	99 23       	and	r25, r25
    1962:	09 f4       	brne	.+2      	; 0x1966 <__vector_13+0x40>
    1964:	4a c0       	rjmp	.+148    	; 0x19fa <__vector_13+0xd4>
      msg_buffer_pointer--;
    1966:	91 50       	subi	r25, 0x01	; 1
    1968:	90 93 90 06 	sts	0x0690, r25	; 0x800690 <msg_buffer_pointer>
      BT_sendChar(udr_temp);
    196c:	0e 94 d7 01 	call	0x3ae	; 0x3ae <BT_sendChar>
    1970:	44 c0       	rjmp	.+136    	; 0x19fa <__vector_13+0xd4>
      }
    return;
    }

  msg_buffer[msg_buffer_pointer] = udr_temp;
    1972:	90 91 90 06 	lds	r25, 0x0690	; 0x800690 <msg_buffer_pointer>
    1976:	e9 2f       	mov	r30, r25
    1978:	f0 e0       	ldi	r31, 0x00	; 0
    197a:	ef 56       	subi	r30, 0x6F	; 111
    197c:	f9 4f       	sbci	r31, 0xF9	; 249
    197e:	80 83       	st	Z, r24
  msg_buffer_pointer++;
    1980:	9f 5f       	subi	r25, 0xFF	; 255
    1982:	90 93 90 06 	sts	0x0690, r25	; 0x800690 <msg_buffer_pointer>

  // Msg is empty
  // Ignore null msgs
  if (msg_buffer_pointer == 1) {
    1986:	91 30       	cpi	r25, 0x01	; 1
    1988:	39 f4       	brne	.+14     	; 0x1998 <__vector_13+0x72>
    if (msg_buffer[0] == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    198a:	90 91 91 06 	lds	r25, 0x0691	; 0x800691 <msg_buffer>
    198e:	9d 30       	cpi	r25, 0x0D	; 13
    1990:	19 f4       	brne	.+6      	; 0x1998 <__vector_13+0x72>
      msg_buffer_pointer = 0;
    1992:	10 92 90 06 	sts	0x0690, r1	; 0x800690 <msg_buffer_pointer>
      return;
    1996:	31 c0       	rjmp	.+98     	; 0x19fa <__vector_13+0xd4>
      }
    }

  // Echo the sent char on the terminal
  //! Proteus virtual terminal doesn't send a line feed char (ASCII code: 10). Instead it sends a carriage return (ASCII code: 13).
  if (udr_temp != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER)
    1998:	8d 30       	cpi	r24, 0x0D	; 13
    199a:	11 f0       	breq	.+4      	; 0x19a0 <__vector_13+0x7a>
    BT_sendChar(udr_temp);
    199c:	0e 94 d7 01 	call	0x3ae	; 0x3ae <BT_sendChar>

  // Msg is longer than required
  if (msg_buffer_pointer == msg_length) {
    19a0:	e0 91 90 06 	lds	r30, 0x0690	; 0x800690 <msg_buffer_pointer>
    19a4:	80 91 a0 06 	lds	r24, 0x06A0	; 0x8006a0 <msg_length>
    19a8:	e8 13       	cpse	r30, r24
    19aa:	12 c0       	rjmp	.+36     	; 0x19d0 <__vector_13+0xaa>
    if (msg_buffer[msg_buffer_pointer - 1] != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    19ac:	f0 e0       	ldi	r31, 0x00	; 0
    19ae:	e0 57       	subi	r30, 0x70	; 112
    19b0:	f9 4f       	sbci	r31, 0xF9	; 249
    19b2:	80 81       	ld	r24, Z
    19b4:	8d 30       	cpi	r24, 0x0D	; 13
    19b6:	61 f0       	breq	.+24     	; 0x19d0 <__vector_13+0xaa>
      invalid_user_input = true;
    19b8:	81 e0       	ldi	r24, 0x01	; 1
    19ba:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <invalid_user_input>
      dump_invalid_data = true;
    19be:	80 93 e9 06 	sts	0x06E9, r24	; 0x8006e9 <dump_invalid_data>
      msg_buffer_pointer = 0;
    19c2:	10 92 90 06 	sts	0x0690, r1	; 0x800690 <msg_buffer_pointer>
      BT_sendChar('\r');
    19c6:	8d e0       	ldi	r24, 0x0D	; 13
    19c8:	0e 94 d7 01 	call	0x3ae	; 0x3ae <BT_sendChar>
      callFunWhenBufferReady();
    19cc:	0e 94 52 09 	call	0x12a4	; 0x12a4 <callFunWhenBufferReady>
      }
    }

  // Msg has ended and is within the required length
  if (udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    19d0:	80 91 ed 06 	lds	r24, 0x06ED	; 0x8006ed <udr_temp>
    19d4:	8d 30       	cpi	r24, 0x0D	; 13
    19d6:	89 f4       	brne	.+34     	; 0x19fa <__vector_13+0xd4>
    if (msg_buffer_pointer <= msg_length) {
    19d8:	e0 91 90 06 	lds	r30, 0x0690	; 0x800690 <msg_buffer_pointer>
    19dc:	80 91 a0 06 	lds	r24, 0x06A0	; 0x8006a0 <msg_length>
    19e0:	8e 17       	cp	r24, r30
    19e2:	58 f0       	brcs	.+22     	; 0x19fa <__vector_13+0xd4>
      // Replace the carriage return with null to terminate the string correctly
      msg_buffer[msg_buffer_pointer - 1] = '\0';
    19e4:	f0 e0       	ldi	r31, 0x00	; 0
    19e6:	e0 57       	subi	r30, 0x70	; 112
    19e8:	f9 4f       	sbci	r31, 0xF9	; 249
    19ea:	10 82       	st	Z, r1
      BT_sendChar('\r');
    19ec:	8d e0       	ldi	r24, 0x0D	; 13
    19ee:	0e 94 d7 01 	call	0x3ae	; 0x3ae <BT_sendChar>
      callFunWhenBufferReady();
    19f2:	0e 94 52 09 	call	0x12a4	; 0x12a4 <callFunWhenBufferReady>
      msg_buffer_pointer = 0;
    19f6:	10 92 90 06 	sts	0x0690, r1	; 0x800690 <msg_buffer_pointer>
      callFunWhenBufferReady();
      msg_buffer_pointer = 0;
      }
    }
#endif
  }
    19fa:	ff 91       	pop	r31
    19fc:	ef 91       	pop	r30
    19fe:	bf 91       	pop	r27
    1a00:	af 91       	pop	r26
    1a02:	9f 91       	pop	r25
    1a04:	8f 91       	pop	r24
    1a06:	7f 91       	pop	r23
    1a08:	6f 91       	pop	r22
    1a0a:	5f 91       	pop	r21
    1a0c:	4f 91       	pop	r20
    1a0e:	3f 91       	pop	r19
    1a10:	2f 91       	pop	r18
    1a12:	0f 90       	pop	r0
    1a14:	0f be       	out	0x3f, r0	; 63
    1a16:	0f 90       	pop	r0
    1a18:	1f 90       	pop	r1
    1a1a:	18 95       	reti

00001a1c <__vector_1>:

ISR(INT0_vect) {
    1a1c:	1f 92       	push	r1
    1a1e:	0f 92       	push	r0
    1a20:	0f b6       	in	r0, 0x3f	; 63
    1a22:	0f 92       	push	r0
    1a24:	11 24       	eor	r1, r1
    1a26:	2f 93       	push	r18
    1a28:	3f 93       	push	r19
    1a2a:	4f 93       	push	r20
    1a2c:	5f 93       	push	r21
    1a2e:	6f 93       	push	r22
    1a30:	7f 93       	push	r23
    1a32:	8f 93       	push	r24
    1a34:	9f 93       	push	r25
    1a36:	af 93       	push	r26
    1a38:	bf 93       	push	r27
    1a3a:	ef 93       	push	r30
    1a3c:	ff 93       	push	r31
  // Initialize communication with the user
  // Request user login credentials
  remote_login_prompt();
    1a3e:	0e 94 81 0c 	call	0x1902	; 0x1902 <remote_login_prompt>
  }
    1a42:	ff 91       	pop	r31
    1a44:	ef 91       	pop	r30
    1a46:	bf 91       	pop	r27
    1a48:	af 91       	pop	r26
    1a4a:	9f 91       	pop	r25
    1a4c:	8f 91       	pop	r24
    1a4e:	7f 91       	pop	r23
    1a50:	6f 91       	pop	r22
    1a52:	5f 91       	pop	r21
    1a54:	4f 91       	pop	r20
    1a56:	3f 91       	pop	r19
    1a58:	2f 91       	pop	r18
    1a5a:	0f 90       	pop	r0
    1a5c:	0f be       	out	0x3f, r0	; 63
    1a5e:	0f 90       	pop	r0
    1a60:	1f 90       	pop	r1
    1a62:	18 95       	reti

00001a64 <__vector_16>:
#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_BY_ACTIVATING_TIMER0_OVF_INT
// To reset the TOV0 flag. Alternatively, it can be reset in the ADC complete interrupt.
ISR(TIMER0_OVF_vect) {}
#endif

ISR(ADC_vect) {
    1a64:	1f 92       	push	r1
    1a66:	0f 92       	push	r0
    1a68:	0f b6       	in	r0, 0x3f	; 63
    1a6a:	0f 92       	push	r0
    1a6c:	11 24       	eor	r1, r1
    1a6e:	2f 93       	push	r18
    1a70:	3f 93       	push	r19
    1a72:	4f 93       	push	r20
    1a74:	5f 93       	push	r21
    1a76:	6f 93       	push	r22
    1a78:	7f 93       	push	r23
    1a7a:	8f 93       	push	r24
    1a7c:	9f 93       	push	r25
    1a7e:	af 93       	push	r26
    1a80:	bf 93       	push	r27
    1a82:	cf 93       	push	r28
    1a84:	df 93       	push	r29
    1a86:	ef 93       	push	r30
    1a88:	ff 93       	push	r31
  u16 temperature;
  temperature = ADCL + (ADCH << 8);
    1a8a:	84 b1       	in	r24, 0x04	; 4
    1a8c:	c5 b1       	in	r28, 0x05	; 5
    1a8e:	d0 e0       	ldi	r29, 0x00	; 0
    1a90:	dc 2f       	mov	r29, r28
    1a92:	cc 27       	eor	r28, r28
    1a94:	c8 0f       	add	r28, r24
    1a96:	d1 1d       	adc	r29, r1
  // Since the ADC is set to use the internal VREF of 2.56 V, the resolution of the ADC is 2.5 mV. This resolution allows to measure the temperature
  // out of the LM35 with a resolution of 0.25 degree celsius, since each 10mV  increment on the LM35 output is 1 degree C.
  // If the temperature is higher than the maximum specified temperature, turn on the AC.
  if (temperature > AMBIENT_HIGH_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, HIGH);
    1a98:	c1 37       	cpi	r28, 0x71	; 113
    1a9a:	d1 05       	cpc	r29, r1
    1a9c:	28 f0       	brcs	.+10     	; 0x1aa8 <__vector_16+0x44>
    1a9e:	41 e0       	ldi	r20, 0x01	; 1
    1aa0:	63 e4       	ldi	r22, 0x43	; 67
    1aa2:	87 e0       	ldi	r24, 0x07	; 7
    1aa4:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>
  // If the temperature became below the minimum specified temperature turn off the AC.
  if (temperature < AMBIENT_LOW_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, LOW);
    1aa8:	c4 35       	cpi	r28, 0x54	; 84
    1aaa:	d1 05       	cpc	r29, r1
    1aac:	28 f4       	brcc	.+10     	; 0x1ab8 <__vector_16+0x54>
    1aae:	40 e0       	ldi	r20, 0x00	; 0
    1ab0:	63 e4       	ldi	r22, 0x43	; 67
    1ab2:	87 e0       	ldi	r24, 0x07	; 7
    1ab4:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <DIO_write>

#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_VIA_ADC_COMPLETE_INTERRUPT
  // Since the ADC is configured in auto trigger mode with timer 0 overflow as the trigger, 
  // The overflow interrupt flag bit must be cleared by software if timer 0 overflow interrupt isn't used. 
  // Otherwise the triggering won't work and the ADC will halt.
  set_bit(TIFR, TOV0);
    1ab8:	88 b7       	in	r24, 0x38	; 56
    1aba:	81 60       	ori	r24, 0x01	; 1
    1abc:	88 bf       	out	0x38, r24	; 56
#endif
    1abe:	ff 91       	pop	r31
    1ac0:	ef 91       	pop	r30
    1ac2:	df 91       	pop	r29
    1ac4:	cf 91       	pop	r28
    1ac6:	bf 91       	pop	r27
    1ac8:	af 91       	pop	r26
    1aca:	9f 91       	pop	r25
    1acc:	8f 91       	pop	r24
    1ace:	7f 91       	pop	r23
    1ad0:	6f 91       	pop	r22
    1ad2:	5f 91       	pop	r21
    1ad4:	4f 91       	pop	r20
    1ad6:	3f 91       	pop	r19
    1ad8:	2f 91       	pop	r18
    1ada:	0f 90       	pop	r0
    1adc:	0f be       	out	0x3f, r0	; 63
    1ade:	0f 90       	pop	r0
    1ae0:	1f 90       	pop	r1
    1ae2:	18 95       	reti

00001ae4 <getUserByName>:
    }
  }

bool validate_user_password(ST_User_t* user, s8* password) {
  return (strcmp(user->password, password) == 0);
  }
    1ae4:	9f 92       	push	r9
    1ae6:	af 92       	push	r10
    1ae8:	bf 92       	push	r11
    1aea:	cf 92       	push	r12
    1aec:	df 92       	push	r13
    1aee:	ef 92       	push	r14
    1af0:	ff 92       	push	r15
    1af2:	0f 93       	push	r16
    1af4:	1f 93       	push	r17
    1af6:	cf 93       	push	r28
    1af8:	df 93       	push	r29
    1afa:	cd b7       	in	r28, 0x3d	; 61
    1afc:	de b7       	in	r29, 0x3e	; 62
    1afe:	6d 97       	sbiw	r28, 0x1d	; 29
    1b00:	0f b6       	in	r0, 0x3f	; 63
    1b02:	f8 94       	cli
    1b04:	de bf       	out	0x3e, r29	; 62
    1b06:	0f be       	out	0x3f, r0	; 63
    1b08:	cd bf       	out	0x3d, r28	; 61
    1b0a:	7c 01       	movw	r14, r24
    1b0c:	6b 01       	movw	r12, r22
    1b0e:	91 2c       	mov	r9, r1
    1b10:	6b c0       	rjmp	.+214    	; 0x1be8 <getUserByName+0x104>
    1b12:	ae 01       	movw	r20, r28
    1b14:	4f 5f       	subi	r20, 0xFF	; 255
    1b16:	5f 4f       	sbci	r21, 0xFF	; 255
    1b18:	60 e0       	ldi	r22, 0x00	; 0
    1b1a:	89 2d       	mov	r24, r9
    1b1c:	0e 94 ac 00 	call	0x158	; 0x158 <EEPROM_read_byte>
    1b20:	ae 01       	movw	r20, r28
    1b22:	4e 5f       	subi	r20, 0xFE	; 254
    1b24:	5f 4f       	sbci	r21, 0xFF	; 255
    1b26:	61 e0       	ldi	r22, 0x01	; 1
    1b28:	89 2d       	mov	r24, r9
    1b2a:	0e 94 ac 00 	call	0x158	; 0x158 <EEPROM_read_byte>
    1b2e:	b1 2c       	mov	r11, r1
    1b30:	56 c0       	rjmp	.+172    	; 0x1bde <getUserByName+0xfa>
    1b32:	89 81       	ldd	r24, Y+1	; 0x01
    1b34:	90 e0       	ldi	r25, 0x00	; 0
    1b36:	0b 2c       	mov	r0, r11
    1b38:	02 c0       	rjmp	.+4      	; 0x1b3e <getUserByName+0x5a>
    1b3a:	95 95       	asr	r25
    1b3c:	87 95       	ror	r24
    1b3e:	0a 94       	dec	r0
    1b40:	e2 f7       	brpl	.-8      	; 0x1b3a <getUserByName+0x56>
    1b42:	80 ff       	sbrs	r24, 0
    1b44:	4b c0       	rjmp	.+150    	; 0x1bdc <getUserByName+0xf8>
    1b46:	6f e1       	ldi	r22, 0x1F	; 31
    1b48:	b6 9e       	mul	r11, r22
    1b4a:	a0 2c       	mov	r10, r0
    1b4c:	11 24       	eor	r1, r1
    1b4e:	68 e0       	ldi	r22, 0x08	; 8
    1b50:	6a 0d       	add	r22, r10
    1b52:	9e 01       	movw	r18, r28
    1b54:	2d 5f       	subi	r18, 0xFD	; 253
    1b56:	3f 4f       	sbci	r19, 0xFF	; 255
    1b58:	4d e0       	ldi	r20, 0x0D	; 13
    1b5a:	50 e0       	ldi	r21, 0x00	; 0
    1b5c:	89 2d       	mov	r24, r9
    1b5e:	0e 94 cd 00 	call	0x19a	; 0x19a <EEPROM_read_block>
    1b62:	be 01       	movw	r22, r28
    1b64:	6d 5f       	subi	r22, 0xFD	; 253
    1b66:	7f 4f       	sbci	r23, 0xFF	; 255
    1b68:	c7 01       	movw	r24, r14
    1b6a:	0e 94 ca 11 	call	0x2394	; 0x2394 <strcmp>
    1b6e:	89 2b       	or	r24, r25
    1b70:	a9 f5       	brne	.+106    	; 0x1bdc <getUserByName+0xf8>
    1b72:	65 e1       	ldi	r22, 0x15	; 21
    1b74:	6a 0d       	add	r22, r10
    1b76:	9e 01       	movw	r18, r28
    1b78:	20 5f       	subi	r18, 0xF0	; 240
    1b7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1b7c:	47 e0       	ldi	r20, 0x07	; 7
    1b7e:	50 e0       	ldi	r21, 0x00	; 0
    1b80:	89 2d       	mov	r24, r9
    1b82:	0e 94 cd 00 	call	0x19a	; 0x19a <EEPROM_read_block>
    1b86:	6c e1       	ldi	r22, 0x1C	; 28
    1b88:	6a 0d       	add	r22, r10
    1b8a:	9e 01       	movw	r18, r28
    1b8c:	29 5e       	subi	r18, 0xE9	; 233
    1b8e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b90:	47 e0       	ldi	r20, 0x07	; 7
    1b92:	50 e0       	ldi	r21, 0x00	; 0
    1b94:	89 2d       	mov	r24, r9
    1b96:	0e 94 cd 00 	call	0x19a	; 0x19a <EEPROM_read_block>
    1b9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b9c:	90 e0       	ldi	r25, 0x00	; 0
    1b9e:	02 c0       	rjmp	.+4      	; 0x1ba4 <getUserByName+0xc0>
    1ba0:	95 95       	asr	r25
    1ba2:	87 95       	ror	r24
    1ba4:	ba 94       	dec	r11
    1ba6:	e2 f7       	brpl	.-8      	; 0x1ba0 <getUserByName+0xbc>
    1ba8:	98 2f       	mov	r25, r24
    1baa:	91 70       	andi	r25, 0x01	; 1
    1bac:	f6 01       	movw	r30, r12
    1bae:	91 93       	st	Z+, r25
    1bb0:	be 01       	movw	r22, r28
    1bb2:	6d 5f       	subi	r22, 0xFD	; 253
    1bb4:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb6:	cf 01       	movw	r24, r30
    1bb8:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <strcpy>
    1bbc:	be 01       	movw	r22, r28
    1bbe:	60 5f       	subi	r22, 0xF0	; 240
    1bc0:	7f 4f       	sbci	r23, 0xFF	; 255
    1bc2:	c6 01       	movw	r24, r12
    1bc4:	0e 96       	adiw	r24, 0x0e	; 14
    1bc6:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <strcpy>
    1bca:	be 01       	movw	r22, r28
    1bcc:	69 5e       	subi	r22, 0xE9	; 233
    1bce:	7f 4f       	sbci	r23, 0xFF	; 255
    1bd0:	c6 01       	movw	r24, r12
    1bd2:	45 96       	adiw	r24, 0x15	; 21
    1bd4:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <strcpy>
    1bd8:	82 e0       	ldi	r24, 0x02	; 2
    1bda:	0b c0       	rjmp	.+22     	; 0x1bf2 <getUserByName+0x10e>
    1bdc:	b3 94       	inc	r11
    1bde:	87 e0       	ldi	r24, 0x07	; 7
    1be0:	8b 15       	cp	r24, r11
    1be2:	08 f0       	brcs	.+2      	; 0x1be6 <getUserByName+0x102>
    1be4:	a6 cf       	rjmp	.-180    	; 0x1b32 <getUserByName+0x4e>
    1be6:	93 94       	inc	r9
    1be8:	87 e0       	ldi	r24, 0x07	; 7
    1bea:	89 15       	cp	r24, r9
    1bec:	08 f0       	brcs	.+2      	; 0x1bf0 <getUserByName+0x10c>
    1bee:	91 cf       	rjmp	.-222    	; 0x1b12 <getUserByName+0x2e>
    1bf0:	83 e0       	ldi	r24, 0x03	; 3
    1bf2:	6d 96       	adiw	r28, 0x1d	; 29
    1bf4:	0f b6       	in	r0, 0x3f	; 63
    1bf6:	f8 94       	cli
    1bf8:	de bf       	out	0x3e, r29	; 62
    1bfa:	0f be       	out	0x3f, r0	; 63
    1bfc:	cd bf       	out	0x3d, r28	; 61
    1bfe:	df 91       	pop	r29
    1c00:	cf 91       	pop	r28
    1c02:	1f 91       	pop	r17
    1c04:	0f 91       	pop	r16
    1c06:	ff 90       	pop	r15
    1c08:	ef 90       	pop	r14
    1c0a:	df 90       	pop	r13
    1c0c:	cf 90       	pop	r12
    1c0e:	bf 90       	pop	r11
    1c10:	af 90       	pop	r10
    1c12:	9f 90       	pop	r9
    1c14:	08 95       	ret

00001c16 <getUserByCode>:
    1c16:	9f 92       	push	r9
    1c18:	af 92       	push	r10
    1c1a:	bf 92       	push	r11
    1c1c:	cf 92       	push	r12
    1c1e:	df 92       	push	r13
    1c20:	ef 92       	push	r14
    1c22:	ff 92       	push	r15
    1c24:	0f 93       	push	r16
    1c26:	1f 93       	push	r17
    1c28:	cf 93       	push	r28
    1c2a:	df 93       	push	r29
    1c2c:	cd b7       	in	r28, 0x3d	; 61
    1c2e:	de b7       	in	r29, 0x3e	; 62
    1c30:	6d 97       	sbiw	r28, 0x1d	; 29
    1c32:	0f b6       	in	r0, 0x3f	; 63
    1c34:	f8 94       	cli
    1c36:	de bf       	out	0x3e, r29	; 62
    1c38:	0f be       	out	0x3f, r0	; 63
    1c3a:	cd bf       	out	0x3d, r28	; 61
    1c3c:	7c 01       	movw	r14, r24
    1c3e:	6b 01       	movw	r12, r22
    1c40:	91 2c       	mov	r9, r1
    1c42:	6b c0       	rjmp	.+214    	; 0x1d1a <getUserByCode+0x104>
    1c44:	ae 01       	movw	r20, r28
    1c46:	4f 5f       	subi	r20, 0xFF	; 255
    1c48:	5f 4f       	sbci	r21, 0xFF	; 255
    1c4a:	60 e0       	ldi	r22, 0x00	; 0
    1c4c:	89 2d       	mov	r24, r9
    1c4e:	0e 94 ac 00 	call	0x158	; 0x158 <EEPROM_read_byte>
    1c52:	ae 01       	movw	r20, r28
    1c54:	4e 5f       	subi	r20, 0xFE	; 254
    1c56:	5f 4f       	sbci	r21, 0xFF	; 255
    1c58:	61 e0       	ldi	r22, 0x01	; 1
    1c5a:	89 2d       	mov	r24, r9
    1c5c:	0e 94 ac 00 	call	0x158	; 0x158 <EEPROM_read_byte>
    1c60:	b1 2c       	mov	r11, r1
    1c62:	56 c0       	rjmp	.+172    	; 0x1d10 <getUserByCode+0xfa>
    1c64:	89 81       	ldd	r24, Y+1	; 0x01
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	0b 2c       	mov	r0, r11
    1c6a:	02 c0       	rjmp	.+4      	; 0x1c70 <getUserByCode+0x5a>
    1c6c:	95 95       	asr	r25
    1c6e:	87 95       	ror	r24
    1c70:	0a 94       	dec	r0
    1c72:	e2 f7       	brpl	.-8      	; 0x1c6c <getUserByCode+0x56>
    1c74:	80 ff       	sbrs	r24, 0
    1c76:	4b c0       	rjmp	.+150    	; 0x1d0e <getUserByCode+0xf8>
    1c78:	6f e1       	ldi	r22, 0x1F	; 31
    1c7a:	b6 9e       	mul	r11, r22
    1c7c:	a0 2c       	mov	r10, r0
    1c7e:	11 24       	eor	r1, r1
    1c80:	65 e1       	ldi	r22, 0x15	; 21
    1c82:	6a 0d       	add	r22, r10
    1c84:	9e 01       	movw	r18, r28
    1c86:	20 5f       	subi	r18, 0xF0	; 240
    1c88:	3f 4f       	sbci	r19, 0xFF	; 255
    1c8a:	47 e0       	ldi	r20, 0x07	; 7
    1c8c:	50 e0       	ldi	r21, 0x00	; 0
    1c8e:	89 2d       	mov	r24, r9
    1c90:	0e 94 cd 00 	call	0x19a	; 0x19a <EEPROM_read_block>
    1c94:	be 01       	movw	r22, r28
    1c96:	60 5f       	subi	r22, 0xF0	; 240
    1c98:	7f 4f       	sbci	r23, 0xFF	; 255
    1c9a:	c7 01       	movw	r24, r14
    1c9c:	0e 94 ca 11 	call	0x2394	; 0x2394 <strcmp>
    1ca0:	89 2b       	or	r24, r25
    1ca2:	a9 f5       	brne	.+106    	; 0x1d0e <getUserByCode+0xf8>
    1ca4:	68 e0       	ldi	r22, 0x08	; 8
    1ca6:	6a 0d       	add	r22, r10
    1ca8:	9e 01       	movw	r18, r28
    1caa:	2d 5f       	subi	r18, 0xFD	; 253
    1cac:	3f 4f       	sbci	r19, 0xFF	; 255
    1cae:	4d e0       	ldi	r20, 0x0D	; 13
    1cb0:	50 e0       	ldi	r21, 0x00	; 0
    1cb2:	89 2d       	mov	r24, r9
    1cb4:	0e 94 cd 00 	call	0x19a	; 0x19a <EEPROM_read_block>
    1cb8:	6c e1       	ldi	r22, 0x1C	; 28
    1cba:	6a 0d       	add	r22, r10
    1cbc:	9e 01       	movw	r18, r28
    1cbe:	29 5e       	subi	r18, 0xE9	; 233
    1cc0:	3f 4f       	sbci	r19, 0xFF	; 255
    1cc2:	47 e0       	ldi	r20, 0x07	; 7
    1cc4:	50 e0       	ldi	r21, 0x00	; 0
    1cc6:	89 2d       	mov	r24, r9
    1cc8:	0e 94 cd 00 	call	0x19a	; 0x19a <EEPROM_read_block>
    1ccc:	8a 81       	ldd	r24, Y+2	; 0x02
    1cce:	90 e0       	ldi	r25, 0x00	; 0
    1cd0:	02 c0       	rjmp	.+4      	; 0x1cd6 <getUserByCode+0xc0>
    1cd2:	95 95       	asr	r25
    1cd4:	87 95       	ror	r24
    1cd6:	ba 94       	dec	r11
    1cd8:	e2 f7       	brpl	.-8      	; 0x1cd2 <getUserByCode+0xbc>
    1cda:	98 2f       	mov	r25, r24
    1cdc:	91 70       	andi	r25, 0x01	; 1
    1cde:	f6 01       	movw	r30, r12
    1ce0:	91 93       	st	Z+, r25
    1ce2:	be 01       	movw	r22, r28
    1ce4:	6d 5f       	subi	r22, 0xFD	; 253
    1ce6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ce8:	cf 01       	movw	r24, r30
    1cea:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <strcpy>
    1cee:	be 01       	movw	r22, r28
    1cf0:	60 5f       	subi	r22, 0xF0	; 240
    1cf2:	7f 4f       	sbci	r23, 0xFF	; 255
    1cf4:	c6 01       	movw	r24, r12
    1cf6:	0e 96       	adiw	r24, 0x0e	; 14
    1cf8:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <strcpy>
    1cfc:	be 01       	movw	r22, r28
    1cfe:	69 5e       	subi	r22, 0xE9	; 233
    1d00:	7f 4f       	sbci	r23, 0xFF	; 255
    1d02:	c6 01       	movw	r24, r12
    1d04:	45 96       	adiw	r24, 0x15	; 21
    1d06:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <strcpy>
    1d0a:	82 e0       	ldi	r24, 0x02	; 2
    1d0c:	0b c0       	rjmp	.+22     	; 0x1d24 <getUserByCode+0x10e>
    1d0e:	b3 94       	inc	r11
    1d10:	87 e0       	ldi	r24, 0x07	; 7
    1d12:	8b 15       	cp	r24, r11
    1d14:	08 f0       	brcs	.+2      	; 0x1d18 <getUserByCode+0x102>
    1d16:	a6 cf       	rjmp	.-180    	; 0x1c64 <getUserByCode+0x4e>
    1d18:	93 94       	inc	r9
    1d1a:	87 e0       	ldi	r24, 0x07	; 7
    1d1c:	89 15       	cp	r24, r9
    1d1e:	08 f0       	brcs	.+2      	; 0x1d22 <getUserByCode+0x10c>
    1d20:	91 cf       	rjmp	.-222    	; 0x1c44 <getUserByCode+0x2e>
    1d22:	83 e0       	ldi	r24, 0x03	; 3
    1d24:	6d 96       	adiw	r28, 0x1d	; 29
    1d26:	0f b6       	in	r0, 0x3f	; 63
    1d28:	f8 94       	cli
    1d2a:	de bf       	out	0x3e, r29	; 62
    1d2c:	0f be       	out	0x3f, r0	; 63
    1d2e:	cd bf       	out	0x3d, r28	; 61
    1d30:	df 91       	pop	r29
    1d32:	cf 91       	pop	r28
    1d34:	1f 91       	pop	r17
    1d36:	0f 91       	pop	r16
    1d38:	ff 90       	pop	r15
    1d3a:	ef 90       	pop	r14
    1d3c:	df 90       	pop	r13
    1d3e:	cf 90       	pop	r12
    1d40:	bf 90       	pop	r11
    1d42:	af 90       	pop	r10
    1d44:	9f 90       	pop	r9
    1d46:	08 95       	ret

00001d48 <set_alarm>:

void set_alarm(void) {
  Buzzer_on(BUZZER_PORT, BUZZER_PIN);
    1d48:	66 e0       	ldi	r22, 0x06	; 6
    1d4a:	84 e4       	ldi	r24, 0x44	; 68
    1d4c:	0e 94 a3 00 	call	0x146	; 0x146 <Buzzer_on>
    1d50:	08 95       	ret

00001d52 <write_user>:
  }

void write_user(u8 userBlockIndex, ST_User_t* user) {
    1d52:	ef 92       	push	r14
    1d54:	ff 92       	push	r15
    1d56:	0f 93       	push	r16
    1d58:	1f 93       	push	r17
    1d5a:	cf 93       	push	r28
    1d5c:	df 93       	push	r29
    1d5e:	00 d0       	rcall	.+0      	; 0x1d60 <write_user+0xe>
    1d60:	cd b7       	in	r28, 0x3d	; 61
    1d62:	de b7       	in	r29, 0x3e	; 62
    1d64:	7b 01       	movw	r14, r22
  // Get the user block location (page - index)
  u8 page = userBlockIndex / 8;
    1d66:	08 2f       	mov	r16, r24
    1d68:	06 95       	lsr	r16
    1d6a:	06 95       	lsr	r16
    1d6c:	06 95       	lsr	r16
  u8 blockNumber = userBlockIndex % 8;
    1d6e:	18 2f       	mov	r17, r24
    1d70:	17 70       	andi	r17, 0x07	; 7
  // Read and update the block status (reserve the block). And update the user authority level flag if the user is admin
  u8 usersBlockStatus, usersAuthorityLevel;
  EEPROM_read_byte(page, 0, &usersBlockStatus);
    1d72:	ae 01       	movw	r20, r28
    1d74:	4f 5f       	subi	r20, 0xFF	; 255
    1d76:	5f 4f       	sbci	r21, 0xFF	; 255
    1d78:	60 e0       	ldi	r22, 0x00	; 0
    1d7a:	80 2f       	mov	r24, r16
    1d7c:	0e 94 ac 00 	call	0x158	; 0x158 <EEPROM_read_byte>
  EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    1d80:	ae 01       	movw	r20, r28
    1d82:	4e 5f       	subi	r20, 0xFE	; 254
    1d84:	5f 4f       	sbci	r21, 0xFF	; 255
    1d86:	61 e0       	ldi	r22, 0x01	; 1
    1d88:	80 2f       	mov	r24, r16
    1d8a:	0e 94 ac 00 	call	0x158	; 0x158 <EEPROM_read_byte>
  set_bit(usersBlockStatus, blockNumber);
    1d8e:	81 e0       	ldi	r24, 0x01	; 1
    1d90:	90 e0       	ldi	r25, 0x00	; 0
    1d92:	01 2e       	mov	r0, r17
    1d94:	02 c0       	rjmp	.+4      	; 0x1d9a <write_user+0x48>
    1d96:	88 0f       	add	r24, r24
    1d98:	99 1f       	adc	r25, r25
    1d9a:	0a 94       	dec	r0
    1d9c:	e2 f7       	brpl	.-8      	; 0x1d96 <write_user+0x44>
    1d9e:	49 81       	ldd	r20, Y+1	; 0x01
    1da0:	48 2b       	or	r20, r24
    1da2:	49 83       	std	Y+1, r20	; 0x01
  if (user->isAdmin) set_bit(usersAuthorityLevel, blockNumber);
    1da4:	f7 01       	movw	r30, r14
    1da6:	20 81       	ld	r18, Z
    1da8:	22 23       	and	r18, r18
    1daa:	19 f0       	breq	.+6      	; 0x1db2 <write_user+0x60>
    1dac:	9a 81       	ldd	r25, Y+2	; 0x02
    1dae:	89 2b       	or	r24, r25
    1db0:	8a 83       	std	Y+2, r24	; 0x02
  EEPROM_write_byte(page, 0, usersBlockStatus);
    1db2:	60 e0       	ldi	r22, 0x00	; 0
    1db4:	80 2f       	mov	r24, r16
    1db6:	0e 94 03 01 	call	0x206	; 0x206 <EEPROM_write_byte>
  EEPROM_write_byte(page, 1, usersAuthorityLevel);
    1dba:	4a 81       	ldd	r20, Y+2	; 0x02
    1dbc:	61 e0       	ldi	r22, 0x01	; 1
    1dbe:	80 2f       	mov	r24, r16
    1dc0:	0e 94 03 01 	call	0x206	; 0x206 <EEPROM_write_byte>
  // Write the user data
  EEPROM_write_block(page, 8 + 31 * blockNumber, 13, user->name);
    1dc4:	97 01       	movw	r18, r14
    1dc6:	2f 5f       	subi	r18, 0xFF	; 255
    1dc8:	3f 4f       	sbci	r19, 0xFF	; 255
    1dca:	6f e1       	ldi	r22, 0x1F	; 31
    1dcc:	16 9f       	mul	r17, r22
    1dce:	10 2d       	mov	r17, r0
    1dd0:	11 24       	eor	r1, r1
    1dd2:	68 e0       	ldi	r22, 0x08	; 8
    1dd4:	61 0f       	add	r22, r17
    1dd6:	4d e0       	ldi	r20, 0x0D	; 13
    1dd8:	50 e0       	ldi	r21, 0x00	; 0
    1dda:	80 2f       	mov	r24, r16
    1ddc:	0e 94 22 01 	call	0x244	; 0x244 <EEPROM_write_block>
  EEPROM_write_block(page, 21 + 31 * blockNumber, 7, user->code);
    1de0:	97 01       	movw	r18, r14
    1de2:	22 5f       	subi	r18, 0xF2	; 242
    1de4:	3f 4f       	sbci	r19, 0xFF	; 255
    1de6:	65 e1       	ldi	r22, 0x15	; 21
    1de8:	61 0f       	add	r22, r17
    1dea:	47 e0       	ldi	r20, 0x07	; 7
    1dec:	50 e0       	ldi	r21, 0x00	; 0
    1dee:	80 2f       	mov	r24, r16
    1df0:	0e 94 22 01 	call	0x244	; 0x244 <EEPROM_write_block>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
    1df4:	97 01       	movw	r18, r14
    1df6:	2b 5e       	subi	r18, 0xEB	; 235
    1df8:	3f 4f       	sbci	r19, 0xFF	; 255
    1dfa:	6c e1       	ldi	r22, 0x1C	; 28
    1dfc:	61 0f       	add	r22, r17
    1dfe:	4b e0       	ldi	r20, 0x0B	; 11
    1e00:	50 e0       	ldi	r21, 0x00	; 0
    1e02:	80 2f       	mov	r24, r16
    1e04:	0e 94 22 01 	call	0x244	; 0x244 <EEPROM_write_block>
  }
    1e08:	0f 90       	pop	r0
    1e0a:	0f 90       	pop	r0
    1e0c:	df 91       	pop	r29
    1e0e:	cf 91       	pop	r28
    1e10:	1f 91       	pop	r17
    1e12:	0f 91       	pop	r16
    1e14:	ff 90       	pop	r15
    1e16:	ef 90       	pop	r14
    1e18:	08 95       	ret

00001e1a <add_user>:

EN_UserStatusCode_t add_user(ST_User_t* user) {
    1e1a:	ef 92       	push	r14
    1e1c:	ff 92       	push	r15
    1e1e:	1f 93       	push	r17
    1e20:	cf 93       	push	r28
    1e22:	df 93       	push	r29
    1e24:	1f 92       	push	r1
    1e26:	cd b7       	in	r28, 0x3d	; 61
    1e28:	de b7       	in	r29, 0x3e	; 62
    1e2a:	7c 01       	movw	r14, r24
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    1e2c:	10 e0       	ldi	r17, 0x00	; 0
    1e2e:	1a c0       	rjmp	.+52     	; 0x1e64 <add_user+0x4a>
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    1e30:	ae 01       	movw	r20, r28
    1e32:	4f 5f       	subi	r20, 0xFF	; 255
    1e34:	5f 4f       	sbci	r21, 0xFF	; 255
    1e36:	60 e0       	ldi	r22, 0x00	; 0
    1e38:	81 2f       	mov	r24, r17
    1e3a:	0e 94 ac 00 	call	0x158	; 0x158 <EEPROM_read_byte>
    if (usersBlockStatus != 0xFF) {
    1e3e:	99 81       	ldd	r25, Y+1	; 0x01
    1e40:	9f 3f       	cpi	r25, 0xFF	; 255
    1e42:	79 f0       	breq	.+30     	; 0x1e62 <add_user+0x48>
    1e44:	02 c0       	rjmp	.+4      	; 0x1e4a <add_user+0x30>
      // Find the block number in the page
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
    1e46:	8f 5f       	subi	r24, 0xFF	; 255
    1e48:	01 c0       	rjmp	.+2      	; 0x1e4c <add_user+0x32>
    1e4a:	80 e0       	ldi	r24, 0x00	; 0
    1e4c:	29 2f       	mov	r18, r25
    1e4e:	30 e0       	ldi	r19, 0x00	; 0
    1e50:	08 2e       	mov	r0, r24
    1e52:	02 c0       	rjmp	.+4      	; 0x1e58 <add_user+0x3e>
    1e54:	35 95       	asr	r19
    1e56:	27 95       	ror	r18
    1e58:	0a 94       	dec	r0
    1e5a:	e2 f7       	brpl	.-8      	; 0x1e54 <add_user+0x3a>
    1e5c:	20 fd       	sbrc	r18, 0
    1e5e:	f3 cf       	rjmp	.-26     	; 0x1e46 <add_user+0x2c>
    1e60:	04 c0       	rjmp	.+8      	; 0x1e6a <add_user+0x50>
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    1e62:	1f 5f       	subi	r17, 0xFF	; 255
    1e64:	18 30       	cpi	r17, 0x08	; 8
    1e66:	20 f3       	brcs	.-56     	; 0x1e30 <add_user+0x16>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
    1e68:	80 e0       	ldi	r24, 0x00	; 0
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    1e6a:	18 30       	cpi	r17, 0x08	; 8
    1e6c:	49 f0       	breq	.+18     	; 0x1e80 <add_user+0x66>
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
    1e6e:	11 0f       	add	r17, r17
    1e70:	11 0f       	add	r17, r17
    1e72:	11 0f       	add	r17, r17
  write_user(availableUserBlockIndex, user);
    1e74:	b7 01       	movw	r22, r14
    1e76:	81 0f       	add	r24, r17
    1e78:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <write_user>
  return USER_ADDED_SUCCESSFULLY;
    1e7c:	89 e0       	ldi	r24, 0x09	; 9
    1e7e:	01 c0       	rjmp	.+2      	; 0x1e82 <add_user+0x68>
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    1e80:	8b e0       	ldi	r24, 0x0B	; 11
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
  write_user(availableUserBlockIndex, user);
  return USER_ADDED_SUCCESSFULLY;
  }
    1e82:	0f 90       	pop	r0
    1e84:	df 91       	pop	r29
    1e86:	cf 91       	pop	r28
    1e88:	1f 91       	pop	r17
    1e8a:	ff 90       	pop	r15
    1e8c:	ef 90       	pop	r14
    1e8e:	08 95       	ret

00001e90 <delete_user>:

EN_UserStatusCode_t delete_user(ST_User_t* user) {
    1e90:	cf 92       	push	r12
    1e92:	df 92       	push	r13
    1e94:	ef 92       	push	r14
    1e96:	ff 92       	push	r15
    1e98:	0f 93       	push	r16
    1e9a:	1f 93       	push	r17
    1e9c:	cf 93       	push	r28
    1e9e:	df 93       	push	r29
    1ea0:	cd b7       	in	r28, 0x3d	; 61
    1ea2:	de b7       	in	r29, 0x3e	; 62
    1ea4:	29 97       	sbiw	r28, 0x09	; 9
    1ea6:	0f b6       	in	r0, 0x3f	; 63
    1ea8:	f8 94       	cli
    1eaa:	de bf       	out	0x3e, r29	; 62
    1eac:	0f be       	out	0x3f, r0	; 63
    1eae:	cd bf       	out	0x3d, r28	; 61
    1eb0:	6c 01       	movw	r12, r24
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    1eb2:	00 e0       	ldi	r16, 0x00	; 0
    1eb4:	4d c0       	rjmp	.+154    	; 0x1f50 <delete_user+0xc0>
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    1eb6:	ae 01       	movw	r20, r28
    1eb8:	4f 5f       	subi	r20, 0xFF	; 255
    1eba:	5f 4f       	sbci	r21, 0xFF	; 255
    1ebc:	60 e0       	ldi	r22, 0x00	; 0
    1ebe:	80 2f       	mov	r24, r16
    1ec0:	0e 94 ac 00 	call	0x158	; 0x158 <EEPROM_read_byte>
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    1ec4:	ae 01       	movw	r20, r28
    1ec6:	4e 5f       	subi	r20, 0xFE	; 254
    1ec8:	5f 4f       	sbci	r21, 0xFF	; 255
    1eca:	61 e0       	ldi	r22, 0x01	; 1
    1ecc:	80 2f       	mov	r24, r16
    1ece:	0e 94 ac 00 	call	0x158	; 0x158 <EEPROM_read_byte>
    for (userIndex = 0; userIndex < 8;userIndex++) {
    1ed2:	10 e0       	ldi	r17, 0x00	; 0
    1ed4:	3a c0       	rjmp	.+116    	; 0x1f4a <delete_user+0xba>
      if (read_bit(usersBlockStatus, userIndex)) {  // If the user isn't deleted
    1ed6:	89 81       	ldd	r24, Y+1	; 0x01
    1ed8:	90 e0       	ldi	r25, 0x00	; 0
    1eda:	01 2e       	mov	r0, r17
    1edc:	02 c0       	rjmp	.+4      	; 0x1ee2 <delete_user+0x52>
    1ede:	95 95       	asr	r25
    1ee0:	87 95       	ror	r24
    1ee2:	0a 94       	dec	r0
    1ee4:	e2 f7       	brpl	.-8      	; 0x1ede <delete_user+0x4e>
    1ee6:	80 ff       	sbrs	r24, 0
    1ee8:	2f c0       	rjmp	.+94     	; 0x1f48 <delete_user+0xb8>
        EEPROM_read_block(page, 21 + 31 * userIndex, 7, tempUserCode);
    1eea:	6f e1       	ldi	r22, 0x1F	; 31
    1eec:	16 9f       	mul	r17, r22
    1eee:	60 2d       	mov	r22, r0
    1ef0:	11 24       	eor	r1, r1
    1ef2:	6b 5e       	subi	r22, 0xEB	; 235
    1ef4:	9e 01       	movw	r18, r28
    1ef6:	2d 5f       	subi	r18, 0xFD	; 253
    1ef8:	3f 4f       	sbci	r19, 0xFF	; 255
    1efa:	47 e0       	ldi	r20, 0x07	; 7
    1efc:	50 e0       	ldi	r21, 0x00	; 0
    1efe:	80 2f       	mov	r24, r16
    1f00:	0e 94 cd 00 	call	0x19a	; 0x19a <EEPROM_read_block>
        if (strcmp(user->code, tempUserCode) == 0) { // User has been found
    1f04:	be 01       	movw	r22, r28
    1f06:	6d 5f       	subi	r22, 0xFD	; 253
    1f08:	7f 4f       	sbci	r23, 0xFF	; 255
    1f0a:	c6 01       	movw	r24, r12
    1f0c:	0e 96       	adiw	r24, 0x0e	; 14
    1f0e:	0e 94 ca 11 	call	0x2394	; 0x2394 <strcmp>
    1f12:	89 2b       	or	r24, r25
    1f14:	c9 f4       	brne	.+50     	; 0x1f48 <delete_user+0xb8>
          // Mark it as deleted
          clear_bit(usersBlockStatus, userIndex);
    1f16:	81 e0       	ldi	r24, 0x01	; 1
    1f18:	90 e0       	ldi	r25, 0x00	; 0
    1f1a:	02 c0       	rjmp	.+4      	; 0x1f20 <delete_user+0x90>
    1f1c:	88 0f       	add	r24, r24
    1f1e:	99 1f       	adc	r25, r25
    1f20:	1a 95       	dec	r17
    1f22:	e2 f7       	brpl	.-8      	; 0x1f1c <delete_user+0x8c>
    1f24:	80 95       	com	r24
    1f26:	49 81       	ldd	r20, Y+1	; 0x01
    1f28:	48 23       	and	r20, r24
    1f2a:	49 83       	std	Y+1, r20	; 0x01
          clear_bit(usersAuthorityLevel, userIndex);
    1f2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f2e:	89 23       	and	r24, r25
    1f30:	8a 83       	std	Y+2, r24	; 0x02
          EEPROM_write_byte(page, 0, usersBlockStatus);
    1f32:	60 e0       	ldi	r22, 0x00	; 0
    1f34:	80 2f       	mov	r24, r16
    1f36:	0e 94 03 01 	call	0x206	; 0x206 <EEPROM_write_byte>
          EEPROM_write_byte(page, 1, usersAuthorityLevel);
    1f3a:	4a 81       	ldd	r20, Y+2	; 0x02
    1f3c:	61 e0       	ldi	r22, 0x01	; 1
    1f3e:	80 2f       	mov	r24, r16
    1f40:	0e 94 03 01 	call	0x206	; 0x206 <EEPROM_write_byte>
          return USER_DELETED_SUCCESSFULLY;
    1f44:	8a e0       	ldi	r24, 0x0A	; 10
    1f46:	08 c0       	rjmp	.+16     	; 0x1f58 <delete_user+0xc8>
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    for (userIndex = 0; userIndex < 8;userIndex++) {
    1f48:	1f 5f       	subi	r17, 0xFF	; 255
    1f4a:	18 30       	cpi	r17, 0x08	; 8
    1f4c:	20 f2       	brcs	.-120    	; 0x1ed6 <delete_user+0x46>
EN_UserStatusCode_t delete_user(ST_User_t* user) {
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    1f4e:	0f 5f       	subi	r16, 0xFF	; 255
    1f50:	08 30       	cpi	r16, 0x08	; 8
    1f52:	08 f4       	brcc	.+2      	; 0x1f56 <delete_user+0xc6>
    1f54:	b0 cf       	rjmp	.-160    	; 0x1eb6 <delete_user+0x26>
          return USER_DELETED_SUCCESSFULLY;
          }
        }
      }
    }
  return USER_NOT_FOUND;
    1f56:	83 e0       	ldi	r24, 0x03	; 3
  }
    1f58:	29 96       	adiw	r28, 0x09	; 9
    1f5a:	0f b6       	in	r0, 0x3f	; 63
    1f5c:	f8 94       	cli
    1f5e:	de bf       	out	0x3e, r29	; 62
    1f60:	0f be       	out	0x3f, r0	; 63
    1f62:	cd bf       	out	0x3d, r28	; 61
    1f64:	df 91       	pop	r29
    1f66:	cf 91       	pop	r28
    1f68:	1f 91       	pop	r17
    1f6a:	0f 91       	pop	r16
    1f6c:	ff 90       	pop	r15
    1f6e:	ef 90       	pop	r14
    1f70:	df 90       	pop	r13
    1f72:	cf 90       	pop	r12
    1f74:	08 95       	ret

00001f76 <__subsf3>:
    1f76:	50 58       	subi	r21, 0x80	; 128

00001f78 <__addsf3>:
    1f78:	bb 27       	eor	r27, r27
    1f7a:	aa 27       	eor	r26, r26
    1f7c:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <__addsf3x>
    1f80:	0c 94 1d 11 	jmp	0x223a	; 0x223a <__fp_round>
    1f84:	0e 94 0f 11 	call	0x221e	; 0x221e <__fp_pscA>
    1f88:	38 f0       	brcs	.+14     	; 0x1f98 <__addsf3+0x20>
    1f8a:	0e 94 16 11 	call	0x222c	; 0x222c <__fp_pscB>
    1f8e:	20 f0       	brcs	.+8      	; 0x1f98 <__addsf3+0x20>
    1f90:	39 f4       	brne	.+14     	; 0x1fa0 <__addsf3+0x28>
    1f92:	9f 3f       	cpi	r25, 0xFF	; 255
    1f94:	19 f4       	brne	.+6      	; 0x1f9c <__addsf3+0x24>
    1f96:	26 f4       	brtc	.+8      	; 0x1fa0 <__addsf3+0x28>
    1f98:	0c 94 0c 11 	jmp	0x2218	; 0x2218 <__fp_nan>
    1f9c:	0e f4       	brtc	.+2      	; 0x1fa0 <__addsf3+0x28>
    1f9e:	e0 95       	com	r30
    1fa0:	e7 fb       	bst	r30, 7
    1fa2:	0c 94 06 11 	jmp	0x220c	; 0x220c <__fp_inf>

00001fa6 <__addsf3x>:
    1fa6:	e9 2f       	mov	r30, r25
    1fa8:	0e 94 2e 11 	call	0x225c	; 0x225c <__fp_split3>
    1fac:	58 f3       	brcs	.-42     	; 0x1f84 <__addsf3+0xc>
    1fae:	ba 17       	cp	r27, r26
    1fb0:	62 07       	cpc	r22, r18
    1fb2:	73 07       	cpc	r23, r19
    1fb4:	84 07       	cpc	r24, r20
    1fb6:	95 07       	cpc	r25, r21
    1fb8:	20 f0       	brcs	.+8      	; 0x1fc2 <__addsf3x+0x1c>
    1fba:	79 f4       	brne	.+30     	; 0x1fda <__addsf3x+0x34>
    1fbc:	a6 f5       	brtc	.+104    	; 0x2026 <__addsf3x+0x80>
    1fbe:	0c 94 50 11 	jmp	0x22a0	; 0x22a0 <__fp_zero>
    1fc2:	0e f4       	brtc	.+2      	; 0x1fc6 <__addsf3x+0x20>
    1fc4:	e0 95       	com	r30
    1fc6:	0b 2e       	mov	r0, r27
    1fc8:	ba 2f       	mov	r27, r26
    1fca:	a0 2d       	mov	r26, r0
    1fcc:	0b 01       	movw	r0, r22
    1fce:	b9 01       	movw	r22, r18
    1fd0:	90 01       	movw	r18, r0
    1fd2:	0c 01       	movw	r0, r24
    1fd4:	ca 01       	movw	r24, r20
    1fd6:	a0 01       	movw	r20, r0
    1fd8:	11 24       	eor	r1, r1
    1fda:	ff 27       	eor	r31, r31
    1fdc:	59 1b       	sub	r21, r25
    1fde:	99 f0       	breq	.+38     	; 0x2006 <__addsf3x+0x60>
    1fe0:	59 3f       	cpi	r21, 0xF9	; 249
    1fe2:	50 f4       	brcc	.+20     	; 0x1ff8 <__addsf3x+0x52>
    1fe4:	50 3e       	cpi	r21, 0xE0	; 224
    1fe6:	68 f1       	brcs	.+90     	; 0x2042 <__addsf3x+0x9c>
    1fe8:	1a 16       	cp	r1, r26
    1fea:	f0 40       	sbci	r31, 0x00	; 0
    1fec:	a2 2f       	mov	r26, r18
    1fee:	23 2f       	mov	r18, r19
    1ff0:	34 2f       	mov	r19, r20
    1ff2:	44 27       	eor	r20, r20
    1ff4:	58 5f       	subi	r21, 0xF8	; 248
    1ff6:	f3 cf       	rjmp	.-26     	; 0x1fde <__addsf3x+0x38>
    1ff8:	46 95       	lsr	r20
    1ffa:	37 95       	ror	r19
    1ffc:	27 95       	ror	r18
    1ffe:	a7 95       	ror	r26
    2000:	f0 40       	sbci	r31, 0x00	; 0
    2002:	53 95       	inc	r21
    2004:	c9 f7       	brne	.-14     	; 0x1ff8 <__addsf3x+0x52>
    2006:	7e f4       	brtc	.+30     	; 0x2026 <__addsf3x+0x80>
    2008:	1f 16       	cp	r1, r31
    200a:	ba 0b       	sbc	r27, r26
    200c:	62 0b       	sbc	r22, r18
    200e:	73 0b       	sbc	r23, r19
    2010:	84 0b       	sbc	r24, r20
    2012:	ba f0       	brmi	.+46     	; 0x2042 <__addsf3x+0x9c>
    2014:	91 50       	subi	r25, 0x01	; 1
    2016:	a1 f0       	breq	.+40     	; 0x2040 <__addsf3x+0x9a>
    2018:	ff 0f       	add	r31, r31
    201a:	bb 1f       	adc	r27, r27
    201c:	66 1f       	adc	r22, r22
    201e:	77 1f       	adc	r23, r23
    2020:	88 1f       	adc	r24, r24
    2022:	c2 f7       	brpl	.-16     	; 0x2014 <__addsf3x+0x6e>
    2024:	0e c0       	rjmp	.+28     	; 0x2042 <__addsf3x+0x9c>
    2026:	ba 0f       	add	r27, r26
    2028:	62 1f       	adc	r22, r18
    202a:	73 1f       	adc	r23, r19
    202c:	84 1f       	adc	r24, r20
    202e:	48 f4       	brcc	.+18     	; 0x2042 <__addsf3x+0x9c>
    2030:	87 95       	ror	r24
    2032:	77 95       	ror	r23
    2034:	67 95       	ror	r22
    2036:	b7 95       	ror	r27
    2038:	f7 95       	ror	r31
    203a:	9e 3f       	cpi	r25, 0xFE	; 254
    203c:	08 f0       	brcs	.+2      	; 0x2040 <__addsf3x+0x9a>
    203e:	b0 cf       	rjmp	.-160    	; 0x1fa0 <__addsf3+0x28>
    2040:	93 95       	inc	r25
    2042:	88 0f       	add	r24, r24
    2044:	08 f0       	brcs	.+2      	; 0x2048 <__addsf3x+0xa2>
    2046:	99 27       	eor	r25, r25
    2048:	ee 0f       	add	r30, r30
    204a:	97 95       	ror	r25
    204c:	87 95       	ror	r24
    204e:	08 95       	ret

00002050 <__divsf3>:
    2050:	0e 94 3c 10 	call	0x2078	; 0x2078 <__divsf3x>
    2054:	0c 94 1d 11 	jmp	0x223a	; 0x223a <__fp_round>
    2058:	0e 94 16 11 	call	0x222c	; 0x222c <__fp_pscB>
    205c:	58 f0       	brcs	.+22     	; 0x2074 <__divsf3+0x24>
    205e:	0e 94 0f 11 	call	0x221e	; 0x221e <__fp_pscA>
    2062:	40 f0       	brcs	.+16     	; 0x2074 <__divsf3+0x24>
    2064:	29 f4       	brne	.+10     	; 0x2070 <__divsf3+0x20>
    2066:	5f 3f       	cpi	r21, 0xFF	; 255
    2068:	29 f0       	breq	.+10     	; 0x2074 <__divsf3+0x24>
    206a:	0c 94 06 11 	jmp	0x220c	; 0x220c <__fp_inf>
    206e:	51 11       	cpse	r21, r1
    2070:	0c 94 51 11 	jmp	0x22a2	; 0x22a2 <__fp_szero>
    2074:	0c 94 0c 11 	jmp	0x2218	; 0x2218 <__fp_nan>

00002078 <__divsf3x>:
    2078:	0e 94 2e 11 	call	0x225c	; 0x225c <__fp_split3>
    207c:	68 f3       	brcs	.-38     	; 0x2058 <__divsf3+0x8>

0000207e <__divsf3_pse>:
    207e:	99 23       	and	r25, r25
    2080:	b1 f3       	breq	.-20     	; 0x206e <__divsf3+0x1e>
    2082:	55 23       	and	r21, r21
    2084:	91 f3       	breq	.-28     	; 0x206a <__divsf3+0x1a>
    2086:	95 1b       	sub	r25, r21
    2088:	55 0b       	sbc	r21, r21
    208a:	bb 27       	eor	r27, r27
    208c:	aa 27       	eor	r26, r26
    208e:	62 17       	cp	r22, r18
    2090:	73 07       	cpc	r23, r19
    2092:	84 07       	cpc	r24, r20
    2094:	38 f0       	brcs	.+14     	; 0x20a4 <__divsf3_pse+0x26>
    2096:	9f 5f       	subi	r25, 0xFF	; 255
    2098:	5f 4f       	sbci	r21, 0xFF	; 255
    209a:	22 0f       	add	r18, r18
    209c:	33 1f       	adc	r19, r19
    209e:	44 1f       	adc	r20, r20
    20a0:	aa 1f       	adc	r26, r26
    20a2:	a9 f3       	breq	.-22     	; 0x208e <__divsf3_pse+0x10>
    20a4:	35 d0       	rcall	.+106    	; 0x2110 <__divsf3_pse+0x92>
    20a6:	0e 2e       	mov	r0, r30
    20a8:	3a f0       	brmi	.+14     	; 0x20b8 <__divsf3_pse+0x3a>
    20aa:	e0 e8       	ldi	r30, 0x80	; 128
    20ac:	32 d0       	rcall	.+100    	; 0x2112 <__divsf3_pse+0x94>
    20ae:	91 50       	subi	r25, 0x01	; 1
    20b0:	50 40       	sbci	r21, 0x00	; 0
    20b2:	e6 95       	lsr	r30
    20b4:	00 1c       	adc	r0, r0
    20b6:	ca f7       	brpl	.-14     	; 0x20aa <__divsf3_pse+0x2c>
    20b8:	2b d0       	rcall	.+86     	; 0x2110 <__divsf3_pse+0x92>
    20ba:	fe 2f       	mov	r31, r30
    20bc:	29 d0       	rcall	.+82     	; 0x2110 <__divsf3_pse+0x92>
    20be:	66 0f       	add	r22, r22
    20c0:	77 1f       	adc	r23, r23
    20c2:	88 1f       	adc	r24, r24
    20c4:	bb 1f       	adc	r27, r27
    20c6:	26 17       	cp	r18, r22
    20c8:	37 07       	cpc	r19, r23
    20ca:	48 07       	cpc	r20, r24
    20cc:	ab 07       	cpc	r26, r27
    20ce:	b0 e8       	ldi	r27, 0x80	; 128
    20d0:	09 f0       	breq	.+2      	; 0x20d4 <__divsf3_pse+0x56>
    20d2:	bb 0b       	sbc	r27, r27
    20d4:	80 2d       	mov	r24, r0
    20d6:	bf 01       	movw	r22, r30
    20d8:	ff 27       	eor	r31, r31
    20da:	93 58       	subi	r25, 0x83	; 131
    20dc:	5f 4f       	sbci	r21, 0xFF	; 255
    20de:	3a f0       	brmi	.+14     	; 0x20ee <__divsf3_pse+0x70>
    20e0:	9e 3f       	cpi	r25, 0xFE	; 254
    20e2:	51 05       	cpc	r21, r1
    20e4:	78 f0       	brcs	.+30     	; 0x2104 <__divsf3_pse+0x86>
    20e6:	0c 94 06 11 	jmp	0x220c	; 0x220c <__fp_inf>
    20ea:	0c 94 51 11 	jmp	0x22a2	; 0x22a2 <__fp_szero>
    20ee:	5f 3f       	cpi	r21, 0xFF	; 255
    20f0:	e4 f3       	brlt	.-8      	; 0x20ea <__divsf3_pse+0x6c>
    20f2:	98 3e       	cpi	r25, 0xE8	; 232
    20f4:	d4 f3       	brlt	.-12     	; 0x20ea <__divsf3_pse+0x6c>
    20f6:	86 95       	lsr	r24
    20f8:	77 95       	ror	r23
    20fa:	67 95       	ror	r22
    20fc:	b7 95       	ror	r27
    20fe:	f7 95       	ror	r31
    2100:	9f 5f       	subi	r25, 0xFF	; 255
    2102:	c9 f7       	brne	.-14     	; 0x20f6 <__divsf3_pse+0x78>
    2104:	88 0f       	add	r24, r24
    2106:	91 1d       	adc	r25, r1
    2108:	96 95       	lsr	r25
    210a:	87 95       	ror	r24
    210c:	97 f9       	bld	r25, 7
    210e:	08 95       	ret
    2110:	e1 e0       	ldi	r30, 0x01	; 1
    2112:	66 0f       	add	r22, r22
    2114:	77 1f       	adc	r23, r23
    2116:	88 1f       	adc	r24, r24
    2118:	bb 1f       	adc	r27, r27
    211a:	62 17       	cp	r22, r18
    211c:	73 07       	cpc	r23, r19
    211e:	84 07       	cpc	r24, r20
    2120:	ba 07       	cpc	r27, r26
    2122:	20 f0       	brcs	.+8      	; 0x212c <__divsf3_pse+0xae>
    2124:	62 1b       	sub	r22, r18
    2126:	73 0b       	sbc	r23, r19
    2128:	84 0b       	sbc	r24, r20
    212a:	ba 0b       	sbc	r27, r26
    212c:	ee 1f       	adc	r30, r30
    212e:	88 f7       	brcc	.-30     	; 0x2112 <__divsf3_pse+0x94>
    2130:	e0 95       	com	r30
    2132:	08 95       	ret

00002134 <__fixunssfsi>:
    2134:	0e 94 36 11 	call	0x226c	; 0x226c <__fp_splitA>
    2138:	88 f0       	brcs	.+34     	; 0x215c <__fixunssfsi+0x28>
    213a:	9f 57       	subi	r25, 0x7F	; 127
    213c:	98 f0       	brcs	.+38     	; 0x2164 <__fixunssfsi+0x30>
    213e:	b9 2f       	mov	r27, r25
    2140:	99 27       	eor	r25, r25
    2142:	b7 51       	subi	r27, 0x17	; 23
    2144:	b0 f0       	brcs	.+44     	; 0x2172 <__fixunssfsi+0x3e>
    2146:	e1 f0       	breq	.+56     	; 0x2180 <__fixunssfsi+0x4c>
    2148:	66 0f       	add	r22, r22
    214a:	77 1f       	adc	r23, r23
    214c:	88 1f       	adc	r24, r24
    214e:	99 1f       	adc	r25, r25
    2150:	1a f0       	brmi	.+6      	; 0x2158 <__fixunssfsi+0x24>
    2152:	ba 95       	dec	r27
    2154:	c9 f7       	brne	.-14     	; 0x2148 <__fixunssfsi+0x14>
    2156:	14 c0       	rjmp	.+40     	; 0x2180 <__fixunssfsi+0x4c>
    2158:	b1 30       	cpi	r27, 0x01	; 1
    215a:	91 f0       	breq	.+36     	; 0x2180 <__fixunssfsi+0x4c>
    215c:	0e 94 50 11 	call	0x22a0	; 0x22a0 <__fp_zero>
    2160:	b1 e0       	ldi	r27, 0x01	; 1
    2162:	08 95       	ret
    2164:	0c 94 50 11 	jmp	0x22a0	; 0x22a0 <__fp_zero>
    2168:	67 2f       	mov	r22, r23
    216a:	78 2f       	mov	r23, r24
    216c:	88 27       	eor	r24, r24
    216e:	b8 5f       	subi	r27, 0xF8	; 248
    2170:	39 f0       	breq	.+14     	; 0x2180 <__fixunssfsi+0x4c>
    2172:	b9 3f       	cpi	r27, 0xF9	; 249
    2174:	cc f3       	brlt	.-14     	; 0x2168 <__fixunssfsi+0x34>
    2176:	86 95       	lsr	r24
    2178:	77 95       	ror	r23
    217a:	67 95       	ror	r22
    217c:	b3 95       	inc	r27
    217e:	d9 f7       	brne	.-10     	; 0x2176 <__fixunssfsi+0x42>
    2180:	3e f4       	brtc	.+14     	; 0x2190 <__fixunssfsi+0x5c>
    2182:	90 95       	com	r25
    2184:	80 95       	com	r24
    2186:	70 95       	com	r23
    2188:	61 95       	neg	r22
    218a:	7f 4f       	sbci	r23, 0xFF	; 255
    218c:	8f 4f       	sbci	r24, 0xFF	; 255
    218e:	9f 4f       	sbci	r25, 0xFF	; 255
    2190:	08 95       	ret

00002192 <__floatunsisf>:
    2192:	e8 94       	clt
    2194:	09 c0       	rjmp	.+18     	; 0x21a8 <__floatsisf+0x12>

00002196 <__floatsisf>:
    2196:	97 fb       	bst	r25, 7
    2198:	3e f4       	brtc	.+14     	; 0x21a8 <__floatsisf+0x12>
    219a:	90 95       	com	r25
    219c:	80 95       	com	r24
    219e:	70 95       	com	r23
    21a0:	61 95       	neg	r22
    21a2:	7f 4f       	sbci	r23, 0xFF	; 255
    21a4:	8f 4f       	sbci	r24, 0xFF	; 255
    21a6:	9f 4f       	sbci	r25, 0xFF	; 255
    21a8:	99 23       	and	r25, r25
    21aa:	a9 f0       	breq	.+42     	; 0x21d6 <__floatsisf+0x40>
    21ac:	f9 2f       	mov	r31, r25
    21ae:	96 e9       	ldi	r25, 0x96	; 150
    21b0:	bb 27       	eor	r27, r27
    21b2:	93 95       	inc	r25
    21b4:	f6 95       	lsr	r31
    21b6:	87 95       	ror	r24
    21b8:	77 95       	ror	r23
    21ba:	67 95       	ror	r22
    21bc:	b7 95       	ror	r27
    21be:	f1 11       	cpse	r31, r1
    21c0:	f8 cf       	rjmp	.-16     	; 0x21b2 <__floatsisf+0x1c>
    21c2:	fa f4       	brpl	.+62     	; 0x2202 <__floatsisf+0x6c>
    21c4:	bb 0f       	add	r27, r27
    21c6:	11 f4       	brne	.+4      	; 0x21cc <__floatsisf+0x36>
    21c8:	60 ff       	sbrs	r22, 0
    21ca:	1b c0       	rjmp	.+54     	; 0x2202 <__floatsisf+0x6c>
    21cc:	6f 5f       	subi	r22, 0xFF	; 255
    21ce:	7f 4f       	sbci	r23, 0xFF	; 255
    21d0:	8f 4f       	sbci	r24, 0xFF	; 255
    21d2:	9f 4f       	sbci	r25, 0xFF	; 255
    21d4:	16 c0       	rjmp	.+44     	; 0x2202 <__floatsisf+0x6c>
    21d6:	88 23       	and	r24, r24
    21d8:	11 f0       	breq	.+4      	; 0x21de <__floatsisf+0x48>
    21da:	96 e9       	ldi	r25, 0x96	; 150
    21dc:	11 c0       	rjmp	.+34     	; 0x2200 <__floatsisf+0x6a>
    21de:	77 23       	and	r23, r23
    21e0:	21 f0       	breq	.+8      	; 0x21ea <__floatsisf+0x54>
    21e2:	9e e8       	ldi	r25, 0x8E	; 142
    21e4:	87 2f       	mov	r24, r23
    21e6:	76 2f       	mov	r23, r22
    21e8:	05 c0       	rjmp	.+10     	; 0x21f4 <__floatsisf+0x5e>
    21ea:	66 23       	and	r22, r22
    21ec:	71 f0       	breq	.+28     	; 0x220a <__floatsisf+0x74>
    21ee:	96 e8       	ldi	r25, 0x86	; 134
    21f0:	86 2f       	mov	r24, r22
    21f2:	70 e0       	ldi	r23, 0x00	; 0
    21f4:	60 e0       	ldi	r22, 0x00	; 0
    21f6:	2a f0       	brmi	.+10     	; 0x2202 <__floatsisf+0x6c>
    21f8:	9a 95       	dec	r25
    21fa:	66 0f       	add	r22, r22
    21fc:	77 1f       	adc	r23, r23
    21fe:	88 1f       	adc	r24, r24
    2200:	da f7       	brpl	.-10     	; 0x21f8 <__floatsisf+0x62>
    2202:	88 0f       	add	r24, r24
    2204:	96 95       	lsr	r25
    2206:	87 95       	ror	r24
    2208:	97 f9       	bld	r25, 7
    220a:	08 95       	ret

0000220c <__fp_inf>:
    220c:	97 f9       	bld	r25, 7
    220e:	9f 67       	ori	r25, 0x7F	; 127
    2210:	80 e8       	ldi	r24, 0x80	; 128
    2212:	70 e0       	ldi	r23, 0x00	; 0
    2214:	60 e0       	ldi	r22, 0x00	; 0
    2216:	08 95       	ret

00002218 <__fp_nan>:
    2218:	9f ef       	ldi	r25, 0xFF	; 255
    221a:	80 ec       	ldi	r24, 0xC0	; 192
    221c:	08 95       	ret

0000221e <__fp_pscA>:
    221e:	00 24       	eor	r0, r0
    2220:	0a 94       	dec	r0
    2222:	16 16       	cp	r1, r22
    2224:	17 06       	cpc	r1, r23
    2226:	18 06       	cpc	r1, r24
    2228:	09 06       	cpc	r0, r25
    222a:	08 95       	ret

0000222c <__fp_pscB>:
    222c:	00 24       	eor	r0, r0
    222e:	0a 94       	dec	r0
    2230:	12 16       	cp	r1, r18
    2232:	13 06       	cpc	r1, r19
    2234:	14 06       	cpc	r1, r20
    2236:	05 06       	cpc	r0, r21
    2238:	08 95       	ret

0000223a <__fp_round>:
    223a:	09 2e       	mov	r0, r25
    223c:	03 94       	inc	r0
    223e:	00 0c       	add	r0, r0
    2240:	11 f4       	brne	.+4      	; 0x2246 <__fp_round+0xc>
    2242:	88 23       	and	r24, r24
    2244:	52 f0       	brmi	.+20     	; 0x225a <__fp_round+0x20>
    2246:	bb 0f       	add	r27, r27
    2248:	40 f4       	brcc	.+16     	; 0x225a <__fp_round+0x20>
    224a:	bf 2b       	or	r27, r31
    224c:	11 f4       	brne	.+4      	; 0x2252 <__fp_round+0x18>
    224e:	60 ff       	sbrs	r22, 0
    2250:	04 c0       	rjmp	.+8      	; 0x225a <__fp_round+0x20>
    2252:	6f 5f       	subi	r22, 0xFF	; 255
    2254:	7f 4f       	sbci	r23, 0xFF	; 255
    2256:	8f 4f       	sbci	r24, 0xFF	; 255
    2258:	9f 4f       	sbci	r25, 0xFF	; 255
    225a:	08 95       	ret

0000225c <__fp_split3>:
    225c:	57 fd       	sbrc	r21, 7
    225e:	90 58       	subi	r25, 0x80	; 128
    2260:	44 0f       	add	r20, r20
    2262:	55 1f       	adc	r21, r21
    2264:	59 f0       	breq	.+22     	; 0x227c <__fp_splitA+0x10>
    2266:	5f 3f       	cpi	r21, 0xFF	; 255
    2268:	71 f0       	breq	.+28     	; 0x2286 <__fp_splitA+0x1a>
    226a:	47 95       	ror	r20

0000226c <__fp_splitA>:
    226c:	88 0f       	add	r24, r24
    226e:	97 fb       	bst	r25, 7
    2270:	99 1f       	adc	r25, r25
    2272:	61 f0       	breq	.+24     	; 0x228c <__fp_splitA+0x20>
    2274:	9f 3f       	cpi	r25, 0xFF	; 255
    2276:	79 f0       	breq	.+30     	; 0x2296 <__fp_splitA+0x2a>
    2278:	87 95       	ror	r24
    227a:	08 95       	ret
    227c:	12 16       	cp	r1, r18
    227e:	13 06       	cpc	r1, r19
    2280:	14 06       	cpc	r1, r20
    2282:	55 1f       	adc	r21, r21
    2284:	f2 cf       	rjmp	.-28     	; 0x226a <__fp_split3+0xe>
    2286:	46 95       	lsr	r20
    2288:	f1 df       	rcall	.-30     	; 0x226c <__fp_splitA>
    228a:	08 c0       	rjmp	.+16     	; 0x229c <__fp_splitA+0x30>
    228c:	16 16       	cp	r1, r22
    228e:	17 06       	cpc	r1, r23
    2290:	18 06       	cpc	r1, r24
    2292:	99 1f       	adc	r25, r25
    2294:	f1 cf       	rjmp	.-30     	; 0x2278 <__fp_splitA+0xc>
    2296:	86 95       	lsr	r24
    2298:	71 05       	cpc	r23, r1
    229a:	61 05       	cpc	r22, r1
    229c:	08 94       	sec
    229e:	08 95       	ret

000022a0 <__fp_zero>:
    22a0:	e8 94       	clt

000022a2 <__fp_szero>:
    22a2:	bb 27       	eor	r27, r27
    22a4:	66 27       	eor	r22, r22
    22a6:	77 27       	eor	r23, r23
    22a8:	cb 01       	movw	r24, r22
    22aa:	97 f9       	bld	r25, 7
    22ac:	08 95       	ret

000022ae <__mulsf3>:
    22ae:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <__mulsf3x>
    22b2:	0c 94 1d 11 	jmp	0x223a	; 0x223a <__fp_round>
    22b6:	0e 94 0f 11 	call	0x221e	; 0x221e <__fp_pscA>
    22ba:	38 f0       	brcs	.+14     	; 0x22ca <__mulsf3+0x1c>
    22bc:	0e 94 16 11 	call	0x222c	; 0x222c <__fp_pscB>
    22c0:	20 f0       	brcs	.+8      	; 0x22ca <__mulsf3+0x1c>
    22c2:	95 23       	and	r25, r21
    22c4:	11 f0       	breq	.+4      	; 0x22ca <__mulsf3+0x1c>
    22c6:	0c 94 06 11 	jmp	0x220c	; 0x220c <__fp_inf>
    22ca:	0c 94 0c 11 	jmp	0x2218	; 0x2218 <__fp_nan>
    22ce:	11 24       	eor	r1, r1
    22d0:	0c 94 51 11 	jmp	0x22a2	; 0x22a2 <__fp_szero>

000022d4 <__mulsf3x>:
    22d4:	0e 94 2e 11 	call	0x225c	; 0x225c <__fp_split3>
    22d8:	70 f3       	brcs	.-36     	; 0x22b6 <__mulsf3+0x8>

000022da <__mulsf3_pse>:
    22da:	95 9f       	mul	r25, r21
    22dc:	c1 f3       	breq	.-16     	; 0x22ce <__mulsf3+0x20>
    22de:	95 0f       	add	r25, r21
    22e0:	50 e0       	ldi	r21, 0x00	; 0
    22e2:	55 1f       	adc	r21, r21
    22e4:	62 9f       	mul	r22, r18
    22e6:	f0 01       	movw	r30, r0
    22e8:	72 9f       	mul	r23, r18
    22ea:	bb 27       	eor	r27, r27
    22ec:	f0 0d       	add	r31, r0
    22ee:	b1 1d       	adc	r27, r1
    22f0:	63 9f       	mul	r22, r19
    22f2:	aa 27       	eor	r26, r26
    22f4:	f0 0d       	add	r31, r0
    22f6:	b1 1d       	adc	r27, r1
    22f8:	aa 1f       	adc	r26, r26
    22fa:	64 9f       	mul	r22, r20
    22fc:	66 27       	eor	r22, r22
    22fe:	b0 0d       	add	r27, r0
    2300:	a1 1d       	adc	r26, r1
    2302:	66 1f       	adc	r22, r22
    2304:	82 9f       	mul	r24, r18
    2306:	22 27       	eor	r18, r18
    2308:	b0 0d       	add	r27, r0
    230a:	a1 1d       	adc	r26, r1
    230c:	62 1f       	adc	r22, r18
    230e:	73 9f       	mul	r23, r19
    2310:	b0 0d       	add	r27, r0
    2312:	a1 1d       	adc	r26, r1
    2314:	62 1f       	adc	r22, r18
    2316:	83 9f       	mul	r24, r19
    2318:	a0 0d       	add	r26, r0
    231a:	61 1d       	adc	r22, r1
    231c:	22 1f       	adc	r18, r18
    231e:	74 9f       	mul	r23, r20
    2320:	33 27       	eor	r19, r19
    2322:	a0 0d       	add	r26, r0
    2324:	61 1d       	adc	r22, r1
    2326:	23 1f       	adc	r18, r19
    2328:	84 9f       	mul	r24, r20
    232a:	60 0d       	add	r22, r0
    232c:	21 1d       	adc	r18, r1
    232e:	82 2f       	mov	r24, r18
    2330:	76 2f       	mov	r23, r22
    2332:	6a 2f       	mov	r22, r26
    2334:	11 24       	eor	r1, r1
    2336:	9f 57       	subi	r25, 0x7F	; 127
    2338:	50 40       	sbci	r21, 0x00	; 0
    233a:	9a f0       	brmi	.+38     	; 0x2362 <__mulsf3_pse+0x88>
    233c:	f1 f0       	breq	.+60     	; 0x237a <__mulsf3_pse+0xa0>
    233e:	88 23       	and	r24, r24
    2340:	4a f0       	brmi	.+18     	; 0x2354 <__mulsf3_pse+0x7a>
    2342:	ee 0f       	add	r30, r30
    2344:	ff 1f       	adc	r31, r31
    2346:	bb 1f       	adc	r27, r27
    2348:	66 1f       	adc	r22, r22
    234a:	77 1f       	adc	r23, r23
    234c:	88 1f       	adc	r24, r24
    234e:	91 50       	subi	r25, 0x01	; 1
    2350:	50 40       	sbci	r21, 0x00	; 0
    2352:	a9 f7       	brne	.-22     	; 0x233e <__mulsf3_pse+0x64>
    2354:	9e 3f       	cpi	r25, 0xFE	; 254
    2356:	51 05       	cpc	r21, r1
    2358:	80 f0       	brcs	.+32     	; 0x237a <__mulsf3_pse+0xa0>
    235a:	0c 94 06 11 	jmp	0x220c	; 0x220c <__fp_inf>
    235e:	0c 94 51 11 	jmp	0x22a2	; 0x22a2 <__fp_szero>
    2362:	5f 3f       	cpi	r21, 0xFF	; 255
    2364:	e4 f3       	brlt	.-8      	; 0x235e <__mulsf3_pse+0x84>
    2366:	98 3e       	cpi	r25, 0xE8	; 232
    2368:	d4 f3       	brlt	.-12     	; 0x235e <__mulsf3_pse+0x84>
    236a:	86 95       	lsr	r24
    236c:	77 95       	ror	r23
    236e:	67 95       	ror	r22
    2370:	b7 95       	ror	r27
    2372:	f7 95       	ror	r31
    2374:	e7 95       	ror	r30
    2376:	9f 5f       	subi	r25, 0xFF	; 255
    2378:	c1 f7       	brne	.-16     	; 0x236a <__mulsf3_pse+0x90>
    237a:	fe 2b       	or	r31, r30
    237c:	88 0f       	add	r24, r24
    237e:	91 1d       	adc	r25, r1
    2380:	96 95       	lsr	r25
    2382:	87 95       	ror	r24
    2384:	97 f9       	bld	r25, 7
    2386:	08 95       	ret

00002388 <__tablejump2__>:
    2388:	ee 0f       	add	r30, r30
    238a:	ff 1f       	adc	r31, r31
    238c:	05 90       	lpm	r0, Z+
    238e:	f4 91       	lpm	r31, Z
    2390:	e0 2d       	mov	r30, r0
    2392:	09 94       	ijmp

00002394 <strcmp>:
    2394:	fb 01       	movw	r30, r22
    2396:	dc 01       	movw	r26, r24
    2398:	8d 91       	ld	r24, X+
    239a:	01 90       	ld	r0, Z+
    239c:	80 19       	sub	r24, r0
    239e:	01 10       	cpse	r0, r1
    23a0:	d9 f3       	breq	.-10     	; 0x2398 <strcmp+0x4>
    23a2:	99 0b       	sbc	r25, r25
    23a4:	08 95       	ret

000023a6 <strcpy>:
    23a6:	fb 01       	movw	r30, r22
    23a8:	dc 01       	movw	r26, r24
    23aa:	01 90       	ld	r0, Z+
    23ac:	0d 92       	st	X+, r0
    23ae:	00 20       	and	r0, r0
    23b0:	e1 f7       	brne	.-8      	; 0x23aa <strcpy+0x4>
    23b2:	08 95       	ret

000023b4 <sprintf>:
    23b4:	ae e0       	ldi	r26, 0x0E	; 14
    23b6:	b0 e0       	ldi	r27, 0x00	; 0
    23b8:	e0 ee       	ldi	r30, 0xE0	; 224
    23ba:	f1 e1       	ldi	r31, 0x11	; 17
    23bc:	0c 94 9b 14 	jmp	0x2936	; 0x2936 <__prologue_saves__+0x1c>
    23c0:	0d 89       	ldd	r16, Y+21	; 0x15
    23c2:	1e 89       	ldd	r17, Y+22	; 0x16
    23c4:	86 e0       	ldi	r24, 0x06	; 6
    23c6:	8c 83       	std	Y+4, r24	; 0x04
    23c8:	1a 83       	std	Y+2, r17	; 0x02
    23ca:	09 83       	std	Y+1, r16	; 0x01
    23cc:	8f ef       	ldi	r24, 0xFF	; 255
    23ce:	9f e7       	ldi	r25, 0x7F	; 127
    23d0:	9e 83       	std	Y+6, r25	; 0x06
    23d2:	8d 83       	std	Y+5, r24	; 0x05
    23d4:	ae 01       	movw	r20, r28
    23d6:	47 5e       	subi	r20, 0xE7	; 231
    23d8:	5f 4f       	sbci	r21, 0xFF	; 255
    23da:	6f 89       	ldd	r22, Y+23	; 0x17
    23dc:	78 8d       	ldd	r23, Y+24	; 0x18
    23de:	ce 01       	movw	r24, r28
    23e0:	01 96       	adiw	r24, 0x01	; 1
    23e2:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <vfprintf>
    23e6:	ef 81       	ldd	r30, Y+7	; 0x07
    23e8:	f8 85       	ldd	r31, Y+8	; 0x08
    23ea:	e0 0f       	add	r30, r16
    23ec:	f1 1f       	adc	r31, r17
    23ee:	10 82       	st	Z, r1
    23f0:	2e 96       	adiw	r28, 0x0e	; 14
    23f2:	e4 e0       	ldi	r30, 0x04	; 4
    23f4:	0c 94 b7 14 	jmp	0x296e	; 0x296e <__epilogue_restores__+0x1c>

000023f8 <vfprintf>:
    23f8:	ab e0       	ldi	r26, 0x0B	; 11
    23fa:	b0 e0       	ldi	r27, 0x00	; 0
    23fc:	e2 e0       	ldi	r30, 0x02	; 2
    23fe:	f2 e1       	ldi	r31, 0x12	; 18
    2400:	0c 94 8d 14 	jmp	0x291a	; 0x291a <__prologue_saves__>
    2404:	6c 01       	movw	r12, r24
    2406:	7b 01       	movw	r14, r22
    2408:	8a 01       	movw	r16, r20
    240a:	fc 01       	movw	r30, r24
    240c:	17 82       	std	Z+7, r1	; 0x07
    240e:	16 82       	std	Z+6, r1	; 0x06
    2410:	83 81       	ldd	r24, Z+3	; 0x03
    2412:	81 ff       	sbrs	r24, 1
    2414:	cc c1       	rjmp	.+920    	; 0x27ae <vfprintf+0x3b6>
    2416:	ce 01       	movw	r24, r28
    2418:	01 96       	adiw	r24, 0x01	; 1
    241a:	3c 01       	movw	r6, r24
    241c:	f6 01       	movw	r30, r12
    241e:	93 81       	ldd	r25, Z+3	; 0x03
    2420:	f7 01       	movw	r30, r14
    2422:	93 fd       	sbrc	r25, 3
    2424:	85 91       	lpm	r24, Z+
    2426:	93 ff       	sbrs	r25, 3
    2428:	81 91       	ld	r24, Z+
    242a:	7f 01       	movw	r14, r30
    242c:	88 23       	and	r24, r24
    242e:	09 f4       	brne	.+2      	; 0x2432 <vfprintf+0x3a>
    2430:	ba c1       	rjmp	.+884    	; 0x27a6 <vfprintf+0x3ae>
    2432:	85 32       	cpi	r24, 0x25	; 37
    2434:	39 f4       	brne	.+14     	; 0x2444 <vfprintf+0x4c>
    2436:	93 fd       	sbrc	r25, 3
    2438:	85 91       	lpm	r24, Z+
    243a:	93 ff       	sbrs	r25, 3
    243c:	81 91       	ld	r24, Z+
    243e:	7f 01       	movw	r14, r30
    2440:	85 32       	cpi	r24, 0x25	; 37
    2442:	29 f4       	brne	.+10     	; 0x244e <vfprintf+0x56>
    2444:	b6 01       	movw	r22, r12
    2446:	90 e0       	ldi	r25, 0x00	; 0
    2448:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <fputc>
    244c:	e7 cf       	rjmp	.-50     	; 0x241c <vfprintf+0x24>
    244e:	91 2c       	mov	r9, r1
    2450:	21 2c       	mov	r2, r1
    2452:	31 2c       	mov	r3, r1
    2454:	ff e1       	ldi	r31, 0x1F	; 31
    2456:	f3 15       	cp	r31, r3
    2458:	d8 f0       	brcs	.+54     	; 0x2490 <vfprintf+0x98>
    245a:	8b 32       	cpi	r24, 0x2B	; 43
    245c:	79 f0       	breq	.+30     	; 0x247c <vfprintf+0x84>
    245e:	38 f4       	brcc	.+14     	; 0x246e <vfprintf+0x76>
    2460:	80 32       	cpi	r24, 0x20	; 32
    2462:	79 f0       	breq	.+30     	; 0x2482 <vfprintf+0x8a>
    2464:	83 32       	cpi	r24, 0x23	; 35
    2466:	a1 f4       	brne	.+40     	; 0x2490 <vfprintf+0x98>
    2468:	23 2d       	mov	r18, r3
    246a:	20 61       	ori	r18, 0x10	; 16
    246c:	1d c0       	rjmp	.+58     	; 0x24a8 <vfprintf+0xb0>
    246e:	8d 32       	cpi	r24, 0x2D	; 45
    2470:	61 f0       	breq	.+24     	; 0x248a <vfprintf+0x92>
    2472:	80 33       	cpi	r24, 0x30	; 48
    2474:	69 f4       	brne	.+26     	; 0x2490 <vfprintf+0x98>
    2476:	23 2d       	mov	r18, r3
    2478:	21 60       	ori	r18, 0x01	; 1
    247a:	16 c0       	rjmp	.+44     	; 0x24a8 <vfprintf+0xb0>
    247c:	83 2d       	mov	r24, r3
    247e:	82 60       	ori	r24, 0x02	; 2
    2480:	38 2e       	mov	r3, r24
    2482:	e3 2d       	mov	r30, r3
    2484:	e4 60       	ori	r30, 0x04	; 4
    2486:	3e 2e       	mov	r3, r30
    2488:	2a c0       	rjmp	.+84     	; 0x24de <vfprintf+0xe6>
    248a:	f3 2d       	mov	r31, r3
    248c:	f8 60       	ori	r31, 0x08	; 8
    248e:	1d c0       	rjmp	.+58     	; 0x24ca <vfprintf+0xd2>
    2490:	37 fc       	sbrc	r3, 7
    2492:	2d c0       	rjmp	.+90     	; 0x24ee <vfprintf+0xf6>
    2494:	20 ed       	ldi	r18, 0xD0	; 208
    2496:	28 0f       	add	r18, r24
    2498:	2a 30       	cpi	r18, 0x0A	; 10
    249a:	40 f0       	brcs	.+16     	; 0x24ac <vfprintf+0xb4>
    249c:	8e 32       	cpi	r24, 0x2E	; 46
    249e:	b9 f4       	brne	.+46     	; 0x24ce <vfprintf+0xd6>
    24a0:	36 fc       	sbrc	r3, 6
    24a2:	81 c1       	rjmp	.+770    	; 0x27a6 <vfprintf+0x3ae>
    24a4:	23 2d       	mov	r18, r3
    24a6:	20 64       	ori	r18, 0x40	; 64
    24a8:	32 2e       	mov	r3, r18
    24aa:	19 c0       	rjmp	.+50     	; 0x24de <vfprintf+0xe6>
    24ac:	36 fe       	sbrs	r3, 6
    24ae:	06 c0       	rjmp	.+12     	; 0x24bc <vfprintf+0xc4>
    24b0:	8a e0       	ldi	r24, 0x0A	; 10
    24b2:	98 9e       	mul	r9, r24
    24b4:	20 0d       	add	r18, r0
    24b6:	11 24       	eor	r1, r1
    24b8:	92 2e       	mov	r9, r18
    24ba:	11 c0       	rjmp	.+34     	; 0x24de <vfprintf+0xe6>
    24bc:	ea e0       	ldi	r30, 0x0A	; 10
    24be:	2e 9e       	mul	r2, r30
    24c0:	20 0d       	add	r18, r0
    24c2:	11 24       	eor	r1, r1
    24c4:	22 2e       	mov	r2, r18
    24c6:	f3 2d       	mov	r31, r3
    24c8:	f0 62       	ori	r31, 0x20	; 32
    24ca:	3f 2e       	mov	r3, r31
    24cc:	08 c0       	rjmp	.+16     	; 0x24de <vfprintf+0xe6>
    24ce:	8c 36       	cpi	r24, 0x6C	; 108
    24d0:	21 f4       	brne	.+8      	; 0x24da <vfprintf+0xe2>
    24d2:	83 2d       	mov	r24, r3
    24d4:	80 68       	ori	r24, 0x80	; 128
    24d6:	38 2e       	mov	r3, r24
    24d8:	02 c0       	rjmp	.+4      	; 0x24de <vfprintf+0xe6>
    24da:	88 36       	cpi	r24, 0x68	; 104
    24dc:	41 f4       	brne	.+16     	; 0x24ee <vfprintf+0xf6>
    24de:	f7 01       	movw	r30, r14
    24e0:	93 fd       	sbrc	r25, 3
    24e2:	85 91       	lpm	r24, Z+
    24e4:	93 ff       	sbrs	r25, 3
    24e6:	81 91       	ld	r24, Z+
    24e8:	7f 01       	movw	r14, r30
    24ea:	81 11       	cpse	r24, r1
    24ec:	b3 cf       	rjmp	.-154    	; 0x2454 <vfprintf+0x5c>
    24ee:	98 2f       	mov	r25, r24
    24f0:	9f 7d       	andi	r25, 0xDF	; 223
    24f2:	95 54       	subi	r25, 0x45	; 69
    24f4:	93 30       	cpi	r25, 0x03	; 3
    24f6:	28 f4       	brcc	.+10     	; 0x2502 <vfprintf+0x10a>
    24f8:	0c 5f       	subi	r16, 0xFC	; 252
    24fa:	1f 4f       	sbci	r17, 0xFF	; 255
    24fc:	9f e3       	ldi	r25, 0x3F	; 63
    24fe:	99 83       	std	Y+1, r25	; 0x01
    2500:	0d c0       	rjmp	.+26     	; 0x251c <vfprintf+0x124>
    2502:	83 36       	cpi	r24, 0x63	; 99
    2504:	31 f0       	breq	.+12     	; 0x2512 <vfprintf+0x11a>
    2506:	83 37       	cpi	r24, 0x73	; 115
    2508:	71 f0       	breq	.+28     	; 0x2526 <vfprintf+0x12e>
    250a:	83 35       	cpi	r24, 0x53	; 83
    250c:	09 f0       	breq	.+2      	; 0x2510 <vfprintf+0x118>
    250e:	59 c0       	rjmp	.+178    	; 0x25c2 <vfprintf+0x1ca>
    2510:	21 c0       	rjmp	.+66     	; 0x2554 <vfprintf+0x15c>
    2512:	f8 01       	movw	r30, r16
    2514:	80 81       	ld	r24, Z
    2516:	89 83       	std	Y+1, r24	; 0x01
    2518:	0e 5f       	subi	r16, 0xFE	; 254
    251a:	1f 4f       	sbci	r17, 0xFF	; 255
    251c:	88 24       	eor	r8, r8
    251e:	83 94       	inc	r8
    2520:	91 2c       	mov	r9, r1
    2522:	53 01       	movw	r10, r6
    2524:	13 c0       	rjmp	.+38     	; 0x254c <vfprintf+0x154>
    2526:	28 01       	movw	r4, r16
    2528:	f2 e0       	ldi	r31, 0x02	; 2
    252a:	4f 0e       	add	r4, r31
    252c:	51 1c       	adc	r5, r1
    252e:	f8 01       	movw	r30, r16
    2530:	a0 80       	ld	r10, Z
    2532:	b1 80       	ldd	r11, Z+1	; 0x01
    2534:	36 fe       	sbrs	r3, 6
    2536:	03 c0       	rjmp	.+6      	; 0x253e <vfprintf+0x146>
    2538:	69 2d       	mov	r22, r9
    253a:	70 e0       	ldi	r23, 0x00	; 0
    253c:	02 c0       	rjmp	.+4      	; 0x2542 <vfprintf+0x14a>
    253e:	6f ef       	ldi	r22, 0xFF	; 255
    2540:	7f ef       	ldi	r23, 0xFF	; 255
    2542:	c5 01       	movw	r24, r10
    2544:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <strnlen>
    2548:	4c 01       	movw	r8, r24
    254a:	82 01       	movw	r16, r4
    254c:	f3 2d       	mov	r31, r3
    254e:	ff 77       	andi	r31, 0x7F	; 127
    2550:	3f 2e       	mov	r3, r31
    2552:	16 c0       	rjmp	.+44     	; 0x2580 <vfprintf+0x188>
    2554:	28 01       	movw	r4, r16
    2556:	22 e0       	ldi	r18, 0x02	; 2
    2558:	42 0e       	add	r4, r18
    255a:	51 1c       	adc	r5, r1
    255c:	f8 01       	movw	r30, r16
    255e:	a0 80       	ld	r10, Z
    2560:	b1 80       	ldd	r11, Z+1	; 0x01
    2562:	36 fe       	sbrs	r3, 6
    2564:	03 c0       	rjmp	.+6      	; 0x256c <vfprintf+0x174>
    2566:	69 2d       	mov	r22, r9
    2568:	70 e0       	ldi	r23, 0x00	; 0
    256a:	02 c0       	rjmp	.+4      	; 0x2570 <vfprintf+0x178>
    256c:	6f ef       	ldi	r22, 0xFF	; 255
    256e:	7f ef       	ldi	r23, 0xFF	; 255
    2570:	c5 01       	movw	r24, r10
    2572:	0e 94 dd 13 	call	0x27ba	; 0x27ba <strnlen_P>
    2576:	4c 01       	movw	r8, r24
    2578:	f3 2d       	mov	r31, r3
    257a:	f0 68       	ori	r31, 0x80	; 128
    257c:	3f 2e       	mov	r3, r31
    257e:	82 01       	movw	r16, r4
    2580:	33 fc       	sbrc	r3, 3
    2582:	1b c0       	rjmp	.+54     	; 0x25ba <vfprintf+0x1c2>
    2584:	82 2d       	mov	r24, r2
    2586:	90 e0       	ldi	r25, 0x00	; 0
    2588:	88 16       	cp	r8, r24
    258a:	99 06       	cpc	r9, r25
    258c:	b0 f4       	brcc	.+44     	; 0x25ba <vfprintf+0x1c2>
    258e:	b6 01       	movw	r22, r12
    2590:	80 e2       	ldi	r24, 0x20	; 32
    2592:	90 e0       	ldi	r25, 0x00	; 0
    2594:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <fputc>
    2598:	2a 94       	dec	r2
    259a:	f4 cf       	rjmp	.-24     	; 0x2584 <vfprintf+0x18c>
    259c:	f5 01       	movw	r30, r10
    259e:	37 fc       	sbrc	r3, 7
    25a0:	85 91       	lpm	r24, Z+
    25a2:	37 fe       	sbrs	r3, 7
    25a4:	81 91       	ld	r24, Z+
    25a6:	5f 01       	movw	r10, r30
    25a8:	b6 01       	movw	r22, r12
    25aa:	90 e0       	ldi	r25, 0x00	; 0
    25ac:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <fputc>
    25b0:	21 10       	cpse	r2, r1
    25b2:	2a 94       	dec	r2
    25b4:	21 e0       	ldi	r18, 0x01	; 1
    25b6:	82 1a       	sub	r8, r18
    25b8:	91 08       	sbc	r9, r1
    25ba:	81 14       	cp	r8, r1
    25bc:	91 04       	cpc	r9, r1
    25be:	71 f7       	brne	.-36     	; 0x259c <vfprintf+0x1a4>
    25c0:	e8 c0       	rjmp	.+464    	; 0x2792 <vfprintf+0x39a>
    25c2:	84 36       	cpi	r24, 0x64	; 100
    25c4:	11 f0       	breq	.+4      	; 0x25ca <vfprintf+0x1d2>
    25c6:	89 36       	cpi	r24, 0x69	; 105
    25c8:	41 f5       	brne	.+80     	; 0x261a <vfprintf+0x222>
    25ca:	f8 01       	movw	r30, r16
    25cc:	37 fe       	sbrs	r3, 7
    25ce:	07 c0       	rjmp	.+14     	; 0x25de <vfprintf+0x1e6>
    25d0:	60 81       	ld	r22, Z
    25d2:	71 81       	ldd	r23, Z+1	; 0x01
    25d4:	82 81       	ldd	r24, Z+2	; 0x02
    25d6:	93 81       	ldd	r25, Z+3	; 0x03
    25d8:	0c 5f       	subi	r16, 0xFC	; 252
    25da:	1f 4f       	sbci	r17, 0xFF	; 255
    25dc:	08 c0       	rjmp	.+16     	; 0x25ee <vfprintf+0x1f6>
    25de:	60 81       	ld	r22, Z
    25e0:	71 81       	ldd	r23, Z+1	; 0x01
    25e2:	07 2e       	mov	r0, r23
    25e4:	00 0c       	add	r0, r0
    25e6:	88 0b       	sbc	r24, r24
    25e8:	99 0b       	sbc	r25, r25
    25ea:	0e 5f       	subi	r16, 0xFE	; 254
    25ec:	1f 4f       	sbci	r17, 0xFF	; 255
    25ee:	f3 2d       	mov	r31, r3
    25f0:	ff 76       	andi	r31, 0x6F	; 111
    25f2:	3f 2e       	mov	r3, r31
    25f4:	97 ff       	sbrs	r25, 7
    25f6:	09 c0       	rjmp	.+18     	; 0x260a <vfprintf+0x212>
    25f8:	90 95       	com	r25
    25fa:	80 95       	com	r24
    25fc:	70 95       	com	r23
    25fe:	61 95       	neg	r22
    2600:	7f 4f       	sbci	r23, 0xFF	; 255
    2602:	8f 4f       	sbci	r24, 0xFF	; 255
    2604:	9f 4f       	sbci	r25, 0xFF	; 255
    2606:	f0 68       	ori	r31, 0x80	; 128
    2608:	3f 2e       	mov	r3, r31
    260a:	2a e0       	ldi	r18, 0x0A	; 10
    260c:	30 e0       	ldi	r19, 0x00	; 0
    260e:	a3 01       	movw	r20, r6
    2610:	0e 94 2f 14 	call	0x285e	; 0x285e <__ultoa_invert>
    2614:	88 2e       	mov	r8, r24
    2616:	86 18       	sub	r8, r6
    2618:	45 c0       	rjmp	.+138    	; 0x26a4 <vfprintf+0x2ac>
    261a:	85 37       	cpi	r24, 0x75	; 117
    261c:	31 f4       	brne	.+12     	; 0x262a <vfprintf+0x232>
    261e:	23 2d       	mov	r18, r3
    2620:	2f 7e       	andi	r18, 0xEF	; 239
    2622:	b2 2e       	mov	r11, r18
    2624:	2a e0       	ldi	r18, 0x0A	; 10
    2626:	30 e0       	ldi	r19, 0x00	; 0
    2628:	25 c0       	rjmp	.+74     	; 0x2674 <vfprintf+0x27c>
    262a:	93 2d       	mov	r25, r3
    262c:	99 7f       	andi	r25, 0xF9	; 249
    262e:	b9 2e       	mov	r11, r25
    2630:	8f 36       	cpi	r24, 0x6F	; 111
    2632:	c1 f0       	breq	.+48     	; 0x2664 <vfprintf+0x26c>
    2634:	18 f4       	brcc	.+6      	; 0x263c <vfprintf+0x244>
    2636:	88 35       	cpi	r24, 0x58	; 88
    2638:	79 f0       	breq	.+30     	; 0x2658 <vfprintf+0x260>
    263a:	b5 c0       	rjmp	.+362    	; 0x27a6 <vfprintf+0x3ae>
    263c:	80 37       	cpi	r24, 0x70	; 112
    263e:	19 f0       	breq	.+6      	; 0x2646 <vfprintf+0x24e>
    2640:	88 37       	cpi	r24, 0x78	; 120
    2642:	21 f0       	breq	.+8      	; 0x264c <vfprintf+0x254>
    2644:	b0 c0       	rjmp	.+352    	; 0x27a6 <vfprintf+0x3ae>
    2646:	e9 2f       	mov	r30, r25
    2648:	e0 61       	ori	r30, 0x10	; 16
    264a:	be 2e       	mov	r11, r30
    264c:	b4 fe       	sbrs	r11, 4
    264e:	0d c0       	rjmp	.+26     	; 0x266a <vfprintf+0x272>
    2650:	fb 2d       	mov	r31, r11
    2652:	f4 60       	ori	r31, 0x04	; 4
    2654:	bf 2e       	mov	r11, r31
    2656:	09 c0       	rjmp	.+18     	; 0x266a <vfprintf+0x272>
    2658:	34 fe       	sbrs	r3, 4
    265a:	0a c0       	rjmp	.+20     	; 0x2670 <vfprintf+0x278>
    265c:	29 2f       	mov	r18, r25
    265e:	26 60       	ori	r18, 0x06	; 6
    2660:	b2 2e       	mov	r11, r18
    2662:	06 c0       	rjmp	.+12     	; 0x2670 <vfprintf+0x278>
    2664:	28 e0       	ldi	r18, 0x08	; 8
    2666:	30 e0       	ldi	r19, 0x00	; 0
    2668:	05 c0       	rjmp	.+10     	; 0x2674 <vfprintf+0x27c>
    266a:	20 e1       	ldi	r18, 0x10	; 16
    266c:	30 e0       	ldi	r19, 0x00	; 0
    266e:	02 c0       	rjmp	.+4      	; 0x2674 <vfprintf+0x27c>
    2670:	20 e1       	ldi	r18, 0x10	; 16
    2672:	32 e0       	ldi	r19, 0x02	; 2
    2674:	f8 01       	movw	r30, r16
    2676:	b7 fe       	sbrs	r11, 7
    2678:	07 c0       	rjmp	.+14     	; 0x2688 <vfprintf+0x290>
    267a:	60 81       	ld	r22, Z
    267c:	71 81       	ldd	r23, Z+1	; 0x01
    267e:	82 81       	ldd	r24, Z+2	; 0x02
    2680:	93 81       	ldd	r25, Z+3	; 0x03
    2682:	0c 5f       	subi	r16, 0xFC	; 252
    2684:	1f 4f       	sbci	r17, 0xFF	; 255
    2686:	06 c0       	rjmp	.+12     	; 0x2694 <vfprintf+0x29c>
    2688:	60 81       	ld	r22, Z
    268a:	71 81       	ldd	r23, Z+1	; 0x01
    268c:	80 e0       	ldi	r24, 0x00	; 0
    268e:	90 e0       	ldi	r25, 0x00	; 0
    2690:	0e 5f       	subi	r16, 0xFE	; 254
    2692:	1f 4f       	sbci	r17, 0xFF	; 255
    2694:	a3 01       	movw	r20, r6
    2696:	0e 94 2f 14 	call	0x285e	; 0x285e <__ultoa_invert>
    269a:	88 2e       	mov	r8, r24
    269c:	86 18       	sub	r8, r6
    269e:	fb 2d       	mov	r31, r11
    26a0:	ff 77       	andi	r31, 0x7F	; 127
    26a2:	3f 2e       	mov	r3, r31
    26a4:	36 fe       	sbrs	r3, 6
    26a6:	0d c0       	rjmp	.+26     	; 0x26c2 <vfprintf+0x2ca>
    26a8:	23 2d       	mov	r18, r3
    26aa:	2e 7f       	andi	r18, 0xFE	; 254
    26ac:	a2 2e       	mov	r10, r18
    26ae:	89 14       	cp	r8, r9
    26b0:	58 f4       	brcc	.+22     	; 0x26c8 <vfprintf+0x2d0>
    26b2:	34 fe       	sbrs	r3, 4
    26b4:	0b c0       	rjmp	.+22     	; 0x26cc <vfprintf+0x2d4>
    26b6:	32 fc       	sbrc	r3, 2
    26b8:	09 c0       	rjmp	.+18     	; 0x26cc <vfprintf+0x2d4>
    26ba:	83 2d       	mov	r24, r3
    26bc:	8e 7e       	andi	r24, 0xEE	; 238
    26be:	a8 2e       	mov	r10, r24
    26c0:	05 c0       	rjmp	.+10     	; 0x26cc <vfprintf+0x2d4>
    26c2:	b8 2c       	mov	r11, r8
    26c4:	a3 2c       	mov	r10, r3
    26c6:	03 c0       	rjmp	.+6      	; 0x26ce <vfprintf+0x2d6>
    26c8:	b8 2c       	mov	r11, r8
    26ca:	01 c0       	rjmp	.+2      	; 0x26ce <vfprintf+0x2d6>
    26cc:	b9 2c       	mov	r11, r9
    26ce:	a4 fe       	sbrs	r10, 4
    26d0:	0f c0       	rjmp	.+30     	; 0x26f0 <vfprintf+0x2f8>
    26d2:	fe 01       	movw	r30, r28
    26d4:	e8 0d       	add	r30, r8
    26d6:	f1 1d       	adc	r31, r1
    26d8:	80 81       	ld	r24, Z
    26da:	80 33       	cpi	r24, 0x30	; 48
    26dc:	21 f4       	brne	.+8      	; 0x26e6 <vfprintf+0x2ee>
    26de:	9a 2d       	mov	r25, r10
    26e0:	99 7e       	andi	r25, 0xE9	; 233
    26e2:	a9 2e       	mov	r10, r25
    26e4:	09 c0       	rjmp	.+18     	; 0x26f8 <vfprintf+0x300>
    26e6:	a2 fe       	sbrs	r10, 2
    26e8:	06 c0       	rjmp	.+12     	; 0x26f6 <vfprintf+0x2fe>
    26ea:	b3 94       	inc	r11
    26ec:	b3 94       	inc	r11
    26ee:	04 c0       	rjmp	.+8      	; 0x26f8 <vfprintf+0x300>
    26f0:	8a 2d       	mov	r24, r10
    26f2:	86 78       	andi	r24, 0x86	; 134
    26f4:	09 f0       	breq	.+2      	; 0x26f8 <vfprintf+0x300>
    26f6:	b3 94       	inc	r11
    26f8:	a3 fc       	sbrc	r10, 3
    26fa:	11 c0       	rjmp	.+34     	; 0x271e <vfprintf+0x326>
    26fc:	a0 fe       	sbrs	r10, 0
    26fe:	06 c0       	rjmp	.+12     	; 0x270c <vfprintf+0x314>
    2700:	b2 14       	cp	r11, r2
    2702:	88 f4       	brcc	.+34     	; 0x2726 <vfprintf+0x32e>
    2704:	28 0c       	add	r2, r8
    2706:	92 2c       	mov	r9, r2
    2708:	9b 18       	sub	r9, r11
    270a:	0e c0       	rjmp	.+28     	; 0x2728 <vfprintf+0x330>
    270c:	b2 14       	cp	r11, r2
    270e:	60 f4       	brcc	.+24     	; 0x2728 <vfprintf+0x330>
    2710:	b6 01       	movw	r22, r12
    2712:	80 e2       	ldi	r24, 0x20	; 32
    2714:	90 e0       	ldi	r25, 0x00	; 0
    2716:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <fputc>
    271a:	b3 94       	inc	r11
    271c:	f7 cf       	rjmp	.-18     	; 0x270c <vfprintf+0x314>
    271e:	b2 14       	cp	r11, r2
    2720:	18 f4       	brcc	.+6      	; 0x2728 <vfprintf+0x330>
    2722:	2b 18       	sub	r2, r11
    2724:	02 c0       	rjmp	.+4      	; 0x272a <vfprintf+0x332>
    2726:	98 2c       	mov	r9, r8
    2728:	21 2c       	mov	r2, r1
    272a:	a4 fe       	sbrs	r10, 4
    272c:	10 c0       	rjmp	.+32     	; 0x274e <vfprintf+0x356>
    272e:	b6 01       	movw	r22, r12
    2730:	80 e3       	ldi	r24, 0x30	; 48
    2732:	90 e0       	ldi	r25, 0x00	; 0
    2734:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <fputc>
    2738:	a2 fe       	sbrs	r10, 2
    273a:	17 c0       	rjmp	.+46     	; 0x276a <vfprintf+0x372>
    273c:	a1 fc       	sbrc	r10, 1
    273e:	03 c0       	rjmp	.+6      	; 0x2746 <vfprintf+0x34e>
    2740:	88 e7       	ldi	r24, 0x78	; 120
    2742:	90 e0       	ldi	r25, 0x00	; 0
    2744:	02 c0       	rjmp	.+4      	; 0x274a <vfprintf+0x352>
    2746:	88 e5       	ldi	r24, 0x58	; 88
    2748:	90 e0       	ldi	r25, 0x00	; 0
    274a:	b6 01       	movw	r22, r12
    274c:	0c c0       	rjmp	.+24     	; 0x2766 <vfprintf+0x36e>
    274e:	8a 2d       	mov	r24, r10
    2750:	86 78       	andi	r24, 0x86	; 134
    2752:	59 f0       	breq	.+22     	; 0x276a <vfprintf+0x372>
    2754:	a1 fe       	sbrs	r10, 1
    2756:	02 c0       	rjmp	.+4      	; 0x275c <vfprintf+0x364>
    2758:	8b e2       	ldi	r24, 0x2B	; 43
    275a:	01 c0       	rjmp	.+2      	; 0x275e <vfprintf+0x366>
    275c:	80 e2       	ldi	r24, 0x20	; 32
    275e:	a7 fc       	sbrc	r10, 7
    2760:	8d e2       	ldi	r24, 0x2D	; 45
    2762:	b6 01       	movw	r22, r12
    2764:	90 e0       	ldi	r25, 0x00	; 0
    2766:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <fputc>
    276a:	89 14       	cp	r8, r9
    276c:	38 f4       	brcc	.+14     	; 0x277c <vfprintf+0x384>
    276e:	b6 01       	movw	r22, r12
    2770:	80 e3       	ldi	r24, 0x30	; 48
    2772:	90 e0       	ldi	r25, 0x00	; 0
    2774:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <fputc>
    2778:	9a 94       	dec	r9
    277a:	f7 cf       	rjmp	.-18     	; 0x276a <vfprintf+0x372>
    277c:	8a 94       	dec	r8
    277e:	f3 01       	movw	r30, r6
    2780:	e8 0d       	add	r30, r8
    2782:	f1 1d       	adc	r31, r1
    2784:	80 81       	ld	r24, Z
    2786:	b6 01       	movw	r22, r12
    2788:	90 e0       	ldi	r25, 0x00	; 0
    278a:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <fputc>
    278e:	81 10       	cpse	r8, r1
    2790:	f5 cf       	rjmp	.-22     	; 0x277c <vfprintf+0x384>
    2792:	22 20       	and	r2, r2
    2794:	09 f4       	brne	.+2      	; 0x2798 <vfprintf+0x3a0>
    2796:	42 ce       	rjmp	.-892    	; 0x241c <vfprintf+0x24>
    2798:	b6 01       	movw	r22, r12
    279a:	80 e2       	ldi	r24, 0x20	; 32
    279c:	90 e0       	ldi	r25, 0x00	; 0
    279e:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <fputc>
    27a2:	2a 94       	dec	r2
    27a4:	f6 cf       	rjmp	.-20     	; 0x2792 <vfprintf+0x39a>
    27a6:	f6 01       	movw	r30, r12
    27a8:	86 81       	ldd	r24, Z+6	; 0x06
    27aa:	97 81       	ldd	r25, Z+7	; 0x07
    27ac:	02 c0       	rjmp	.+4      	; 0x27b2 <vfprintf+0x3ba>
    27ae:	8f ef       	ldi	r24, 0xFF	; 255
    27b0:	9f ef       	ldi	r25, 0xFF	; 255
    27b2:	2b 96       	adiw	r28, 0x0b	; 11
    27b4:	e2 e1       	ldi	r30, 0x12	; 18
    27b6:	0c 94 a9 14 	jmp	0x2952	; 0x2952 <__epilogue_restores__>

000027ba <strnlen_P>:
    27ba:	fc 01       	movw	r30, r24
    27bc:	05 90       	lpm	r0, Z+
    27be:	61 50       	subi	r22, 0x01	; 1
    27c0:	70 40       	sbci	r23, 0x00	; 0
    27c2:	01 10       	cpse	r0, r1
    27c4:	d8 f7       	brcc	.-10     	; 0x27bc <strnlen_P+0x2>
    27c6:	80 95       	com	r24
    27c8:	90 95       	com	r25
    27ca:	8e 0f       	add	r24, r30
    27cc:	9f 1f       	adc	r25, r31
    27ce:	08 95       	ret

000027d0 <strnlen>:
    27d0:	fc 01       	movw	r30, r24
    27d2:	61 50       	subi	r22, 0x01	; 1
    27d4:	70 40       	sbci	r23, 0x00	; 0
    27d6:	01 90       	ld	r0, Z+
    27d8:	01 10       	cpse	r0, r1
    27da:	d8 f7       	brcc	.-10     	; 0x27d2 <strnlen+0x2>
    27dc:	80 95       	com	r24
    27de:	90 95       	com	r25
    27e0:	8e 0f       	add	r24, r30
    27e2:	9f 1f       	adc	r25, r31
    27e4:	08 95       	ret

000027e6 <fputc>:
    27e6:	0f 93       	push	r16
    27e8:	1f 93       	push	r17
    27ea:	cf 93       	push	r28
    27ec:	df 93       	push	r29
    27ee:	fb 01       	movw	r30, r22
    27f0:	23 81       	ldd	r18, Z+3	; 0x03
    27f2:	21 fd       	sbrc	r18, 1
    27f4:	03 c0       	rjmp	.+6      	; 0x27fc <fputc+0x16>
    27f6:	8f ef       	ldi	r24, 0xFF	; 255
    27f8:	9f ef       	ldi	r25, 0xFF	; 255
    27fa:	2c c0       	rjmp	.+88     	; 0x2854 <fputc+0x6e>
    27fc:	22 ff       	sbrs	r18, 2
    27fe:	16 c0       	rjmp	.+44     	; 0x282c <fputc+0x46>
    2800:	46 81       	ldd	r20, Z+6	; 0x06
    2802:	57 81       	ldd	r21, Z+7	; 0x07
    2804:	24 81       	ldd	r18, Z+4	; 0x04
    2806:	35 81       	ldd	r19, Z+5	; 0x05
    2808:	42 17       	cp	r20, r18
    280a:	53 07       	cpc	r21, r19
    280c:	44 f4       	brge	.+16     	; 0x281e <fputc+0x38>
    280e:	a0 81       	ld	r26, Z
    2810:	b1 81       	ldd	r27, Z+1	; 0x01
    2812:	9d 01       	movw	r18, r26
    2814:	2f 5f       	subi	r18, 0xFF	; 255
    2816:	3f 4f       	sbci	r19, 0xFF	; 255
    2818:	31 83       	std	Z+1, r19	; 0x01
    281a:	20 83       	st	Z, r18
    281c:	8c 93       	st	X, r24
    281e:	26 81       	ldd	r18, Z+6	; 0x06
    2820:	37 81       	ldd	r19, Z+7	; 0x07
    2822:	2f 5f       	subi	r18, 0xFF	; 255
    2824:	3f 4f       	sbci	r19, 0xFF	; 255
    2826:	37 83       	std	Z+7, r19	; 0x07
    2828:	26 83       	std	Z+6, r18	; 0x06
    282a:	14 c0       	rjmp	.+40     	; 0x2854 <fputc+0x6e>
    282c:	8b 01       	movw	r16, r22
    282e:	ec 01       	movw	r28, r24
    2830:	fb 01       	movw	r30, r22
    2832:	00 84       	ldd	r0, Z+8	; 0x08
    2834:	f1 85       	ldd	r31, Z+9	; 0x09
    2836:	e0 2d       	mov	r30, r0
    2838:	09 95       	icall
    283a:	89 2b       	or	r24, r25
    283c:	e1 f6       	brne	.-72     	; 0x27f6 <fputc+0x10>
    283e:	d8 01       	movw	r26, r16
    2840:	16 96       	adiw	r26, 0x06	; 6
    2842:	8d 91       	ld	r24, X+
    2844:	9c 91       	ld	r25, X
    2846:	17 97       	sbiw	r26, 0x07	; 7
    2848:	01 96       	adiw	r24, 0x01	; 1
    284a:	17 96       	adiw	r26, 0x07	; 7
    284c:	9c 93       	st	X, r25
    284e:	8e 93       	st	-X, r24
    2850:	16 97       	sbiw	r26, 0x06	; 6
    2852:	ce 01       	movw	r24, r28
    2854:	df 91       	pop	r29
    2856:	cf 91       	pop	r28
    2858:	1f 91       	pop	r17
    285a:	0f 91       	pop	r16
    285c:	08 95       	ret

0000285e <__ultoa_invert>:
    285e:	fa 01       	movw	r30, r20
    2860:	aa 27       	eor	r26, r26
    2862:	28 30       	cpi	r18, 0x08	; 8
    2864:	51 f1       	breq	.+84     	; 0x28ba <__ultoa_invert+0x5c>
    2866:	20 31       	cpi	r18, 0x10	; 16
    2868:	81 f1       	breq	.+96     	; 0x28ca <__ultoa_invert+0x6c>
    286a:	e8 94       	clt
    286c:	6f 93       	push	r22
    286e:	6e 7f       	andi	r22, 0xFE	; 254
    2870:	6e 5f       	subi	r22, 0xFE	; 254
    2872:	7f 4f       	sbci	r23, 0xFF	; 255
    2874:	8f 4f       	sbci	r24, 0xFF	; 255
    2876:	9f 4f       	sbci	r25, 0xFF	; 255
    2878:	af 4f       	sbci	r26, 0xFF	; 255
    287a:	b1 e0       	ldi	r27, 0x01	; 1
    287c:	3e d0       	rcall	.+124    	; 0x28fa <__ultoa_invert+0x9c>
    287e:	b4 e0       	ldi	r27, 0x04	; 4
    2880:	3c d0       	rcall	.+120    	; 0x28fa <__ultoa_invert+0x9c>
    2882:	67 0f       	add	r22, r23
    2884:	78 1f       	adc	r23, r24
    2886:	89 1f       	adc	r24, r25
    2888:	9a 1f       	adc	r25, r26
    288a:	a1 1d       	adc	r26, r1
    288c:	68 0f       	add	r22, r24
    288e:	79 1f       	adc	r23, r25
    2890:	8a 1f       	adc	r24, r26
    2892:	91 1d       	adc	r25, r1
    2894:	a1 1d       	adc	r26, r1
    2896:	6a 0f       	add	r22, r26
    2898:	71 1d       	adc	r23, r1
    289a:	81 1d       	adc	r24, r1
    289c:	91 1d       	adc	r25, r1
    289e:	a1 1d       	adc	r26, r1
    28a0:	20 d0       	rcall	.+64     	; 0x28e2 <__ultoa_invert+0x84>
    28a2:	09 f4       	brne	.+2      	; 0x28a6 <__ultoa_invert+0x48>
    28a4:	68 94       	set
    28a6:	3f 91       	pop	r19
    28a8:	2a e0       	ldi	r18, 0x0A	; 10
    28aa:	26 9f       	mul	r18, r22
    28ac:	11 24       	eor	r1, r1
    28ae:	30 19       	sub	r19, r0
    28b0:	30 5d       	subi	r19, 0xD0	; 208
    28b2:	31 93       	st	Z+, r19
    28b4:	de f6       	brtc	.-74     	; 0x286c <__ultoa_invert+0xe>
    28b6:	cf 01       	movw	r24, r30
    28b8:	08 95       	ret
    28ba:	46 2f       	mov	r20, r22
    28bc:	47 70       	andi	r20, 0x07	; 7
    28be:	40 5d       	subi	r20, 0xD0	; 208
    28c0:	41 93       	st	Z+, r20
    28c2:	b3 e0       	ldi	r27, 0x03	; 3
    28c4:	0f d0       	rcall	.+30     	; 0x28e4 <__ultoa_invert+0x86>
    28c6:	c9 f7       	brne	.-14     	; 0x28ba <__ultoa_invert+0x5c>
    28c8:	f6 cf       	rjmp	.-20     	; 0x28b6 <__ultoa_invert+0x58>
    28ca:	46 2f       	mov	r20, r22
    28cc:	4f 70       	andi	r20, 0x0F	; 15
    28ce:	40 5d       	subi	r20, 0xD0	; 208
    28d0:	4a 33       	cpi	r20, 0x3A	; 58
    28d2:	18 f0       	brcs	.+6      	; 0x28da <__ultoa_invert+0x7c>
    28d4:	49 5d       	subi	r20, 0xD9	; 217
    28d6:	31 fd       	sbrc	r19, 1
    28d8:	40 52       	subi	r20, 0x20	; 32
    28da:	41 93       	st	Z+, r20
    28dc:	02 d0       	rcall	.+4      	; 0x28e2 <__ultoa_invert+0x84>
    28de:	a9 f7       	brne	.-22     	; 0x28ca <__ultoa_invert+0x6c>
    28e0:	ea cf       	rjmp	.-44     	; 0x28b6 <__ultoa_invert+0x58>
    28e2:	b4 e0       	ldi	r27, 0x04	; 4
    28e4:	a6 95       	lsr	r26
    28e6:	97 95       	ror	r25
    28e8:	87 95       	ror	r24
    28ea:	77 95       	ror	r23
    28ec:	67 95       	ror	r22
    28ee:	ba 95       	dec	r27
    28f0:	c9 f7       	brne	.-14     	; 0x28e4 <__ultoa_invert+0x86>
    28f2:	00 97       	sbiw	r24, 0x00	; 0
    28f4:	61 05       	cpc	r22, r1
    28f6:	71 05       	cpc	r23, r1
    28f8:	08 95       	ret
    28fa:	9b 01       	movw	r18, r22
    28fc:	ac 01       	movw	r20, r24
    28fe:	0a 2e       	mov	r0, r26
    2900:	06 94       	lsr	r0
    2902:	57 95       	ror	r21
    2904:	47 95       	ror	r20
    2906:	37 95       	ror	r19
    2908:	27 95       	ror	r18
    290a:	ba 95       	dec	r27
    290c:	c9 f7       	brne	.-14     	; 0x2900 <__ultoa_invert+0xa2>
    290e:	62 0f       	add	r22, r18
    2910:	73 1f       	adc	r23, r19
    2912:	84 1f       	adc	r24, r20
    2914:	95 1f       	adc	r25, r21
    2916:	a0 1d       	adc	r26, r0
    2918:	08 95       	ret

0000291a <__prologue_saves__>:
    291a:	2f 92       	push	r2
    291c:	3f 92       	push	r3
    291e:	4f 92       	push	r4
    2920:	5f 92       	push	r5
    2922:	6f 92       	push	r6
    2924:	7f 92       	push	r7
    2926:	8f 92       	push	r8
    2928:	9f 92       	push	r9
    292a:	af 92       	push	r10
    292c:	bf 92       	push	r11
    292e:	cf 92       	push	r12
    2930:	df 92       	push	r13
    2932:	ef 92       	push	r14
    2934:	ff 92       	push	r15
    2936:	0f 93       	push	r16
    2938:	1f 93       	push	r17
    293a:	cf 93       	push	r28
    293c:	df 93       	push	r29
    293e:	cd b7       	in	r28, 0x3d	; 61
    2940:	de b7       	in	r29, 0x3e	; 62
    2942:	ca 1b       	sub	r28, r26
    2944:	db 0b       	sbc	r29, r27
    2946:	0f b6       	in	r0, 0x3f	; 63
    2948:	f8 94       	cli
    294a:	de bf       	out	0x3e, r29	; 62
    294c:	0f be       	out	0x3f, r0	; 63
    294e:	cd bf       	out	0x3d, r28	; 61
    2950:	09 94       	ijmp

00002952 <__epilogue_restores__>:
    2952:	2a 88       	ldd	r2, Y+18	; 0x12
    2954:	39 88       	ldd	r3, Y+17	; 0x11
    2956:	48 88       	ldd	r4, Y+16	; 0x10
    2958:	5f 84       	ldd	r5, Y+15	; 0x0f
    295a:	6e 84       	ldd	r6, Y+14	; 0x0e
    295c:	7d 84       	ldd	r7, Y+13	; 0x0d
    295e:	8c 84       	ldd	r8, Y+12	; 0x0c
    2960:	9b 84       	ldd	r9, Y+11	; 0x0b
    2962:	aa 84       	ldd	r10, Y+10	; 0x0a
    2964:	b9 84       	ldd	r11, Y+9	; 0x09
    2966:	c8 84       	ldd	r12, Y+8	; 0x08
    2968:	df 80       	ldd	r13, Y+7	; 0x07
    296a:	ee 80       	ldd	r14, Y+6	; 0x06
    296c:	fd 80       	ldd	r15, Y+5	; 0x05
    296e:	0c 81       	ldd	r16, Y+4	; 0x04
    2970:	1b 81       	ldd	r17, Y+3	; 0x03
    2972:	aa 81       	ldd	r26, Y+2	; 0x02
    2974:	b9 81       	ldd	r27, Y+1	; 0x01
    2976:	ce 0f       	add	r28, r30
    2978:	d1 1d       	adc	r29, r1
    297a:	0f b6       	in	r0, 0x3f	; 63
    297c:	f8 94       	cli
    297e:	de bf       	out	0x3e, r29	; 62
    2980:	0f be       	out	0x3f, r0	; 63
    2982:	cd bf       	out	0x3d, r28	; 61
    2984:	ed 01       	movw	r28, r26
    2986:	08 95       	ret

00002988 <_exit>:
    2988:	f8 94       	cli

0000298a <__stop_program>:
    298a:	ff cf       	rjmp	.-2      	; 0x298a <__stop_program>
