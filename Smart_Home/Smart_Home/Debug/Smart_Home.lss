
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002da6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000006e4  00800060  00002da6  00002e3a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000ba  00800744  00800744  0000351e  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000351e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000357c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000598  00000000  00000000  000035b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006822  00000000  00000000  00003b50  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001876  00000000  00000000  0000a372  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003fee  00000000  00000000  0000bbe8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000dac  00000000  00000000  0000fbd8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001433  00000000  00000000  00010984  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000357e  00000000  00000000  00011db7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000468  00000000  00000000  00015335  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 84 00 	jmp	0x108	; 0x108 <__ctors_end>
       4:	0c 94 09 0f 	jmp	0x1e12	; 0x1e12 <__vector_1>
       8:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
       c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      10:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      14:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      18:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      1c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      20:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      24:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      28:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      2c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      30:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      34:	0c 94 92 0e 	jmp	0x1d24	; 0x1d24 <__vector_13>
      38:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      3c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      40:	0c 94 2d 0f 	jmp	0x1e5a	; 0x1e5a <__vector_16>
      44:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      48:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      4c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      50:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      54:	20 06       	cpc	r2, r16
      56:	34 06       	cpc	r3, r20
      58:	34 06       	cpc	r3, r20
      5a:	34 06       	cpc	r3, r20
      5c:	34 06       	cpc	r3, r20
      5e:	34 06       	cpc	r3, r20
      60:	34 06       	cpc	r3, r20
      62:	34 06       	cpc	r3, r20
      64:	36 06       	cpc	r3, r22
      66:	34 06       	cpc	r3, r20
      68:	34 06       	cpc	r3, r20
      6a:	34 06       	cpc	r3, r20
      6c:	34 06       	cpc	r3, r20
      6e:	34 06       	cpc	r3, r20
      70:	34 06       	cpc	r3, r20
      72:	34 06       	cpc	r3, r20
      74:	22 06       	cpc	r2, r18
      76:	34 06       	cpc	r3, r20
      78:	34 06       	cpc	r3, r20
      7a:	34 06       	cpc	r3, r20
      7c:	34 06       	cpc	r3, r20
      7e:	34 06       	cpc	r3, r20
      80:	34 06       	cpc	r3, r20
      82:	34 06       	cpc	r3, r20
      84:	24 06       	cpc	r2, r20
      86:	34 06       	cpc	r3, r20
      88:	34 06       	cpc	r3, r20
      8a:	34 06       	cpc	r3, r20
      8c:	34 06       	cpc	r3, r20
      8e:	34 06       	cpc	r3, r20
      90:	34 06       	cpc	r3, r20
      92:	34 06       	cpc	r3, r20
      94:	26 06       	cpc	r2, r22
      96:	34 06       	cpc	r3, r20
      98:	34 06       	cpc	r3, r20
      9a:	34 06       	cpc	r3, r20
      9c:	34 06       	cpc	r3, r20
      9e:	34 06       	cpc	r3, r20
      a0:	34 06       	cpc	r3, r20
      a2:	34 06       	cpc	r3, r20
      a4:	28 06       	cpc	r2, r24
      a6:	34 06       	cpc	r3, r20
      a8:	34 06       	cpc	r3, r20
      aa:	34 06       	cpc	r3, r20
      ac:	34 06       	cpc	r3, r20
      ae:	34 06       	cpc	r3, r20
      b0:	34 06       	cpc	r3, r20
      b2:	34 06       	cpc	r3, r20
      b4:	2a 06       	cpc	r2, r26
      b6:	34 06       	cpc	r3, r20
      b8:	34 06       	cpc	r3, r20
      ba:	34 06       	cpc	r3, r20
      bc:	34 06       	cpc	r3, r20
      be:	34 06       	cpc	r3, r20
      c0:	34 06       	cpc	r3, r20
      c2:	34 06       	cpc	r3, r20
      c4:	2c 06       	cpc	r2, r28
      c6:	34 06       	cpc	r3, r20
      c8:	34 06       	cpc	r3, r20
      ca:	34 06       	cpc	r3, r20
      cc:	34 06       	cpc	r3, r20
      ce:	34 06       	cpc	r3, r20
      d0:	34 06       	cpc	r3, r20
      d2:	34 06       	cpc	r3, r20
      d4:	2e 06       	cpc	r2, r30
      d6:	34 06       	cpc	r3, r20
      d8:	34 06       	cpc	r3, r20
      da:	34 06       	cpc	r3, r20
      dc:	34 06       	cpc	r3, r20
      de:	34 06       	cpc	r3, r20
      e0:	34 06       	cpc	r3, r20
      e2:	34 06       	cpc	r3, r20
      e4:	30 06       	cpc	r3, r16
      e6:	34 06       	cpc	r3, r20
      e8:	34 06       	cpc	r3, r20
      ea:	34 06       	cpc	r3, r20
      ec:	34 06       	cpc	r3, r20
      ee:	34 06       	cpc	r3, r20
      f0:	34 06       	cpc	r3, r20
      f2:	34 06       	cpc	r3, r20
      f4:	32 06       	cpc	r3, r18
      f6:	f0 07       	cpc	r31, r16
      f8:	f7 07       	cpc	r31, r23
      fa:	fe 07       	cpc	r31, r30
      fc:	05 08       	sbc	r0, r5
      fe:	0c 08       	sbc	r0, r12
     100:	13 08       	sbc	r1, r3
     102:	1a 08       	sbc	r1, r10
     104:	21 08       	sbc	r2, r1
     106:	28 08       	sbc	r2, r8

00000108 <__ctors_end>:
     108:	11 24       	eor	r1, r1
     10a:	1f be       	out	0x3f, r1	; 63
     10c:	cf e5       	ldi	r28, 0x5F	; 95
     10e:	d8 e0       	ldi	r29, 0x08	; 8
     110:	de bf       	out	0x3e, r29	; 62
     112:	cd bf       	out	0x3d, r28	; 61

00000114 <__do_copy_data>:
     114:	17 e0       	ldi	r17, 0x07	; 7
     116:	a0 e6       	ldi	r26, 0x60	; 96
     118:	b0 e0       	ldi	r27, 0x00	; 0
     11a:	e6 ea       	ldi	r30, 0xA6	; 166
     11c:	fd e2       	ldi	r31, 0x2D	; 45
     11e:	02 c0       	rjmp	.+4      	; 0x124 <__do_copy_data+0x10>
     120:	05 90       	lpm	r0, Z+
     122:	0d 92       	st	X+, r0
     124:	a4 34       	cpi	r26, 0x44	; 68
     126:	b1 07       	cpc	r27, r17
     128:	d9 f7       	brne	.-10     	; 0x120 <__do_copy_data+0xc>

0000012a <__do_clear_bss>:
     12a:	27 e0       	ldi	r18, 0x07	; 7
     12c:	a4 e4       	ldi	r26, 0x44	; 68
     12e:	b7 e0       	ldi	r27, 0x07	; 7
     130:	01 c0       	rjmp	.+2      	; 0x134 <.do_clear_bss_start>

00000132 <.do_clear_bss_loop>:
     132:	1d 92       	st	X+, r1

00000134 <.do_clear_bss_start>:
     134:	ae 3f       	cpi	r26, 0xFE	; 254
     136:	b2 07       	cpc	r27, r18
     138:	e1 f7       	brne	.-8      	; 0x132 <.do_clear_bss_loop>
     13a:	0e 94 0f 04 	call	0x81e	; 0x81e <main>
     13e:	0c 94 d1 16 	jmp	0x2da2	; 0x2da2 <_exit>

00000142 <__bad_interrupt>:
     142:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000146 <Buzzer_on>:
  // Return error code to indicate that the buzzer initialization failed
  return BUZZER_ERROR_INIT;
  }

// Turn on the buzzer
EN_BuzzerError_t Buzzer_on(u8 buzzerPort, u8 buzzerPin) {
     146:	98 2f       	mov	r25, r24
     148:	86 2f       	mov	r24, r22
  if (DIO_write(buzzerPin, buzzerPort, HIGH) == DIO_OK) {
     14a:	41 e0       	ldi	r20, 0x01	; 1
     14c:	69 2f       	mov	r22, r25
     14e:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
     152:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that attempting to turn on the buzzer has failed
  return BUZZER_ERROR_ON;
     154:	82 e0       	ldi	r24, 0x02	; 2
  }
     156:	08 95       	ret

00000158 <EEPROM_init>:
 */

#include "eeprom.h"

void EEPROM_init() {
  I2C_init();
     158:	0e 94 38 06 	call	0xc70	; 0xc70 <I2C_init>
     15c:	08 95       	ret

0000015e <EEPROM_read_byte>:
  }

void EEPROM_read_byte(u8 page, u8 address, s8* data) {
     15e:	0f 93       	push	r16
     160:	1f 93       	push	r17
     162:	cf 93       	push	r28
     164:	df 93       	push	r29
     166:	c8 2f       	mov	r28, r24
     168:	d6 2f       	mov	r29, r22
     16a:	8a 01       	movw	r16, r20
  I2C_start();
     16c:	0e 94 3c 06 	call	0xc78	; 0xc78 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     170:	cc 0f       	add	r28, r28
     172:	80 ea       	ldi	r24, 0xA0	; 160
     174:	8c 0f       	add	r24, r28
     176:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  I2C_write(address);
     17a:	8d 2f       	mov	r24, r29
     17c:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  I2C_start();
     180:	0e 94 3c 06 	call	0xc78	; 0xc78 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     184:	81 ea       	ldi	r24, 0xA1	; 161
     186:	8c 0f       	add	r24, r28
     188:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  // read_Ack will halt the reading here, because it will send the next byte, which will not be received and wait for ack, which will not be sent. 
  // Nack must be sent after the arrival of the last requested byte. It's used basically to indicate that no further data transmission is required and then the stop condition is sent
  I2C_read_Nack(data);
     18c:	c8 01       	movw	r24, r16
     18e:	0e 94 58 06 	call	0xcb0	; 0xcb0 <I2C_read_Nack>
  I2C_stop();
     192:	0e 94 63 06 	call	0xcc6	; 0xcc6 <I2C_stop>
  }
     196:	df 91       	pop	r29
     198:	cf 91       	pop	r28
     19a:	1f 91       	pop	r17
     19c:	0f 91       	pop	r16
     19e:	08 95       	ret

000001a0 <EEPROM_read_block>:

void EEPROM_read_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     1a0:	ef 92       	push	r14
     1a2:	ff 92       	push	r15
     1a4:	0f 93       	push	r16
     1a6:	1f 93       	push	r17
     1a8:	cf 93       	push	r28
     1aa:	df 93       	push	r29
     1ac:	c8 2f       	mov	r28, r24
     1ae:	d6 2f       	mov	r29, r22
     1b0:	7a 01       	movw	r14, r20
     1b2:	89 01       	movw	r16, r18
  u16 i;
  for (i = 0;i < bytes_number;i++) {
    EEPROM_read_byte(page, address + i, &data[i]);
    }
#elif READ_BLOCK_METHOD == MULTIBYTE
  I2C_start();
     1b4:	0e 94 3c 06 	call	0xc78	; 0xc78 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     1b8:	cc 0f       	add	r28, r28
     1ba:	80 ea       	ldi	r24, 0xA0	; 160
     1bc:	8c 0f       	add	r24, r28
     1be:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  I2C_write(address);
     1c2:	8d 2f       	mov	r24, r29
     1c4:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  I2C_start();
     1c8:	0e 94 3c 06 	call	0xc78	; 0xc78 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     1cc:	81 ea       	ldi	r24, 0xA1	; 161
     1ce:	8c 0f       	add	r24, r28
     1d0:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1d4:	c0 e0       	ldi	r28, 0x00	; 0
     1d6:	d0 e0       	ldi	r29, 0x00	; 0
     1d8:	06 c0       	rjmp	.+12     	; 0x1e6 <EEPROM_read_block+0x46>
    I2C_read_Ack(&data[i]);
     1da:	c8 01       	movw	r24, r16
     1dc:	8c 0f       	add	r24, r28
     1de:	9d 1f       	adc	r25, r29
     1e0:	0e 94 4d 06 	call	0xc9a	; 0xc9a <I2C_read_Ack>
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  I2C_start();
  I2C_write(0xA0 + (page << 1) + 1);
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1e4:	21 96       	adiw	r28, 0x01	; 1
     1e6:	c7 01       	movw	r24, r14
     1e8:	01 97       	sbiw	r24, 0x01	; 1
     1ea:	c8 17       	cp	r28, r24
     1ec:	d9 07       	cpc	r29, r25
     1ee:	a8 f3       	brcs	.-22     	; 0x1da <EEPROM_read_block+0x3a>
    I2C_read_Ack(&data[i]);
    }
  I2C_read_Nack(&data[i]);
     1f0:	c8 01       	movw	r24, r16
     1f2:	8c 0f       	add	r24, r28
     1f4:	9d 1f       	adc	r25, r29
     1f6:	0e 94 58 06 	call	0xcb0	; 0xcb0 <I2C_read_Nack>
  I2C_stop();
     1fa:	0e 94 63 06 	call	0xcc6	; 0xcc6 <I2C_stop>
#endif
  }
     1fe:	df 91       	pop	r29
     200:	cf 91       	pop	r28
     202:	1f 91       	pop	r17
     204:	0f 91       	pop	r16
     206:	ff 90       	pop	r15
     208:	ef 90       	pop	r14
     20a:	08 95       	ret

0000020c <EEPROM_write_byte>:

void EEPROM_write_byte(u8 page, u8 address, s8 data) {
     20c:	1f 93       	push	r17
     20e:	cf 93       	push	r28
     210:	df 93       	push	r29
     212:	c8 2f       	mov	r28, r24
     214:	16 2f       	mov	r17, r22
     216:	d4 2f       	mov	r29, r20
  I2C_start();
     218:	0e 94 3c 06 	call	0xc78	; 0xc78 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     21c:	8c 2f       	mov	r24, r28
     21e:	88 0f       	add	r24, r24
     220:	80 56       	subi	r24, 0x60	; 96
     222:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  I2C_write(address);
     226:	81 2f       	mov	r24, r17
     228:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  I2C_write(data);
     22c:	8d 2f       	mov	r24, r29
     22e:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  I2C_stop();
     232:	0e 94 63 06 	call	0xcc6	; 0xcc6 <I2C_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     236:	8f e3       	ldi	r24, 0x3F	; 63
     238:	9c e9       	ldi	r25, 0x9C	; 156
     23a:	01 97       	sbiw	r24, 0x01	; 1
     23c:	f1 f7       	brne	.-4      	; 0x23a <EEPROM_write_byte+0x2e>
     23e:	00 c0       	rjmp	.+0      	; 0x240 <EEPROM_write_byte+0x34>
     240:	00 00       	nop

#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
  }
     242:	df 91       	pop	r29
     244:	cf 91       	pop	r28
     246:	1f 91       	pop	r17
     248:	08 95       	ret

0000024a <EEPROM_write_block>:

// bytes_number must be within page size (256 bytes)
void EEPROM_write_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     24a:	6f 92       	push	r6
     24c:	7f 92       	push	r7
     24e:	8f 92       	push	r8
     250:	9f 92       	push	r9
     252:	af 92       	push	r10
     254:	bf 92       	push	r11
     256:	cf 92       	push	r12
     258:	df 92       	push	r13
     25a:	ef 92       	push	r14
     25c:	ff 92       	push	r15
     25e:	0f 93       	push	r16
     260:	1f 93       	push	r17
     262:	cf 93       	push	r28
     264:	df 93       	push	r29
     266:	78 2e       	mov	r7, r24
     268:	66 2e       	mov	r6, r22
     26a:	6a 01       	movw	r12, r20
     26c:	89 01       	movw	r16, r18
  //! If data is required to be written in the first 16 bytes starting from byte 10 for example, the data will be stored starting from bytes 10, 
  //! and if the data exceeds the row limit ** IT WILL ROLL OVER AND OVERWRITE THE ROW **. Therefore, in a single multibyte write cycle, we can't write more than 16 bytes at maximum if starting from the first byte in the row
  //! or the remaining bytes till the end of the row from the starting position. The remaining bytes must be written in another write cycle to avoind the roll over problem.

  u16 dataIndex, blockNumber, i;
  u16 first_block_size = 16 - (address % 16);
     26e:	86 2f       	mov	r24, r22
     270:	8f 70       	andi	r24, 0x0F	; 15
     272:	20 e1       	ldi	r18, 0x10	; 16
     274:	30 e0       	ldi	r19, 0x00	; 0
     276:	79 01       	movw	r14, r18
     278:	e8 1a       	sub	r14, r24
     27a:	f1 08       	sbc	r15, r1
  if (16 - (address % 16) > bytes_number) first_block_size = bytes_number;
     27c:	4e 15       	cp	r20, r14
     27e:	5f 05       	cpc	r21, r15
     280:	08 f4       	brcc	.+2      	; 0x284 <EEPROM_write_block+0x3a>
     282:	7a 01       	movw	r14, r20

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
     284:	0e 94 3c 06 	call	0xc78	; 0xc78 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     288:	87 2d       	mov	r24, r7
     28a:	88 0f       	add	r24, r24
     28c:	0f 2e       	mov	r0, r31
     28e:	f0 ea       	ldi	r31, 0xA0	; 160
     290:	7f 2e       	mov	r7, r31
     292:	f0 2d       	mov	r31, r0
     294:	78 0e       	add	r7, r24
     296:	87 2d       	mov	r24, r7
     298:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  I2C_write(address);
     29c:	86 2d       	mov	r24, r6
     29e:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2a2:	c0 e0       	ldi	r28, 0x00	; 0
     2a4:	d0 e0       	ldi	r29, 0x00	; 0
     2a6:	07 c0       	rjmp	.+14     	; 0x2b6 <EEPROM_write_block+0x6c>
    I2C_write(data[dataIndex]);
     2a8:	f8 01       	movw	r30, r16
     2aa:	ec 0f       	add	r30, r28
     2ac:	fd 1f       	adc	r31, r29
     2ae:	80 81       	ld	r24, Z
     2b0:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2b4:	21 96       	adiw	r28, 0x01	; 1
     2b6:	ce 15       	cp	r28, r14
     2b8:	df 05       	cpc	r29, r15
     2ba:	b0 f3       	brcs	.-20     	; 0x2a8 <EEPROM_write_block+0x5e>
    I2C_write(data[dataIndex]);
    }
  I2C_stop();
     2bc:	0e 94 63 06 	call	0xcc6	; 0xcc6 <I2C_stop>
     2c0:	8f e3       	ldi	r24, 0x3F	; 63
     2c2:	9c e9       	ldi	r25, 0x9C	; 156
     2c4:	01 97       	sbiw	r24, 0x01	; 1
     2c6:	f1 f7       	brne	.-4      	; 0x2c4 <EEPROM_write_block+0x7a>
     2c8:	00 c0       	rjmp	.+0      	; 0x2ca <EEPROM_write_block+0x80>
     2ca:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif

  // Return if the data fits in the row (data fits in a single row or the remaining part of it after the address)
  if (first_block_size == bytes_number) return;
     2cc:	ec 14       	cp	r14, r12
     2ce:	fd 04       	cpc	r15, r13
     2d0:	09 f4       	brne	.+2      	; 0x2d4 <EEPROM_write_block+0x8a>
     2d2:	61 c0       	rjmp	.+194    	; 0x396 <EEPROM_write_block+0x14c>

  u16 last_block_size = (address + bytes_number) % 16;
     2d4:	56 01       	movw	r10, r12
     2d6:	a6 0c       	add	r10, r6
     2d8:	b1 1c       	adc	r11, r1
     2da:	9f e0       	ldi	r25, 0x0F	; 15
     2dc:	a9 22       	and	r10, r25
     2de:	bb 24       	eor	r11, r11
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
     2e0:	ce 18       	sub	r12, r14
     2e2:	df 08       	sbc	r13, r15
     2e4:	ca 18       	sub	r12, r10
     2e6:	db 08       	sbc	r13, r11
     2e8:	d6 94       	lsr	r13
     2ea:	c7 94       	ror	r12
     2ec:	d6 94       	lsr	r13
     2ee:	c7 94       	ror	r12
     2f0:	d6 94       	lsr	r13
     2f2:	c7 94       	ror	r12
     2f4:	d6 94       	lsr	r13
     2f6:	c7 94       	ror	r12
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     2f8:	e1 2c       	mov	r14, r1
     2fa:	f1 2c       	mov	r15, r1
     2fc:	27 c0       	rjmp	.+78     	; 0x34c <EEPROM_write_block+0x102>
    I2C_start();
     2fe:	0e 94 3c 06 	call	0xc78	; 0xc78 <I2C_start>
    I2C_write(0xA0 + (page << 1));
     302:	87 2d       	mov	r24, r7
     304:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
    I2C_write(address + dataIndex);
     308:	8c 2f       	mov	r24, r28
     30a:	86 0d       	add	r24, r6
     30c:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
    for (i = 0;i < 16;i++) {
     310:	81 2c       	mov	r8, r1
     312:	91 2c       	mov	r9, r1
     314:	0b c0       	rjmp	.+22     	; 0x32c <EEPROM_write_block+0xe2>
      I2C_write(data[dataIndex + i]);
     316:	fe 01       	movw	r30, r28
     318:	e8 0d       	add	r30, r8
     31a:	f9 1d       	adc	r31, r9
     31c:	e0 0f       	add	r30, r16
     31e:	f1 1f       	adc	r31, r17
     320:	80 81       	ld	r24, Z
     322:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
    I2C_start();
    I2C_write(0xA0 + (page << 1));
    I2C_write(address + dataIndex);
    for (i = 0;i < 16;i++) {
     326:	8f ef       	ldi	r24, 0xFF	; 255
     328:	88 1a       	sub	r8, r24
     32a:	98 0a       	sbc	r9, r24
     32c:	90 e1       	ldi	r25, 0x10	; 16
     32e:	89 16       	cp	r8, r25
     330:	91 04       	cpc	r9, r1
     332:	88 f3       	brcs	.-30     	; 0x316 <EEPROM_write_block+0xcc>
      I2C_write(data[dataIndex + i]);
      }
    dataIndex += 16;
     334:	60 96       	adiw	r28, 0x10	; 16
    I2C_stop();
     336:	0e 94 63 06 	call	0xcc6	; 0xcc6 <I2C_stop>
     33a:	8f e3       	ldi	r24, 0x3F	; 63
     33c:	9c e9       	ldi	r25, 0x9C	; 156
     33e:	01 97       	sbiw	r24, 0x01	; 1
     340:	f1 f7       	brne	.-4      	; 0x33e <EEPROM_write_block+0xf4>
     342:	00 c0       	rjmp	.+0      	; 0x344 <EEPROM_write_block+0xfa>
     344:	00 00       	nop
  if (first_block_size == bytes_number) return;

  u16 last_block_size = (address + bytes_number) % 16;
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     346:	9f ef       	ldi	r25, 0xFF	; 255
     348:	e9 1a       	sub	r14, r25
     34a:	f9 0a       	sbc	r15, r25
     34c:	ec 14       	cp	r14, r12
     34e:	fd 04       	cpc	r15, r13
     350:	b0 f2       	brcs	.-84     	; 0x2fe <EEPROM_write_block+0xb4>
    _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
    }

  // Write the last part of the data
  I2C_start();
     352:	0e 94 3c 06 	call	0xc78	; 0xc78 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     356:	87 2d       	mov	r24, r7
     358:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  I2C_write(address + dataIndex);
     35c:	8c 2f       	mov	r24, r28
     35e:	86 0d       	add	r24, r6
     360:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>
  for (i = 0;i < last_block_size;i++) {
     364:	e1 2c       	mov	r14, r1
     366:	f1 2c       	mov	r15, r1
     368:	0b c0       	rjmp	.+22     	; 0x380 <EEPROM_write_block+0x136>
    I2C_write(data[dataIndex + i]);
     36a:	fe 01       	movw	r30, r28
     36c:	ee 0d       	add	r30, r14
     36e:	ff 1d       	adc	r31, r15
     370:	e0 0f       	add	r30, r16
     372:	f1 1f       	adc	r31, r17
     374:	80 81       	ld	r24, Z
     376:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_write>

  // Write the last part of the data
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address + dataIndex);
  for (i = 0;i < last_block_size;i++) {
     37a:	8f ef       	ldi	r24, 0xFF	; 255
     37c:	e8 1a       	sub	r14, r24
     37e:	f8 0a       	sbc	r15, r24
     380:	ea 14       	cp	r14, r10
     382:	fb 04       	cpc	r15, r11
     384:	90 f3       	brcs	.-28     	; 0x36a <EEPROM_write_block+0x120>
    I2C_write(data[dataIndex + i]);
    }
  I2C_stop();
     386:	0e 94 63 06 	call	0xcc6	; 0xcc6 <I2C_stop>
     38a:	8f e3       	ldi	r24, 0x3F	; 63
     38c:	9c e9       	ldi	r25, 0x9C	; 156
     38e:	01 97       	sbiw	r24, 0x01	; 1
     390:	f1 f7       	brne	.-4      	; 0x38e <EEPROM_write_block+0x144>
     392:	00 c0       	rjmp	.+0      	; 0x394 <EEPROM_write_block+0x14a>
     394:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
#endif
     396:	df 91       	pop	r29
     398:	cf 91       	pop	r28
     39a:	1f 91       	pop	r17
     39c:	0f 91       	pop	r16
     39e:	ff 90       	pop	r15
     3a0:	ef 90       	pop	r14
     3a2:	df 90       	pop	r13
     3a4:	cf 90       	pop	r12
     3a6:	bf 90       	pop	r11
     3a8:	af 90       	pop	r10
     3aa:	9f 90       	pop	r9
     3ac:	8f 90       	pop	r8
     3ae:	7f 90       	pop	r7
     3b0:	6f 90       	pop	r6
     3b2:	08 95       	ret

000003b4 <BT_sendChar>:
  DIO_init(HC_05_STATUS_PIN, HC_05_STATUS_PORT, IN);
  UART_init(baudRate);
  }

void BT_sendChar(s8 data) {
  UART_sendChar(data);
     3b4:	0e 94 04 07 	call	0xe08	; 0xe08 <UART_sendChar>
     3b8:	08 95       	ret

000003ba <BT_sendString>:
  }

void BT_sendString(s8* str) {
  UART_sendString(str);
     3ba:	0e 94 0a 07 	call	0xe14	; 0xe14 <UART_sendString>
     3be:	08 95       	ret

000003c0 <Keypad_init>:

#include "keypad.h"

EN_KeypadStatusCode_t Keypad_init(void) {
  // Set rows as outputs
  DIO_init(KEYPAD_R0_PIN, KEYPAD_PORT, OUT);
     3c0:	41 e0       	ldi	r20, 0x01	; 1
     3c2:	62 e4       	ldi	r22, 0x42	; 66
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  DIO_init(KEYPAD_R1_PIN, KEYPAD_PORT, OUT);
     3ca:	41 e0       	ldi	r20, 0x01	; 1
     3cc:	62 e4       	ldi	r22, 0x42	; 66
     3ce:	81 e0       	ldi	r24, 0x01	; 1
     3d0:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  DIO_init(KEYPAD_R2_PIN, KEYPAD_PORT, OUT);
     3d4:	41 e0       	ldi	r20, 0x01	; 1
     3d6:	62 e4       	ldi	r22, 0x42	; 66
     3d8:	82 e0       	ldi	r24, 0x02	; 2
     3da:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  DIO_init(KEYPAD_R3_PIN, KEYPAD_PORT, OUT);
     3de:	41 e0       	ldi	r20, 0x01	; 1
     3e0:	62 e4       	ldi	r22, 0x42	; 66
     3e2:	83 e0       	ldi	r24, 0x03	; 3
     3e4:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  // Set all high
  DIO_write(KEYPAD_R0_PIN, KEYPAD_PORT, HIGH);
     3e8:	41 e0       	ldi	r20, 0x01	; 1
     3ea:	62 e4       	ldi	r22, 0x42	; 66
     3ec:	80 e0       	ldi	r24, 0x00	; 0
     3ee:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  DIO_write(KEYPAD_R1_PIN, KEYPAD_PORT, HIGH);
     3f2:	41 e0       	ldi	r20, 0x01	; 1
     3f4:	62 e4       	ldi	r22, 0x42	; 66
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  DIO_write(KEYPAD_R2_PIN, KEYPAD_PORT, HIGH);
     3fc:	41 e0       	ldi	r20, 0x01	; 1
     3fe:	62 e4       	ldi	r22, 0x42	; 66
     400:	82 e0       	ldi	r24, 0x02	; 2
     402:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  DIO_write(KEYPAD_R3_PIN, KEYPAD_PORT, HIGH);
     406:	41 e0       	ldi	r20, 0x01	; 1
     408:	62 e4       	ldi	r22, 0x42	; 66
     40a:	83 e0       	ldi	r24, 0x03	; 3
     40c:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  // Set columns as inputs
  DIO_init(KEYPAD_C0_PIN, KEYPAD_PORT, IN);
     410:	40 e0       	ldi	r20, 0x00	; 0
     412:	62 e4       	ldi	r22, 0x42	; 66
     414:	84 e0       	ldi	r24, 0x04	; 4
     416:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  DIO_init(KEYPAD_C1_PIN, KEYPAD_PORT, IN);
     41a:	40 e0       	ldi	r20, 0x00	; 0
     41c:	62 e4       	ldi	r22, 0x42	; 66
     41e:	85 e0       	ldi	r24, 0x05	; 5
     420:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  DIO_init(KEYPAD_C2_PIN, KEYPAD_PORT, IN);
     424:	40 e0       	ldi	r20, 0x00	; 0
     426:	62 e4       	ldi	r22, 0x42	; 66
     428:	86 e0       	ldi	r24, 0x06	; 6
     42a:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  DIO_init(KEYPAD_C3_PIN, KEYPAD_PORT, IN);
     42e:	40 e0       	ldi	r20, 0x00	; 0
     430:	62 e4       	ldi	r22, 0x42	; 66
     432:	87 e0       	ldi	r24, 0x07	; 7
     434:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  // Activate the pull up resistors
  DIO_write(KEYPAD_C0_PIN, KEYPAD_PORT, HIGH);
     438:	41 e0       	ldi	r20, 0x01	; 1
     43a:	62 e4       	ldi	r22, 0x42	; 66
     43c:	84 e0       	ldi	r24, 0x04	; 4
     43e:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  DIO_write(KEYPAD_C1_PIN, KEYPAD_PORT, HIGH);
     442:	41 e0       	ldi	r20, 0x01	; 1
     444:	62 e4       	ldi	r22, 0x42	; 66
     446:	85 e0       	ldi	r24, 0x05	; 5
     448:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  DIO_write(KEYPAD_C2_PIN, KEYPAD_PORT, HIGH);
     44c:	41 e0       	ldi	r20, 0x01	; 1
     44e:	62 e4       	ldi	r22, 0x42	; 66
     450:	86 e0       	ldi	r24, 0x06	; 6
     452:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  DIO_write(KEYPAD_C3_PIN, KEYPAD_PORT, HIGH);
     456:	41 e0       	ldi	r20, 0x01	; 1
     458:	62 e4       	ldi	r22, 0x42	; 66
     45a:	87 e0       	ldi	r24, 0x07	; 7
     45c:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>

  return KEYPAD_INIT_OK;
  }
     460:	80 e0       	ldi	r24, 0x00	; 0
     462:	08 95       	ret

00000464 <toggle_row>:

void toggle_row(u8 row) {
  switch (row) {
     464:	81 30       	cpi	r24, 0x01	; 1
     466:	59 f0       	breq	.+22     	; 0x47e <toggle_row+0x1a>
     468:	28 f0       	brcs	.+10     	; 0x474 <toggle_row+0x10>
     46a:	82 30       	cpi	r24, 0x02	; 2
     46c:	69 f0       	breq	.+26     	; 0x488 <toggle_row+0x24>
     46e:	83 30       	cpi	r24, 0x03	; 3
     470:	81 f0       	breq	.+32     	; 0x492 <toggle_row+0x2e>
     472:	08 95       	ret
      case 0:
        DIO_toggle(KEYPAD_R0_PIN, KEYPAD_PORT);
     474:	62 e4       	ldi	r22, 0x42	; 66
     476:	80 e0       	ldi	r24, 0x00	; 0
     478:	0e 94 c1 05 	call	0xb82	; 0xb82 <DIO_toggle>
        break;
     47c:	08 95       	ret
      case 1:
        DIO_toggle(KEYPAD_R1_PIN, KEYPAD_PORT);
     47e:	62 e4       	ldi	r22, 0x42	; 66
     480:	81 e0       	ldi	r24, 0x01	; 1
     482:	0e 94 c1 05 	call	0xb82	; 0xb82 <DIO_toggle>
        break;
     486:	08 95       	ret
      case 2:
        DIO_toggle(KEYPAD_R2_PIN, KEYPAD_PORT);
     488:	62 e4       	ldi	r22, 0x42	; 66
     48a:	82 e0       	ldi	r24, 0x02	; 2
     48c:	0e 94 c1 05 	call	0xb82	; 0xb82 <DIO_toggle>
        break;
     490:	08 95       	ret
      case 3:
        DIO_toggle(KEYPAD_R3_PIN, KEYPAD_PORT);
     492:	62 e4       	ldi	r22, 0x42	; 66
     494:	83 e0       	ldi	r24, 0x03	; 3
     496:	0e 94 c1 05 	call	0xb82	; 0xb82 <DIO_toggle>
     49a:	08 95       	ret

0000049c <check_col>:
        break;
    }
  }

void check_col(u8 col, u8* res) {
  switch (col) {
     49c:	81 30       	cpi	r24, 0x01	; 1
     49e:	61 f0       	breq	.+24     	; 0x4b8 <check_col+0x1c>
     4a0:	28 f0       	brcs	.+10     	; 0x4ac <check_col+0x10>
     4a2:	82 30       	cpi	r24, 0x02	; 2
     4a4:	79 f0       	breq	.+30     	; 0x4c4 <check_col+0x28>
     4a6:	83 30       	cpi	r24, 0x03	; 3
     4a8:	99 f0       	breq	.+38     	; 0x4d0 <check_col+0x34>
     4aa:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_C0_PIN, KEYPAD_PORT, res);
     4ac:	ab 01       	movw	r20, r22
     4ae:	62 e4       	ldi	r22, 0x42	; 66
     4b0:	84 e0       	ldi	r24, 0x04	; 4
     4b2:	0e 94 6b 05 	call	0xad6	; 0xad6 <DIO_Read>
        break;
     4b6:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_C1_PIN, KEYPAD_PORT, res);
     4b8:	ab 01       	movw	r20, r22
     4ba:	62 e4       	ldi	r22, 0x42	; 66
     4bc:	85 e0       	ldi	r24, 0x05	; 5
     4be:	0e 94 6b 05 	call	0xad6	; 0xad6 <DIO_Read>
        break;
     4c2:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_C2_PIN, KEYPAD_PORT, res);
     4c4:	ab 01       	movw	r20, r22
     4c6:	62 e4       	ldi	r22, 0x42	; 66
     4c8:	86 e0       	ldi	r24, 0x06	; 6
     4ca:	0e 94 6b 05 	call	0xad6	; 0xad6 <DIO_Read>
        break;
     4ce:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_C3_PIN, KEYPAD_PORT, res);
     4d0:	ab 01       	movw	r20, r22
     4d2:	62 e4       	ldi	r22, 0x42	; 66
     4d4:	87 e0       	ldi	r24, 0x07	; 7
     4d6:	0e 94 6b 05 	call	0xad6	; 0xad6 <DIO_Read>
     4da:	08 95       	ret

000004dc <check_row>:
        break;
    }
  }

void check_row(u8 row, u8* res) {
  switch (row) {
     4dc:	81 30       	cpi	r24, 0x01	; 1
     4de:	61 f0       	breq	.+24     	; 0x4f8 <check_row+0x1c>
     4e0:	28 f0       	brcs	.+10     	; 0x4ec <check_row+0x10>
     4e2:	82 30       	cpi	r24, 0x02	; 2
     4e4:	79 f0       	breq	.+30     	; 0x504 <check_row+0x28>
     4e6:	83 30       	cpi	r24, 0x03	; 3
     4e8:	99 f0       	breq	.+38     	; 0x510 <check_row+0x34>
     4ea:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_R0_PIN, KEYPAD_PORT, res);
     4ec:	ab 01       	movw	r20, r22
     4ee:	62 e4       	ldi	r22, 0x42	; 66
     4f0:	80 e0       	ldi	r24, 0x00	; 0
     4f2:	0e 94 6b 05 	call	0xad6	; 0xad6 <DIO_Read>
        break;
     4f6:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_R1_PIN, KEYPAD_PORT, res);
     4f8:	ab 01       	movw	r20, r22
     4fa:	62 e4       	ldi	r22, 0x42	; 66
     4fc:	81 e0       	ldi	r24, 0x01	; 1
     4fe:	0e 94 6b 05 	call	0xad6	; 0xad6 <DIO_Read>
        break;
     502:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_R2_PIN, KEYPAD_PORT, res);
     504:	ab 01       	movw	r20, r22
     506:	62 e4       	ldi	r22, 0x42	; 66
     508:	82 e0       	ldi	r24, 0x02	; 2
     50a:	0e 94 6b 05 	call	0xad6	; 0xad6 <DIO_Read>
        break;
     50e:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_R3_PIN, KEYPAD_PORT, res);
     510:	ab 01       	movw	r20, r22
     512:	62 e4       	ldi	r22, 0x42	; 66
     514:	83 e0       	ldi	r24, 0x03	; 3
     516:	0e 94 6b 05 	call	0xad6	; 0xad6 <DIO_Read>
     51a:	08 95       	ret

0000051c <Keypad_getPressedKey>:
        break;
    }
  }

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
     51c:	ef 92       	push	r14
     51e:	ff 92       	push	r15
     520:	0f 93       	push	r16
     522:	1f 93       	push	r17
     524:	cf 93       	push	r28
     526:	df 93       	push	r29
     528:	cd b7       	in	r28, 0x3d	; 61
     52a:	de b7       	in	r29, 0x3e	; 62
     52c:	62 97       	sbiw	r28, 0x12	; 18
     52e:	0f b6       	in	r0, 0x3f	; 63
     530:	f8 94       	cli
     532:	de bf       	out	0x3e, r29	; 62
     534:	0f be       	out	0x3f, r0	; 63
     536:	cd bf       	out	0x3d, r28	; 61
     538:	7c 01       	movw	r14, r24
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
     53a:	80 e1       	ldi	r24, 0x10	; 16
     53c:	e1 e6       	ldi	r30, 0x61	; 97
     53e:	f0 e0       	ldi	r31, 0x00	; 0
     540:	de 01       	movw	r26, r28
     542:	11 96       	adiw	r26, 0x01	; 1
     544:	01 90       	ld	r0, Z+
     546:	0d 92       	st	X+, r0
     548:	8a 95       	dec	r24
     54a:	e1 f7       	brne	.-8      	; 0x544 <Keypad_getPressedKey+0x28>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     54c:	00 e0       	ldi	r16, 0x00	; 0
     54e:	1c c0       	rjmp	.+56     	; 0x588 <Keypad_getPressedKey+0x6c>
    check_row(row, &row_state);
     550:	be 01       	movw	r22, r28
     552:	6e 5e       	subi	r22, 0xEE	; 238
     554:	7f 4f       	sbci	r23, 0xFF	; 255
     556:	80 2f       	mov	r24, r16
     558:	0e 94 6e 02 	call	0x4dc	; 0x4dc <check_row>
    if (row_state == LOW) {
     55c:	8a 89       	ldd	r24, Y+18	; 0x12
     55e:	88 23       	and	r24, r24
     560:	61 f0       	breq	.+24     	; 0x57a <Keypad_getPressedKey+0x5e>
     562:	11 c0       	rjmp	.+34     	; 0x586 <Keypad_getPressedKey+0x6a>
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
     564:	be 01       	movw	r22, r28
     566:	6f 5e       	subi	r22, 0xEF	; 239
     568:	7f 4f       	sbci	r23, 0xFF	; 255
     56a:	81 2f       	mov	r24, r17
     56c:	0e 94 4e 02 	call	0x49c	; 0x49c <check_col>
        if (col_state == LOW) {
     570:	89 89       	ldd	r24, Y+17	; 0x11
     572:	88 23       	and	r24, r24
     574:	c9 f1       	breq	.+114    	; 0x5e8 <Keypad_getPressedKey+0xcc>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
     576:	1f 5f       	subi	r17, 0xFF	; 255
     578:	01 c0       	rjmp	.+2      	; 0x57c <Keypad_getPressedKey+0x60>
     57a:	10 e0       	ldi	r17, 0x00	; 0
     57c:	14 30       	cpi	r17, 0x04	; 4
     57e:	90 f3       	brcs	.-28     	; 0x564 <Keypad_getPressedKey+0x48>
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
          }
        }
      toggle_row(row);
     580:	80 2f       	mov	r24, r16
     582:	0e 94 32 02 	call	0x464	; 0x464 <toggle_row>

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     586:	0f 5f       	subi	r16, 0xFF	; 255
     588:	04 30       	cpi	r16, 0x04	; 4
     58a:	10 f3       	brcs	.-60     	; 0x550 <Keypad_getPressedKey+0x34>
     58c:	00 e0       	ldi	r16, 0x00	; 0
     58e:	28 c0       	rjmp	.+80     	; 0x5e0 <Keypad_getPressedKey+0xc4>
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
     590:	80 2f       	mov	r24, r16
     592:	0e 94 32 02 	call	0x464	; 0x464 <toggle_row>
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     596:	10 e0       	ldi	r17, 0x00	; 0
     598:	1d c0       	rjmp	.+58     	; 0x5d4 <Keypad_getPressedKey+0xb8>
      check_col(col, &col_state);
     59a:	be 01       	movw	r22, r28
     59c:	6f 5e       	subi	r22, 0xEF	; 239
     59e:	7f 4f       	sbci	r23, 0xFF	; 255
     5a0:	81 2f       	mov	r24, r17
     5a2:	0e 94 4e 02 	call	0x49c	; 0x49c <check_col>
      if (col_state == LOW) {
     5a6:	89 89       	ldd	r24, Y+17	; 0x11
     5a8:	81 11       	cpse	r24, r1
     5aa:	13 c0       	rjmp	.+38     	; 0x5d2 <Keypad_getPressedKey+0xb6>
        // while (col_state == LOW) {  // Wait until the key is released (busy waiting - halts the system)
        //   check_col(col, &col_state);
        //   }
        *key = keys[row][col];
     5ac:	e0 2f       	mov	r30, r16
     5ae:	f0 e0       	ldi	r31, 0x00	; 0
     5b0:	ee 0f       	add	r30, r30
     5b2:	ff 1f       	adc	r31, r31
     5b4:	ee 0f       	add	r30, r30
     5b6:	ff 1f       	adc	r31, r31
     5b8:	81 e0       	ldi	r24, 0x01	; 1
     5ba:	90 e0       	ldi	r25, 0x00	; 0
     5bc:	8c 0f       	add	r24, r28
     5be:	9d 1f       	adc	r25, r29
     5c0:	e8 0f       	add	r30, r24
     5c2:	f9 1f       	adc	r31, r25
     5c4:	e1 0f       	add	r30, r17
     5c6:	f1 1d       	adc	r31, r1
     5c8:	80 81       	ld	r24, Z
     5ca:	f7 01       	movw	r30, r14
     5cc:	80 83       	st	Z, r24
        return KEY_PRESSED;
     5ce:	81 e0       	ldi	r24, 0x01	; 1
     5d0:	0c c0       	rjmp	.+24     	; 0x5ea <Keypad_getPressedKey+0xce>
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     5d2:	1f 5f       	subi	r17, 0xFF	; 255
     5d4:	14 30       	cpi	r17, 0x04	; 4
     5d6:	08 f3       	brcs	.-62     	; 0x59a <Keypad_getPressedKey+0x7e>
        //   }
        *key = keys[row][col];
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
     5d8:	80 2f       	mov	r24, r16
     5da:	0e 94 32 02 	call	0x464	; 0x464 <toggle_row>
          }
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
     5de:	0f 5f       	subi	r16, 0xFF	; 255
     5e0:	04 30       	cpi	r16, 0x04	; 4
     5e2:	b0 f2       	brcs	.-84     	; 0x590 <Keypad_getPressedKey+0x74>
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     5e4:	82 e0       	ldi	r24, 0x02	; 2
     5e6:	01 c0       	rjmp	.+2      	; 0x5ea <Keypad_getPressedKey+0xce>
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
     5e8:	82 e0       	ldi	r24, 0x02	; 2
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     5ea:	62 96       	adiw	r28, 0x12	; 18
     5ec:	0f b6       	in	r0, 0x3f	; 63
     5ee:	f8 94       	cli
     5f0:	de bf       	out	0x3e, r29	; 62
     5f2:	0f be       	out	0x3f, r0	; 63
     5f4:	cd bf       	out	0x3d, r28	; 61
     5f6:	df 91       	pop	r29
     5f8:	cf 91       	pop	r28
     5fa:	1f 91       	pop	r17
     5fc:	0f 91       	pop	r16
     5fe:	ff 90       	pop	r15
     600:	ef 90       	pop	r14
     602:	08 95       	ret

00000604 <LCD_sendEnablePulse>:
#include "lcd.h"

 // TODO: implement the eight bit mode

void LCD_sendEnablePulse(void) {
  DIO_write(EN, LCD_CTRL_PORT, HIGH);
     604:	41 e0       	ldi	r20, 0x01	; 1
     606:	61 e4       	ldi	r22, 0x41	; 65
     608:	86 e0       	ldi	r24, 0x06	; 6
     60a:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     60e:	8a e1       	ldi	r24, 0x1A	; 26
     610:	8a 95       	dec	r24
     612:	f1 f7       	brne	.-4      	; 0x610 <LCD_sendEnablePulse+0xc>
     614:	00 c0       	rjmp	.+0      	; 0x616 <LCD_sendEnablePulse+0x12>
  _delay_us(5);
  DIO_write(EN, LCD_CTRL_PORT, LOW);
     616:	40 e0       	ldi	r20, 0x00	; 0
     618:	61 e4       	ldi	r22, 0x41	; 65
     61a:	86 e0       	ldi	r24, 0x06	; 6
     61c:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
     620:	08 95       	ret

00000622 <LCD_write_4bits>:
  }

void LCD_write_4bits(u8 data) {
     622:	cf 93       	push	r28
     624:	c8 2f       	mov	r28, r24
  DIO_write(LCD_DATA_PIN4, LCD_DATA_PORT, read_bit(data, 0));
     626:	48 2f       	mov	r20, r24
     628:	41 70       	andi	r20, 0x01	; 1
     62a:	61 e4       	ldi	r22, 0x41	; 65
     62c:	80 e0       	ldi	r24, 0x00	; 0
     62e:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  DIO_write(LCD_DATA_PIN5, LCD_DATA_PORT, read_bit(data, 1));
     632:	c1 fb       	bst	r28, 1
     634:	44 27       	eor	r20, r20
     636:	40 f9       	bld	r20, 0
     638:	61 e4       	ldi	r22, 0x41	; 65
     63a:	81 e0       	ldi	r24, 0x01	; 1
     63c:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  DIO_write(LCD_DATA_PIN6, LCD_DATA_PORT, read_bit(data, 2));
     640:	c2 fb       	bst	r28, 2
     642:	44 27       	eor	r20, r20
     644:	40 f9       	bld	r20, 0
     646:	61 e4       	ldi	r22, 0x41	; 65
     648:	82 e0       	ldi	r24, 0x02	; 2
     64a:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  DIO_write(LCD_DATA_PIN7, LCD_DATA_PORT, read_bit(data, 3));
     64e:	c3 fb       	bst	r28, 3
     650:	44 27       	eor	r20, r20
     652:	40 f9       	bld	r20, 0
     654:	61 e4       	ldi	r22, 0x41	; 65
     656:	83 e0       	ldi	r24, 0x03	; 3
     658:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  }
     65c:	cf 91       	pop	r28
     65e:	08 95       	ret

00000660 <LCD_sendData>:

void LCD_sendData(u8 data) {
     660:	cf 93       	push	r28
     662:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(data >> 4);
     664:	82 95       	swap	r24
     666:	8f 70       	andi	r24, 0x0F	; 15
     668:	0e 94 11 03 	call	0x622	; 0x622 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, HIGH); // To indicate that this data
     66c:	41 e0       	ldi	r20, 0x01	; 1
     66e:	61 e4       	ldi	r22, 0x41	; 65
     670:	84 e0       	ldi	r24, 0x04	; 4
     672:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>

  LCD_sendEnablePulse();
     676:	0e 94 02 03 	call	0x604	; 0x604 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the data to be sent

  LCD_write_4bits(data);
     67a:	8c 2f       	mov	r24, r28
     67c:	0e 94 11 03 	call	0x622	; 0x622 <LCD_write_4bits>

  LCD_sendEnablePulse();
     680:	0e 94 02 03 	call	0x604	; 0x604 <LCD_sendEnablePulse>
     684:	85 e0       	ldi	r24, 0x05	; 5
     686:	8a 95       	dec	r24
     688:	f1 f7       	brne	.-4      	; 0x686 <LCD_sendData+0x26>
     68a:	00 00       	nop

  _delay_us(1); // wait for the data to be processed
#else

#endif
  }
     68c:	cf 91       	pop	r28
     68e:	08 95       	ret

00000690 <LCD_sendCommand>:

void LCD_sendCommand(u8 cmd) {
     690:	cf 93       	push	r28
     692:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(cmd >> 4);
     694:	82 95       	swap	r24
     696:	8f 70       	andi	r24, 0x0F	; 15
     698:	0e 94 11 03 	call	0x622	; 0x622 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, LOW); // To indicate that this a command
     69c:	40 e0       	ldi	r20, 0x00	; 0
     69e:	61 e4       	ldi	r22, 0x41	; 65
     6a0:	84 e0       	ldi	r24, 0x04	; 4
     6a2:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>

  LCD_sendEnablePulse();
     6a6:	0e 94 02 03 	call	0x604	; 0x604 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the command to be sent

  LCD_write_4bits(cmd);
     6aa:	8c 2f       	mov	r24, r28
     6ac:	0e 94 11 03 	call	0x622	; 0x622 <LCD_write_4bits>

  LCD_sendEnablePulse();
     6b0:	0e 94 02 03 	call	0x604	; 0x604 <LCD_sendEnablePulse>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6b4:	8f ed       	ldi	r24, 0xDF	; 223
     6b6:	9e e2       	ldi	r25, 0x2E	; 46
     6b8:	01 97       	sbiw	r24, 0x01	; 1
     6ba:	f1 f7       	brne	.-4      	; 0x6b8 <LCD_sendCommand+0x28>
     6bc:	00 c0       	rjmp	.+0      	; 0x6be <LCD_sendCommand+0x2e>
     6be:	00 00       	nop

  _delay_ms(3); // wait for the command to be executed
#else

#endif
  }
     6c0:	cf 91       	pop	r28
     6c2:	08 95       	ret

000006c4 <LCD_clear_screen>:

void LCD_clear_screen() {
  LCD_sendCommand(0x01);
     6c4:	81 e0       	ldi	r24, 0x01	; 1
     6c6:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
     6ca:	08 95       	ret

000006cc <LCD_init>:
     6cc:	2f ef       	ldi	r18, 0xFF	; 255
     6ce:	89 ef       	ldi	r24, 0xF9	; 249
     6d0:	90 e0       	ldi	r25, 0x00	; 0
     6d2:	21 50       	subi	r18, 0x01	; 1
     6d4:	80 40       	sbci	r24, 0x00	; 0
     6d6:	90 40       	sbci	r25, 0x00	; 0
     6d8:	e1 f7       	brne	.-8      	; 0x6d2 <LCD_init+0x6>
     6da:	00 c0       	rjmp	.+0      	; 0x6dc <LCD_init+0x10>
     6dc:	00 00       	nop

void LCD_init(void) {
  _delay_ms(20); // wait for the LCD to start up.

#if LCD_MODE == FOUR_BIT_MODE
  DIO_init(LCD_DATA_PIN4, LCD_DATA_PORT, OUT);
     6de:	41 e0       	ldi	r20, 0x01	; 1
     6e0:	61 e4       	ldi	r22, 0x41	; 65
     6e2:	80 e0       	ldi	r24, 0x00	; 0
     6e4:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  DIO_init(LCD_DATA_PIN5, LCD_DATA_PORT, OUT);
     6e8:	41 e0       	ldi	r20, 0x01	; 1
     6ea:	61 e4       	ldi	r22, 0x41	; 65
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  DIO_init(LCD_DATA_PIN6, LCD_DATA_PORT, OUT);
     6f2:	41 e0       	ldi	r20, 0x01	; 1
     6f4:	61 e4       	ldi	r22, 0x41	; 65
     6f6:	82 e0       	ldi	r24, 0x02	; 2
     6f8:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  DIO_init(LCD_DATA_PIN7, LCD_DATA_PORT, OUT);
     6fc:	41 e0       	ldi	r20, 0x01	; 1
     6fe:	61 e4       	ldi	r22, 0x41	; 65
     700:	83 e0       	ldi	r24, 0x03	; 3
     702:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>

  DIO_init(RS, LCD_CTRL_PORT, OUT);
     706:	41 e0       	ldi	r20, 0x01	; 1
     708:	61 e4       	ldi	r22, 0x41	; 65
     70a:	84 e0       	ldi	r24, 0x04	; 4
     70c:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  DIO_init(RW, LCD_CTRL_PORT, OUT);
     710:	41 e0       	ldi	r20, 0x01	; 1
     712:	61 e4       	ldi	r22, 0x41	; 65
     714:	85 e0       	ldi	r24, 0x05	; 5
     716:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>
  DIO_init(EN, LCD_CTRL_PORT, OUT);
     71a:	41 e0       	ldi	r20, 0x01	; 1
     71c:	61 e4       	ldi	r22, 0x41	; 65
     71e:	86 e0       	ldi	r24, 0x06	; 6
     720:	0e 94 37 04 	call	0x86e	; 0x86e <DIO_init>

  DIO_write(RW, LCD_CTRL_PORT, LOW);
     724:	40 e0       	ldi	r20, 0x00	; 0
     726:	61 e4       	ldi	r22, 0x41	; 65
     728:	85 e0       	ldi	r24, 0x05	; 5
     72a:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>

  LCD_sendCommand(0x02);  // return home 
     72e:	82 e0       	ldi	r24, 0x02	; 2
     730:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
  LCD_sendCommand(0x28);  // 2 line  and 4 bit mode
     734:	88 e2       	ldi	r24, 0x28	; 40
     736:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
  LCD_sendCommand(0x0C);  // display on 
     73a:	8c e0       	ldi	r24, 0x0C	; 12
     73c:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
  LCD_sendCommand(0x06);  // auto increment 
     740:	86 e0       	ldi	r24, 0x06	; 6
     742:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
  LCD_clear_screen();
     746:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
     74a:	08 95       	ret

0000074c <LCD_write_string>:
#else

#endif
  }

void LCD_write_string(s8* str) {
     74c:	cf 92       	push	r12
     74e:	df 92       	push	r13
     750:	ef 92       	push	r14
     752:	ff 92       	push	r15
     754:	cf 93       	push	r28
     756:	df 93       	push	r29
     758:	ec 01       	movw	r28, r24
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     75a:	c1 2c       	mov	r12, r1
     75c:	d1 2c       	mov	r13, r1
     75e:	76 01       	movw	r14, r12
     760:	07 c0       	rjmp	.+14     	; 0x770 <LCD_write_string+0x24>
    LCD_sendData(str[i]);
     762:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
#endif
  }

void LCD_write_string(s8* str) {
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     766:	8f ef       	ldi	r24, 0xFF	; 255
     768:	c8 1a       	sub	r12, r24
     76a:	d8 0a       	sbc	r13, r24
     76c:	e8 0a       	sbc	r14, r24
     76e:	f8 0a       	sbc	r15, r24
     770:	fe 01       	movw	r30, r28
     772:	ec 0d       	add	r30, r12
     774:	fd 1d       	adc	r31, r13
     776:	80 81       	ld	r24, Z
     778:	81 11       	cpse	r24, r1
     77a:	f3 cf       	rjmp	.-26     	; 0x762 <LCD_write_string+0x16>
    LCD_sendData(str[i]);
    }
  }
     77c:	df 91       	pop	r29
     77e:	cf 91       	pop	r28
     780:	ff 90       	pop	r15
     782:	ef 90       	pop	r14
     784:	df 90       	pop	r13
     786:	cf 90       	pop	r12
     788:	08 95       	ret

0000078a <LCD_move_cursor_xy>:

void LCD_move_cursor_xy(u8 x, u8 y) {
  switch (y) {
     78a:	66 23       	and	r22, r22
     78c:	19 f0       	breq	.+6      	; 0x794 <LCD_move_cursor_xy+0xa>
     78e:	61 30       	cpi	r22, 0x01	; 1
     790:	29 f0       	breq	.+10     	; 0x79c <LCD_move_cursor_xy+0x12>
     792:	08 95       	ret
      case 0:
        LCD_sendCommand(0x80 + x);
     794:	80 58       	subi	r24, 0x80	; 128
     796:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
        break;
     79a:	08 95       	ret
      case 1:
        LCD_sendCommand(0xC0 + x);
     79c:	80 54       	subi	r24, 0x40	; 64
     79e:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
     7a2:	08 95       	ret

000007a4 <LCD_write_string_xy>:
        break;
    }
  }

void LCD_write_string_xy(u8 x, u8 y, s8* str) {
     7a4:	cf 93       	push	r28
     7a6:	df 93       	push	r29
     7a8:	ea 01       	movw	r28, r20
  LCD_move_cursor_xy(x, y);
     7aa:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
  LCD_write_string(str);
     7ae:	ce 01       	movw	r24, r28
     7b0:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
  // TODO: Input validation
     7b4:	df 91       	pop	r29
     7b6:	cf 91       	pop	r28
     7b8:	08 95       	ret

000007ba <LED_on>:
  // Return error code to indicate that the led initialization failed
  return LED_ERROR_INIT;
  }

// Turn on the LED
EN_ledError_t LED_on(u8 ledPort, u8 ledPin) {
     7ba:	98 2f       	mov	r25, r24
     7bc:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, HIGH) == DIO_OK) {
     7be:	41 e0       	ldi	r20, 0x01	; 1
     7c0:	69 2f       	mov	r22, r25
     7c2:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
     7c6:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn on the led has failed
  return LED_ERROR_ON;
     7c8:	82 e0       	ldi	r24, 0x02	; 2
  }
     7ca:	08 95       	ret

000007cc <LED_off>:

// Turn off the LED
EN_ledError_t LED_off(u8 ledPort, u8 ledPin) {
     7cc:	98 2f       	mov	r25, r24
     7ce:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, LOW) == DIO_OK) {
     7d0:	40 e0       	ldi	r20, 0x00	; 0
     7d2:	69 2f       	mov	r22, r25
     7d4:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
     7d8:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn off the led has failed
  return LED_ERROR_OFF;
     7da:	83 e0       	ldi	r24, 0x03	; 3
  }
     7dc:	08 95       	ret

000007de <LED_toggle>:

// Toggle the LED
EN_ledError_t LED_toggle(u8 ledPort, u8 ledPin) {
     7de:	98 2f       	mov	r25, r24
     7e0:	86 2f       	mov	r24, r22
  if (DIO_toggle(ledPin, ledPort) == DIO_OK) {
     7e2:	69 2f       	mov	r22, r25
     7e4:	0e 94 c1 05 	call	0xb82	; 0xb82 <DIO_toggle>
     7e8:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to toggle the led has failed
  return LED_ERROR_TOGGLE;
     7ea:	84 e0       	ldi	r24, 0x04	; 4
     7ec:	08 95       	ret

000007ee <Servo_move_to_angle>:
  Timer_start(TIMER_1, 8);
  }

// Moves the servo to a specific angle (relative to the 0 angle position, not the previous one).
void Servo_move_to_angle(u8 angle) {
  PWM_set_DC(SERVO_PWM_PIN, ((double)angle / ((SERVO_MAX_ANGLE - SERVO_MIN_ANGLE) * (SERVO_PULSE_PERIODIC_TIME_mS / (SERVO_MAX_HIGH_PULSE_DURATION_mS - SERVO_MIN_HIGH_PULSE_DURATION_mS)))) + (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS));
     7ee:	68 2f       	mov	r22, r24
     7f0:	70 e0       	ldi	r23, 0x00	; 0
     7f2:	80 e0       	ldi	r24, 0x00	; 0
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	0e 94 c7 12 	call	0x258e	; 0x258e <__floatunsisf>
     7fa:	20 e0       	ldi	r18, 0x00	; 0
     7fc:	30 e0       	ldi	r19, 0x00	; 0
     7fe:	41 ee       	ldi	r20, 0xE1	; 225
     800:	54 e4       	ldi	r21, 0x44	; 68
     802:	0e 94 26 12 	call	0x244c	; 0x244c <__divsf3>
     806:	2d ec       	ldi	r18, 0xCD	; 205
     808:	3c ec       	ldi	r19, 0xCC	; 204
     80a:	4c ec       	ldi	r20, 0xCC	; 204
     80c:	5c e3       	ldi	r21, 0x3C	; 60
     80e:	0e 94 ba 11 	call	0x2374	; 0x2374 <__addsf3>
     812:	ab 01       	movw	r20, r22
     814:	bc 01       	movw	r22, r24
     816:	81 e0       	ldi	r24, 0x01	; 1
     818:	0e 94 c5 06 	call	0xd8a	; 0xd8a <PWM_set_DC>
     81c:	08 95       	ret

0000081e <main>:
 */

#include "Application/app.h"

int main(void) {
	Local_access_init();
     81e:	0e 94 c1 07 	call	0xf82	; 0xf82 <Local_access_init>
	run_system = true;
     822:	81 e0       	ldi	r24, 0x01	; 1
     824:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
	
	// App_init();

	// App_start();
	while (run_system) {
     828:	02 c0       	rjmp	.+4      	; 0x82e <main+0x10>
		Local_control_input_handler();
     82a:	0e 94 55 09 	call	0x12aa	; 0x12aa <Local_control_input_handler>
	run_system = true;
	
	// App_init();

	// App_start();
	while (run_system) {
     82e:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     832:	81 11       	cpse	r24, r1
     834:	fa cf       	rjmp	.-12     	; 0x82a <main+0xc>
		Local_control_input_handler();
		}
	}
     836:	80 e0       	ldi	r24, 0x00	; 0
     838:	90 e0       	ldi	r25, 0x00	; 0
     83a:	08 95       	ret

0000083c <isValidPinNumber>:
 */

#include "dio.h"

bool isValidPinNumber(u8 pinNumber) {
	if (pinNumber < 8) {
     83c:	88 30       	cpi	r24, 0x08	; 8
     83e:	10 f4       	brcc	.+4      	; 0x844 <isValidPinNumber+0x8>
		return true;
     840:	81 e0       	ldi	r24, 0x01	; 1
     842:	08 95       	ret
		}
	return false;
     844:	80 e0       	ldi	r24, 0x00	; 0
	}
     846:	08 95       	ret

00000848 <isValidPortNumber>:

bool isValidPortNumber(u8 portNumber) {
	if (portNumber == PORT_A || portNumber == PORT_B || portNumber == PORT_C || portNumber == PORT_D) {
     848:	81 54       	subi	r24, 0x41	; 65
     84a:	84 30       	cpi	r24, 0x04	; 4
     84c:	10 f4       	brcc	.+4      	; 0x852 <isValidPortNumber+0xa>
		return true;
     84e:	81 e0       	ldi	r24, 0x01	; 1
     850:	08 95       	ret
		}
	return false;
     852:	80 e0       	ldi	r24, 0x00	; 0
	}
     854:	08 95       	ret

00000856 <isValidDirection>:

bool isValidDirection(u8 direction) {
	if (direction == IN || direction == OUT) {
     856:	82 30       	cpi	r24, 0x02	; 2
     858:	10 f4       	brcc	.+4      	; 0x85e <isValidDirection+0x8>
		return true;
     85a:	81 e0       	ldi	r24, 0x01	; 1
     85c:	08 95       	ret
		}
	return false;
     85e:	80 e0       	ldi	r24, 0x00	; 0
	}
     860:	08 95       	ret

00000862 <isValidState>:

bool isValidState(u8 state) {
	if (state == HIGH || state == LOW) {
     862:	82 30       	cpi	r24, 0x02	; 2
     864:	10 f4       	brcc	.+4      	; 0x86a <isValidState+0x8>
		return true;
     866:	81 e0       	ldi	r24, 0x01	; 1
     868:	08 95       	ret
		}
	return false;
     86a:	80 e0       	ldi	r24, 0x00	; 0
	}
     86c:	08 95       	ret

0000086e <DIO_init>:

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
     86e:	1f 93       	push	r17
     870:	cf 93       	push	r28
     872:	df 93       	push	r29
     874:	c8 2f       	mov	r28, r24
     876:	d6 2f       	mov	r29, r22
     878:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     87a:	0e 94 1e 04 	call	0x83c	; 0x83c <isValidPinNumber>
     87e:	88 23       	and	r24, r24
     880:	09 f4       	brne	.+2      	; 0x884 <DIO_init+0x16>
     882:	84 c0       	rjmp	.+264    	; 0x98c <DIO_init+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     884:	8d 2f       	mov	r24, r29
     886:	0e 94 24 04 	call	0x848	; 0x848 <isValidPortNumber>
     88a:	88 23       	and	r24, r24
     88c:	09 f4       	brne	.+2      	; 0x890 <DIO_init+0x22>
     88e:	80 c0       	rjmp	.+256    	; 0x990 <DIO_init+0x122>
		return WRONG_PORT;
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
     890:	81 2f       	mov	r24, r17
     892:	0e 94 2b 04 	call	0x856	; 0x856 <isValidDirection>
     896:	88 23       	and	r24, r24
     898:	09 f4       	brne	.+2      	; 0x89c <DIO_init+0x2e>
     89a:	7c c0       	rjmp	.+248    	; 0x994 <DIO_init+0x126>
		return WRONG_DIRECTION;
		}
	switch (portNumber) {
     89c:	d2 34       	cpi	r29, 0x42	; 66
     89e:	29 f1       	breq	.+74     	; 0x8ea <DIO_init+0x7c>
     8a0:	18 f4       	brcc	.+6      	; 0x8a8 <DIO_init+0x3a>
     8a2:	d1 34       	cpi	r29, 0x41	; 65
     8a4:	39 f0       	breq	.+14     	; 0x8b4 <DIO_init+0x46>
     8a6:	78 c0       	rjmp	.+240    	; 0x998 <DIO_init+0x12a>
     8a8:	d3 34       	cpi	r29, 0x43	; 67
     8aa:	d1 f1       	breq	.+116    	; 0x920 <DIO_init+0xb2>
     8ac:	d4 34       	cpi	r29, 0x44	; 68
     8ae:	09 f4       	brne	.+2      	; 0x8b2 <DIO_init+0x44>
     8b0:	52 c0       	rjmp	.+164    	; 0x956 <DIO_init+0xe8>
     8b2:	72 c0       	rjmp	.+228    	; 0x998 <DIO_init+0x12a>
			case PORT_A:
				if (direction == OUT) {
     8b4:	11 30       	cpi	r17, 0x01	; 1
     8b6:	61 f4       	brne	.+24     	; 0x8d0 <DIO_init+0x62>
					set_bit(DDRA, pinNumber);
     8b8:	2a b3       	in	r18, 0x1a	; 26
     8ba:	81 e0       	ldi	r24, 0x01	; 1
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	02 c0       	rjmp	.+4      	; 0x8c4 <DIO_init+0x56>
     8c0:	88 0f       	add	r24, r24
     8c2:	99 1f       	adc	r25, r25
     8c4:	ca 95       	dec	r28
     8c6:	e2 f7       	brpl	.-8      	; 0x8c0 <DIO_init+0x52>
     8c8:	82 2b       	or	r24, r18
     8ca:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     8cc:	80 e0       	ldi	r24, 0x00	; 0
     8ce:	65 c0       	rjmp	.+202    	; 0x99a <DIO_init+0x12c>
			case PORT_A:
				if (direction == OUT) {
					set_bit(DDRA, pinNumber);
					}
				else {
					clear_bit(DDRA, pinNumber);
     8d0:	2a b3       	in	r18, 0x1a	; 26
     8d2:	81 e0       	ldi	r24, 0x01	; 1
     8d4:	90 e0       	ldi	r25, 0x00	; 0
     8d6:	02 c0       	rjmp	.+4      	; 0x8dc <DIO_init+0x6e>
     8d8:	88 0f       	add	r24, r24
     8da:	99 1f       	adc	r25, r25
     8dc:	ca 95       	dec	r28
     8de:	e2 f7       	brpl	.-8      	; 0x8d8 <DIO_init+0x6a>
     8e0:	80 95       	com	r24
     8e2:	82 23       	and	r24, r18
     8e4:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	58 c0       	rjmp	.+176    	; 0x99a <DIO_init+0x12c>
				else {
					clear_bit(DDRA, pinNumber);
					}
				break;
			case PORT_B:
				if (direction == OUT) {
     8ea:	11 30       	cpi	r17, 0x01	; 1
     8ec:	61 f4       	brne	.+24     	; 0x906 <DIO_init+0x98>
					set_bit(DDRB, pinNumber);
     8ee:	27 b3       	in	r18, 0x17	; 23
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	90 e0       	ldi	r25, 0x00	; 0
     8f4:	02 c0       	rjmp	.+4      	; 0x8fa <DIO_init+0x8c>
     8f6:	88 0f       	add	r24, r24
     8f8:	99 1f       	adc	r25, r25
     8fa:	ca 95       	dec	r28
     8fc:	e2 f7       	brpl	.-8      	; 0x8f6 <DIO_init+0x88>
     8fe:	82 2b       	or	r24, r18
     900:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     902:	80 e0       	ldi	r24, 0x00	; 0
     904:	4a c0       	rjmp	.+148    	; 0x99a <DIO_init+0x12c>
			case PORT_B:
				if (direction == OUT) {
					set_bit(DDRB, pinNumber);
					}
				else {
					clear_bit(DDRB, pinNumber);
     906:	27 b3       	in	r18, 0x17	; 23
     908:	81 e0       	ldi	r24, 0x01	; 1
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	02 c0       	rjmp	.+4      	; 0x912 <DIO_init+0xa4>
     90e:	88 0f       	add	r24, r24
     910:	99 1f       	adc	r25, r25
     912:	ca 95       	dec	r28
     914:	e2 f7       	brpl	.-8      	; 0x90e <DIO_init+0xa0>
     916:	80 95       	com	r24
     918:	82 23       	and	r24, r18
     91a:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     91c:	80 e0       	ldi	r24, 0x00	; 0
     91e:	3d c0       	rjmp	.+122    	; 0x99a <DIO_init+0x12c>
				else {
					clear_bit(DDRB, pinNumber);
					}
				break;
			case PORT_C:
				if (direction == OUT) {
     920:	11 30       	cpi	r17, 0x01	; 1
     922:	61 f4       	brne	.+24     	; 0x93c <DIO_init+0xce>
					set_bit(DDRC, pinNumber);
     924:	24 b3       	in	r18, 0x14	; 20
     926:	81 e0       	ldi	r24, 0x01	; 1
     928:	90 e0       	ldi	r25, 0x00	; 0
     92a:	02 c0       	rjmp	.+4      	; 0x930 <DIO_init+0xc2>
     92c:	88 0f       	add	r24, r24
     92e:	99 1f       	adc	r25, r25
     930:	ca 95       	dec	r28
     932:	e2 f7       	brpl	.-8      	; 0x92c <DIO_init+0xbe>
     934:	82 2b       	or	r24, r18
     936:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     938:	80 e0       	ldi	r24, 0x00	; 0
     93a:	2f c0       	rjmp	.+94     	; 0x99a <DIO_init+0x12c>
			case PORT_C:
				if (direction == OUT) {
					set_bit(DDRC, pinNumber);
					}
				else {
					clear_bit(DDRC, pinNumber);
     93c:	24 b3       	in	r18, 0x14	; 20
     93e:	81 e0       	ldi	r24, 0x01	; 1
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	02 c0       	rjmp	.+4      	; 0x948 <DIO_init+0xda>
     944:	88 0f       	add	r24, r24
     946:	99 1f       	adc	r25, r25
     948:	ca 95       	dec	r28
     94a:	e2 f7       	brpl	.-8      	; 0x944 <DIO_init+0xd6>
     94c:	80 95       	com	r24
     94e:	82 23       	and	r24, r18
     950:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     952:	80 e0       	ldi	r24, 0x00	; 0
     954:	22 c0       	rjmp	.+68     	; 0x99a <DIO_init+0x12c>
				else {
					clear_bit(DDRC, pinNumber);
					}
				break;
			case PORT_D:
				if (direction == OUT) {
     956:	11 30       	cpi	r17, 0x01	; 1
     958:	61 f4       	brne	.+24     	; 0x972 <DIO_init+0x104>
					set_bit(DDRD, pinNumber);
     95a:	21 b3       	in	r18, 0x11	; 17
     95c:	81 e0       	ldi	r24, 0x01	; 1
     95e:	90 e0       	ldi	r25, 0x00	; 0
     960:	02 c0       	rjmp	.+4      	; 0x966 <DIO_init+0xf8>
     962:	88 0f       	add	r24, r24
     964:	99 1f       	adc	r25, r25
     966:	ca 95       	dec	r28
     968:	e2 f7       	brpl	.-8      	; 0x962 <DIO_init+0xf4>
     96a:	82 2b       	or	r24, r18
     96c:	81 bb       	out	0x11, r24	; 17
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	14 c0       	rjmp	.+40     	; 0x99a <DIO_init+0x12c>
			case PORT_D:
				if (direction == OUT) {
					set_bit(DDRD, pinNumber);
					}
				else {
					clear_bit(DDRD, pinNumber);
     972:	21 b3       	in	r18, 0x11	; 17
     974:	81 e0       	ldi	r24, 0x01	; 1
     976:	90 e0       	ldi	r25, 0x00	; 0
     978:	02 c0       	rjmp	.+4      	; 0x97e <DIO_init+0x110>
     97a:	88 0f       	add	r24, r24
     97c:	99 1f       	adc	r25, r25
     97e:	ca 95       	dec	r28
     980:	e2 f7       	brpl	.-8      	; 0x97a <DIO_init+0x10c>
     982:	80 95       	com	r24
     984:	82 23       	and	r24, r18
     986:	81 bb       	out	0x11, r24	; 17
					}
				break;
		}
	return DIO_OK;
     988:	80 e0       	ldi	r24, 0x00	; 0
     98a:	07 c0       	rjmp	.+14     	; 0x99a <DIO_init+0x12c>

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     98c:	81 e0       	ldi	r24, 0x01	; 1
     98e:	05 c0       	rjmp	.+10     	; 0x99a <DIO_init+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     990:	82 e0       	ldi	r24, 0x02	; 2
     992:	03 c0       	rjmp	.+6      	; 0x99a <DIO_init+0x12c>
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
		return WRONG_DIRECTION;
     994:	83 e0       	ldi	r24, 0x03	; 3
     996:	01 c0       	rjmp	.+2      	; 0x99a <DIO_init+0x12c>
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     998:	80 e0       	ldi	r24, 0x00	; 0
	}
     99a:	df 91       	pop	r29
     99c:	cf 91       	pop	r28
     99e:	1f 91       	pop	r17
     9a0:	08 95       	ret

000009a2 <DIO_write>:

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
     9a2:	1f 93       	push	r17
     9a4:	cf 93       	push	r28
     9a6:	df 93       	push	r29
     9a8:	c8 2f       	mov	r28, r24
     9aa:	d6 2f       	mov	r29, r22
     9ac:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     9ae:	0e 94 1e 04 	call	0x83c	; 0x83c <isValidPinNumber>
     9b2:	88 23       	and	r24, r24
     9b4:	09 f4       	brne	.+2      	; 0x9b8 <DIO_write+0x16>
     9b6:	84 c0       	rjmp	.+264    	; 0xac0 <DIO_write+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     9b8:	8d 2f       	mov	r24, r29
     9ba:	0e 94 24 04 	call	0x848	; 0x848 <isValidPortNumber>
     9be:	88 23       	and	r24, r24
     9c0:	09 f4       	brne	.+2      	; 0x9c4 <DIO_write+0x22>
     9c2:	80 c0       	rjmp	.+256    	; 0xac4 <DIO_write+0x122>
		return WRONG_PORT;
		}
	// Validate the pin state
	if (!isValidState(state)) {
     9c4:	81 2f       	mov	r24, r17
     9c6:	0e 94 31 04 	call	0x862	; 0x862 <isValidState>
     9ca:	88 23       	and	r24, r24
     9cc:	09 f4       	brne	.+2      	; 0x9d0 <DIO_write+0x2e>
     9ce:	7c c0       	rjmp	.+248    	; 0xac8 <DIO_write+0x126>
		return WRONG_STATE;
		}
	switch (portNumber) {
     9d0:	d2 34       	cpi	r29, 0x42	; 66
     9d2:	29 f1       	breq	.+74     	; 0xa1e <DIO_write+0x7c>
     9d4:	18 f4       	brcc	.+6      	; 0x9dc <DIO_write+0x3a>
     9d6:	d1 34       	cpi	r29, 0x41	; 65
     9d8:	39 f0       	breq	.+14     	; 0x9e8 <DIO_write+0x46>
     9da:	78 c0       	rjmp	.+240    	; 0xacc <DIO_write+0x12a>
     9dc:	d3 34       	cpi	r29, 0x43	; 67
     9de:	d1 f1       	breq	.+116    	; 0xa54 <DIO_write+0xb2>
     9e0:	d4 34       	cpi	r29, 0x44	; 68
     9e2:	09 f4       	brne	.+2      	; 0x9e6 <DIO_write+0x44>
     9e4:	52 c0       	rjmp	.+164    	; 0xa8a <DIO_write+0xe8>
     9e6:	72 c0       	rjmp	.+228    	; 0xacc <DIO_write+0x12a>
			case PORT_A:
				if (state == HIGH) {
     9e8:	11 30       	cpi	r17, 0x01	; 1
     9ea:	61 f4       	brne	.+24     	; 0xa04 <DIO_write+0x62>
					set_bit(PORTA, pinNumber);
     9ec:	2b b3       	in	r18, 0x1b	; 27
     9ee:	81 e0       	ldi	r24, 0x01	; 1
     9f0:	90 e0       	ldi	r25, 0x00	; 0
     9f2:	02 c0       	rjmp	.+4      	; 0x9f8 <DIO_write+0x56>
     9f4:	88 0f       	add	r24, r24
     9f6:	99 1f       	adc	r25, r25
     9f8:	ca 95       	dec	r28
     9fa:	e2 f7       	brpl	.-8      	; 0x9f4 <DIO_write+0x52>
     9fc:	82 2b       	or	r24, r18
     9fe:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a00:	80 e0       	ldi	r24, 0x00	; 0
     a02:	65 c0       	rjmp	.+202    	; 0xace <DIO_write+0x12c>
			case PORT_A:
				if (state == HIGH) {
					set_bit(PORTA, pinNumber);
					}
				else {
					clear_bit(PORTA, pinNumber);
     a04:	2b b3       	in	r18, 0x1b	; 27
     a06:	81 e0       	ldi	r24, 0x01	; 1
     a08:	90 e0       	ldi	r25, 0x00	; 0
     a0a:	02 c0       	rjmp	.+4      	; 0xa10 <DIO_write+0x6e>
     a0c:	88 0f       	add	r24, r24
     a0e:	99 1f       	adc	r25, r25
     a10:	ca 95       	dec	r28
     a12:	e2 f7       	brpl	.-8      	; 0xa0c <DIO_write+0x6a>
     a14:	80 95       	com	r24
     a16:	82 23       	and	r24, r18
     a18:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a1a:	80 e0       	ldi	r24, 0x00	; 0
     a1c:	58 c0       	rjmp	.+176    	; 0xace <DIO_write+0x12c>
				else {
					clear_bit(PORTA, pinNumber);
					}
				break;
			case PORT_B:
				if (state == HIGH) {
     a1e:	11 30       	cpi	r17, 0x01	; 1
     a20:	61 f4       	brne	.+24     	; 0xa3a <DIO_write+0x98>
					set_bit(PORTB, pinNumber);
     a22:	28 b3       	in	r18, 0x18	; 24
     a24:	81 e0       	ldi	r24, 0x01	; 1
     a26:	90 e0       	ldi	r25, 0x00	; 0
     a28:	02 c0       	rjmp	.+4      	; 0xa2e <DIO_write+0x8c>
     a2a:	88 0f       	add	r24, r24
     a2c:	99 1f       	adc	r25, r25
     a2e:	ca 95       	dec	r28
     a30:	e2 f7       	brpl	.-8      	; 0xa2a <DIO_write+0x88>
     a32:	82 2b       	or	r24, r18
     a34:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a36:	80 e0       	ldi	r24, 0x00	; 0
     a38:	4a c0       	rjmp	.+148    	; 0xace <DIO_write+0x12c>
			case PORT_B:
				if (state == HIGH) {
					set_bit(PORTB, pinNumber);
					}
				else {
					clear_bit(PORTB, pinNumber);
     a3a:	28 b3       	in	r18, 0x18	; 24
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	02 c0       	rjmp	.+4      	; 0xa46 <DIO_write+0xa4>
     a42:	88 0f       	add	r24, r24
     a44:	99 1f       	adc	r25, r25
     a46:	ca 95       	dec	r28
     a48:	e2 f7       	brpl	.-8      	; 0xa42 <DIO_write+0xa0>
     a4a:	80 95       	com	r24
     a4c:	82 23       	and	r24, r18
     a4e:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	3d c0       	rjmp	.+122    	; 0xace <DIO_write+0x12c>
				else {
					clear_bit(PORTB, pinNumber);
					}
				break;
			case PORT_C:
				if (state == HIGH) {
     a54:	11 30       	cpi	r17, 0x01	; 1
     a56:	61 f4       	brne	.+24     	; 0xa70 <DIO_write+0xce>
					set_bit(PORTC, pinNumber);
     a58:	25 b3       	in	r18, 0x15	; 21
     a5a:	81 e0       	ldi	r24, 0x01	; 1
     a5c:	90 e0       	ldi	r25, 0x00	; 0
     a5e:	02 c0       	rjmp	.+4      	; 0xa64 <DIO_write+0xc2>
     a60:	88 0f       	add	r24, r24
     a62:	99 1f       	adc	r25, r25
     a64:	ca 95       	dec	r28
     a66:	e2 f7       	brpl	.-8      	; 0xa60 <DIO_write+0xbe>
     a68:	82 2b       	or	r24, r18
     a6a:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a6c:	80 e0       	ldi	r24, 0x00	; 0
     a6e:	2f c0       	rjmp	.+94     	; 0xace <DIO_write+0x12c>
			case PORT_C:
				if (state == HIGH) {
					set_bit(PORTC, pinNumber);
					}
				else {
					clear_bit(PORTC, pinNumber);
     a70:	25 b3       	in	r18, 0x15	; 21
     a72:	81 e0       	ldi	r24, 0x01	; 1
     a74:	90 e0       	ldi	r25, 0x00	; 0
     a76:	02 c0       	rjmp	.+4      	; 0xa7c <DIO_write+0xda>
     a78:	88 0f       	add	r24, r24
     a7a:	99 1f       	adc	r25, r25
     a7c:	ca 95       	dec	r28
     a7e:	e2 f7       	brpl	.-8      	; 0xa78 <DIO_write+0xd6>
     a80:	80 95       	com	r24
     a82:	82 23       	and	r24, r18
     a84:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a86:	80 e0       	ldi	r24, 0x00	; 0
     a88:	22 c0       	rjmp	.+68     	; 0xace <DIO_write+0x12c>
				else {
					clear_bit(PORTC, pinNumber);
					}
				break;
			case PORT_D:
				if (state == HIGH) {
     a8a:	11 30       	cpi	r17, 0x01	; 1
     a8c:	61 f4       	brne	.+24     	; 0xaa6 <DIO_write+0x104>
					set_bit(PORTD, pinNumber);
     a8e:	22 b3       	in	r18, 0x12	; 18
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	02 c0       	rjmp	.+4      	; 0xa9a <DIO_write+0xf8>
     a96:	88 0f       	add	r24, r24
     a98:	99 1f       	adc	r25, r25
     a9a:	ca 95       	dec	r28
     a9c:	e2 f7       	brpl	.-8      	; 0xa96 <DIO_write+0xf4>
     a9e:	82 2b       	or	r24, r18
     aa0:	82 bb       	out	0x12, r24	; 18
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     aa2:	80 e0       	ldi	r24, 0x00	; 0
     aa4:	14 c0       	rjmp	.+40     	; 0xace <DIO_write+0x12c>
			case PORT_D:
				if (state == HIGH) {
					set_bit(PORTD, pinNumber);
					}
				else {
					clear_bit(PORTD, pinNumber);
     aa6:	22 b3       	in	r18, 0x12	; 18
     aa8:	81 e0       	ldi	r24, 0x01	; 1
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	02 c0       	rjmp	.+4      	; 0xab2 <DIO_write+0x110>
     aae:	88 0f       	add	r24, r24
     ab0:	99 1f       	adc	r25, r25
     ab2:	ca 95       	dec	r28
     ab4:	e2 f7       	brpl	.-8      	; 0xaae <DIO_write+0x10c>
     ab6:	80 95       	com	r24
     ab8:	82 23       	and	r24, r18
     aba:	82 bb       	out	0x12, r24	; 18
					}
				break;
		}
	return DIO_OK;
     abc:	80 e0       	ldi	r24, 0x00	; 0
     abe:	07 c0       	rjmp	.+14     	; 0xace <DIO_write+0x12c>

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     ac0:	81 e0       	ldi	r24, 0x01	; 1
     ac2:	05 c0       	rjmp	.+10     	; 0xace <DIO_write+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     ac4:	82 e0       	ldi	r24, 0x02	; 2
     ac6:	03 c0       	rjmp	.+6      	; 0xace <DIO_write+0x12c>
		}
	// Validate the pin state
	if (!isValidState(state)) {
		return WRONG_STATE;
     ac8:	84 e0       	ldi	r24, 0x04	; 4
     aca:	01 c0       	rjmp	.+2      	; 0xace <DIO_write+0x12c>
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     acc:	80 e0       	ldi	r24, 0x00	; 0
	}
     ace:	df 91       	pop	r29
     ad0:	cf 91       	pop	r28
     ad2:	1f 91       	pop	r17
     ad4:	08 95       	ret

00000ad6 <DIO_Read>:

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
     ad6:	0f 93       	push	r16
     ad8:	1f 93       	push	r17
     ada:	cf 93       	push	r28
     adc:	df 93       	push	r29
     ade:	d8 2f       	mov	r29, r24
     ae0:	c6 2f       	mov	r28, r22
     ae2:	8a 01       	movw	r16, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     ae4:	0e 94 1e 04 	call	0x83c	; 0x83c <isValidPinNumber>
     ae8:	88 23       	and	r24, r24
     aea:	09 f4       	brne	.+2      	; 0xaee <DIO_Read+0x18>
     aec:	40 c0       	rjmp	.+128    	; 0xb6e <DIO_Read+0x98>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     aee:	8c 2f       	mov	r24, r28
     af0:	0e 94 24 04 	call	0x848	; 0x848 <isValidPortNumber>
     af4:	88 23       	and	r24, r24
     af6:	e9 f1       	breq	.+122    	; 0xb72 <DIO_Read+0x9c>
		return WRONG_PORT;
		}
	switch (portNumber) {
     af8:	c2 34       	cpi	r28, 0x42	; 66
     afa:	a9 f0       	breq	.+42     	; 0xb26 <DIO_Read+0x50>
     afc:	18 f4       	brcc	.+6      	; 0xb04 <DIO_Read+0x2e>
     afe:	c1 34       	cpi	r28, 0x41	; 65
     b00:	31 f0       	breq	.+12     	; 0xb0e <DIO_Read+0x38>
     b02:	39 c0       	rjmp	.+114    	; 0xb76 <DIO_Read+0xa0>
     b04:	c3 34       	cpi	r28, 0x43	; 67
     b06:	d9 f0       	breq	.+54     	; 0xb3e <DIO_Read+0x68>
     b08:	c4 34       	cpi	r28, 0x44	; 68
     b0a:	29 f1       	breq	.+74     	; 0xb56 <DIO_Read+0x80>
     b0c:	34 c0       	rjmp	.+104    	; 0xb76 <DIO_Read+0xa0>
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
     b0e:	89 b3       	in	r24, 0x19	; 25
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	02 c0       	rjmp	.+4      	; 0xb18 <DIO_Read+0x42>
     b14:	95 95       	asr	r25
     b16:	87 95       	ror	r24
     b18:	da 95       	dec	r29
     b1a:	e2 f7       	brpl	.-8      	; 0xb14 <DIO_Read+0x3e>
     b1c:	81 70       	andi	r24, 0x01	; 1
     b1e:	f8 01       	movw	r30, r16
     b20:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b22:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
     b24:	29 c0       	rjmp	.+82     	; 0xb78 <DIO_Read+0xa2>
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
     b26:	86 b3       	in	r24, 0x16	; 22
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	02 c0       	rjmp	.+4      	; 0xb30 <DIO_Read+0x5a>
     b2c:	95 95       	asr	r25
     b2e:	87 95       	ror	r24
     b30:	da 95       	dec	r29
     b32:	e2 f7       	brpl	.-8      	; 0xb2c <DIO_Read+0x56>
     b34:	81 70       	andi	r24, 0x01	; 1
     b36:	f8 01       	movw	r30, r16
     b38:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b3a:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
     b3c:	1d c0       	rjmp	.+58     	; 0xb78 <DIO_Read+0xa2>
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
     b3e:	83 b3       	in	r24, 0x13	; 19
     b40:	90 e0       	ldi	r25, 0x00	; 0
     b42:	02 c0       	rjmp	.+4      	; 0xb48 <DIO_Read+0x72>
     b44:	95 95       	asr	r25
     b46:	87 95       	ror	r24
     b48:	da 95       	dec	r29
     b4a:	e2 f7       	brpl	.-8      	; 0xb44 <DIO_Read+0x6e>
     b4c:	81 70       	andi	r24, 0x01	; 1
     b4e:	f8 01       	movw	r30, r16
     b50:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b52:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
     b54:	11 c0       	rjmp	.+34     	; 0xb78 <DIO_Read+0xa2>
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
     b56:	80 b3       	in	r24, 0x10	; 16
     b58:	90 e0       	ldi	r25, 0x00	; 0
     b5a:	02 c0       	rjmp	.+4      	; 0xb60 <DIO_Read+0x8a>
     b5c:	95 95       	asr	r25
     b5e:	87 95       	ror	r24
     b60:	da 95       	dec	r29
     b62:	e2 f7       	brpl	.-8      	; 0xb5c <DIO_Read+0x86>
     b64:	81 70       	andi	r24, 0x01	; 1
     b66:	f8 01       	movw	r30, r16
     b68:	80 83       	st	Z, r24
				break;
		}
	return DIO_OK;
     b6a:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
     b6c:	05 c0       	rjmp	.+10     	; 0xb78 <DIO_Read+0xa2>

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     b6e:	81 e0       	ldi	r24, 0x01	; 1
     b70:	03 c0       	rjmp	.+6      	; 0xb78 <DIO_Read+0xa2>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     b72:	82 e0       	ldi	r24, 0x02	; 2
     b74:	01 c0       	rjmp	.+2      	; 0xb78 <DIO_Read+0xa2>
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b76:	80 e0       	ldi	r24, 0x00	; 0
	}
     b78:	df 91       	pop	r29
     b7a:	cf 91       	pop	r28
     b7c:	1f 91       	pop	r17
     b7e:	0f 91       	pop	r16
     b80:	08 95       	ret

00000b82 <DIO_toggle>:

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
     b82:	cf 93       	push	r28
     b84:	df 93       	push	r29
     b86:	d8 2f       	mov	r29, r24
     b88:	c6 2f       	mov	r28, r22
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     b8a:	0e 94 1e 04 	call	0x83c	; 0x83c <isValidPinNumber>
     b8e:	88 23       	and	r24, r24
     b90:	09 f4       	brne	.+2      	; 0xb94 <DIO_toggle+0x12>
     b92:	40 c0       	rjmp	.+128    	; 0xc14 <DIO_toggle+0x92>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     b94:	8c 2f       	mov	r24, r28
     b96:	0e 94 24 04 	call	0x848	; 0x848 <isValidPortNumber>
     b9a:	88 23       	and	r24, r24
     b9c:	e9 f1       	breq	.+122    	; 0xc18 <DIO_toggle+0x96>
		return WRONG_PORT;
		}
	switch (portNumber) {
     b9e:	c2 34       	cpi	r28, 0x42	; 66
     ba0:	a9 f0       	breq	.+42     	; 0xbcc <DIO_toggle+0x4a>
     ba2:	18 f4       	brcc	.+6      	; 0xbaa <DIO_toggle+0x28>
     ba4:	c1 34       	cpi	r28, 0x41	; 65
     ba6:	31 f0       	breq	.+12     	; 0xbb4 <DIO_toggle+0x32>
     ba8:	39 c0       	rjmp	.+114    	; 0xc1c <DIO_toggle+0x9a>
     baa:	c3 34       	cpi	r28, 0x43	; 67
     bac:	d9 f0       	breq	.+54     	; 0xbe4 <DIO_toggle+0x62>
     bae:	c4 34       	cpi	r28, 0x44	; 68
     bb0:	29 f1       	breq	.+74     	; 0xbfc <DIO_toggle+0x7a>
     bb2:	34 c0       	rjmp	.+104    	; 0xc1c <DIO_toggle+0x9a>
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
     bb4:	2b b3       	in	r18, 0x1b	; 27
     bb6:	81 e0       	ldi	r24, 0x01	; 1
     bb8:	90 e0       	ldi	r25, 0x00	; 0
     bba:	02 c0       	rjmp	.+4      	; 0xbc0 <DIO_toggle+0x3e>
     bbc:	88 0f       	add	r24, r24
     bbe:	99 1f       	adc	r25, r25
     bc0:	da 95       	dec	r29
     bc2:	e2 f7       	brpl	.-8      	; 0xbbc <DIO_toggle+0x3a>
     bc4:	82 27       	eor	r24, r18
     bc6:	8b bb       	out	0x1b, r24	; 27
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     bc8:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
     bca:	29 c0       	rjmp	.+82     	; 0xc1e <DIO_toggle+0x9c>
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
     bcc:	28 b3       	in	r18, 0x18	; 24
     bce:	81 e0       	ldi	r24, 0x01	; 1
     bd0:	90 e0       	ldi	r25, 0x00	; 0
     bd2:	02 c0       	rjmp	.+4      	; 0xbd8 <DIO_toggle+0x56>
     bd4:	88 0f       	add	r24, r24
     bd6:	99 1f       	adc	r25, r25
     bd8:	da 95       	dec	r29
     bda:	e2 f7       	brpl	.-8      	; 0xbd4 <DIO_toggle+0x52>
     bdc:	82 27       	eor	r24, r18
     bde:	88 bb       	out	0x18, r24	; 24
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     be0:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
     be2:	1d c0       	rjmp	.+58     	; 0xc1e <DIO_toggle+0x9c>
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
     be4:	25 b3       	in	r18, 0x15	; 21
     be6:	81 e0       	ldi	r24, 0x01	; 1
     be8:	90 e0       	ldi	r25, 0x00	; 0
     bea:	02 c0       	rjmp	.+4      	; 0xbf0 <DIO_toggle+0x6e>
     bec:	88 0f       	add	r24, r24
     bee:	99 1f       	adc	r25, r25
     bf0:	da 95       	dec	r29
     bf2:	e2 f7       	brpl	.-8      	; 0xbec <DIO_toggle+0x6a>
     bf4:	82 27       	eor	r24, r18
     bf6:	85 bb       	out	0x15, r24	; 21
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     bf8:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
     bfa:	11 c0       	rjmp	.+34     	; 0xc1e <DIO_toggle+0x9c>
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
     bfc:	22 b3       	in	r18, 0x12	; 18
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	90 e0       	ldi	r25, 0x00	; 0
     c02:	02 c0       	rjmp	.+4      	; 0xc08 <DIO_toggle+0x86>
     c04:	88 0f       	add	r24, r24
     c06:	99 1f       	adc	r25, r25
     c08:	da 95       	dec	r29
     c0a:	e2 f7       	brpl	.-8      	; 0xc04 <DIO_toggle+0x82>
     c0c:	82 27       	eor	r24, r18
     c0e:	82 bb       	out	0x12, r24	; 18
				break;
		}
	return DIO_OK;
     c10:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
     c12:	05 c0       	rjmp	.+10     	; 0xc1e <DIO_toggle+0x9c>

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     c14:	81 e0       	ldi	r24, 0x01	; 1
     c16:	03 c0       	rjmp	.+6      	; 0xc1e <DIO_toggle+0x9c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     c18:	82 e0       	ldi	r24, 0x02	; 2
     c1a:	01 c0       	rjmp	.+2      	; 0xc1e <DIO_toggle+0x9c>
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     c1c:	80 e0       	ldi	r24, 0x00	; 0
     c1e:	df 91       	pop	r29
     c20:	cf 91       	pop	r28
     c22:	08 95       	ret

00000c24 <getCurrentStatus>:

EN_I2CMasterStatusCode_t I2C_repeatedStart() {   // Same as start, just a different name
  TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  while (read_bit(TWCR, TWINT) == 0);
  return getCurrentStatus();
  }
     c24:	81 b1       	in	r24, 0x01	; 1
     c26:	e8 2f       	mov	r30, r24
     c28:	e8 7f       	andi	r30, 0xF8	; 248
     c2a:	8e 2f       	mov	r24, r30
     c2c:	90 e0       	ldi	r25, 0x00	; 0
     c2e:	fc 01       	movw	r30, r24
     c30:	38 97       	sbiw	r30, 0x08	; 8
     c32:	e1 35       	cpi	r30, 0x51	; 81
     c34:	f1 05       	cpc	r31, r1
     c36:	c0 f4       	brcc	.+48     	; 0xc68 <getCurrentStatus+0x44>
     c38:	e6 5d       	subi	r30, 0xD6	; 214
     c3a:	ff 4f       	sbci	r31, 0xFF	; 255
     c3c:	0c 94 c2 13 	jmp	0x2784	; 0x2784 <__tablejump2__>
     c40:	80 e0       	ldi	r24, 0x00	; 0
     c42:	08 95       	ret
     c44:	82 e0       	ldi	r24, 0x02	; 2
     c46:	08 95       	ret
     c48:	83 e0       	ldi	r24, 0x03	; 3
     c4a:	08 95       	ret
     c4c:	84 e0       	ldi	r24, 0x04	; 4
     c4e:	08 95       	ret
     c50:	85 e0       	ldi	r24, 0x05	; 5
     c52:	08 95       	ret
     c54:	86 e0       	ldi	r24, 0x06	; 6
     c56:	08 95       	ret
     c58:	87 e0       	ldi	r24, 0x07	; 7
     c5a:	08 95       	ret
     c5c:	88 e0       	ldi	r24, 0x08	; 8
     c5e:	08 95       	ret
     c60:	89 e0       	ldi	r24, 0x09	; 9
     c62:	08 95       	ret
     c64:	8a e0       	ldi	r24, 0x0A	; 10
     c66:	08 95       	ret
     c68:	8b e0       	ldi	r24, 0x0B	; 11
     c6a:	08 95       	ret
     c6c:	81 e0       	ldi	r24, 0x01	; 1
     c6e:	08 95       	ret

00000c70 <I2C_init>:
     c70:	11 b8       	out	0x01, r1	; 1
     c72:	8f ef       	ldi	r24, 0xFF	; 255
     c74:	80 b9       	out	0x00, r24	; 0
     c76:	08 95       	ret

00000c78 <I2C_start>:
     c78:	84 ea       	ldi	r24, 0xA4	; 164
     c7a:	86 bf       	out	0x36, r24	; 54
     c7c:	06 b6       	in	r0, 0x36	; 54
     c7e:	07 fe       	sbrs	r0, 7
     c80:	fd cf       	rjmp	.-6      	; 0xc7c <I2C_start+0x4>
     c82:	0e 94 12 06 	call	0xc24	; 0xc24 <getCurrentStatus>
     c86:	08 95       	ret

00000c88 <I2C_write>:

EN_I2CMasterStatusCode_t I2C_write(u8 data) {
  TWDR = data;
     c88:	83 b9       	out	0x03, r24	; 3
  TWCR = (1 << TWEN) | (1 << TWINT);
     c8a:	84 e8       	ldi	r24, 0x84	; 132
     c8c:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWINT) == 0);
     c8e:	06 b6       	in	r0, 0x36	; 54
     c90:	07 fe       	sbrs	r0, 7
     c92:	fd cf       	rjmp	.-6      	; 0xc8e <I2C_write+0x6>
  return getCurrentStatus();
     c94:	0e 94 12 06 	call	0xc24	; 0xc24 <getCurrentStatus>
  }
     c98:	08 95       	ret

00000c9a <I2C_read_Ack>:

EN_I2CMasterStatusCode_t I2C_read_Ack(u8* data) {
  TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWINT);
     c9a:	24 ec       	ldi	r18, 0xC4	; 196
     c9c:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     c9e:	06 b6       	in	r0, 0x36	; 54
     ca0:	07 fe       	sbrs	r0, 7
     ca2:	fd cf       	rjmp	.-6      	; 0xc9e <I2C_read_Ack+0x4>
  *data = TWDR;
     ca4:	23 b1       	in	r18, 0x03	; 3
     ca6:	fc 01       	movw	r30, r24
     ca8:	20 83       	st	Z, r18
  return getCurrentStatus();
     caa:	0e 94 12 06 	call	0xc24	; 0xc24 <getCurrentStatus>
  }
     cae:	08 95       	ret

00000cb0 <I2C_read_Nack>:

EN_I2CMasterStatusCode_t I2C_read_Nack(u8* data) {
  TWCR = (1 << TWEN) | (1 << TWINT);
     cb0:	24 e8       	ldi	r18, 0x84	; 132
     cb2:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     cb4:	06 b6       	in	r0, 0x36	; 54
     cb6:	07 fe       	sbrs	r0, 7
     cb8:	fd cf       	rjmp	.-6      	; 0xcb4 <I2C_read_Nack+0x4>
  *data = TWDR;
     cba:	23 b1       	in	r18, 0x03	; 3
     cbc:	fc 01       	movw	r30, r24
     cbe:	20 83       	st	Z, r18
  return getCurrentStatus();
     cc0:	0e 94 12 06 	call	0xc24	; 0xc24 <getCurrentStatus>
  }
     cc4:	08 95       	ret

00000cc6 <I2C_stop>:

void I2C_stop(void) {
  TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
     cc6:	84 e9       	ldi	r24, 0x94	; 148
     cc8:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWSTO));	// Wait until stop condition finishes
     cca:	06 b6       	in	r0, 0x36	; 54
     ccc:	04 fc       	sbrc	r0, 4
     cce:	fd cf       	rjmp	.-6      	; 0xcca <I2C_stop+0x4>
  }
     cd0:	08 95       	ret

00000cd2 <PWM_OCP_disconnect>:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  PWM_OCP_connect(pwmPin);
  return TIMER_OK;
  }
     cd2:	84 30       	cpi	r24, 0x04	; 4
     cd4:	40 f5       	brcc	.+80     	; 0xd26 <PWM_OCP_disconnect+0x54>
     cd6:	81 30       	cpi	r24, 0x01	; 1
     cd8:	71 f0       	breq	.+28     	; 0xcf6 <PWM_OCP_disconnect+0x24>
     cda:	28 f0       	brcs	.+10     	; 0xce6 <PWM_OCP_disconnect+0x14>
     cdc:	82 30       	cpi	r24, 0x02	; 2
     cde:	99 f0       	breq	.+38     	; 0xd06 <PWM_OCP_disconnect+0x34>
     ce0:	83 30       	cpi	r24, 0x03	; 3
     ce2:	c9 f0       	breq	.+50     	; 0xd16 <PWM_OCP_disconnect+0x44>
     ce4:	22 c0       	rjmp	.+68     	; 0xd2a <PWM_OCP_disconnect+0x58>
     ce6:	83 b7       	in	r24, 0x33	; 51
     ce8:	8f 7e       	andi	r24, 0xEF	; 239
     cea:	83 bf       	out	0x33, r24	; 51
     cec:	83 b7       	in	r24, 0x33	; 51
     cee:	8f 7d       	andi	r24, 0xDF	; 223
     cf0:	83 bf       	out	0x33, r24	; 51
     cf2:	80 e0       	ldi	r24, 0x00	; 0
     cf4:	08 95       	ret
     cf6:	8f b5       	in	r24, 0x2f	; 47
     cf8:	8f 7b       	andi	r24, 0xBF	; 191
     cfa:	8f bd       	out	0x2f, r24	; 47
     cfc:	8f b5       	in	r24, 0x2f	; 47
     cfe:	8f 77       	andi	r24, 0x7F	; 127
     d00:	8f bd       	out	0x2f, r24	; 47
     d02:	80 e0       	ldi	r24, 0x00	; 0
     d04:	08 95       	ret
     d06:	8f b5       	in	r24, 0x2f	; 47
     d08:	8f 7e       	andi	r24, 0xEF	; 239
     d0a:	8f bd       	out	0x2f, r24	; 47
     d0c:	8f b5       	in	r24, 0x2f	; 47
     d0e:	8f 7d       	andi	r24, 0xDF	; 223
     d10:	8f bd       	out	0x2f, r24	; 47
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	08 95       	ret
     d16:	85 b5       	in	r24, 0x25	; 37
     d18:	8f 7e       	andi	r24, 0xEF	; 239
     d1a:	85 bd       	out	0x25, r24	; 37
     d1c:	85 b5       	in	r24, 0x25	; 37
     d1e:	8f 7d       	andi	r24, 0xDF	; 223
     d20:	85 bd       	out	0x25, r24	; 37
     d22:	80 e0       	ldi	r24, 0x00	; 0
     d24:	08 95       	ret
     d26:	87 e0       	ldi	r24, 0x07	; 7
     d28:	08 95       	ret
     d2a:	80 e0       	ldi	r24, 0x00	; 0
     d2c:	08 95       	ret

00000d2e <PWM_OCP_connect>:
     d2e:	84 30       	cpi	r24, 0x04	; 4
     d30:	40 f5       	brcc	.+80     	; 0xd82 <PWM_OCP_connect+0x54>
     d32:	81 30       	cpi	r24, 0x01	; 1
     d34:	71 f0       	breq	.+28     	; 0xd52 <PWM_OCP_connect+0x24>
     d36:	28 f0       	brcs	.+10     	; 0xd42 <PWM_OCP_connect+0x14>
     d38:	82 30       	cpi	r24, 0x02	; 2
     d3a:	99 f0       	breq	.+38     	; 0xd62 <PWM_OCP_connect+0x34>
     d3c:	83 30       	cpi	r24, 0x03	; 3
     d3e:	c9 f0       	breq	.+50     	; 0xd72 <PWM_OCP_connect+0x44>
     d40:	22 c0       	rjmp	.+68     	; 0xd86 <PWM_OCP_connect+0x58>
     d42:	83 b7       	in	r24, 0x33	; 51
     d44:	8f 7e       	andi	r24, 0xEF	; 239
     d46:	83 bf       	out	0x33, r24	; 51
     d48:	83 b7       	in	r24, 0x33	; 51
     d4a:	80 62       	ori	r24, 0x20	; 32
     d4c:	83 bf       	out	0x33, r24	; 51
     d4e:	80 e0       	ldi	r24, 0x00	; 0
     d50:	08 95       	ret
     d52:	8f b5       	in	r24, 0x2f	; 47
     d54:	8f 7b       	andi	r24, 0xBF	; 191
     d56:	8f bd       	out	0x2f, r24	; 47
     d58:	8f b5       	in	r24, 0x2f	; 47
     d5a:	80 68       	ori	r24, 0x80	; 128
     d5c:	8f bd       	out	0x2f, r24	; 47
     d5e:	80 e0       	ldi	r24, 0x00	; 0
     d60:	08 95       	ret
     d62:	8f b5       	in	r24, 0x2f	; 47
     d64:	8f 7e       	andi	r24, 0xEF	; 239
     d66:	8f bd       	out	0x2f, r24	; 47
     d68:	8f b5       	in	r24, 0x2f	; 47
     d6a:	80 62       	ori	r24, 0x20	; 32
     d6c:	8f bd       	out	0x2f, r24	; 47
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	08 95       	ret
     d72:	85 b5       	in	r24, 0x25	; 37
     d74:	8f 7e       	andi	r24, 0xEF	; 239
     d76:	85 bd       	out	0x25, r24	; 37
     d78:	85 b5       	in	r24, 0x25	; 37
     d7a:	80 62       	ori	r24, 0x20	; 32
     d7c:	85 bd       	out	0x25, r24	; 37
     d7e:	80 e0       	ldi	r24, 0x00	; 0
     d80:	08 95       	ret
     d82:	87 e0       	ldi	r24, 0x07	; 7
     d84:	08 95       	ret
     d86:	80 e0       	ldi	r24, 0x00	; 0
     d88:	08 95       	ret

00000d8a <PWM_set_DC>:
    }
  return TIMER_OK;
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
     d8a:	28 2f       	mov	r18, r24
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
     d8c:	84 30       	cpi	r24, 0x04	; 4
     d8e:	c0 f5       	brcc	.+112    	; 0xe00 <PWM_set_DC+0x76>
     d90:	cb 01       	movw	r24, r22
     d92:	ba 01       	movw	r22, r20
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
     d94:	21 30       	cpi	r18, 0x01	; 1
     d96:	89 f0       	breq	.+34     	; 0xdba <PWM_set_DC+0x30>
     d98:	28 f0       	brcs	.+10     	; 0xda4 <PWM_set_DC+0x1a>
     d9a:	22 30       	cpi	r18, 0x02	; 2
     d9c:	d1 f0       	breq	.+52     	; 0xdd2 <PWM_set_DC+0x48>
     d9e:	23 30       	cpi	r18, 0x03	; 3
     da0:	21 f1       	breq	.+72     	; 0xdea <PWM_set_DC+0x60>
     da2:	30 c0       	rjmp	.+96     	; 0xe04 <PWM_set_DC+0x7a>
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
     da4:	20 e0       	ldi	r18, 0x00	; 0
     da6:	30 e0       	ldi	r19, 0x00	; 0
     da8:	4f e7       	ldi	r20, 0x7F	; 127
     daa:	53 e4       	ldi	r21, 0x43	; 67
     dac:	0e 94 55 13 	call	0x26aa	; 0x26aa <__mulsf3>
     db0:	0e 94 98 12 	call	0x2530	; 0x2530 <__fixunssfsi>
     db4:	6c bf       	out	0x3c, r22	; 60
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     db6:	80 e0       	ldi	r24, 0x00	; 0
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
        break;
     db8:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     dba:	20 e0       	ldi	r18, 0x00	; 0
     dbc:	30 e4       	ldi	r19, 0x40	; 64
     dbe:	4c e9       	ldi	r20, 0x9C	; 156
     dc0:	56 e4       	ldi	r21, 0x46	; 70
     dc2:	0e 94 55 13 	call	0x26aa	; 0x26aa <__mulsf3>
     dc6:	0e 94 98 12 	call	0x2530	; 0x2530 <__fixunssfsi>
     dca:	7b bd       	out	0x2b, r23	; 43
     dcc:	6a bd       	out	0x2a, r22	; 42
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     dce:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1A = (u16)(dutyCycle * 65535);
#endif
        break;
     dd0:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     dd2:	20 e0       	ldi	r18, 0x00	; 0
     dd4:	30 e4       	ldi	r19, 0x40	; 64
     dd6:	4c e9       	ldi	r20, 0x9C	; 156
     dd8:	56 e4       	ldi	r21, 0x46	; 70
     dda:	0e 94 55 13 	call	0x26aa	; 0x26aa <__mulsf3>
     dde:	0e 94 98 12 	call	0x2530	; 0x2530 <__fixunssfsi>
     de2:	79 bd       	out	0x29, r23	; 41
     de4:	68 bd       	out	0x28, r22	; 40
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     de6:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
     de8:	08 95       	ret
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
     dea:	20 e0       	ldi	r18, 0x00	; 0
     dec:	30 e0       	ldi	r19, 0x00	; 0
     dee:	4f e7       	ldi	r20, 0x7F	; 127
     df0:	53 e4       	ldi	r21, 0x43	; 67
     df2:	0e 94 55 13 	call	0x26aa	; 0x26aa <__mulsf3>
     df6:	0e 94 98 12 	call	0x2530	; 0x2530 <__fixunssfsi>
     dfa:	63 bd       	out	0x23, r22	; 35
        break;
    }
  return TIMER_OK;
     dfc:	80 e0       	ldi	r24, 0x00	; 0
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
     dfe:	08 95       	ret
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
     e00:	87 e0       	ldi	r24, 0x07	; 7
     e02:	08 95       	ret
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     e04:	80 e0       	ldi	r24, 0x00	; 0
  }
     e06:	08 95       	ret

00000e08 <UART_sendChar>:
  }

// Receive a Char using UART
void UART_receiveChar(s8* x) {
  while (!read_bit(UCSRA, RXC)); // Wait for the data to be received.
  *x = UDR;
     e08:	5d 9b       	sbis	0x0b, 5	; 11
     e0a:	fe cf       	rjmp	.-4      	; 0xe08 <UART_sendChar>
     e0c:	8c b9       	out	0x0c, r24	; 12
     e0e:	5e 9b       	sbis	0x0b, 6	; 11
     e10:	fe cf       	rjmp	.-4      	; 0xe0e <UART_sendChar+0x6>
     e12:	08 95       	ret

00000e14 <UART_sendString>:
  }

void UART_sendString(s8* str) {
     e14:	cf 92       	push	r12
     e16:	df 92       	push	r13
     e18:	ef 92       	push	r14
     e1a:	ff 92       	push	r15
     e1c:	cf 93       	push	r28
     e1e:	df 93       	push	r29
     e20:	ec 01       	movw	r28, r24
  u32 i = 0;
     e22:	c1 2c       	mov	r12, r1
     e24:	d1 2c       	mov	r13, r1
     e26:	76 01       	movw	r14, r12
  while (str[i] != 0) {
     e28:	07 c0       	rjmp	.+14     	; 0xe38 <UART_sendString+0x24>
    UART_sendChar(str[i]);
     e2a:	0e 94 04 07 	call	0xe08	; 0xe08 <UART_sendChar>
    i++;
     e2e:	8f ef       	ldi	r24, 0xFF	; 255
     e30:	c8 1a       	sub	r12, r24
     e32:	d8 0a       	sbc	r13, r24
     e34:	e8 0a       	sbc	r14, r24
     e36:	f8 0a       	sbc	r15, r24
  *x = UDR;
  }

void UART_sendString(s8* str) {
  u32 i = 0;
  while (str[i] != 0) {
     e38:	fe 01       	movw	r30, r28
     e3a:	ec 0d       	add	r30, r12
     e3c:	fd 1d       	adc	r31, r13
     e3e:	80 81       	ld	r24, Z
     e40:	81 11       	cpse	r24, r1
     e42:	f3 cf       	rjmp	.-26     	; 0xe2a <UART_sendString+0x16>
    UART_sendChar(str[i]);
    i++;
    }
  UART_sendChar(0); // Send null to terminate the string
     e44:	0e 94 04 07 	call	0xe08	; 0xe08 <UART_sendChar>
  }
     e48:	df 91       	pop	r29
     e4a:	cf 91       	pop	r28
     e4c:	ff 90       	pop	r15
     e4e:	ef 90       	pop	r14
     e50:	df 90       	pop	r13
     e52:	cf 90       	pop	r12
     e54:	08 95       	ret

00000e56 <Door_open>:
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
  }

// Open the door by moving the servo to the open angle
void Door_open(void) {
  Servo_move_to_angle(DOOR_OPEN_ANGLE);
     e56:	84 eb       	ldi	r24, 0xB4	; 180
     e58:	0e 94 f7 03 	call	0x7ee	; 0x7ee <Servo_move_to_angle>
     e5c:	08 95       	ret

00000e5e <Door_close>:
  }

// Close the door by moving the servo to the close angle
void Door_close(void) {
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
     e5e:	80 e0       	ldi	r24, 0x00	; 0
     e60:	0e 94 f7 03 	call	0x7ee	; 0x7ee <Servo_move_to_angle>
     e64:	08 95       	ret

00000e66 <Lamp_on>:
  Timer_start(TIMER_2, LAMP_6_DIMMABLE_PRESCALAR);
  }

// Turn on a lamp
void Lamp_on(u8 lampNumber) {
  switch (lampNumber) {
     e66:	83 30       	cpi	r24, 0x03	; 3
     e68:	b1 f0       	breq	.+44     	; 0xe96 <Lamp_on+0x30>
     e6a:	28 f4       	brcc	.+10     	; 0xe76 <Lamp_on+0x10>
     e6c:	81 30       	cpi	r24, 0x01	; 1
     e6e:	49 f0       	breq	.+18     	; 0xe82 <Lamp_on+0x1c>
     e70:	82 30       	cpi	r24, 0x02	; 2
     e72:	61 f0       	breq	.+24     	; 0xe8c <Lamp_on+0x26>
     e74:	08 95       	ret
     e76:	85 30       	cpi	r24, 0x05	; 5
     e78:	c1 f0       	breq	.+48     	; 0xeaa <Lamp_on+0x44>
     e7a:	90 f0       	brcs	.+36     	; 0xea0 <Lamp_on+0x3a>
     e7c:	86 30       	cpi	r24, 0x06	; 6
     e7e:	d1 f0       	breq	.+52     	; 0xeb4 <Lamp_on+0x4e>
     e80:	08 95       	ret
      case LAMP_1:
        LED_on(LAMP_1_PORT, LAMP_1_PIN);
     e82:	62 e0       	ldi	r22, 0x02	; 2
     e84:	83 e4       	ldi	r24, 0x43	; 67
     e86:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LED_on>
        break;
     e8a:	08 95       	ret
      case LAMP_2:
        LED_on(LAMP_2_PORT, LAMP_2_PIN);
     e8c:	63 e0       	ldi	r22, 0x03	; 3
     e8e:	83 e4       	ldi	r24, 0x43	; 67
     e90:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LED_on>
        break;
     e94:	08 95       	ret
      case LAMP_3:
        LED_on(LAMP_3_PORT, LAMP_3_PIN);
     e96:	64 e0       	ldi	r22, 0x04	; 4
     e98:	83 e4       	ldi	r24, 0x43	; 67
     e9a:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LED_on>
        break;
     e9e:	08 95       	ret
      case LAMP_4:
        LED_on(LAMP_4_PORT, LAMP_4_PIN);
     ea0:	65 e0       	ldi	r22, 0x05	; 5
     ea2:	83 e4       	ldi	r24, 0x43	; 67
     ea4:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LED_on>
        break;
     ea8:	08 95       	ret
      case LAMP_5:
        LED_on(LAMP_5_PORT, LAMP_5_PIN);
     eaa:	66 e0       	ldi	r22, 0x06	; 6
     eac:	83 e4       	ldi	r24, 0x43	; 67
     eae:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LED_on>
        break;
     eb2:	08 95       	ret
      case LAMP_6:
        PWM_OCP_connect(LAMP_6_DIMMABLE_PWM_PIN);
     eb4:	83 e0       	ldi	r24, 0x03	; 3
     eb6:	0e 94 97 06 	call	0xd2e	; 0xd2e <PWM_OCP_connect>
     eba:	08 95       	ret

00000ebc <Lamp_off>:
    }
  }

// Turn off a lamp
void Lamp_off(u8 lampNumber) {
  switch (lampNumber) {
     ebc:	83 30       	cpi	r24, 0x03	; 3
     ebe:	b1 f0       	breq	.+44     	; 0xeec <Lamp_off+0x30>
     ec0:	28 f4       	brcc	.+10     	; 0xecc <Lamp_off+0x10>
     ec2:	81 30       	cpi	r24, 0x01	; 1
     ec4:	49 f0       	breq	.+18     	; 0xed8 <Lamp_off+0x1c>
     ec6:	82 30       	cpi	r24, 0x02	; 2
     ec8:	61 f0       	breq	.+24     	; 0xee2 <Lamp_off+0x26>
     eca:	08 95       	ret
     ecc:	85 30       	cpi	r24, 0x05	; 5
     ece:	c1 f0       	breq	.+48     	; 0xf00 <Lamp_off+0x44>
     ed0:	90 f0       	brcs	.+36     	; 0xef6 <Lamp_off+0x3a>
     ed2:	86 30       	cpi	r24, 0x06	; 6
     ed4:	d1 f0       	breq	.+52     	; 0xf0a <Lamp_off+0x4e>
     ed6:	08 95       	ret
      case LAMP_1:
        LED_off(LAMP_1_PORT, LAMP_1_PIN);
     ed8:	62 e0       	ldi	r22, 0x02	; 2
     eda:	83 e4       	ldi	r24, 0x43	; 67
     edc:	0e 94 e6 03 	call	0x7cc	; 0x7cc <LED_off>
        break;
     ee0:	08 95       	ret
      case LAMP_2:
        LED_off(LAMP_2_PORT, LAMP_2_PIN);
     ee2:	63 e0       	ldi	r22, 0x03	; 3
     ee4:	83 e4       	ldi	r24, 0x43	; 67
     ee6:	0e 94 e6 03 	call	0x7cc	; 0x7cc <LED_off>
        break;
     eea:	08 95       	ret
      case LAMP_3:
        LED_off(LAMP_3_PORT, LAMP_3_PIN);
     eec:	64 e0       	ldi	r22, 0x04	; 4
     eee:	83 e4       	ldi	r24, 0x43	; 67
     ef0:	0e 94 e6 03 	call	0x7cc	; 0x7cc <LED_off>
        break;
     ef4:	08 95       	ret
      case LAMP_4:
        LED_off(LAMP_4_PORT, LAMP_4_PIN);
     ef6:	65 e0       	ldi	r22, 0x05	; 5
     ef8:	83 e4       	ldi	r24, 0x43	; 67
     efa:	0e 94 e6 03 	call	0x7cc	; 0x7cc <LED_off>
        break;
     efe:	08 95       	ret
      case LAMP_5:
        LED_off(LAMP_5_PORT, LAMP_5_PIN);
     f00:	66 e0       	ldi	r22, 0x06	; 6
     f02:	83 e4       	ldi	r24, 0x43	; 67
     f04:	0e 94 e6 03 	call	0x7cc	; 0x7cc <LED_off>
        break;
     f08:	08 95       	ret
      case LAMP_6:
        PWM_OCP_disconnect(LAMP_6_DIMMABLE_PWM_PIN);
     f0a:	83 e0       	ldi	r24, 0x03	; 3
     f0c:	0e 94 69 06 	call	0xcd2	; 0xcd2 <PWM_OCP_disconnect>
     f10:	08 95       	ret

00000f12 <Lamp_toggle>:
    }
  }

// Toggle a lamp
void Lamp_toggle(u8 lampNumber) {
  switch (lampNumber) {
     f12:	83 30       	cpi	r24, 0x03	; 3
     f14:	b1 f0       	breq	.+44     	; 0xf42 <Lamp_toggle+0x30>
     f16:	28 f4       	brcc	.+10     	; 0xf22 <Lamp_toggle+0x10>
     f18:	81 30       	cpi	r24, 0x01	; 1
     f1a:	49 f0       	breq	.+18     	; 0xf2e <Lamp_toggle+0x1c>
     f1c:	82 30       	cpi	r24, 0x02	; 2
     f1e:	61 f0       	breq	.+24     	; 0xf38 <Lamp_toggle+0x26>
     f20:	08 95       	ret
     f22:	85 30       	cpi	r24, 0x05	; 5
     f24:	c1 f0       	breq	.+48     	; 0xf56 <Lamp_toggle+0x44>
     f26:	90 f0       	brcs	.+36     	; 0xf4c <Lamp_toggle+0x3a>
     f28:	86 30       	cpi	r24, 0x06	; 6
     f2a:	d1 f0       	breq	.+52     	; 0xf60 <Lamp_toggle+0x4e>
     f2c:	08 95       	ret
      case LAMP_1:
        LED_toggle(LAMP_1_PORT, LAMP_1_PIN);
     f2e:	62 e0       	ldi	r22, 0x02	; 2
     f30:	83 e4       	ldi	r24, 0x43	; 67
     f32:	0e 94 ef 03 	call	0x7de	; 0x7de <LED_toggle>
        break;
     f36:	08 95       	ret
      case LAMP_2:
        LED_toggle(LAMP_2_PORT, LAMP_2_PIN);
     f38:	63 e0       	ldi	r22, 0x03	; 3
     f3a:	83 e4       	ldi	r24, 0x43	; 67
     f3c:	0e 94 ef 03 	call	0x7de	; 0x7de <LED_toggle>
        break;
     f40:	08 95       	ret
      case LAMP_3:
        LED_toggle(LAMP_3_PORT, LAMP_3_PIN);
     f42:	64 e0       	ldi	r22, 0x04	; 4
     f44:	83 e4       	ldi	r24, 0x43	; 67
     f46:	0e 94 ef 03 	call	0x7de	; 0x7de <LED_toggle>
        break;
     f4a:	08 95       	ret
      case LAMP_4:
        LED_toggle(LAMP_4_PORT, LAMP_4_PIN);
     f4c:	65 e0       	ldi	r22, 0x05	; 5
     f4e:	83 e4       	ldi	r24, 0x43	; 67
     f50:	0e 94 ef 03 	call	0x7de	; 0x7de <LED_toggle>
        break;
     f54:	08 95       	ret
      case LAMP_5:
        LED_toggle(LAMP_5_PORT, LAMP_5_PIN);
     f56:	66 e0       	ldi	r22, 0x06	; 6
     f58:	83 e4       	ldi	r24, 0x43	; 67
     f5a:	0e 94 ef 03 	call	0x7de	; 0x7de <LED_toggle>
        break;
     f5e:	08 95       	ret
      case LAMP_6:
        if (read_bit(TCCR2, COM21)) { // OC pin is connected and lamp6 is on
     f60:	05 b4       	in	r0, 0x25	; 37
     f62:	05 fe       	sbrs	r0, 5
     f64:	04 c0       	rjmp	.+8      	; 0xf6e <Lamp_toggle+0x5c>
          Lamp_off(6);
     f66:	86 e0       	ldi	r24, 0x06	; 6
     f68:	0e 94 5e 07 	call	0xebc	; 0xebc <Lamp_off>
     f6c:	08 95       	ret
          }
        else {
          Lamp_on(6);
     f6e:	86 e0       	ldi	r24, 0x06	; 6
     f70:	0e 94 33 07 	call	0xe66	; 0xe66 <Lamp_on>
     f74:	08 95       	ret

00000f76 <Lamp_dimmable_set_brightness>:
        break;
    }
  }

// Adjust the brightness of the dimmable lamp
void Lamp_dimmable_set_brightness(double brightness) {
     f76:	ab 01       	movw	r20, r22
     f78:	bc 01       	movw	r22, r24
  PWM_set_DC(LAMP_6_DIMMABLE_PWM_PIN, brightness);
     f7a:	83 e0       	ldi	r24, 0x03	; 3
     f7c:	0e 94 c5 06 	call	0xd8a	; 0xd8a <PWM_set_DC>
     f80:	08 95       	ret

00000f82 <Local_access_init>:

ST_User_t local_user;

// Initialize the local control system
void Local_access_init(void) {
  LCD_init();
     f82:	0e 94 66 03 	call	0x6cc	; 0x6cc <LCD_init>
  Keypad_init();
     f86:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <Keypad_init>
  User_DB_init();
     f8a:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <User_DB_init>
     f8e:	08 95       	ret

00000f90 <Get_running_devices>:
  }

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
     f90:	cf 93       	push	r28
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
     f92:	c0 e0       	ldi	r28, 0x00	; 0
     f94:	0a c0       	rjmp	.+20     	; 0xfaa <Get_running_devices+0x1a>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
     f96:	4c 2f       	mov	r20, r28
     f98:	50 e0       	ldi	r21, 0x00	; 0
     f9a:	45 5a       	subi	r20, 0xA5	; 165
     f9c:	58 4f       	sbci	r21, 0xF8	; 248
     f9e:	63 e4       	ldi	r22, 0x43	; 67
     fa0:	82 e0       	ldi	r24, 0x02	; 2
     fa2:	8c 0f       	add	r24, r28
     fa4:	0e 94 6b 05 	call	0xad6	; 0xad6 <DIO_Read>

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
     fa8:	cf 5f       	subi	r28, 0xFF	; 255
     faa:	c5 30       	cpi	r28, 0x05	; 5
     fac:	a0 f3       	brcs	.-24     	; 0xf96 <Get_running_devices+0x6>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
    }
  // Check the dimmable lamp
  running_devices[5] = read_bit(TCCR2, COM21); // To see if the OC pins are connected
     fae:	85 b5       	in	r24, 0x25	; 37
     fb0:	85 fb       	bst	r24, 5
     fb2:	88 27       	eor	r24, r24
     fb4:	80 f9       	bld	r24, 0
     fb6:	80 93 60 07 	sts	0x0760, r24	; 0x800760 <running_devices+0x5>
  // Check the AC
  DIO_Read(7, PORT_D, &running_devices[6]);
     fba:	41 e6       	ldi	r20, 0x61	; 97
     fbc:	57 e0       	ldi	r21, 0x07	; 7
     fbe:	64 e4       	ldi	r22, 0x44	; 68
     fc0:	87 e0       	ldi	r24, 0x07	; 7
     fc2:	0e 94 6b 05 	call	0xad6	; 0xad6 <DIO_Read>
  }
     fc6:	cf 91       	pop	r28
     fc8:	08 95       	ret

00000fca <Show_bottom_options_menu>:

// Shows the bottom line options on the LCD
void Show_bottom_options_menu(u8 menu) {
  switch (menu) {
     fca:	90 e0       	ldi	r25, 0x00	; 0
     fcc:	fc 01       	movw	r30, r24
     fce:	31 97       	sbiw	r30, 0x01	; 1
     fd0:	e9 30       	cpi	r30, 0x09	; 9
     fd2:	f1 05       	cpc	r31, r1
     fd4:	08 f0       	brcs	.+2      	; 0xfd8 <Show_bottom_options_menu+0xe>
     fd6:	42 c0       	rjmp	.+132    	; 0x105c <Show_bottom_options_menu+0x92>
     fd8:	e5 58       	subi	r30, 0x85	; 133
     fda:	ff 4f       	sbci	r31, 0xFF	; 255
     fdc:	0c 94 c2 13 	jmp	0x2784	; 0x2784 <__tablejump2__>
      case 1:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_1);
     fe0:	41 e7       	ldi	r20, 0x71	; 113
     fe2:	50 e0       	ldi	r21, 0x00	; 0
     fe4:	61 e0       	ldi	r22, 0x01	; 1
     fe6:	80 e0       	ldi	r24, 0x00	; 0
     fe8:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
     fec:	08 95       	ret
      case 2:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_2);
     fee:	42 e8       	ldi	r20, 0x82	; 130
     ff0:	50 e0       	ldi	r21, 0x00	; 0
     ff2:	61 e0       	ldi	r22, 0x01	; 1
     ff4:	80 e0       	ldi	r24, 0x00	; 0
     ff6:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
     ffa:	08 95       	ret
      case 3:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_3);
     ffc:	43 e9       	ldi	r20, 0x93	; 147
     ffe:	50 e0       	ldi	r21, 0x00	; 0
    1000:	61 e0       	ldi	r22, 0x01	; 1
    1002:	80 e0       	ldi	r24, 0x00	; 0
    1004:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    1008:	08 95       	ret
      case 4:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_4);
    100a:	44 ea       	ldi	r20, 0xA4	; 164
    100c:	50 e0       	ldi	r21, 0x00	; 0
    100e:	61 e0       	ldi	r22, 0x01	; 1
    1010:	80 e0       	ldi	r24, 0x00	; 0
    1012:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    1016:	08 95       	ret
      case 5:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_5);
    1018:	45 eb       	ldi	r20, 0xB5	; 181
    101a:	50 e0       	ldi	r21, 0x00	; 0
    101c:	61 e0       	ldi	r22, 0x01	; 1
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    1024:	08 95       	ret
      case 6:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_6);
    1026:	46 ec       	ldi	r20, 0xC6	; 198
    1028:	50 e0       	ldi	r21, 0x00	; 0
    102a:	61 e0       	ldi	r22, 0x01	; 1
    102c:	80 e0       	ldi	r24, 0x00	; 0
    102e:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    1032:	08 95       	ret
      case 7:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_7);
    1034:	47 ed       	ldi	r20, 0xD7	; 215
    1036:	50 e0       	ldi	r21, 0x00	; 0
    1038:	61 e0       	ldi	r22, 0x01	; 1
    103a:	80 e0       	ldi	r24, 0x00	; 0
    103c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    1040:	08 95       	ret
      case 8:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_8);
    1042:	48 ee       	ldi	r20, 0xE8	; 232
    1044:	50 e0       	ldi	r21, 0x00	; 0
    1046:	61 e0       	ldi	r22, 0x01	; 1
    1048:	80 e0       	ldi	r24, 0x00	; 0
    104a:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    104e:	08 95       	ret
      case 9:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_9);
    1050:	49 ef       	ldi	r20, 0xF9	; 249
    1052:	50 e0       	ldi	r21, 0x00	; 0
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	80 e0       	ldi	r24, 0x00	; 0
    1058:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
    105c:	08 95       	ret

0000105e <Show_side_options_menu>:
    }
  }

// Shows the side options list on the LCD
void Show_side_options_menu(void) {
  LCD_write_string_xy(12, 0, BACKSPACE_OPTION);
    105e:	4a e0       	ldi	r20, 0x0A	; 10
    1060:	51 e0       	ldi	r21, 0x01	; 1
    1062:	60 e0       	ldi	r22, 0x00	; 0
    1064:	8c e0       	ldi	r24, 0x0C	; 12
    1066:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
  LCD_write_string_xy(12, 1, ENTER_OPTION);
    106a:	4f e0       	ldi	r20, 0x0F	; 15
    106c:	51 e0       	ldi	r21, 0x01	; 1
    106e:	61 e0       	ldi	r22, 0x01	; 1
    1070:	8c e0       	ldi	r24, 0x0C	; 12
    1072:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
    1076:	08 95       	ret

00001078 <Get_devices_status>:
  }

// Updates the device status array, which has lamp 6 brightness level 
void Get_devices_status(void) {
    1078:	cf 93       	push	r28
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    107a:	c0 e0       	ldi	r28, 0x00	; 0
    107c:	0a c0       	rjmp	.+20     	; 0x1092 <Get_devices_status+0x1a>
    DIO_Read(lamp + 2, PORT_C, &devices_status[lamp]);
    107e:	4c 2f       	mov	r20, r28
    1080:	50 e0       	ldi	r21, 0x00	; 0
    1082:	4b 59       	subi	r20, 0x9B	; 155
    1084:	58 4f       	sbci	r21, 0xF8	; 248
    1086:	63 e4       	ldi	r22, 0x43	; 67
    1088:	82 e0       	ldi	r24, 0x02	; 2
    108a:	8c 0f       	add	r24, r28
    108c:	0e 94 6b 05 	call	0xad6	; 0xad6 <DIO_Read>

// Updates the device status array, which has lamp 6 brightness level 
void Get_devices_status(void) {
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    1090:	cf 5f       	subi	r28, 0xFF	; 255
    1092:	c5 30       	cpi	r28, 0x05	; 5
    1094:	a0 f3       	brcs	.-24     	; 0x107e <Get_devices_status+0x6>
    DIO_Read(lamp + 2, PORT_C, &devices_status[lamp]);
    }
  devices_status[5] = (u8)(OCR1A / 200);
    1096:	2a b5       	in	r18, 0x2a	; 42
    1098:	3b b5       	in	r19, 0x2b	; 43
    109a:	36 95       	lsr	r19
    109c:	27 95       	ror	r18
    109e:	36 95       	lsr	r19
    10a0:	27 95       	ror	r18
    10a2:	36 95       	lsr	r19
    10a4:	27 95       	ror	r18
    10a6:	ab e7       	ldi	r26, 0x7B	; 123
    10a8:	b4 e1       	ldi	r27, 0x14	; 20
    10aa:	0e 94 c8 13 	call	0x2790	; 0x2790 <__umulhisi3>
    10ae:	96 95       	lsr	r25
    10b0:	87 95       	ror	r24
    10b2:	80 93 6a 07 	sts	0x076A, r24	; 0x80076a <devices_status+0x5>
  }
    10b6:	cf 91       	pop	r28
    10b8:	08 95       	ret

000010ba <Show_running_devices>:

// Shows the currently running devices with the appropriate control menu appended (Screen controls and login- no device controls)
void Show_running_devices(u8 screen) {
    10ba:	cf 93       	push	r28
    10bc:	c8 2f       	mov	r28, r24
  // Do nothing if the correct screen is shown.
  // if (screen == running_devices_screen) return;
  LCD_clear_screen();
    10be:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
  // Write device name
  switch (screen) {
    10c2:	c7 30       	cpi	r28, 0x07	; 7
    10c4:	39 f4       	brne	.+14     	; 0x10d4 <Show_running_devices+0x1a>
      case 7:
        LCD_write_string_xy(0, 0, "AC: ");
    10c6:	44 e1       	ldi	r20, 0x14	; 20
    10c8:	51 e0       	ldi	r21, 0x01	; 1
    10ca:	60 e0       	ldi	r22, 0x00	; 0
    10cc:	80 e0       	ldi	r24, 0x00	; 0
    10ce:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    10d2:	0e c0       	rjmp	.+28     	; 0x10f0 <Show_running_devices+0x36>
      default:
        LCD_write_string_xy(0, 0, "Lamp");
    10d4:	49 e1       	ldi	r20, 0x19	; 25
    10d6:	51 e0       	ldi	r21, 0x01	; 1
    10d8:	60 e0       	ldi	r22, 0x00	; 0
    10da:	80 e0       	ldi	r24, 0x00	; 0
    10dc:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        LCD_sendData(screen + 48);
    10e0:	80 e3       	ldi	r24, 0x30	; 48
    10e2:	8c 0f       	add	r24, r28
    10e4:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
        LCD_write_string(": ");
    10e8:	8e e5       	ldi	r24, 0x5E	; 94
    10ea:	96 e0       	ldi	r25, 0x06	; 6
    10ec:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
        break;
    }
  // Write the device state
  if (running_devices[screen - 1])
    10f0:	ec 2f       	mov	r30, r28
    10f2:	f0 e0       	ldi	r31, 0x00	; 0
    10f4:	e6 5a       	subi	r30, 0xA6	; 166
    10f6:	f8 4f       	sbci	r31, 0xF8	; 248
    10f8:	80 81       	ld	r24, Z
    10fa:	88 23       	and	r24, r24
    10fc:	29 f0       	breq	.+10     	; 0x1108 <Show_running_devices+0x4e>
    LCD_write_string("On");
    10fe:	8e e1       	ldi	r24, 0x1E	; 30
    1100:	91 e0       	ldi	r25, 0x01	; 1
    1102:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
    1106:	04 c0       	rjmp	.+8      	; 0x1110 <Show_running_devices+0x56>
  else
    LCD_write_string("Off");
    1108:	81 e2       	ldi	r24, 0x21	; 33
    110a:	91 e0       	ldi	r25, 0x01	; 1
    110c:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
  // Show the options menu
  switch (screen) {
    1110:	c1 30       	cpi	r28, 0x01	; 1
    1112:	19 f0       	breq	.+6      	; 0x111a <Show_running_devices+0x60>
    1114:	c7 30       	cpi	r28, 0x07	; 7
    1116:	29 f0       	breq	.+10     	; 0x1122 <Show_running_devices+0x68>
    1118:	08 c0       	rjmp	.+16     	; 0x112a <Show_running_devices+0x70>
      case 1:
        Show_bottom_options_menu(3);
    111a:	83 e0       	ldi	r24, 0x03	; 3
    111c:	0e 94 e5 07 	call	0xfca	; 0xfca <Show_bottom_options_menu>
        break;
    1120:	07 c0       	rjmp	.+14     	; 0x1130 <Show_running_devices+0x76>
      case 7:
        Show_bottom_options_menu(2);
    1122:	82 e0       	ldi	r24, 0x02	; 2
    1124:	0e 94 e5 07 	call	0xfca	; 0xfca <Show_bottom_options_menu>
        break;
    1128:	03 c0       	rjmp	.+6      	; 0x1130 <Show_running_devices+0x76>
      default:
        Show_bottom_options_menu(1);
    112a:	81 e0       	ldi	r24, 0x01	; 1
    112c:	0e 94 e5 07 	call	0xfca	; 0xfca <Show_bottom_options_menu>
        break;
    }
  }
    1130:	cf 91       	pop	r28
    1132:	08 95       	ret

00001134 <Show_devices_controls>:

// Shows the currently running devices with the appropriate control menu appended (Devices' controls)
void Show_devices_controls(u8 screen) {
    1134:	1f 93       	push	r17
    1136:	cf 93       	push	r28
    1138:	df 93       	push	r29
    113a:	00 d0       	rcall	.+0      	; 0x113c <Show_devices_controls+0x8>
    113c:	00 d0       	rcall	.+0      	; 0x113e <Show_devices_controls+0xa>
    113e:	cd b7       	in	r28, 0x3d	; 61
    1140:	de b7       	in	r29, 0x3e	; 62
    1142:	18 2f       	mov	r17, r24
  // Do nothing if the correct screen is shown.
  // if (screen == control_devices_screen) return;
  LCD_clear_screen();
    1144:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
  LCD_write_string_xy(0, 0, "Lamp");
    1148:	49 e1       	ldi	r20, 0x19	; 25
    114a:	51 e0       	ldi	r21, 0x01	; 1
    114c:	60 e0       	ldi	r22, 0x00	; 0
    114e:	80 e0       	ldi	r24, 0x00	; 0
    1150:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
  LCD_sendData(screen + 48);
    1154:	80 e3       	ldi	r24, 0x30	; 48
    1156:	81 0f       	add	r24, r17
    1158:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
  LCD_write_string(":  ");
    115c:	85 e2       	ldi	r24, 0x25	; 37
    115e:	91 e0       	ldi	r25, 0x01	; 1
    1160:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>

  if (screen < 6) {
    1164:	16 30       	cpi	r17, 0x06	; 6
    1166:	88 f4       	brcc	.+34     	; 0x118a <Show_devices_controls+0x56>
    // Write the device state
    if (devices_status[screen - 1])
    1168:	e1 2f       	mov	r30, r17
    116a:	f0 e0       	ldi	r31, 0x00	; 0
    116c:	ec 59       	subi	r30, 0x9C	; 156
    116e:	f8 4f       	sbci	r31, 0xF8	; 248
    1170:	80 81       	ld	r24, Z
    1172:	88 23       	and	r24, r24
    1174:	29 f0       	breq	.+10     	; 0x1180 <Show_devices_controls+0x4c>
      LCD_write_string("On");
    1176:	8e e1       	ldi	r24, 0x1E	; 30
    1178:	91 e0       	ldi	r25, 0x01	; 1
    117a:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
    117e:	19 c0       	rjmp	.+50     	; 0x11b2 <Show_devices_controls+0x7e>
    else
      LCD_write_string("Off");
    1180:	81 e2       	ldi	r24, 0x21	; 33
    1182:	91 e0       	ldi	r25, 0x01	; 1
    1184:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
    1188:	14 c0       	rjmp	.+40     	; 0x11b2 <Show_devices_controls+0x7e>
    }
  else {
    s8 brightness[4];
    sprintf(brightness, "%d%%", devices_status[5]);
    118a:	80 91 6a 07 	lds	r24, 0x076A	; 0x80076a <devices_status+0x5>
    118e:	1f 92       	push	r1
    1190:	8f 93       	push	r24
    1192:	89 e2       	ldi	r24, 0x29	; 41
    1194:	91 e0       	ldi	r25, 0x01	; 1
    1196:	9f 93       	push	r25
    1198:	8f 93       	push	r24
    119a:	ce 01       	movw	r24, r28
    119c:	01 96       	adiw	r24, 0x01	; 1
    119e:	9f 93       	push	r25
    11a0:	8f 93       	push	r24
    11a2:	0e 94 e7 13 	call	0x27ce	; 0x27ce <sprintf>
    11a6:	0f 90       	pop	r0
    11a8:	0f 90       	pop	r0
    11aa:	0f 90       	pop	r0
    11ac:	0f 90       	pop	r0
    11ae:	0f 90       	pop	r0
    11b0:	0f 90       	pop	r0
    }
  // Show the options menu
  switch (screen) {
    11b2:	11 30       	cpi	r17, 0x01	; 1
    11b4:	19 f0       	breq	.+6      	; 0x11bc <Show_devices_controls+0x88>
    11b6:	16 30       	cpi	r17, 0x06	; 6
    11b8:	69 f0       	breq	.+26     	; 0x11d4 <Show_devices_controls+0xa0>
    11ba:	10 c0       	rjmp	.+32     	; 0x11dc <Show_devices_controls+0xa8>
      case 1:
        if (devices_status[0])
    11bc:	80 91 65 07 	lds	r24, 0x0765	; 0x800765 <devices_status>
    11c0:	88 23       	and	r24, r24
    11c2:	21 f0       	breq	.+8      	; 0x11cc <Show_devices_controls+0x98>
          Show_bottom_options_menu(8);
    11c4:	88 e0       	ldi	r24, 0x08	; 8
    11c6:	0e 94 e5 07 	call	0xfca	; 0xfca <Show_bottom_options_menu>
    11ca:	16 c0       	rjmp	.+44     	; 0x11f8 <Show_devices_controls+0xc4>
        else
          Show_bottom_options_menu(7);
    11cc:	87 e0       	ldi	r24, 0x07	; 7
    11ce:	0e 94 e5 07 	call	0xfca	; 0xfca <Show_bottom_options_menu>
    11d2:	12 c0       	rjmp	.+36     	; 0x11f8 <Show_devices_controls+0xc4>
        break;
      case 6:
        Show_bottom_options_menu(9);
    11d4:	89 e0       	ldi	r24, 0x09	; 9
    11d6:	0e 94 e5 07 	call	0xfca	; 0xfca <Show_bottom_options_menu>
        break;
    11da:	0e c0       	rjmp	.+28     	; 0x11f8 <Show_devices_controls+0xc4>
      default:
        if (devices_status[screen - 1])
    11dc:	e1 2f       	mov	r30, r17
    11de:	f0 e0       	ldi	r31, 0x00	; 0
    11e0:	ec 59       	subi	r30, 0x9C	; 156
    11e2:	f8 4f       	sbci	r31, 0xF8	; 248
    11e4:	80 81       	ld	r24, Z
    11e6:	88 23       	and	r24, r24
    11e8:	21 f0       	breq	.+8      	; 0x11f2 <Show_devices_controls+0xbe>
          Show_bottom_options_menu(6);
    11ea:	86 e0       	ldi	r24, 0x06	; 6
    11ec:	0e 94 e5 07 	call	0xfca	; 0xfca <Show_bottom_options_menu>
    11f0:	03 c0       	rjmp	.+6      	; 0x11f8 <Show_devices_controls+0xc4>
        else
          Show_bottom_options_menu(5);
    11f2:	85 e0       	ldi	r24, 0x05	; 5
    11f4:	0e 94 e5 07 	call	0xfca	; 0xfca <Show_bottom_options_menu>
        break;
    }
  }
    11f8:	0f 90       	pop	r0
    11fa:	0f 90       	pop	r0
    11fc:	0f 90       	pop	r0
    11fe:	0f 90       	pop	r0
    1200:	df 91       	pop	r29
    1202:	cf 91       	pop	r28
    1204:	1f 91       	pop	r17
    1206:	08 95       	ret

00001208 <invalid_local_login_attempt>:

// Handles setting the alarm and halting the system when the user enters invalid credentials during login
void invalid_local_login_attempt(void) {
  invalid_trails++;
    1208:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <__data_end>
    120c:	8f 5f       	subi	r24, 0xFF	; 255
    120e:	80 93 44 07 	sts	0x0744, r24	; 0x800744 <__data_end>
  if (invalid_trails < 3) {
    1212:	83 30       	cpi	r24, 0x03	; 3
    1214:	00 f5       	brcc	.+64     	; 0x1256 <invalid_local_login_attempt+0x4e>
    LCD_clear_screen();
    1216:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
    LCD_move_cursor_xy(3, 0);
    121a:	60 e0       	ldi	r22, 0x00	; 0
    121c:	83 e0       	ldi	r24, 0x03	; 3
    121e:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
    LCD_sendData((3 - invalid_trails) + 48);
    1222:	90 91 44 07 	lds	r25, 0x0744	; 0x800744 <__data_end>
    1226:	83 e3       	ldi	r24, 0x33	; 51
    1228:	89 1b       	sub	r24, r25
    122a:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
    LCD_write_string(" attempts");
    122e:	8e e2       	ldi	r24, 0x2E	; 46
    1230:	91 e0       	ldi	r25, 0x01	; 1
    1232:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
    LCD_write_string_xy(3, 1, "remaining !");
    1236:	48 e3       	ldi	r20, 0x38	; 56
    1238:	51 e0       	ldi	r21, 0x01	; 1
    123a:	61 e0       	ldi	r22, 0x01	; 1
    123c:	83 e0       	ldi	r24, 0x03	; 3
    123e:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
    1242:	2f ef       	ldi	r18, 0xFF	; 255
    1244:	8d e3       	ldi	r24, 0x3D	; 61
    1246:	99 e4       	ldi	r25, 0x49	; 73
    1248:	21 50       	subi	r18, 0x01	; 1
    124a:	80 40       	sbci	r24, 0x00	; 0
    124c:	90 40       	sbci	r25, 0x00	; 0
    124e:	e1 f7       	brne	.-8      	; 0x1248 <invalid_local_login_attempt+0x40>
    1250:	00 c0       	rjmp	.+0      	; 0x1252 <invalid_local_login_attempt+0x4a>
    1252:	00 00       	nop
    1254:	08 95       	ret
    _delay_ms(1500);
    return;
    }
  LCD_clear_screen();
    1256:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
  LCD_write_string_xy(4, 0, "Too many");
    125a:	44 e4       	ldi	r20, 0x44	; 68
    125c:	51 e0       	ldi	r21, 0x01	; 1
    125e:	60 e0       	ldi	r22, 0x00	; 0
    1260:	84 e0       	ldi	r24, 0x04	; 4
    1262:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
  LCD_write_string_xy(0, 1, "wrong attempts!");
    1266:	4d e4       	ldi	r20, 0x4D	; 77
    1268:	51 e0       	ldi	r21, 0x01	; 1
    126a:	61 e0       	ldi	r22, 0x01	; 1
    126c:	80 e0       	ldi	r24, 0x00	; 0
    126e:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
    1272:	2f ef       	ldi	r18, 0xFF	; 255
    1274:	8d e3       	ldi	r24, 0x3D	; 61
    1276:	99 e4       	ldi	r25, 0x49	; 73
    1278:	21 50       	subi	r18, 0x01	; 1
    127a:	80 40       	sbci	r24, 0x00	; 0
    127c:	90 40       	sbci	r25, 0x00	; 0
    127e:	e1 f7       	brne	.-8      	; 0x1278 <invalid_local_login_attempt+0x70>
    1280:	00 c0       	rjmp	.+0      	; 0x1282 <invalid_local_login_attempt+0x7a>
    1282:	00 00       	nop
  _delay_ms(1500);
  LCD_clear_screen();
    1284:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
  LCD_write_string_xy(3, 0, "- System -");
    1288:	4d e5       	ldi	r20, 0x5D	; 93
    128a:	51 e0       	ldi	r21, 0x01	; 1
    128c:	60 e0       	ldi	r22, 0x00	; 0
    128e:	83 e0       	ldi	r24, 0x03	; 3
    1290:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
  LCD_write_string_xy(2, 1, "- Suspended -");
    1294:	48 e6       	ldi	r20, 0x68	; 104
    1296:	51 e0       	ldi	r21, 0x01	; 1
    1298:	61 e0       	ldi	r22, 0x01	; 1
    129a:	82 e0       	ldi	r24, 0x02	; 2
    129c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
  Alarm_set();
    12a0:	0e 94 a2 10 	call	0x2144	; 0x2144 <Alarm_set>
  run_system = false;
    12a4:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
    12a8:	08 95       	ret

000012aa <Local_control_input_handler>:
  }

// Used in the super loop for getting the user input and handling it.
void Local_control_input_handler(void) {
    12aa:	1f 93       	push	r17
    12ac:	cf 93       	push	r28
    12ae:	df 93       	push	r29
    12b0:	1f 92       	push	r1
    12b2:	cd b7       	in	r28, 0x3d	; 61
    12b4:	de b7       	in	r29, 0x3e	; 62
  u8 pressed_key;
  EN_KeypadStatusCode_t keypad_stat = Keypad_getPressedKey(&pressed_key);
    12b6:	ce 01       	movw	r24, r28
    12b8:	01 96       	adiw	r24, 0x01	; 1
    12ba:	0e 94 8e 02 	call	0x51c	; 0x51c <Keypad_getPressedKey>
    12be:	18 2f       	mov	r17, r24
  switch (local_control_running_task) {
    12c0:	80 91 63 07 	lds	r24, 0x0763	; 0x800763 <local_control_running_task>
    12c4:	81 30       	cpi	r24, 0x01	; 1
    12c6:	a9 f1       	breq	.+106    	; 0x1332 <Local_control_input_handler+0x88>
    12c8:	20 f0       	brcs	.+8      	; 0x12d2 <Local_control_input_handler+0x28>
    12ca:	82 30       	cpi	r24, 0x02	; 2
    12cc:	09 f4       	brne	.+2      	; 0x12d0 <Local_control_input_handler+0x26>
    12ce:	45 c1       	rjmp	.+650    	; 0x155a <Local_control_input_handler+0x2b0>
    12d0:	e5 c1       	rjmp	.+970    	; 0x169c <Local_control_input_handler+0x3f2>
    // Show running devices
      case 0:
        Get_running_devices();
    12d2:	0e 94 c8 07 	call	0xf90	; 0xf90 <Get_running_devices>
        if (running_devices_screen == 0) {  // First run
    12d6:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <running_devices_screen>
    12da:	81 11       	cpse	r24, r1
    12dc:	08 c0       	rjmp	.+16     	; 0x12ee <Local_control_input_handler+0x44>
          Show_running_devices(1);
    12de:	81 e0       	ldi	r24, 0x01	; 1
    12e0:	0e 94 5d 08 	call	0x10ba	; 0x10ba <Show_running_devices>
          running_devices_screen++;
    12e4:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <running_devices_screen>
    12e8:	8f 5f       	subi	r24, 0xFF	; 255
    12ea:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <running_devices_screen>
          }
        if (keypad_stat == NO_KEY_PRESSED) return;
    12ee:	12 30       	cpi	r17, 0x02	; 2
    12f0:	09 f4       	brne	.+2      	; 0x12f4 <Local_control_input_handler+0x4a>
    12f2:	d4 c1       	rjmp	.+936    	; 0x169c <Local_control_input_handler+0x3f2>
        switch (pressed_key) {
    12f4:	89 81       	ldd	r24, Y+1	; 0x01
    12f6:	82 33       	cpi	r24, 0x32	; 50
    12f8:	61 f0       	breq	.+24     	; 0x1312 <Local_control_input_handler+0x68>
    12fa:	83 33       	cpi	r24, 0x33	; 51
    12fc:	71 f0       	breq	.+28     	; 0x131a <Local_control_input_handler+0x70>
    12fe:	81 33       	cpi	r24, 0x31	; 49
    1300:	99 f4       	brne	.+38     	; 0x1328 <Local_control_input_handler+0x7e>
            case '1':
              if (running_devices_screen > 1) running_devices_screen--;
    1302:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <running_devices_screen>
    1306:	82 30       	cpi	r24, 0x02	; 2
    1308:	78 f0       	brcs	.+30     	; 0x1328 <Local_control_input_handler+0x7e>
    130a:	81 50       	subi	r24, 0x01	; 1
    130c:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <running_devices_screen>
    1310:	0b c0       	rjmp	.+22     	; 0x1328 <Local_control_input_handler+0x7e>
              break;
            case '2':
              local_control_running_task = 1;
    1312:	81 e0       	ldi	r24, 0x01	; 1
    1314:	80 93 63 07 	sts	0x0763, r24	; 0x800763 <local_control_running_task>
              break;
    1318:	07 c0       	rjmp	.+14     	; 0x1328 <Local_control_input_handler+0x7e>
            case '3':
              if (running_devices_screen < 7) running_devices_screen++;
    131a:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <running_devices_screen>
    131e:	87 30       	cpi	r24, 0x07	; 7
    1320:	18 f4       	brcc	.+6      	; 0x1328 <Local_control_input_handler+0x7e>
    1322:	8f 5f       	subi	r24, 0xFF	; 255
    1324:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <running_devices_screen>
              break;
          }
        Show_running_devices(running_devices_screen);
    1328:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <running_devices_screen>
    132c:	0e 94 5d 08 	call	0x10ba	; 0x10ba <Show_running_devices>
        break;
    1330:	b5 c1       	rjmp	.+874    	; 0x169c <Local_control_input_handler+0x3f2>
        // Logging in
      case 1:
        switch (login_stage) {
    1332:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <login_stage>
    1336:	88 23       	and	r24, r24
    1338:	21 f0       	breq	.+8      	; 0x1342 <Local_control_input_handler+0x98>
    133a:	81 30       	cpi	r24, 0x01	; 1
    133c:	09 f4       	brne	.+2      	; 0x1340 <Local_control_input_handler+0x96>
    133e:	73 c0       	rjmp	.+230    	; 0x1426 <Local_control_input_handler+0x17c>
    1340:	ad c1       	rjmp	.+858    	; 0x169c <Local_control_input_handler+0x3f2>
          // Entering the user code
            case 0:
              if (!login_stage_started) {
    1342:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <login_stage_started>
    1346:	81 11       	cpse	r24, r1
    1348:	13 c0       	rjmp	.+38     	; 0x1370 <Local_control_input_handler+0xc6>
                LCD_clear_screen();
    134a:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
                Show_side_options_menu();
    134e:	0e 94 2f 08 	call	0x105e	; 0x105e <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "User Code:");
    1352:	46 e7       	ldi	r20, 0x76	; 118
    1354:	51 e0       	ldi	r21, 0x01	; 1
    1356:	60 e0       	ldi	r22, 0x00	; 0
    1358:	80 e0       	ldi	r24, 0x00	; 0
    135a:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    135e:	61 e0       	ldi	r22, 0x01	; 1
    1360:	80 e0       	ldi	r24, 0x00	; 0
    1362:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
                login_stage_started = true;
    1366:	81 e0       	ldi	r24, 0x01	; 1
    1368:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <login_stage_started>
                input_buffer_pointer = 0;
    136c:	10 92 64 07 	sts	0x0764, r1	; 0x800764 <input_buffer_pointer>
                }
              if (keypad_stat == NO_KEY_PRESSED) return;
    1370:	12 30       	cpi	r17, 0x02	; 2
    1372:	09 f4       	brne	.+2      	; 0x1376 <Local_control_input_handler+0xcc>
    1374:	93 c1       	rjmp	.+806    	; 0x169c <Local_control_input_handler+0x3f2>
              if (pressed_key == '-') { // Delete last input number
    1376:	89 81       	ldd	r24, Y+1	; 0x01
    1378:	8d 32       	cpi	r24, 0x2D	; 45
    137a:	a1 f4       	brne	.+40     	; 0x13a4 <Local_control_input_handler+0xfa>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    137c:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <input_buffer_pointer>
    1380:	88 23       	and	r24, r24
    1382:	19 f0       	breq	.+6      	; 0x138a <Local_control_input_handler+0xe0>
    1384:	81 50       	subi	r24, 0x01	; 1
    1386:	80 93 64 07 	sts	0x0764, r24	; 0x800764 <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    138a:	47 e2       	ldi	r20, 0x27	; 39
    138c:	51 e0       	ldi	r21, 0x01	; 1
    138e:	61 e0       	ldi	r22, 0x01	; 1
    1390:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <input_buffer_pointer>
    1394:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    1398:	61 e0       	ldi	r22, 0x01	; 1
    139a:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <input_buffer_pointer>
    139e:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
    13a2:	7c c1       	rjmp	.+760    	; 0x169c <Local_control_input_handler+0x3f2>
                }
              else if (pressed_key == '=') {
    13a4:	8d 33       	cpi	r24, 0x3D	; 61
    13a6:	39 f5       	brne	.+78     	; 0x13f6 <Local_control_input_handler+0x14c>
                input_buffer[input_buffer_pointer] = 0;
    13a8:	e0 91 64 07 	lds	r30, 0x0764	; 0x800764 <input_buffer_pointer>
    13ac:	f0 e0       	ldi	r31, 0x00	; 0
    13ae:	e5 57       	subi	r30, 0x75	; 117
    13b0:	f8 4f       	sbci	r31, 0xF8	; 248
    13b2:	10 82       	st	Z, r1
                // Validate user code
                EN_UserStatusCode_t codeExists = getUserByCode(input_buffer, &local_user);
    13b4:	6b e6       	ldi	r22, 0x6B	; 107
    13b6:	77 e0       	ldi	r23, 0x07	; 7
    13b8:	8b e8       	ldi	r24, 0x8B	; 139
    13ba:	97 e0       	ldi	r25, 0x07	; 7
    13bc:	0e 94 09 10 	call	0x2012	; 0x2012 <getUserByCode>
                if (codeExists == USER_FOUND) {
    13c0:	82 30       	cpi	r24, 0x02	; 2
    13c2:	31 f4       	brne	.+12     	; 0x13d0 <Local_control_input_handler+0x126>
                  login_stage_started = false;
    13c4:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <login_stage_started>
                  login_stage = 1;
    13c8:	81 e0       	ldi	r24, 0x01	; 1
    13ca:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <login_stage>
    13ce:	66 c1       	rjmp	.+716    	; 0x169c <Local_control_input_handler+0x3f2>
                  }
                else {
                  LCD_clear_screen();
    13d0:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    13d4:	41 e8       	ldi	r20, 0x81	; 129
    13d6:	51 e0       	ldi	r21, 0x01	; 1
    13d8:	60 e0       	ldi	r22, 0x00	; 0
    13da:	85 e0       	ldi	r24, 0x05	; 5
    13dc:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  LCD_write_string_xy(2, 1, "User Code !");
    13e0:	47 e8       	ldi	r20, 0x87	; 135
    13e2:	51 e0       	ldi	r21, 0x01	; 1
    13e4:	61 e0       	ldi	r22, 0x01	; 1
    13e6:	82 e0       	ldi	r24, 0x02	; 2
    13e8:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  invalid_local_login_attempt();
    13ec:	0e 94 04 09 	call	0x1208	; 0x1208 <invalid_local_login_attempt>
                  login_stage_started = false;
    13f0:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <login_stage_started>
    13f4:	53 c1       	rjmp	.+678    	; 0x169c <Local_control_input_handler+0x3f2>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    13f6:	90 ed       	ldi	r25, 0xD0	; 208
    13f8:	98 0f       	add	r25, r24
    13fa:	9a 30       	cpi	r25, 0x0A	; 10
    13fc:	08 f0       	brcs	.+2      	; 0x1400 <Local_control_input_handler+0x156>
    13fe:	4e c1       	rjmp	.+668    	; 0x169c <Local_control_input_handler+0x3f2>
                if (input_buffer_pointer < 6) {
    1400:	90 91 64 07 	lds	r25, 0x0764	; 0x800764 <input_buffer_pointer>
    1404:	96 30       	cpi	r25, 0x06	; 6
    1406:	08 f0       	brcs	.+2      	; 0x140a <Local_control_input_handler+0x160>
    1408:	49 c1       	rjmp	.+658    	; 0x169c <Local_control_input_handler+0x3f2>
                  // Echo the input on the LCD
                  LCD_sendData(pressed_key);
    140a:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
                  input_buffer[input_buffer_pointer] = pressed_key;
    140e:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <input_buffer_pointer>
    1412:	e8 2f       	mov	r30, r24
    1414:	f0 e0       	ldi	r31, 0x00	; 0
    1416:	e5 57       	subi	r30, 0x75	; 117
    1418:	f8 4f       	sbci	r31, 0xF8	; 248
    141a:	99 81       	ldd	r25, Y+1	; 0x01
    141c:	90 83       	st	Z, r25
                  input_buffer_pointer++;
    141e:	8f 5f       	subi	r24, 0xFF	; 255
    1420:	80 93 64 07 	sts	0x0764, r24	; 0x800764 <input_buffer_pointer>
    1424:	3b c1       	rjmp	.+630    	; 0x169c <Local_control_input_handler+0x3f2>
                  }
                }
              break;
              //  Entering the password
            case 1:
              if (!login_stage_started) {
    1426:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <login_stage_started>
    142a:	81 11       	cpse	r24, r1
    142c:	13 c0       	rjmp	.+38     	; 0x1454 <Local_control_input_handler+0x1aa>
                LCD_clear_screen();
    142e:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
                Show_side_options_menu();
    1432:	0e 94 2f 08 	call	0x105e	; 0x105e <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "Password:");
    1436:	43 e9       	ldi	r20, 0x93	; 147
    1438:	51 e0       	ldi	r21, 0x01	; 1
    143a:	60 e0       	ldi	r22, 0x00	; 0
    143c:	80 e0       	ldi	r24, 0x00	; 0
    143e:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    1442:	61 e0       	ldi	r22, 0x01	; 1
    1444:	80 e0       	ldi	r24, 0x00	; 0
    1446:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
                login_stage_started = true;
    144a:	81 e0       	ldi	r24, 0x01	; 1
    144c:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <login_stage_started>
                input_buffer_pointer = 0;
    1450:	10 92 64 07 	sts	0x0764, r1	; 0x800764 <input_buffer_pointer>
                }
              if (pressed_key == '-') { // Delete last input number
    1454:	89 81       	ldd	r24, Y+1	; 0x01
    1456:	8d 32       	cpi	r24, 0x2D	; 45
    1458:	a1 f4       	brne	.+40     	; 0x1482 <Local_control_input_handler+0x1d8>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    145a:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <input_buffer_pointer>
    145e:	88 23       	and	r24, r24
    1460:	19 f0       	breq	.+6      	; 0x1468 <Local_control_input_handler+0x1be>
    1462:	81 50       	subi	r24, 0x01	; 1
    1464:	80 93 64 07 	sts	0x0764, r24	; 0x800764 <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    1468:	47 e2       	ldi	r20, 0x27	; 39
    146a:	51 e0       	ldi	r21, 0x01	; 1
    146c:	61 e0       	ldi	r22, 0x01	; 1
    146e:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <input_buffer_pointer>
    1472:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    1476:	61 e0       	ldi	r22, 0x01	; 1
    1478:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <input_buffer_pointer>
    147c:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
    1480:	0d c1       	rjmp	.+538    	; 0x169c <Local_control_input_handler+0x3f2>
                }
              else if (pressed_key == '=') {
    1482:	8d 33       	cpi	r24, 0x3D	; 61
    1484:	09 f0       	breq	.+2      	; 0x1488 <Local_control_input_handler+0x1de>
    1486:	51 c0       	rjmp	.+162    	; 0x152a <Local_control_input_handler+0x280>
                input_buffer[input_buffer_pointer] = 0;
    1488:	e0 91 64 07 	lds	r30, 0x0764	; 0x800764 <input_buffer_pointer>
    148c:	f0 e0       	ldi	r31, 0x00	; 0
    148e:	e5 57       	subi	r30, 0x75	; 117
    1490:	f8 4f       	sbci	r31, 0xF8	; 248
    1492:	10 82       	st	Z, r1
                // Validate user password
                if (strcmp(input_buffer, local_user.password) == 0) { // Password is correct
    1494:	60 e8       	ldi	r22, 0x80	; 128
    1496:	77 e0       	ldi	r23, 0x07	; 7
    1498:	8b e8       	ldi	r24, 0x8B	; 139
    149a:	97 e0       	ldi	r25, 0x07	; 7
    149c:	0e 94 d7 13 	call	0x27ae	; 0x27ae <strcmp>
    14a0:	89 2b       	or	r24, r25
    14a2:	81 f5       	brne	.+96     	; 0x1504 <Local_control_input_handler+0x25a>
                  login_stage_started = false;
    14a4:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <login_stage_started>
                  login_stage = 0;
    14a8:	10 92 98 07 	sts	0x0798, r1	; 0x800798 <login_stage>
                  local_control_running_task = 2;
    14ac:	82 e0       	ldi	r24, 0x02	; 2
    14ae:	80 93 63 07 	sts	0x0763, r24	; 0x800763 <local_control_running_task>
                  LCD_clear_screen();
    14b2:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
                  LCD_write_string_xy(4, 0, "Welcome");
    14b6:	4d e9       	ldi	r20, 0x9D	; 157
    14b8:	51 e0       	ldi	r21, 0x01	; 1
    14ba:	60 e0       	ldi	r22, 0x00	; 0
    14bc:	84 e0       	ldi	r24, 0x04	; 4
    14be:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  LCD_write_string_xy((16 - strlen(local_user.name)) / 2 - 1, 1, local_user.name);
    14c2:	ec e6       	ldi	r30, 0x6C	; 108
    14c4:	f7 e0       	ldi	r31, 0x07	; 7
    14c6:	01 90       	ld	r0, Z+
    14c8:	00 20       	and	r0, r0
    14ca:	e9 f7       	brne	.-6      	; 0x14c6 <Local_control_input_handler+0x21c>
    14cc:	9f 01       	movw	r18, r30
    14ce:	2d 56       	subi	r18, 0x6D	; 109
    14d0:	37 40       	sbci	r19, 0x07	; 7
    14d2:	80 e1       	ldi	r24, 0x10	; 16
    14d4:	90 e0       	ldi	r25, 0x00	; 0
    14d6:	82 1b       	sub	r24, r18
    14d8:	93 0b       	sbc	r25, r19
    14da:	96 95       	lsr	r25
    14dc:	87 95       	ror	r24
    14de:	4c e6       	ldi	r20, 0x6C	; 108
    14e0:	57 e0       	ldi	r21, 0x07	; 7
    14e2:	61 e0       	ldi	r22, 0x01	; 1
    14e4:	81 50       	subi	r24, 0x01	; 1
    14e6:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  LCD_sendData('!');
    14ea:	81 e2       	ldi	r24, 0x21	; 33
    14ec:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
    14f0:	2f ef       	ldi	r18, 0xFF	; 255
    14f2:	8d e3       	ldi	r24, 0x3D	; 61
    14f4:	99 e4       	ldi	r25, 0x49	; 73
    14f6:	21 50       	subi	r18, 0x01	; 1
    14f8:	80 40       	sbci	r24, 0x00	; 0
    14fa:	90 40       	sbci	r25, 0x00	; 0
    14fc:	e1 f7       	brne	.-8      	; 0x14f6 <Local_control_input_handler+0x24c>
    14fe:	00 c0       	rjmp	.+0      	; 0x1500 <Local_control_input_handler+0x256>
    1500:	00 00       	nop
    1502:	cc c0       	rjmp	.+408    	; 0x169c <Local_control_input_handler+0x3f2>
                  _delay_ms(1500);
                  }
                else {
                  LCD_clear_screen();
    1504:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    1508:	41 e8       	ldi	r20, 0x81	; 129
    150a:	51 e0       	ldi	r21, 0x01	; 1
    150c:	60 e0       	ldi	r22, 0x00	; 0
    150e:	85 e0       	ldi	r24, 0x05	; 5
    1510:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  LCD_write_string_xy(3, 1, "Password !");
    1514:	45 ea       	ldi	r20, 0xA5	; 165
    1516:	51 e0       	ldi	r21, 0x01	; 1
    1518:	61 e0       	ldi	r22, 0x01	; 1
    151a:	83 e0       	ldi	r24, 0x03	; 3
    151c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  login_stage_started = false;
    1520:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <login_stage_started>
                  invalid_local_login_attempt();
    1524:	0e 94 04 09 	call	0x1208	; 0x1208 <invalid_local_login_attempt>
    1528:	b9 c0       	rjmp	.+370    	; 0x169c <Local_control_input_handler+0x3f2>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    152a:	90 ed       	ldi	r25, 0xD0	; 208
    152c:	98 0f       	add	r25, r24
    152e:	9a 30       	cpi	r25, 0x0A	; 10
    1530:	08 f0       	brcs	.+2      	; 0x1534 <Local_control_input_handler+0x28a>
    1532:	b4 c0       	rjmp	.+360    	; 0x169c <Local_control_input_handler+0x3f2>
                // Limit the input length
                if (input_buffer_pointer < 10) {
    1534:	90 91 64 07 	lds	r25, 0x0764	; 0x800764 <input_buffer_pointer>
    1538:	9a 30       	cpi	r25, 0x0A	; 10
    153a:	08 f0       	brcs	.+2      	; 0x153e <Local_control_input_handler+0x294>
    153c:	af c0       	rjmp	.+350    	; 0x169c <Local_control_input_handler+0x3f2>
                  // Echo the input on the LCD
                  LCD_sendData(pressed_key);
    153e:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
                  input_buffer[input_buffer_pointer] = pressed_key;
    1542:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <input_buffer_pointer>
    1546:	e8 2f       	mov	r30, r24
    1548:	f0 e0       	ldi	r31, 0x00	; 0
    154a:	e5 57       	subi	r30, 0x75	; 117
    154c:	f8 4f       	sbci	r31, 0xF8	; 248
    154e:	99 81       	ldd	r25, Y+1	; 0x01
    1550:	90 83       	st	Z, r25
                  input_buffer_pointer++;
    1552:	8f 5f       	subi	r24, 0xFF	; 255
    1554:	80 93 64 07 	sts	0x0764, r24	; 0x800764 <input_buffer_pointer>
    1558:	a1 c0       	rjmp	.+322    	; 0x169c <Local_control_input_handler+0x3f2>
              break;
          }
        break;
        // Devices control
      case 2:
        if (remote_user_loggedin && !control_permission_granted) {
    155a:	80 91 45 07 	lds	r24, 0x0745	; 0x800745 <remote_user_loggedin>
    155e:	88 23       	and	r24, r24
    1560:	99 f0       	breq	.+38     	; 0x1588 <Local_control_input_handler+0x2de>
    1562:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <control_permission_granted>
    1566:	81 11       	cpse	r24, r1
    1568:	0f c0       	rjmp	.+30     	; 0x1588 <Local_control_input_handler+0x2de>
          LCD_clear_screen();
    156a:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
          LCD_write_string_xy(0, 0, "Admin Permission");
    156e:	40 eb       	ldi	r20, 0xB0	; 176
    1570:	51 e0       	ldi	r21, 0x01	; 1
    1572:	60 e0       	ldi	r22, 0x00	; 0
    1574:	80 e0       	ldi	r24, 0x00	; 0
    1576:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
          LCD_write_string_xy(3, 1, "Required !");
    157a:	41 ec       	ldi	r20, 0xC1	; 193
    157c:	51 e0       	ldi	r21, 0x01	; 1
    157e:	61 e0       	ldi	r22, 0x01	; 1
    1580:	83 e0       	ldi	r24, 0x03	; 3
    1582:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
    1586:	8a c0       	rjmp	.+276    	; 0x169c <Local_control_input_handler+0x3f2>
          //~ Controls can be added to allow the user to go back and view the running devices if needed.
          }
        else {
          Get_devices_status();
    1588:	0e 94 3c 08 	call	0x1078	; 0x1078 <Get_devices_status>
          if (control_devices_screen == 0) {  // First run
    158c:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <control_devices_screen>
    1590:	81 11       	cpse	r24, r1
    1592:	08 c0       	rjmp	.+16     	; 0x15a4 <Local_control_input_handler+0x2fa>
            Show_devices_controls(1);
    1594:	81 e0       	ldi	r24, 0x01	; 1
    1596:	0e 94 9a 08 	call	0x1134	; 0x1134 <Show_devices_controls>
            control_devices_screen++;
    159a:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <control_devices_screen>
    159e:	8f 5f       	subi	r24, 0xFF	; 255
    15a0:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <control_devices_screen>
            }
          if (keypad_stat == NO_KEY_PRESSED) return;
    15a4:	12 30       	cpi	r17, 0x02	; 2
    15a6:	09 f4       	brne	.+2      	; 0x15aa <Local_control_input_handler+0x300>
    15a8:	79 c0       	rjmp	.+242    	; 0x169c <Local_control_input_handler+0x3f2>
          switch (pressed_key) {
    15aa:	89 81       	ldd	r24, Y+1	; 0x01
    15ac:	82 33       	cpi	r24, 0x32	; 50
    15ae:	79 f0       	breq	.+30     	; 0x15ce <Local_control_input_handler+0x324>
    15b0:	83 33       	cpi	r24, 0x33	; 51
    15b2:	09 f4       	brne	.+2      	; 0x15b6 <Local_control_input_handler+0x30c>
    15b4:	48 c0       	rjmp	.+144    	; 0x1646 <Local_control_input_handler+0x39c>
    15b6:	81 33       	cpi	r24, 0x31	; 49
    15b8:	09 f0       	breq	.+2      	; 0x15bc <Local_control_input_handler+0x312>
    15ba:	6c c0       	rjmp	.+216    	; 0x1694 <Local_control_input_handler+0x3ea>
              case '1':
                if (control_devices_screen > 1) control_devices_screen--;
    15bc:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <control_devices_screen>
    15c0:	82 30       	cpi	r24, 0x02	; 2
    15c2:	08 f4       	brcc	.+2      	; 0x15c6 <Local_control_input_handler+0x31c>
    15c4:	67 c0       	rjmp	.+206    	; 0x1694 <Local_control_input_handler+0x3ea>
    15c6:	81 50       	subi	r24, 0x01	; 1
    15c8:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <control_devices_screen>
    15cc:	63 c0       	rjmp	.+198    	; 0x1694 <Local_control_input_handler+0x3ea>
                break;
              case '2':
                switch (control_devices_screen) {
    15ce:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <control_devices_screen>
    15d2:	86 30       	cpi	r24, 0x06	; 6
    15d4:	31 f5       	brne	.+76     	; 0x1622 <Local_control_input_handler+0x378>
                    case 6:
                      // Increment the brightness
                      // Floor the brightness
                      devices_status[5] = devices_status[5] - (devices_status[5] % LAMP_6_BRIGHTNESS_PERCENTAGE_STEP);
    15d6:	e5 e6       	ldi	r30, 0x65	; 101
    15d8:	f7 e0       	ldi	r31, 0x07	; 7
    15da:	85 81       	ldd	r24, Z+5	; 0x05
    15dc:	9d ec       	ldi	r25, 0xCD	; 205
    15de:	89 9f       	mul	r24, r25
    15e0:	81 2d       	mov	r24, r1
    15e2:	11 24       	eor	r1, r1
    15e4:	86 95       	lsr	r24
    15e6:	86 95       	lsr	r24
    15e8:	86 95       	lsr	r24
    15ea:	88 0f       	add	r24, r24
    15ec:	98 2f       	mov	r25, r24
    15ee:	99 0f       	add	r25, r25
    15f0:	99 0f       	add	r25, r25
    15f2:	89 0f       	add	r24, r25
                      devices_status[5] += LAMP_6_BRIGHTNESS_PERCENTAGE_STEP;
    15f4:	86 5f       	subi	r24, 0xF6	; 246
    15f6:	85 83       	std	Z+5, r24	; 0x05
                      if (devices_status[5] > 100) devices_status[5] = 100;
    15f8:	85 36       	cpi	r24, 0x65	; 101
    15fa:	18 f0       	brcs	.+6      	; 0x1602 <Local_control_input_handler+0x358>
    15fc:	84 e6       	ldi	r24, 0x64	; 100
    15fe:	80 93 6a 07 	sts	0x076A, r24	; 0x80076a <devices_status+0x5>
                      Lamp_dimmable_set_brightness((double)devices_status[5] / 100.0);
    1602:	60 91 6a 07 	lds	r22, 0x076A	; 0x80076a <devices_status+0x5>
    1606:	70 e0       	ldi	r23, 0x00	; 0
    1608:	80 e0       	ldi	r24, 0x00	; 0
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	0e 94 c7 12 	call	0x258e	; 0x258e <__floatunsisf>
    1610:	20 e0       	ldi	r18, 0x00	; 0
    1612:	30 e0       	ldi	r19, 0x00	; 0
    1614:	48 ec       	ldi	r20, 0xC8	; 200
    1616:	52 e4       	ldi	r21, 0x42	; 66
    1618:	0e 94 26 12 	call	0x244c	; 0x244c <__divsf3>
    161c:	0e 94 bb 07 	call	0xf76	; 0xf76 <Lamp_dimmable_set_brightness>
                      break;
    1620:	39 c0       	rjmp	.+114    	; 0x1694 <Local_control_input_handler+0x3ea>
                    default:
                      Lamp_toggle(control_devices_screen);
    1622:	0e 94 89 07 	call	0xf12	; 0xf12 <Lamp_toggle>
                      devices_status[control_devices_screen - 1] = !devices_status[control_devices_screen - 1];
    1626:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <control_devices_screen>
    162a:	90 e0       	ldi	r25, 0x00	; 0
    162c:	01 97       	sbiw	r24, 0x01	; 1
    162e:	fc 01       	movw	r30, r24
    1630:	eb 59       	subi	r30, 0x9B	; 155
    1632:	f8 4f       	sbci	r31, 0xF8	; 248
    1634:	30 81       	ld	r19, Z
    1636:	21 e0       	ldi	r18, 0x01	; 1
    1638:	31 11       	cpse	r19, r1
    163a:	20 e0       	ldi	r18, 0x00	; 0
    163c:	fc 01       	movw	r30, r24
    163e:	eb 59       	subi	r30, 0x9B	; 155
    1640:	f8 4f       	sbci	r31, 0xF8	; 248
    1642:	20 83       	st	Z, r18
                      break;
    1644:	27 c0       	rjmp	.+78     	; 0x1694 <Local_control_input_handler+0x3ea>
                  }
                break;
              case '3':
                switch (control_devices_screen) {
    1646:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <control_devices_screen>
    164a:	86 30       	cpi	r24, 0x06	; 6
    164c:	f1 f4       	brne	.+60     	; 0x168a <Local_control_input_handler+0x3e0>
                    case 6:
                      // Decrement the brightness
                      // Ceil the brightness
                      devices_status[5] = devices_status[5] - (devices_status[5] % LAMP_6_BRIGHTNESS_PERCENTAGE_STEP) + LAMP_6_BRIGHTNESS_PERCENTAGE_STEP;
    164e:	e5 e6       	ldi	r30, 0x65	; 101
    1650:	f7 e0       	ldi	r31, 0x07	; 7
    1652:	85 81       	ldd	r24, Z+5	; 0x05
    1654:	9d ec       	ldi	r25, 0xCD	; 205
    1656:	89 9f       	mul	r24, r25
    1658:	81 2d       	mov	r24, r1
    165a:	11 24       	eor	r1, r1
    165c:	86 95       	lsr	r24
    165e:	86 95       	lsr	r24
    1660:	86 95       	lsr	r24
    1662:	88 0f       	add	r24, r24
    1664:	68 2f       	mov	r22, r24
    1666:	66 0f       	add	r22, r22
    1668:	66 0f       	add	r22, r22
    166a:	68 0f       	add	r22, r24
                      devices_status[5] -= LAMP_6_BRIGHTNESS_PERCENTAGE_STEP;
    166c:	65 83       	std	Z+5, r22	; 0x05
                      if (devices_status[5] < 0) devices_status[5] = 0;
                      Lamp_dimmable_set_brightness((double)devices_status[5] / 100.0);
    166e:	70 e0       	ldi	r23, 0x00	; 0
    1670:	80 e0       	ldi	r24, 0x00	; 0
    1672:	90 e0       	ldi	r25, 0x00	; 0
    1674:	0e 94 c7 12 	call	0x258e	; 0x258e <__floatunsisf>
    1678:	20 e0       	ldi	r18, 0x00	; 0
    167a:	30 e0       	ldi	r19, 0x00	; 0
    167c:	48 ec       	ldi	r20, 0xC8	; 200
    167e:	52 e4       	ldi	r21, 0x42	; 66
    1680:	0e 94 26 12 	call	0x244c	; 0x244c <__divsf3>
    1684:	0e 94 bb 07 	call	0xf76	; 0xf76 <Lamp_dimmable_set_brightness>
                      break;
    1688:	05 c0       	rjmp	.+10     	; 0x1694 <Local_control_input_handler+0x3ea>
                    default:
                      if (control_devices_screen < 6) control_devices_screen++;
    168a:	86 30       	cpi	r24, 0x06	; 6
    168c:	18 f4       	brcc	.+6      	; 0x1694 <Local_control_input_handler+0x3ea>
    168e:	8f 5f       	subi	r24, 0xFF	; 255
    1690:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <control_devices_screen>
                      break;
                  }
                break;
            }
          Show_devices_controls(control_devices_screen);
    1694:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <control_devices_screen>
    1698:	0e 94 9a 08 	call	0x1134	; 0x1134 <Show_devices_controls>
          }
        break;
    }
  }
    169c:	0f 90       	pop	r0
    169e:	df 91       	pop	r29
    16a0:	cf 91       	pop	r28
    16a2:	1f 91       	pop	r17
    16a4:	08 95       	ret

000016a6 <println_msg>:
  BT_init(baudRate);
  }

void println_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    16a6:	0e 94 dd 01 	call	0x3ba	; 0x3ba <BT_sendString>
  // Send CRLF - carriage return + new line
  BT_sendString("\r\n");
    16aa:	8c ec       	ldi	r24, 0xCC	; 204
    16ac:	91 e0       	ldi	r25, 0x01	; 1
    16ae:	0e 94 dd 01 	call	0x3ba	; 0x3ba <BT_sendString>
    16b2:	08 95       	ret

000016b4 <print_msg>:
  }

void print_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    16b4:	0e 94 dd 01 	call	0x3ba	; 0x3ba <BT_sendString>
    16b8:	08 95       	ret

000016ba <request_user_input>:
  }

void request_user_input(s8 options[4], u8 msgLength) {
    16ba:	cf 93       	push	r28
    16bc:	c6 2f       	mov	r28, r22
  strcpy(user_dialog_tree, options);
    16be:	bc 01       	movw	r22, r24
    16c0:	87 e5       	ldi	r24, 0x57	; 87
    16c2:	97 e0       	ldi	r25, 0x07	; 7
    16c4:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <strcpy>
  msg_length = msgLength;
    16c8:	c0 93 56 07 	sts	0x0756, r28	; 0x800756 <msg_length>
  }
    16cc:	cf 91       	pop	r28
    16ce:	08 95       	ret

000016d0 <print_remote_control_menu>:
      }
    }
  }

void print_remote_control_menu(void) {
  println_msg("Select one of the following devices to control:\t");
    16d0:	8f ec       	ldi	r24, 0xCF	; 207
    16d2:	91 e0       	ldi	r25, 0x01	; 1
    16d4:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
  println_msg("[1] Lamp 1");
    16d8:	80 e0       	ldi	r24, 0x00	; 0
    16da:	92 e0       	ldi	r25, 0x02	; 2
    16dc:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
  println_msg("[2] Lamp 2");
    16e0:	8b e0       	ldi	r24, 0x0B	; 11
    16e2:	92 e0       	ldi	r25, 0x02	; 2
    16e4:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
  println_msg("[3] Lamp 3");
    16e8:	86 e1       	ldi	r24, 0x16	; 22
    16ea:	92 e0       	ldi	r25, 0x02	; 2
    16ec:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
  println_msg("[4] Lamp 4");
    16f0:	81 e2       	ldi	r24, 0x21	; 33
    16f2:	92 e0       	ldi	r25, 0x02	; 2
    16f4:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
  println_msg("[5] Lamp 5");
    16f8:	8c e2       	ldi	r24, 0x2C	; 44
    16fa:	92 e0       	ldi	r25, 0x02	; 2
    16fc:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
  println_msg("[6] Lamp 6");
    1700:	87 e3       	ldi	r24, 0x37	; 55
    1702:	92 e0       	ldi	r25, 0x02	; 2
    1704:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
  if (remote_user.isAdmin) {
    1708:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <remote_user>
    170c:	88 23       	and	r24, r24
    170e:	21 f0       	breq	.+8      	; 0x1718 <print_remote_control_menu+0x48>
    println_msg("[7] The Door");
    1710:	82 e4       	ldi	r24, 0x42	; 66
    1712:	92 e0       	ldi	r25, 0x02	; 2
    1714:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    1718:	08 95       	ret

0000171a <control_device>:
  }

// TODO: Send the status of each device to the user instead of just asking him to switch the device on or off.

void control_device(void) {
  u8 option = msg_buffer[0];
    171a:	60 91 47 07 	lds	r22, 0x0747	; 0x800747 <msg_buffer>
  if (invalid_user_input || option < '0' || option > '9') {
    171e:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <invalid_user_input>
    1722:	81 11       	cpse	r24, r1
    1724:	04 c0       	rjmp	.+8      	; 0x172e <control_device+0x14>
    1726:	60 33       	cpi	r22, 0x30	; 48
    1728:	10 f0       	brcs	.+4      	; 0x172e <control_device+0x14>
    172a:	6a 33       	cpi	r22, 0x3A	; 58
    172c:	60 f0       	brcs	.+24     	; 0x1746 <control_device+0x2c>
    println_msg("\r\nInvalid input!!\t");
    172e:	8f e4       	ldi	r24, 0x4F	; 79
    1730:	92 e0       	ldi	r25, 0x02	; 2
    1732:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    print_remote_control_menu();
    1736:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    173a:	62 e0       	ldi	r22, 0x02	; 2
    173c:	86 ee       	ldi	r24, 0xE6	; 230
    173e:	9b e0       	ldi	r25, 0x0B	; 11
    1740:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1744:	08 95       	ret
    }
  else {
    if (device_number < 6) {
    1746:	80 91 dd 07 	lds	r24, 0x07DD	; 0x8007dd <device_number>
    174a:	86 30       	cpi	r24, 0x06	; 6
    174c:	80 f4       	brcc	.+32     	; 0x176e <control_device+0x54>
      if (option == '1') {
    174e:	61 33       	cpi	r22, 0x31	; 49
    1750:	39 f4       	brne	.+14     	; 0x1760 <control_device+0x46>
        Lamp_on(device_number);
    1752:	0e 94 33 07 	call	0xe66	; 0xe66 <Lamp_on>
        println_msg("The device has been turned on!");
    1756:	82 e6       	ldi	r24, 0x62	; 98
    1758:	92 e0       	ldi	r25, 0x02	; 2
    175a:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    175e:	2e c0       	rjmp	.+92     	; 0x17bc <control_device+0xa2>
        }
      else {
        Lamp_off(device_number);
    1760:	0e 94 5e 07 	call	0xebc	; 0xebc <Lamp_off>
        println_msg("The device has been turned off!");
    1764:	81 e8       	ldi	r24, 0x81	; 129
    1766:	92 e0       	ldi	r25, 0x02	; 2
    1768:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    176c:	27 c0       	rjmp	.+78     	; 0x17bc <control_device+0xa2>
        }
      }
    else if (device_number == 6) { // Dimmable led
    176e:	86 30       	cpi	r24, 0x06	; 6
    1770:	b1 f4       	brne	.+44     	; 0x179e <control_device+0x84>
      Lamp_dimmable_set_brightness(((double)(option - 48) / 9.0));
    1772:	70 e0       	ldi	r23, 0x00	; 0
    1774:	60 53       	subi	r22, 0x30	; 48
    1776:	71 09       	sbc	r23, r1
    1778:	07 2e       	mov	r0, r23
    177a:	00 0c       	add	r0, r0
    177c:	88 0b       	sbc	r24, r24
    177e:	99 0b       	sbc	r25, r25
    1780:	0e 94 c9 12 	call	0x2592	; 0x2592 <__floatsisf>
    1784:	20 e0       	ldi	r18, 0x00	; 0
    1786:	30 e0       	ldi	r19, 0x00	; 0
    1788:	40 e1       	ldi	r20, 0x10	; 16
    178a:	51 e4       	ldi	r21, 0x41	; 65
    178c:	0e 94 26 12 	call	0x244c	; 0x244c <__divsf3>
    1790:	0e 94 bb 07 	call	0xf76	; 0xf76 <Lamp_dimmable_set_brightness>
      println_msg("The brightness has been adjusted!");
    1794:	81 ea       	ldi	r24, 0xA1	; 161
    1796:	92 e0       	ldi	r25, 0x02	; 2
    1798:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    179c:	0f c0       	rjmp	.+30     	; 0x17bc <control_device+0xa2>
      }
    else {
      if (option == '1') {
    179e:	61 33       	cpi	r22, 0x31	; 49
    17a0:	39 f4       	brne	.+14     	; 0x17b0 <control_device+0x96>
        Door_open();
    17a2:	0e 94 2b 07 	call	0xe56	; 0xe56 <Door_open>
        println_msg("The Door is open now.");
    17a6:	83 ec       	ldi	r24, 0xC3	; 195
    17a8:	92 e0       	ldi	r25, 0x02	; 2
    17aa:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    17ae:	06 c0       	rjmp	.+12     	; 0x17bc <control_device+0xa2>
        }
      else {
        Door_close();
    17b0:	0e 94 2f 07 	call	0xe5e	; 0xe5e <Door_close>
        println_msg("The Door is closed now.");
    17b4:	89 ed       	ldi	r24, 0xD9	; 217
    17b6:	92 e0       	ldi	r25, 0x02	; 2
    17b8:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
        }
      }
    print_remote_control_menu();
    17bc:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    17c0:	62 e0       	ldi	r22, 0x02	; 2
    17c2:	86 ee       	ldi	r24, 0xE6	; 230
    17c4:	9b e0       	ldi	r25, 0x0B	; 11
    17c6:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    17ca:	08 95       	ret

000017cc <remote_control>:
    }
  }

void remote_control(void) {
    17cc:	cf 93       	push	r28
  u8 option = msg_buffer[0];
    17ce:	c0 91 47 07 	lds	r28, 0x0747	; 0x800747 <msg_buffer>
  if (remote_user.isAdmin) {
    17d2:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <remote_user>
    17d6:	88 23       	and	r24, r24
    17d8:	49 f1       	breq	.+82     	; 0x182c <remote_control+0x60>
    if (invalid_user_input || option < '1' || option > '7') {
    17da:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <invalid_user_input>
    17de:	81 11       	cpse	r24, r1
    17e0:	04 c0       	rjmp	.+8      	; 0x17ea <remote_control+0x1e>
    17e2:	c1 33       	cpi	r28, 0x31	; 49
    17e4:	10 f0       	brcs	.+4      	; 0x17ea <remote_control+0x1e>
    17e6:	c8 33       	cpi	r28, 0x38	; 56
    17e8:	60 f0       	brcs	.+24     	; 0x1802 <remote_control+0x36>
      println_msg("Invalid option!\t");
    17ea:	81 ef       	ldi	r24, 0xF1	; 241
    17ec:	92 e0       	ldi	r25, 0x02	; 2
    17ee:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      print_remote_control_menu();
    17f2:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    17f6:	62 e0       	ldi	r22, 0x02	; 2
    17f8:	86 ee       	ldi	r24, 0xE6	; 230
    17fa:	9b e0       	ldi	r25, 0x0B	; 11
    17fc:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1800:	3d c0       	rjmp	.+122    	; 0x187c <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    1802:	82 e0       	ldi	r24, 0x02	; 2
    1804:	93 e0       	ldi	r25, 0x03	; 3
    1806:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    180a:	88 e5       	ldi	r24, 0x58	; 88
    180c:	93 e0       	ldi	r25, 0x03	; 3
    180e:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    1812:	81 e9       	ldi	r24, 0x91	; 145
    1814:	93 e0       	ldi	r25, 0x03	; 3
    1816:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      request_user_input(control_device, 2);
    181a:	62 e0       	ldi	r22, 0x02	; 2
    181c:	8d e8       	ldi	r24, 0x8D	; 141
    181e:	9b e0       	ldi	r25, 0x0B	; 11
    1820:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
      device_number = option - 48;
    1824:	c0 53       	subi	r28, 0x30	; 48
    1826:	c0 93 dd 07 	sts	0x07DD, r28	; 0x8007dd <device_number>
    182a:	28 c0       	rjmp	.+80     	; 0x187c <remote_control+0xb0>
      }
    }
  else {
    if (invalid_user_input || option < '1' || option > '6') {
    182c:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <invalid_user_input>
    1830:	81 11       	cpse	r24, r1
    1832:	04 c0       	rjmp	.+8      	; 0x183c <remote_control+0x70>
    1834:	c1 33       	cpi	r28, 0x31	; 49
    1836:	10 f0       	brcs	.+4      	; 0x183c <remote_control+0x70>
    1838:	c7 33       	cpi	r28, 0x37	; 55
    183a:	60 f0       	brcs	.+24     	; 0x1854 <remote_control+0x88>
      println_msg("Invalid option!\t");
    183c:	81 ef       	ldi	r24, 0xF1	; 241
    183e:	92 e0       	ldi	r25, 0x02	; 2
    1840:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      print_remote_control_menu();
    1844:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    1848:	62 e0       	ldi	r22, 0x02	; 2
    184a:	86 ee       	ldi	r24, 0xE6	; 230
    184c:	9b e0       	ldi	r25, 0x0B	; 11
    184e:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1852:	14 c0       	rjmp	.+40     	; 0x187c <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    1854:	82 e0       	ldi	r24, 0x02	; 2
    1856:	93 e0       	ldi	r25, 0x03	; 3
    1858:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    185c:	88 e5       	ldi	r24, 0x58	; 88
    185e:	93 e0       	ldi	r25, 0x03	; 3
    1860:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    1864:	81 e9       	ldi	r24, 0x91	; 145
    1866:	93 e0       	ldi	r25, 0x03	; 3
    1868:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      request_user_input(control_device, 2);
    186c:	62 e0       	ldi	r22, 0x02	; 2
    186e:	8d e8       	ldi	r24, 0x8D	; 141
    1870:	9b e0       	ldi	r25, 0x0B	; 11
    1872:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
      device_number = option - 48;
    1876:	c0 53       	subi	r28, 0x30	; 48
    1878:	c0 93 dd 07 	sts	0x07DD, r28	; 0x8007dd <device_number>
      }
    }
  }
    187c:	cf 91       	pop	r28
    187e:	08 95       	ret

00001880 <print_initial_options_menu>:

void print_initial_options_menu(void) {
  if (remote_user.isAdmin) {
    1880:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <remote_user>
    1884:	88 23       	and	r24, r24
    1886:	a9 f0       	breq	.+42     	; 0x18b2 <print_initial_options_menu+0x32>
    println_msg("Select one of the following options(by entering its number):\t");
    1888:	89 ec       	ldi	r24, 0xC9	; 201
    188a:	93 e0       	ldi	r25, 0x03	; 3
    188c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    println_msg("[1] Add user\t");
    1890:	87 e0       	ldi	r24, 0x07	; 7
    1892:	94 e0       	ldi	r25, 0x04	; 4
    1894:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    println_msg("[2] Delete user\t");
    1898:	85 e1       	ldi	r24, 0x15	; 21
    189a:	94 e0       	ldi	r25, 0x04	; 4
    189c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    println_msg("[3] Control a device\t");
    18a0:	86 e2       	ldi	r24, 0x26	; 38
    18a2:	94 e0       	ldi	r25, 0x04	; 4
    18a4:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    println_msg("[4] Log out\t");
    18a8:	8c e3       	ldi	r24, 0x3C	; 60
    18aa:	94 e0       	ldi	r25, 0x04	; 4
    18ac:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    18b0:	08 95       	ret
    }
  else {
    println_msg("Select one of the following options(by entering its number):\t");
    18b2:	89 ec       	ldi	r24, 0xC9	; 201
    18b4:	93 e0       	ldi	r25, 0x03	; 3
    18b6:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    println_msg("[1] Control a device\t");
    18ba:	89 e4       	ldi	r24, 0x49	; 73
    18bc:	94 e0       	ldi	r25, 0x04	; 4
    18be:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    println_msg("[2] Log out\t");
    18c2:	8f e5       	ldi	r24, 0x5F	; 95
    18c4:	94 e0       	ldi	r25, 0x04	; 4
    18c6:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    18ca:	08 95       	ret

000018cc <delete_user_prompt>:
  strcpy(user_dialog_tree, options);
  msg_length = msgLength;
  }

void delete_user_prompt(void) {
  if (invalid_user_input) {
    18cc:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <invalid_user_input>
    18d0:	88 23       	and	r24, r24
    18d2:	61 f0       	breq	.+24     	; 0x18ec <delete_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    18d4:	8c e6       	ldi	r24, 0x6C	; 108
    18d6:	94 e0       	ldi	r25, 0x04	; 4
    18d8:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    18dc:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    18e0:	62 e0       	ldi	r22, 0x02	; 2
    18e2:	8a e9       	ldi	r24, 0x9A	; 154
    18e4:	9c e0       	ldi	r25, 0x0C	; 12
    18e6:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    18ea:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    18ec:	6b eb       	ldi	r22, 0xBB	; 187
    18ee:	77 e0       	ldi	r23, 0x07	; 7
    18f0:	87 e4       	ldi	r24, 0x47	; 71
    18f2:	97 e0       	ldi	r25, 0x07	; 7
    18f4:	0e 94 70 0f 	call	0x1ee0	; 0x1ee0 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    18f8:	83 30       	cpi	r24, 0x03	; 3
    18fa:	61 f4       	brne	.+24     	; 0x1914 <delete_user_prompt+0x48>
      println_msg("\rError! User not found. Returning to the main menu...");
    18fc:	82 e8       	ldi	r24, 0x82	; 130
    18fe:	94 e0       	ldi	r25, 0x04	; 4
    1900:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      print_initial_options_menu();
    1904:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1908:	62 e0       	ldi	r22, 0x02	; 2
    190a:	8a e9       	ldi	r24, 0x9A	; 154
    190c:	9c e0       	ldi	r25, 0x0C	; 12
    190e:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1912:	08 95       	ret
      }
    else {
      // Delete the user
      delete_user(&temp_user);
    1914:	8b eb       	ldi	r24, 0xBB	; 187
    1916:	97 e0       	ldi	r25, 0x07	; 7
    1918:	0e 94 46 11 	call	0x228c	; 0x228c <delete_user>
      println_msg("The user has been deleted successfully!\t");
    191c:	88 eb       	ldi	r24, 0xB8	; 184
    191e:	94 e0       	ldi	r25, 0x04	; 4
    1920:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1924:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1928:	62 e0       	ldi	r22, 0x02	; 2
    192a:	8a e9       	ldi	r24, 0x9A	; 154
    192c:	9c e0       	ldi	r25, 0x0C	; 12
    192e:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1932:	08 95       	ret

00001934 <initial_options_menu>:
    println_msg("[2] Log out\t");
    }
  }

void initial_options_menu() {
  if (remote_user.isAdmin) {
    1934:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <remote_user>
    1938:	88 23       	and	r24, r24
    193a:	09 f4       	brne	.+2      	; 0x193e <initial_options_menu+0xa>
    193c:	4b c0       	rjmp	.+150    	; 0x19d4 <initial_options_menu+0xa0>
    u8 option = msg_buffer[0];
    193e:	80 91 47 07 	lds	r24, 0x0747	; 0x800747 <msg_buffer>
    if (invalid_user_input || option < '1' || option > '4') {
    1942:	90 91 62 07 	lds	r25, 0x0762	; 0x800762 <invalid_user_input>
    1946:	91 11       	cpse	r25, r1
    1948:	04 c0       	rjmp	.+8      	; 0x1952 <initial_options_menu+0x1e>
    194a:	81 33       	cpi	r24, 0x31	; 49
    194c:	10 f0       	brcs	.+4      	; 0x1952 <initial_options_menu+0x1e>
    194e:	85 33       	cpi	r24, 0x35	; 53
    1950:	60 f0       	brcs	.+24     	; 0x196a <initial_options_menu+0x36>
      println_msg("Invalid option!\t");
    1952:	81 ef       	ldi	r24, 0xF1	; 241
    1954:	92 e0       	ldi	r25, 0x02	; 2
    1956:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      print_initial_options_menu();
    195a:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    195e:	62 e0       	ldi	r22, 0x02	; 2
    1960:	8a e9       	ldi	r24, 0x9A	; 154
    1962:	9c e0       	ldi	r25, 0x0C	; 12
    1964:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1968:	08 95       	ret
      }
    else {
      switch (option) {
    196a:	82 33       	cpi	r24, 0x32	; 50
    196c:	99 f0       	breq	.+38     	; 0x1994 <initial_options_menu+0x60>
    196e:	18 f4       	brcc	.+6      	; 0x1976 <initial_options_menu+0x42>
    1970:	81 33       	cpi	r24, 0x31	; 49
    1972:	31 f0       	breq	.+12     	; 0x1980 <initial_options_menu+0x4c>
    1974:	08 95       	ret
    1976:	83 33       	cpi	r24, 0x33	; 51
    1978:	b9 f0       	breq	.+46     	; 0x19a8 <initial_options_menu+0x74>
    197a:	84 33       	cpi	r24, 0x34	; 52
    197c:	e9 f0       	breq	.+58     	; 0x19b8 <initial_options_menu+0x84>
    197e:	08 95       	ret
          case '1':
            print_msg("Enter the user name: ");
    1980:	81 ee       	ldi	r24, 0xE1	; 225
    1982:	94 e0       	ldi	r25, 0x04	; 4
    1984:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
            request_user_input(add_user_prompt, 13);
    1988:	6d e0       	ldi	r22, 0x0D	; 13
    198a:	8c e9       	ldi	r24, 0x9C	; 156
    198c:	9d e0       	ldi	r25, 0x0D	; 13
    198e:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
            break;
    1992:	08 95       	ret
          case '2':
            print_msg("Enter the user name: ");
    1994:	81 ee       	ldi	r24, 0xE1	; 225
    1996:	94 e0       	ldi	r25, 0x04	; 4
    1998:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
            request_user_input(delete_user_prompt, 13);
    199c:	6d e0       	ldi	r22, 0x0D	; 13
    199e:	86 e6       	ldi	r24, 0x66	; 102
    19a0:	9c e0       	ldi	r25, 0x0C	; 12
    19a2:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
            break;
    19a6:	08 95       	ret
          case '3':
            print_remote_control_menu();
    19a8:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    19ac:	62 e0       	ldi	r22, 0x02	; 2
    19ae:	86 ee       	ldi	r24, 0xE6	; 230
    19b0:	9b e0       	ldi	r25, 0x0B	; 11
    19b2:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
            break;
    19b6:	08 95       	ret
          case '4':
            remote_user_loggedin = true;
    19b8:	81 e0       	ldi	r24, 0x01	; 1
    19ba:	80 93 45 07 	sts	0x0745, r24	; 0x800745 <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    19be:	87 ef       	ldi	r24, 0xF7	; 247
    19c0:	94 e0       	ldi	r25, 0x04	; 4
    19c2:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
            println_msg("You have successfully logged out...");
    19c6:	8f e3       	ldi	r24, 0x3F	; 63
    19c8:	95 e0       	ldi	r25, 0x05	; 5
    19ca:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
            msg_length = 0;
    19ce:	10 92 56 07 	sts	0x0756, r1	; 0x800756 <msg_length>
            break;
    19d2:	08 95       	ret
        }
      }
    }
  else {
    u8 option = msg_buffer[0];
    19d4:	80 91 47 07 	lds	r24, 0x0747	; 0x800747 <msg_buffer>
    if (invalid_user_input || option < '1' || option > '2') {
    19d8:	90 91 62 07 	lds	r25, 0x0762	; 0x800762 <invalid_user_input>
    19dc:	91 11       	cpse	r25, r1
    19de:	04 c0       	rjmp	.+8      	; 0x19e8 <initial_options_menu+0xb4>
    19e0:	81 33       	cpi	r24, 0x31	; 49
    19e2:	10 f0       	brcs	.+4      	; 0x19e8 <initial_options_menu+0xb4>
    19e4:	83 33       	cpi	r24, 0x33	; 51
    19e6:	60 f0       	brcs	.+24     	; 0x1a00 <initial_options_menu+0xcc>
      println_msg("Invalid option!\t");
    19e8:	81 ef       	ldi	r24, 0xF1	; 241
    19ea:	92 e0       	ldi	r25, 0x02	; 2
    19ec:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      print_initial_options_menu();
    19f0:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    19f4:	62 e0       	ldi	r22, 0x02	; 2
    19f6:	8a e9       	ldi	r24, 0x9A	; 154
    19f8:	9c e0       	ldi	r25, 0x0C	; 12
    19fa:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    19fe:	08 95       	ret
      }
    else {
      switch (option) {
    1a00:	81 33       	cpi	r24, 0x31	; 49
    1a02:	19 f0       	breq	.+6      	; 0x1a0a <initial_options_menu+0xd6>
    1a04:	82 33       	cpi	r24, 0x32	; 50
    1a06:	49 f0       	breq	.+18     	; 0x1a1a <initial_options_menu+0xe6>
    1a08:	08 95       	ret
          case '1':
            print_remote_control_menu();
    1a0a:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    1a0e:	62 e0       	ldi	r22, 0x02	; 2
    1a10:	86 ee       	ldi	r24, 0xE6	; 230
    1a12:	9b e0       	ldi	r25, 0x0B	; 11
    1a14:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
            break;
    1a18:	08 95       	ret
          case '2':
            remote_user_loggedin = true;
    1a1a:	81 e0       	ldi	r24, 0x01	; 1
    1a1c:	80 93 45 07 	sts	0x0745, r24	; 0x800745 <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    1a20:	87 ef       	ldi	r24, 0xF7	; 247
    1a22:	94 e0       	ldi	r25, 0x04	; 4
    1a24:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
            println_msg("You have successfully logged out...");
    1a28:	8f e3       	ldi	r24, 0x3F	; 63
    1a2a:	95 e0       	ldi	r25, 0x05	; 5
    1a2c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
            msg_length = 0;
    1a30:	10 92 56 07 	sts	0x0756, r1	; 0x800756 <msg_length>
    1a34:	08 95       	ret

00001a36 <add_user_isAdmin_prompt>:
      }
    }
  }

void add_user_isAdmin_prompt(void) {
  if (invalid_user_input) {
    1a36:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <invalid_user_input>
    1a3a:	88 23       	and	r24, r24
    1a3c:	61 f0       	breq	.+24     	; 0x1a56 <add_user_isAdmin_prompt+0x20>
    println_msg("\r\nInvalid input!!\t");
    1a3e:	8f e4       	ldi	r24, 0x4F	; 79
    1a40:	92 e0       	ldi	r25, 0x02	; 2
    1a42:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    //! The system should ask the user wether he wants to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1a46:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1a4a:	62 e0       	ldi	r22, 0x02	; 2
    1a4c:	8a e9       	ldi	r24, 0x9A	; 154
    1a4e:	9c e0       	ldi	r25, 0x0C	; 12
    1a50:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1a54:	08 95       	ret
    }
  else {
    new_user.isAdmin = (msg_buffer[0] == 'y' || msg_buffer[0] == 'Y');
    1a56:	80 91 47 07 	lds	r24, 0x0747	; 0x800747 <msg_buffer>
    1a5a:	89 37       	cpi	r24, 0x79	; 121
    1a5c:	21 f0       	breq	.+8      	; 0x1a66 <add_user_isAdmin_prompt+0x30>
    1a5e:	89 35       	cpi	r24, 0x59	; 89
    1a60:	21 f4       	brne	.+8      	; 0x1a6a <add_user_isAdmin_prompt+0x34>
    1a62:	81 e0       	ldi	r24, 0x01	; 1
    1a64:	03 c0       	rjmp	.+6      	; 0x1a6c <add_user_isAdmin_prompt+0x36>
    1a66:	81 e0       	ldi	r24, 0x01	; 1
    1a68:	01 c0       	rjmp	.+2      	; 0x1a6c <add_user_isAdmin_prompt+0x36>
    1a6a:	80 e0       	ldi	r24, 0x00	; 0
    1a6c:	80 93 de 07 	sts	0x07DE, r24	; 0x8007de <new_user>
    add_user(&new_user);
    1a70:	8e ed       	ldi	r24, 0xDE	; 222
    1a72:	97 e0       	ldi	r25, 0x07	; 7
    1a74:	0e 94 0b 11 	call	0x2216	; 0x2216 <add_user>
    println_msg("User has been added successfully!");
    1a78:	83 e6       	ldi	r24, 0x63	; 99
    1a7a:	95 e0       	ldi	r25, 0x05	; 5
    1a7c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    //! Return to the main menu
    print_initial_options_menu();
    1a80:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1a84:	62 e0       	ldi	r22, 0x02	; 2
    1a86:	8a e9       	ldi	r24, 0x9A	; 154
    1a88:	9c e0       	ldi	r25, 0x0C	; 12
    1a8a:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1a8e:	08 95       	ret

00001a90 <add_user_password_prompt>:
    }
  }

void add_user_password_prompt(void) {
  if (invalid_user_input) {
    1a90:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <invalid_user_input>
    1a94:	88 23       	and	r24, r24
    1a96:	61 f0       	breq	.+24     	; 0x1ab0 <add_user_password_prompt+0x20>
    println_msg("\r\nPassword too long!!\t");
    1a98:	85 e8       	ldi	r24, 0x85	; 133
    1a9a:	95 e0       	ldi	r25, 0x05	; 5
    1a9c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1aa0:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1aa4:	62 e0       	ldi	r22, 0x02	; 2
    1aa6:	8a e9       	ldi	r24, 0x9A	; 154
    1aa8:	9c e0       	ldi	r25, 0x0C	; 12
    1aaa:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1aae:	08 95       	ret
    }
  else {
    strcpy(new_user.password, msg_buffer);
    1ab0:	67 e4       	ldi	r22, 0x47	; 71
    1ab2:	77 e0       	ldi	r23, 0x07	; 7
    1ab4:	83 ef       	ldi	r24, 0xF3	; 243
    1ab6:	97 e0       	ldi	r25, 0x07	; 7
    1ab8:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <strcpy>
    print_msg("Do you want to make the new user an admin? (y/n) ");
    1abc:	8c e9       	ldi	r24, 0x9C	; 156
    1abe:	95 e0       	ldi	r25, 0x05	; 5
    1ac0:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
    request_user_input(add_user_isAdmin_prompt, 2);
    1ac4:	62 e0       	ldi	r22, 0x02	; 2
    1ac6:	8b e1       	ldi	r24, 0x1B	; 27
    1ac8:	9d e0       	ldi	r25, 0x0D	; 13
    1aca:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1ace:	08 95       	ret

00001ad0 <add_user_code_prompt>:
    }
  }

void add_user_code_prompt(void) {
  if (invalid_user_input) {
    1ad0:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <invalid_user_input>
    1ad4:	88 23       	and	r24, r24
    1ad6:	61 f0       	breq	.+24     	; 0x1af0 <add_user_code_prompt+0x20>
    println_msg("\r\nInvalid user code!\t");
    1ad8:	8e ec       	ldi	r24, 0xCE	; 206
    1ada:	95 e0       	ldi	r25, 0x05	; 5
    1adc:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1ae0:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1ae4:	62 e0       	ldi	r22, 0x02	; 2
    1ae6:	8a e9       	ldi	r24, 0x9A	; 154
    1ae8:	9c e0       	ldi	r25, 0x0C	; 12
    1aea:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1aee:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByCode(msg_buffer, &temp_user);
    1af0:	6b eb       	ldi	r22, 0xBB	; 187
    1af2:	77 e0       	ldi	r23, 0x07	; 7
    1af4:	87 e4       	ldi	r24, 0x47	; 71
    1af6:	97 e0       	ldi	r25, 0x07	; 7
    1af8:	0e 94 09 10 	call	0x2012	; 0x2012 <getUserByCode>
    if (userExists == USER_NOT_FOUND) {
    1afc:	83 30       	cpi	r24, 0x03	; 3
    1afe:	81 f4       	brne	.+32     	; 0x1b20 <add_user_code_prompt+0x50>
      strcpy(new_user.code, msg_buffer);
    1b00:	67 e4       	ldi	r22, 0x47	; 71
    1b02:	77 e0       	ldi	r23, 0x07	; 7
    1b04:	8c ee       	ldi	r24, 0xEC	; 236
    1b06:	97 e0       	ldi	r25, 0x07	; 7
    1b08:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <strcpy>
      print_msg("Enter the new user's password: ");
    1b0c:	84 ee       	ldi	r24, 0xE4	; 228
    1b0e:	95 e0       	ldi	r25, 0x05	; 5
    1b10:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
      request_user_input(add_user_password_prompt, 11);
    1b14:	6b e0       	ldi	r22, 0x0B	; 11
    1b16:	88 e4       	ldi	r24, 0x48	; 72
    1b18:	9d e0       	ldi	r25, 0x0D	; 13
    1b1a:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1b1e:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      println_msg("\rThe user code already exists!\t");
    1b20:	84 e0       	ldi	r24, 0x04	; 4
    1b22:	96 e0       	ldi	r25, 0x06	; 6
    1b24:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1b28:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1b2c:	62 e0       	ldi	r22, 0x02	; 2
    1b2e:	8a e9       	ldi	r24, 0x9A	; 154
    1b30:	9c e0       	ldi	r25, 0x0C	; 12
    1b32:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1b36:	08 95       	ret

00001b38 <add_user_prompt>:
      }
    }
  }

void add_user_prompt(void) {
  if (invalid_user_input) {
    1b38:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <invalid_user_input>
    1b3c:	88 23       	and	r24, r24
    1b3e:	61 f0       	breq	.+24     	; 0x1b58 <add_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    1b40:	8c e6       	ldi	r24, 0x6C	; 108
    1b42:	94 e0       	ldi	r25, 0x04	; 4
    1b44:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1b48:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1b4c:	62 e0       	ldi	r22, 0x02	; 2
    1b4e:	8a e9       	ldi	r24, 0x9A	; 154
    1b50:	9c e0       	ldi	r25, 0x0C	; 12
    1b52:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1b56:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    1b58:	6b eb       	ldi	r22, 0xBB	; 187
    1b5a:	77 e0       	ldi	r23, 0x07	; 7
    1b5c:	87 e4       	ldi	r24, 0x47	; 71
    1b5e:	97 e0       	ldi	r25, 0x07	; 7
    1b60:	0e 94 70 0f 	call	0x1ee0	; 0x1ee0 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    1b64:	83 30       	cpi	r24, 0x03	; 3
    1b66:	81 f4       	brne	.+32     	; 0x1b88 <add_user_prompt+0x50>
      strcpy(new_user.name, msg_buffer);
    1b68:	67 e4       	ldi	r22, 0x47	; 71
    1b6a:	77 e0       	ldi	r23, 0x07	; 7
    1b6c:	8f ed       	ldi	r24, 0xDF	; 223
    1b6e:	97 e0       	ldi	r25, 0x07	; 7
    1b70:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <strcpy>
      print_msg("Enter the new user's code(must be a unique six digit code): ");
    1b74:	84 e2       	ldi	r24, 0x24	; 36
    1b76:	96 e0       	ldi	r25, 0x06	; 6
    1b78:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
      request_user_input(add_user_code_prompt, 7);
    1b7c:	67 e0       	ldi	r22, 0x07	; 7
    1b7e:	88 e6       	ldi	r24, 0x68	; 104
    1b80:	9d e0       	ldi	r25, 0x0D	; 13
    1b82:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1b86:	08 95       	ret
      }
    else {
      // Prompt the user to enter the user code
      println_msg("\rThe user already exists!\t");
    1b88:	81 e6       	ldi	r24, 0x61	; 97
    1b8a:	96 e0       	ldi	r25, 0x06	; 6
    1b8c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1b90:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1b94:	62 e0       	ldi	r22, 0x02	; 2
    1b96:	8a e9       	ldi	r24, 0x9A	; 154
    1b98:	9c e0       	ldi	r25, 0x0C	; 12
    1b9a:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1b9e:	08 95       	ret

00001ba0 <invalid_remote_login_attempt>:
      }
    }
  }

void invalid_remote_login_attempt(void) {
    1ba0:	0f 93       	push	r16
    1ba2:	1f 93       	push	r17
    1ba4:	cf 93       	push	r28
    1ba6:	df 93       	push	r29
    1ba8:	cd b7       	in	r28, 0x3d	; 61
    1baa:	de b7       	in	r29, 0x3e	; 62
    1bac:	e2 97       	sbiw	r28, 0x32	; 50
    1bae:	0f b6       	in	r0, 0x3f	; 63
    1bb0:	f8 94       	cli
    1bb2:	de bf       	out	0x3e, r29	; 62
    1bb4:	0f be       	out	0x3f, r0	; 63
    1bb6:	cd bf       	out	0x3d, r28	; 61
  invalid_trails++;
    1bb8:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <__data_end>
    1bbc:	8f 5f       	subi	r24, 0xFF	; 255
    1bbe:	80 93 44 07 	sts	0x0744, r24	; 0x800744 <__data_end>
  if (invalid_trails < 3) {
    1bc2:	83 30       	cpi	r24, 0x03	; 3
    1bc4:	e8 f4       	brcc	.+58     	; 0x1c00 <invalid_remote_login_attempt+0x60>
    s8 msg[50];
    sprintf(msg, "\r\nInvalid login attempt! \r\n%d attempts remaining.", 3 - invalid_trails);
    1bc6:	23 e0       	ldi	r18, 0x03	; 3
    1bc8:	30 e0       	ldi	r19, 0x00	; 0
    1bca:	a9 01       	movw	r20, r18
    1bcc:	48 1b       	sub	r20, r24
    1bce:	51 09       	sbc	r21, r1
    1bd0:	ca 01       	movw	r24, r20
    1bd2:	9f 93       	push	r25
    1bd4:	4f 93       	push	r20
    1bd6:	8c e7       	ldi	r24, 0x7C	; 124
    1bd8:	96 e0       	ldi	r25, 0x06	; 6
    1bda:	9f 93       	push	r25
    1bdc:	8f 93       	push	r24
    1bde:	8e 01       	movw	r16, r28
    1be0:	0f 5f       	subi	r16, 0xFF	; 255
    1be2:	1f 4f       	sbci	r17, 0xFF	; 255
    1be4:	1f 93       	push	r17
    1be6:	0f 93       	push	r16
    1be8:	0e 94 e7 13 	call	0x27ce	; 0x27ce <sprintf>
    println_msg(msg);
    1bec:	c8 01       	movw	r24, r16
    1bee:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
    1bf2:	0f 90       	pop	r0
    1bf4:	0f 90       	pop	r0
    1bf6:	0f 90       	pop	r0
    1bf8:	0f 90       	pop	r0
    1bfa:	0f 90       	pop	r0
    1bfc:	0f 90       	pop	r0
    1bfe:	04 c0       	rjmp	.+8      	; 0x1c08 <invalid_remote_login_attempt+0x68>
    return;
    }
  Alarm_set();
    1c00:	0e 94 a2 10 	call	0x2144	; 0x2144 <Alarm_set>
  run_system = false;
    1c04:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
  }
    1c08:	e2 96       	adiw	r28, 0x32	; 50
    1c0a:	0f b6       	in	r0, 0x3f	; 63
    1c0c:	f8 94       	cli
    1c0e:	de bf       	out	0x3e, r29	; 62
    1c10:	0f be       	out	0x3f, r0	; 63
    1c12:	cd bf       	out	0x3d, r28	; 61
    1c14:	df 91       	pop	r29
    1c16:	cf 91       	pop	r28
    1c18:	1f 91       	pop	r17
    1c1a:	0f 91       	pop	r16
    1c1c:	08 95       	ret

00001c1e <userPassword_prompt_handler>:

void userPassword_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    1c1e:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <invalid_user_input>
    1c22:	88 23       	and	r24, r24
    1c24:	61 f0       	breq	.+24     	; 0x1c3e <userPassword_prompt_handler+0x20>
    invalid_remote_login_attempt();
    1c26:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <invalid_remote_login_attempt>
    print_msg("Enter your password:\t");
    1c2a:	8e ea       	ldi	r24, 0xAE	; 174
    1c2c:	96 e0       	ldi	r25, 0x06	; 6
    1c2e:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
    request_user_input(userPassword_prompt_handler, 11);
    1c32:	6b e0       	ldi	r22, 0x0B	; 11
    1c34:	8f e0       	ldi	r24, 0x0F	; 15
    1c36:	9e e0       	ldi	r25, 0x0E	; 14
    1c38:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1c3c:	08 95       	ret
    }
  else {
    if (strcmp(remote_user.password, msg_buffer)) { // Wrong password
    1c3e:	67 e4       	ldi	r22, 0x47	; 71
    1c40:	77 e0       	ldi	r23, 0x07	; 7
    1c42:	80 eb       	ldi	r24, 0xB0	; 176
    1c44:	97 e0       	ldi	r25, 0x07	; 7
    1c46:	0e 94 d7 13 	call	0x27ae	; 0x27ae <strcmp>
    1c4a:	89 2b       	or	r24, r25
    1c4c:	81 f0       	breq	.+32     	; 0x1c6e <userPassword_prompt_handler+0x50>
      print_msg("Wrong password!");
    1c4e:	84 ec       	ldi	r24, 0xC4	; 196
    1c50:	96 e0       	ldi	r25, 0x06	; 6
    1c52:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
      invalid_remote_login_attempt();
    1c56:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <invalid_remote_login_attempt>
      print_msg("Enter your password:\t");
    1c5a:	8e ea       	ldi	r24, 0xAE	; 174
    1c5c:	96 e0       	ldi	r25, 0x06	; 6
    1c5e:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    1c62:	6b e0       	ldi	r22, 0x0B	; 11
    1c64:	8f e0       	ldi	r24, 0x0F	; 15
    1c66:	9e e0       	ldi	r25, 0x0E	; 14
    1c68:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1c6c:	08 95       	ret
      }
    else {
      remote_user_loggedin = true;
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	80 93 45 07 	sts	0x0745, r24	; 0x800745 <remote_user_loggedin>
      print_msg("Welcome ");
    1c74:	84 ed       	ldi	r24, 0xD4	; 212
    1c76:	96 e0       	ldi	r25, 0x06	; 6
    1c78:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
      print_msg(remote_user.name);
    1c7c:	8c e9       	ldi	r24, 0x9C	; 156
    1c7e:	97 e0       	ldi	r25, 0x07	; 7
    1c80:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
      println_msg("!");
    1c84:	8a ec       	ldi	r24, 0xCA	; 202
    1c86:	91 e0       	ldi	r25, 0x01	; 1
    1c88:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
      // Show the options menu
      print_initial_options_menu();
    1c8c:	0e 94 40 0c 	call	0x1880	; 0x1880 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1c90:	62 e0       	ldi	r22, 0x02	; 2
    1c92:	8a e9       	ldi	r24, 0x9A	; 154
    1c94:	9c e0       	ldi	r25, 0x0C	; 12
    1c96:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1c9a:	08 95       	ret

00001c9c <userName_prompt_handler>:
    }
  }

void userName_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    1c9c:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <invalid_user_input>
    1ca0:	88 23       	and	r24, r24
    1ca2:	61 f0       	breq	.+24     	; 0x1cbc <userName_prompt_handler+0x20>
    invalid_remote_login_attempt();
    1ca4:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <invalid_remote_login_attempt>
    print_msg("Enter your user name:\t");
    1ca8:	8d ed       	ldi	r24, 0xDD	; 221
    1caa:	96 e0       	ldi	r25, 0x06	; 6
    1cac:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
    request_user_input(userName_prompt_handler, 13);
    1cb0:	6d e0       	ldi	r22, 0x0D	; 13
    1cb2:	8e e4       	ldi	r24, 0x4E	; 78
    1cb4:	9e e0       	ldi	r25, 0x0E	; 14
    1cb6:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1cba:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &remote_user);
    1cbc:	6b e9       	ldi	r22, 0x9B	; 155
    1cbe:	77 e0       	ldi	r23, 0x07	; 7
    1cc0:	87 e4       	ldi	r24, 0x47	; 71
    1cc2:	97 e0       	ldi	r25, 0x07	; 7
    1cc4:	0e 94 70 0f 	call	0x1ee0	; 0x1ee0 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    1cc8:	83 30       	cpi	r24, 0x03	; 3
    1cca:	81 f4       	brne	.+32     	; 0x1cec <userName_prompt_handler+0x50>
      print_msg("User doesn't exist!");
    1ccc:	84 ef       	ldi	r24, 0xF4	; 244
    1cce:	96 e0       	ldi	r25, 0x06	; 6
    1cd0:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
      invalid_remote_login_attempt();
    1cd4:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <invalid_remote_login_attempt>
      print_msg("Enter your user name:\t");
    1cd8:	8d ed       	ldi	r24, 0xDD	; 221
    1cda:	96 e0       	ldi	r25, 0x06	; 6
    1cdc:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
      request_user_input(userName_prompt_handler, 13);
    1ce0:	6d e0       	ldi	r22, 0x0D	; 13
    1ce2:	8e e4       	ldi	r24, 0x4E	; 78
    1ce4:	9e e0       	ldi	r25, 0x0E	; 14
    1ce6:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1cea:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      print_msg("Enter your password:\t");
    1cec:	8e ea       	ldi	r24, 0xAE	; 174
    1cee:	96 e0       	ldi	r25, 0x06	; 6
    1cf0:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    1cf4:	6b e0       	ldi	r22, 0x0B	; 11
    1cf6:	8f e0       	ldi	r24, 0x0F	; 15
    1cf8:	9e e0       	ldi	r25, 0x0E	; 14
    1cfa:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1cfe:	08 95       	ret

00001d00 <remote_login_prompt>:
      }
    }
  }

void remote_login_prompt(void) {
  println_msg("Welcome to the Smart Home System!");
    1d00:	88 e0       	ldi	r24, 0x08	; 8
    1d02:	97 e0       	ldi	r25, 0x07	; 7
    1d04:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
  println_msg("To proceed, please login.");
    1d08:	8a e2       	ldi	r24, 0x2A	; 42
    1d0a:	97 e0       	ldi	r25, 0x07	; 7
    1d0c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <println_msg>
  print_msg("Enter your user name:\t");
    1d10:	8d ed       	ldi	r24, 0xDD	; 221
    1d12:	96 e0       	ldi	r25, 0x06	; 6
    1d14:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <print_msg>
  request_user_input(userName_prompt_handler, 13);
    1d18:	6d e0       	ldi	r22, 0x0D	; 13
    1d1a:	8e e4       	ldi	r24, 0x4E	; 78
    1d1c:	9e e0       	ldi	r25, 0x0E	; 14
    1d1e:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <request_user_input>
    1d22:	08 95       	ret

00001d24 <__vector_13>:
  }

// Handles the user input asynchronously.
ISR(USART_RXC_vect) {
    1d24:	1f 92       	push	r1
    1d26:	0f 92       	push	r0
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	0f 92       	push	r0
    1d2c:	11 24       	eor	r1, r1
    1d2e:	2f 93       	push	r18
    1d30:	3f 93       	push	r19
    1d32:	4f 93       	push	r20
    1d34:	5f 93       	push	r21
    1d36:	6f 93       	push	r22
    1d38:	7f 93       	push	r23
    1d3a:	8f 93       	push	r24
    1d3c:	9f 93       	push	r25
    1d3e:	af 93       	push	r26
    1d40:	bf 93       	push	r27
    1d42:	ef 93       	push	r30
    1d44:	ff 93       	push	r31
#if UART_COMMUNICATION_INTERFACE ==  PROTEUS_VIRTUAL_TERMINAL
  // Read the UDR to clear the RXC bit
  udr_temp = UDR;
    1d46:	8c b1       	in	r24, 0x0c	; 12
    1d48:	80 93 dc 07 	sts	0x07DC, r24	; 0x8007dc <udr_temp>

  // If no input requested, ignore the input. No input requested is indicated by msg length of zero
  if (msg_length == 0) return;
    1d4c:	90 91 56 07 	lds	r25, 0x0756	; 0x800756 <msg_length>
    1d50:	99 23       	and	r25, r25
    1d52:	09 f4       	brne	.+2      	; 0x1d56 <__vector_13+0x32>
    1d54:	4d c0       	rjmp	.+154    	; 0x1df0 <__vector_13+0xcc>

  // Handling backspaces
  if (udr_temp == '\b') {
    1d56:	88 30       	cpi	r24, 0x08	; 8
    1d58:	59 f4       	brne	.+22     	; 0x1d70 <__vector_13+0x4c>
    if (msg_buffer_pointer > 0) {
    1d5a:	90 91 46 07 	lds	r25, 0x0746	; 0x800746 <msg_buffer_pointer>
    1d5e:	99 23       	and	r25, r25
    1d60:	09 f4       	brne	.+2      	; 0x1d64 <__vector_13+0x40>
    1d62:	46 c0       	rjmp	.+140    	; 0x1df0 <__vector_13+0xcc>
      msg_buffer_pointer--;
    1d64:	91 50       	subi	r25, 0x01	; 1
    1d66:	90 93 46 07 	sts	0x0746, r25	; 0x800746 <msg_buffer_pointer>
      BT_sendChar(udr_temp);
    1d6a:	0e 94 da 01 	call	0x3b4	; 0x3b4 <BT_sendChar>
    1d6e:	40 c0       	rjmp	.+128    	; 0x1df0 <__vector_13+0xcc>
      }
    return;
    }

  msg_buffer[msg_buffer_pointer] = udr_temp;
    1d70:	90 91 46 07 	lds	r25, 0x0746	; 0x800746 <msg_buffer_pointer>
    1d74:	e9 2f       	mov	r30, r25
    1d76:	f0 e0       	ldi	r31, 0x00	; 0
    1d78:	e9 5b       	subi	r30, 0xB9	; 185
    1d7a:	f8 4f       	sbci	r31, 0xF8	; 248
    1d7c:	80 83       	st	Z, r24
  msg_buffer_pointer++;
    1d7e:	9f 5f       	subi	r25, 0xFF	; 255
    1d80:	90 93 46 07 	sts	0x0746, r25	; 0x800746 <msg_buffer_pointer>

  // Msg is empty
  // Ignore null msgs
  if (msg_buffer_pointer == 1) {
    1d84:	91 30       	cpi	r25, 0x01	; 1
    1d86:	39 f4       	brne	.+14     	; 0x1d96 <__vector_13+0x72>
    if (msg_buffer[0] == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1d88:	90 91 47 07 	lds	r25, 0x0747	; 0x800747 <msg_buffer>
    1d8c:	9d 30       	cpi	r25, 0x0D	; 13
    1d8e:	19 f4       	brne	.+6      	; 0x1d96 <__vector_13+0x72>
      msg_buffer_pointer = 0;
    1d90:	10 92 46 07 	sts	0x0746, r1	; 0x800746 <msg_buffer_pointer>
      return;
    1d94:	2d c0       	rjmp	.+90     	; 0x1df0 <__vector_13+0xcc>
      }
    }

  // Echo the sent char on the terminal
  //! Proteus virtual terminal doesn't send a line feed char (ASCII code: 10). Instead it sends a carriage return (ASCII code: 13).
  if (udr_temp != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER)
    1d96:	8d 30       	cpi	r24, 0x0D	; 13
    1d98:	11 f0       	breq	.+4      	; 0x1d9e <__vector_13+0x7a>
    BT_sendChar(udr_temp);
    1d9a:	0e 94 da 01 	call	0x3b4	; 0x3b4 <BT_sendChar>

  // Msg is longer than required
  if (msg_buffer_pointer == msg_length) {
    1d9e:	e0 91 46 07 	lds	r30, 0x0746	; 0x800746 <msg_buffer_pointer>
    1da2:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <msg_length>
    1da6:	e8 13       	cpse	r30, r24
    1da8:	10 c0       	rjmp	.+32     	; 0x1dca <__vector_13+0xa6>
    if (msg_buffer[msg_buffer_pointer - 1] != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1daa:	f0 e0       	ldi	r31, 0x00	; 0
    1dac:	ea 5b       	subi	r30, 0xBA	; 186
    1dae:	f8 4f       	sbci	r31, 0xF8	; 248
    1db0:	80 81       	ld	r24, Z
    1db2:	8d 30       	cpi	r24, 0x0D	; 13
    1db4:	51 f0       	breq	.+20     	; 0x1dca <__vector_13+0xa6>
      invalid_user_input = true;
    1db6:	81 e0       	ldi	r24, 0x01	; 1
    1db8:	80 93 62 07 	sts	0x0762, r24	; 0x800762 <invalid_user_input>
      dump_invalid_data = true;
    1dbc:	80 93 db 07 	sts	0x07DB, r24	; 0x8007db <dump_invalid_data>
      msg_buffer_pointer = 0;
    1dc0:	10 92 46 07 	sts	0x0746, r1	; 0x800746 <msg_buffer_pointer>
      BT_sendChar('\r');
    1dc4:	8d e0       	ldi	r24, 0x0D	; 13
    1dc6:	0e 94 da 01 	call	0x3b4	; 0x3b4 <BT_sendChar>
      Remote_control_interface(user_dialog_tree);
      }
    }

  // Msg has ended and is within the required length
  if (udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1dca:	80 91 dc 07 	lds	r24, 0x07DC	; 0x8007dc <udr_temp>
    1dce:	8d 30       	cpi	r24, 0x0D	; 13
    1dd0:	79 f4       	brne	.+30     	; 0x1df0 <__vector_13+0xcc>
    if (msg_buffer_pointer <= msg_length) {
    1dd2:	e0 91 46 07 	lds	r30, 0x0746	; 0x800746 <msg_buffer_pointer>
    1dd6:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <msg_length>
    1dda:	8e 17       	cp	r24, r30
    1ddc:	48 f0       	brcs	.+18     	; 0x1df0 <__vector_13+0xcc>
      // Replace the carriage return with null to terminate the string correctly
      msg_buffer[msg_buffer_pointer - 1] = '\0';
    1dde:	f0 e0       	ldi	r31, 0x00	; 0
    1de0:	ea 5b       	subi	r30, 0xBA	; 186
    1de2:	f8 4f       	sbci	r31, 0xF8	; 248
    1de4:	10 82       	st	Z, r1
      BT_sendChar('\r');
    1de6:	8d e0       	ldi	r24, 0x0D	; 13
    1de8:	0e 94 da 01 	call	0x3b4	; 0x3b4 <BT_sendChar>
      Remote_control_interface(user_dialog_tree);
      msg_buffer_pointer = 0;
    1dec:	10 92 46 07 	sts	0x0746, r1	; 0x800746 <msg_buffer_pointer>
      Remote_control_interface(user_dialog_tree);
      msg_buffer_pointer = 0;
      }
    }
#endif
  }
    1df0:	ff 91       	pop	r31
    1df2:	ef 91       	pop	r30
    1df4:	bf 91       	pop	r27
    1df6:	af 91       	pop	r26
    1df8:	9f 91       	pop	r25
    1dfa:	8f 91       	pop	r24
    1dfc:	7f 91       	pop	r23
    1dfe:	6f 91       	pop	r22
    1e00:	5f 91       	pop	r21
    1e02:	4f 91       	pop	r20
    1e04:	3f 91       	pop	r19
    1e06:	2f 91       	pop	r18
    1e08:	0f 90       	pop	r0
    1e0a:	0f be       	out	0x3f, r0	; 63
    1e0c:	0f 90       	pop	r0
    1e0e:	1f 90       	pop	r1
    1e10:	18 95       	reti

00001e12 <__vector_1>:

ISR(INT0_vect) {
    1e12:	1f 92       	push	r1
    1e14:	0f 92       	push	r0
    1e16:	0f b6       	in	r0, 0x3f	; 63
    1e18:	0f 92       	push	r0
    1e1a:	11 24       	eor	r1, r1
    1e1c:	2f 93       	push	r18
    1e1e:	3f 93       	push	r19
    1e20:	4f 93       	push	r20
    1e22:	5f 93       	push	r21
    1e24:	6f 93       	push	r22
    1e26:	7f 93       	push	r23
    1e28:	8f 93       	push	r24
    1e2a:	9f 93       	push	r25
    1e2c:	af 93       	push	r26
    1e2e:	bf 93       	push	r27
    1e30:	ef 93       	push	r30
    1e32:	ff 93       	push	r31
  // Initialize communication with the user
  // Request user login credentials
  remote_login_prompt();
    1e34:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <remote_login_prompt>
  }
    1e38:	ff 91       	pop	r31
    1e3a:	ef 91       	pop	r30
    1e3c:	bf 91       	pop	r27
    1e3e:	af 91       	pop	r26
    1e40:	9f 91       	pop	r25
    1e42:	8f 91       	pop	r24
    1e44:	7f 91       	pop	r23
    1e46:	6f 91       	pop	r22
    1e48:	5f 91       	pop	r21
    1e4a:	4f 91       	pop	r20
    1e4c:	3f 91       	pop	r19
    1e4e:	2f 91       	pop	r18
    1e50:	0f 90       	pop	r0
    1e52:	0f be       	out	0x3f, r0	; 63
    1e54:	0f 90       	pop	r0
    1e56:	1f 90       	pop	r1
    1e58:	18 95       	reti

00001e5a <__vector_16>:
#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_BY_ACTIVATING_TIMER0_OVF_INT
// To reset the TOV0 flag. Alternatively, it can be reset in the ADC complete interrupt.
ISR(TIMER0_OVF_vect) {}
#endif

ISR(ADC_vect) {
    1e5a:	1f 92       	push	r1
    1e5c:	0f 92       	push	r0
    1e5e:	0f b6       	in	r0, 0x3f	; 63
    1e60:	0f 92       	push	r0
    1e62:	11 24       	eor	r1, r1
    1e64:	2f 93       	push	r18
    1e66:	3f 93       	push	r19
    1e68:	4f 93       	push	r20
    1e6a:	5f 93       	push	r21
    1e6c:	6f 93       	push	r22
    1e6e:	7f 93       	push	r23
    1e70:	8f 93       	push	r24
    1e72:	9f 93       	push	r25
    1e74:	af 93       	push	r26
    1e76:	bf 93       	push	r27
    1e78:	cf 93       	push	r28
    1e7a:	df 93       	push	r29
    1e7c:	ef 93       	push	r30
    1e7e:	ff 93       	push	r31
  u16 temperature;
  temperature = ADCL + (ADCH << 8);
    1e80:	84 b1       	in	r24, 0x04	; 4
    1e82:	c5 b1       	in	r28, 0x05	; 5
    1e84:	d0 e0       	ldi	r29, 0x00	; 0
    1e86:	dc 2f       	mov	r29, r28
    1e88:	cc 27       	eor	r28, r28
    1e8a:	c8 0f       	add	r28, r24
    1e8c:	d1 1d       	adc	r29, r1
  // Since the ADC is set to use the internal VREF of 2.56 V, the resolution of the ADC is 2.5 mV. This resolution allows to measure the temperature
  // out of the LM35 with a resolution of 0.25 degree celsius, since each 10mV  increment on the LM35 output is 1 degree C.
  // If the temperature is higher than the maximum specified temperature, turn on the AC.
  if (temperature > AMBIENT_HIGH_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, HIGH);
    1e8e:	c1 37       	cpi	r28, 0x71	; 113
    1e90:	d1 05       	cpc	r29, r1
    1e92:	28 f0       	brcs	.+10     	; 0x1e9e <__vector_16+0x44>
    1e94:	41 e0       	ldi	r20, 0x01	; 1
    1e96:	63 e4       	ldi	r22, 0x43	; 67
    1e98:	87 e0       	ldi	r24, 0x07	; 7
    1e9a:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>
  // If the temperature became below the minimum specified temperature turn off the AC.
  if (temperature < AMBIENT_LOW_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, LOW);
    1e9e:	c4 35       	cpi	r28, 0x54	; 84
    1ea0:	d1 05       	cpc	r29, r1
    1ea2:	28 f4       	brcc	.+10     	; 0x1eae <__vector_16+0x54>
    1ea4:	40 e0       	ldi	r20, 0x00	; 0
    1ea6:	63 e4       	ldi	r22, 0x43	; 67
    1ea8:	87 e0       	ldi	r24, 0x07	; 7
    1eaa:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <DIO_write>

#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_VIA_ADC_COMPLETE_INTERRUPT
  // Since the ADC is configured in auto trigger mode with timer 0 overflow as the trigger, 
  // The overflow interrupt flag bit must be cleared by software if timer 0 overflow interrupt isn't used. 
  // Otherwise the triggering won't work and the ADC will halt.
  set_bit(TIFR, TOV0);
    1eae:	88 b7       	in	r24, 0x38	; 56
    1eb0:	81 60       	ori	r24, 0x01	; 1
    1eb2:	88 bf       	out	0x38, r24	; 56
#endif
    1eb4:	ff 91       	pop	r31
    1eb6:	ef 91       	pop	r30
    1eb8:	df 91       	pop	r29
    1eba:	cf 91       	pop	r28
    1ebc:	bf 91       	pop	r27
    1ebe:	af 91       	pop	r26
    1ec0:	9f 91       	pop	r25
    1ec2:	8f 91       	pop	r24
    1ec4:	7f 91       	pop	r23
    1ec6:	6f 91       	pop	r22
    1ec8:	5f 91       	pop	r21
    1eca:	4f 91       	pop	r20
    1ecc:	3f 91       	pop	r19
    1ece:	2f 91       	pop	r18
    1ed0:	0f 90       	pop	r0
    1ed2:	0f be       	out	0x3f, r0	; 63
    1ed4:	0f 90       	pop	r0
    1ed6:	1f 90       	pop	r1
    1ed8:	18 95       	reti

00001eda <User_DB_init>:
    return getUserByName(user_code_or_name, user);
    }
  else {
    return getUserByCode(user_code_or_name, user);
    }
  }
    1eda:	0e 94 ac 00 	call	0x158	; 0x158 <EEPROM_init>
    1ede:	08 95       	ret

00001ee0 <getUserByName>:
    1ee0:	9f 92       	push	r9
    1ee2:	af 92       	push	r10
    1ee4:	bf 92       	push	r11
    1ee6:	cf 92       	push	r12
    1ee8:	df 92       	push	r13
    1eea:	ef 92       	push	r14
    1eec:	ff 92       	push	r15
    1eee:	0f 93       	push	r16
    1ef0:	1f 93       	push	r17
    1ef2:	cf 93       	push	r28
    1ef4:	df 93       	push	r29
    1ef6:	cd b7       	in	r28, 0x3d	; 61
    1ef8:	de b7       	in	r29, 0x3e	; 62
    1efa:	6d 97       	sbiw	r28, 0x1d	; 29
    1efc:	0f b6       	in	r0, 0x3f	; 63
    1efe:	f8 94       	cli
    1f00:	de bf       	out	0x3e, r29	; 62
    1f02:	0f be       	out	0x3f, r0	; 63
    1f04:	cd bf       	out	0x3d, r28	; 61
    1f06:	7c 01       	movw	r14, r24
    1f08:	6b 01       	movw	r12, r22
    1f0a:	91 2c       	mov	r9, r1
    1f0c:	6b c0       	rjmp	.+214    	; 0x1fe4 <getUserByName+0x104>
    1f0e:	ae 01       	movw	r20, r28
    1f10:	4f 5f       	subi	r20, 0xFF	; 255
    1f12:	5f 4f       	sbci	r21, 0xFF	; 255
    1f14:	60 e0       	ldi	r22, 0x00	; 0
    1f16:	89 2d       	mov	r24, r9
    1f18:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    1f1c:	ae 01       	movw	r20, r28
    1f1e:	4e 5f       	subi	r20, 0xFE	; 254
    1f20:	5f 4f       	sbci	r21, 0xFF	; 255
    1f22:	61 e0       	ldi	r22, 0x01	; 1
    1f24:	89 2d       	mov	r24, r9
    1f26:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    1f2a:	b1 2c       	mov	r11, r1
    1f2c:	56 c0       	rjmp	.+172    	; 0x1fda <getUserByName+0xfa>
    1f2e:	89 81       	ldd	r24, Y+1	; 0x01
    1f30:	90 e0       	ldi	r25, 0x00	; 0
    1f32:	0b 2c       	mov	r0, r11
    1f34:	02 c0       	rjmp	.+4      	; 0x1f3a <getUserByName+0x5a>
    1f36:	95 95       	asr	r25
    1f38:	87 95       	ror	r24
    1f3a:	0a 94       	dec	r0
    1f3c:	e2 f7       	brpl	.-8      	; 0x1f36 <getUserByName+0x56>
    1f3e:	80 ff       	sbrs	r24, 0
    1f40:	4b c0       	rjmp	.+150    	; 0x1fd8 <getUserByName+0xf8>
    1f42:	6f e1       	ldi	r22, 0x1F	; 31
    1f44:	b6 9e       	mul	r11, r22
    1f46:	a0 2c       	mov	r10, r0
    1f48:	11 24       	eor	r1, r1
    1f4a:	68 e0       	ldi	r22, 0x08	; 8
    1f4c:	6a 0d       	add	r22, r10
    1f4e:	9e 01       	movw	r18, r28
    1f50:	2d 5f       	subi	r18, 0xFD	; 253
    1f52:	3f 4f       	sbci	r19, 0xFF	; 255
    1f54:	4d e0       	ldi	r20, 0x0D	; 13
    1f56:	50 e0       	ldi	r21, 0x00	; 0
    1f58:	89 2d       	mov	r24, r9
    1f5a:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    1f5e:	be 01       	movw	r22, r28
    1f60:	6d 5f       	subi	r22, 0xFD	; 253
    1f62:	7f 4f       	sbci	r23, 0xFF	; 255
    1f64:	c7 01       	movw	r24, r14
    1f66:	0e 94 d7 13 	call	0x27ae	; 0x27ae <strcmp>
    1f6a:	89 2b       	or	r24, r25
    1f6c:	a9 f5       	brne	.+106    	; 0x1fd8 <getUserByName+0xf8>
    1f6e:	65 e1       	ldi	r22, 0x15	; 21
    1f70:	6a 0d       	add	r22, r10
    1f72:	9e 01       	movw	r18, r28
    1f74:	20 5f       	subi	r18, 0xF0	; 240
    1f76:	3f 4f       	sbci	r19, 0xFF	; 255
    1f78:	47 e0       	ldi	r20, 0x07	; 7
    1f7a:	50 e0       	ldi	r21, 0x00	; 0
    1f7c:	89 2d       	mov	r24, r9
    1f7e:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    1f82:	6c e1       	ldi	r22, 0x1C	; 28
    1f84:	6a 0d       	add	r22, r10
    1f86:	9e 01       	movw	r18, r28
    1f88:	29 5e       	subi	r18, 0xE9	; 233
    1f8a:	3f 4f       	sbci	r19, 0xFF	; 255
    1f8c:	47 e0       	ldi	r20, 0x07	; 7
    1f8e:	50 e0       	ldi	r21, 0x00	; 0
    1f90:	89 2d       	mov	r24, r9
    1f92:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    1f96:	8a 81       	ldd	r24, Y+2	; 0x02
    1f98:	90 e0       	ldi	r25, 0x00	; 0
    1f9a:	02 c0       	rjmp	.+4      	; 0x1fa0 <getUserByName+0xc0>
    1f9c:	95 95       	asr	r25
    1f9e:	87 95       	ror	r24
    1fa0:	ba 94       	dec	r11
    1fa2:	e2 f7       	brpl	.-8      	; 0x1f9c <getUserByName+0xbc>
    1fa4:	98 2f       	mov	r25, r24
    1fa6:	91 70       	andi	r25, 0x01	; 1
    1fa8:	f6 01       	movw	r30, r12
    1faa:	91 93       	st	Z+, r25
    1fac:	be 01       	movw	r22, r28
    1fae:	6d 5f       	subi	r22, 0xFD	; 253
    1fb0:	7f 4f       	sbci	r23, 0xFF	; 255
    1fb2:	cf 01       	movw	r24, r30
    1fb4:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <strcpy>
    1fb8:	be 01       	movw	r22, r28
    1fba:	60 5f       	subi	r22, 0xF0	; 240
    1fbc:	7f 4f       	sbci	r23, 0xFF	; 255
    1fbe:	c6 01       	movw	r24, r12
    1fc0:	0e 96       	adiw	r24, 0x0e	; 14
    1fc2:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <strcpy>
    1fc6:	be 01       	movw	r22, r28
    1fc8:	69 5e       	subi	r22, 0xE9	; 233
    1fca:	7f 4f       	sbci	r23, 0xFF	; 255
    1fcc:	c6 01       	movw	r24, r12
    1fce:	45 96       	adiw	r24, 0x15	; 21
    1fd0:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <strcpy>
    1fd4:	82 e0       	ldi	r24, 0x02	; 2
    1fd6:	0b c0       	rjmp	.+22     	; 0x1fee <getUserByName+0x10e>
    1fd8:	b3 94       	inc	r11
    1fda:	87 e0       	ldi	r24, 0x07	; 7
    1fdc:	8b 15       	cp	r24, r11
    1fde:	08 f0       	brcs	.+2      	; 0x1fe2 <getUserByName+0x102>
    1fe0:	a6 cf       	rjmp	.-180    	; 0x1f2e <getUserByName+0x4e>
    1fe2:	93 94       	inc	r9
    1fe4:	87 e0       	ldi	r24, 0x07	; 7
    1fe6:	89 15       	cp	r24, r9
    1fe8:	08 f0       	brcs	.+2      	; 0x1fec <getUserByName+0x10c>
    1fea:	91 cf       	rjmp	.-222    	; 0x1f0e <getUserByName+0x2e>
    1fec:	83 e0       	ldi	r24, 0x03	; 3
    1fee:	6d 96       	adiw	r28, 0x1d	; 29
    1ff0:	0f b6       	in	r0, 0x3f	; 63
    1ff2:	f8 94       	cli
    1ff4:	de bf       	out	0x3e, r29	; 62
    1ff6:	0f be       	out	0x3f, r0	; 63
    1ff8:	cd bf       	out	0x3d, r28	; 61
    1ffa:	df 91       	pop	r29
    1ffc:	cf 91       	pop	r28
    1ffe:	1f 91       	pop	r17
    2000:	0f 91       	pop	r16
    2002:	ff 90       	pop	r15
    2004:	ef 90       	pop	r14
    2006:	df 90       	pop	r13
    2008:	cf 90       	pop	r12
    200a:	bf 90       	pop	r11
    200c:	af 90       	pop	r10
    200e:	9f 90       	pop	r9
    2010:	08 95       	ret

00002012 <getUserByCode>:
    2012:	9f 92       	push	r9
    2014:	af 92       	push	r10
    2016:	bf 92       	push	r11
    2018:	cf 92       	push	r12
    201a:	df 92       	push	r13
    201c:	ef 92       	push	r14
    201e:	ff 92       	push	r15
    2020:	0f 93       	push	r16
    2022:	1f 93       	push	r17
    2024:	cf 93       	push	r28
    2026:	df 93       	push	r29
    2028:	cd b7       	in	r28, 0x3d	; 61
    202a:	de b7       	in	r29, 0x3e	; 62
    202c:	6d 97       	sbiw	r28, 0x1d	; 29
    202e:	0f b6       	in	r0, 0x3f	; 63
    2030:	f8 94       	cli
    2032:	de bf       	out	0x3e, r29	; 62
    2034:	0f be       	out	0x3f, r0	; 63
    2036:	cd bf       	out	0x3d, r28	; 61
    2038:	7c 01       	movw	r14, r24
    203a:	6b 01       	movw	r12, r22
    203c:	91 2c       	mov	r9, r1
    203e:	6b c0       	rjmp	.+214    	; 0x2116 <getUserByCode+0x104>
    2040:	ae 01       	movw	r20, r28
    2042:	4f 5f       	subi	r20, 0xFF	; 255
    2044:	5f 4f       	sbci	r21, 0xFF	; 255
    2046:	60 e0       	ldi	r22, 0x00	; 0
    2048:	89 2d       	mov	r24, r9
    204a:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    204e:	ae 01       	movw	r20, r28
    2050:	4e 5f       	subi	r20, 0xFE	; 254
    2052:	5f 4f       	sbci	r21, 0xFF	; 255
    2054:	61 e0       	ldi	r22, 0x01	; 1
    2056:	89 2d       	mov	r24, r9
    2058:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    205c:	b1 2c       	mov	r11, r1
    205e:	56 c0       	rjmp	.+172    	; 0x210c <getUserByCode+0xfa>
    2060:	89 81       	ldd	r24, Y+1	; 0x01
    2062:	90 e0       	ldi	r25, 0x00	; 0
    2064:	0b 2c       	mov	r0, r11
    2066:	02 c0       	rjmp	.+4      	; 0x206c <getUserByCode+0x5a>
    2068:	95 95       	asr	r25
    206a:	87 95       	ror	r24
    206c:	0a 94       	dec	r0
    206e:	e2 f7       	brpl	.-8      	; 0x2068 <getUserByCode+0x56>
    2070:	80 ff       	sbrs	r24, 0
    2072:	4b c0       	rjmp	.+150    	; 0x210a <getUserByCode+0xf8>
    2074:	6f e1       	ldi	r22, 0x1F	; 31
    2076:	b6 9e       	mul	r11, r22
    2078:	a0 2c       	mov	r10, r0
    207a:	11 24       	eor	r1, r1
    207c:	65 e1       	ldi	r22, 0x15	; 21
    207e:	6a 0d       	add	r22, r10
    2080:	9e 01       	movw	r18, r28
    2082:	20 5f       	subi	r18, 0xF0	; 240
    2084:	3f 4f       	sbci	r19, 0xFF	; 255
    2086:	47 e0       	ldi	r20, 0x07	; 7
    2088:	50 e0       	ldi	r21, 0x00	; 0
    208a:	89 2d       	mov	r24, r9
    208c:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    2090:	be 01       	movw	r22, r28
    2092:	60 5f       	subi	r22, 0xF0	; 240
    2094:	7f 4f       	sbci	r23, 0xFF	; 255
    2096:	c7 01       	movw	r24, r14
    2098:	0e 94 d7 13 	call	0x27ae	; 0x27ae <strcmp>
    209c:	89 2b       	or	r24, r25
    209e:	a9 f5       	brne	.+106    	; 0x210a <getUserByCode+0xf8>
    20a0:	68 e0       	ldi	r22, 0x08	; 8
    20a2:	6a 0d       	add	r22, r10
    20a4:	9e 01       	movw	r18, r28
    20a6:	2d 5f       	subi	r18, 0xFD	; 253
    20a8:	3f 4f       	sbci	r19, 0xFF	; 255
    20aa:	4d e0       	ldi	r20, 0x0D	; 13
    20ac:	50 e0       	ldi	r21, 0x00	; 0
    20ae:	89 2d       	mov	r24, r9
    20b0:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    20b4:	6c e1       	ldi	r22, 0x1C	; 28
    20b6:	6a 0d       	add	r22, r10
    20b8:	9e 01       	movw	r18, r28
    20ba:	29 5e       	subi	r18, 0xE9	; 233
    20bc:	3f 4f       	sbci	r19, 0xFF	; 255
    20be:	47 e0       	ldi	r20, 0x07	; 7
    20c0:	50 e0       	ldi	r21, 0x00	; 0
    20c2:	89 2d       	mov	r24, r9
    20c4:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    20c8:	8a 81       	ldd	r24, Y+2	; 0x02
    20ca:	90 e0       	ldi	r25, 0x00	; 0
    20cc:	02 c0       	rjmp	.+4      	; 0x20d2 <getUserByCode+0xc0>
    20ce:	95 95       	asr	r25
    20d0:	87 95       	ror	r24
    20d2:	ba 94       	dec	r11
    20d4:	e2 f7       	brpl	.-8      	; 0x20ce <getUserByCode+0xbc>
    20d6:	98 2f       	mov	r25, r24
    20d8:	91 70       	andi	r25, 0x01	; 1
    20da:	f6 01       	movw	r30, r12
    20dc:	91 93       	st	Z+, r25
    20de:	be 01       	movw	r22, r28
    20e0:	6d 5f       	subi	r22, 0xFD	; 253
    20e2:	7f 4f       	sbci	r23, 0xFF	; 255
    20e4:	cf 01       	movw	r24, r30
    20e6:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <strcpy>
    20ea:	be 01       	movw	r22, r28
    20ec:	60 5f       	subi	r22, 0xF0	; 240
    20ee:	7f 4f       	sbci	r23, 0xFF	; 255
    20f0:	c6 01       	movw	r24, r12
    20f2:	0e 96       	adiw	r24, 0x0e	; 14
    20f4:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <strcpy>
    20f8:	be 01       	movw	r22, r28
    20fa:	69 5e       	subi	r22, 0xE9	; 233
    20fc:	7f 4f       	sbci	r23, 0xFF	; 255
    20fe:	c6 01       	movw	r24, r12
    2100:	45 96       	adiw	r24, 0x15	; 21
    2102:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <strcpy>
    2106:	82 e0       	ldi	r24, 0x02	; 2
    2108:	0b c0       	rjmp	.+22     	; 0x2120 <getUserByCode+0x10e>
    210a:	b3 94       	inc	r11
    210c:	87 e0       	ldi	r24, 0x07	; 7
    210e:	8b 15       	cp	r24, r11
    2110:	08 f0       	brcs	.+2      	; 0x2114 <getUserByCode+0x102>
    2112:	a6 cf       	rjmp	.-180    	; 0x2060 <getUserByCode+0x4e>
    2114:	93 94       	inc	r9
    2116:	87 e0       	ldi	r24, 0x07	; 7
    2118:	89 15       	cp	r24, r9
    211a:	08 f0       	brcs	.+2      	; 0x211e <getUserByCode+0x10c>
    211c:	91 cf       	rjmp	.-222    	; 0x2040 <getUserByCode+0x2e>
    211e:	83 e0       	ldi	r24, 0x03	; 3
    2120:	6d 96       	adiw	r28, 0x1d	; 29
    2122:	0f b6       	in	r0, 0x3f	; 63
    2124:	f8 94       	cli
    2126:	de bf       	out	0x3e, r29	; 62
    2128:	0f be       	out	0x3f, r0	; 63
    212a:	cd bf       	out	0x3d, r28	; 61
    212c:	df 91       	pop	r29
    212e:	cf 91       	pop	r28
    2130:	1f 91       	pop	r17
    2132:	0f 91       	pop	r16
    2134:	ff 90       	pop	r15
    2136:	ef 90       	pop	r14
    2138:	df 90       	pop	r13
    213a:	cf 90       	pop	r12
    213c:	bf 90       	pop	r11
    213e:	af 90       	pop	r10
    2140:	9f 90       	pop	r9
    2142:	08 95       	ret

00002144 <Alarm_set>:

void Alarm_set(void) {
  Buzzer_on(BUZZER_PORT, BUZZER_PIN);
    2144:	66 e0       	ldi	r22, 0x06	; 6
    2146:	84 e4       	ldi	r24, 0x44	; 68
    2148:	0e 94 a3 00 	call	0x146	; 0x146 <Buzzer_on>
    214c:	08 95       	ret

0000214e <write_user>:
  }

void write_user(u8 userBlockIndex, ST_User_t* user) {
    214e:	ef 92       	push	r14
    2150:	ff 92       	push	r15
    2152:	0f 93       	push	r16
    2154:	1f 93       	push	r17
    2156:	cf 93       	push	r28
    2158:	df 93       	push	r29
    215a:	00 d0       	rcall	.+0      	; 0x215c <write_user+0xe>
    215c:	cd b7       	in	r28, 0x3d	; 61
    215e:	de b7       	in	r29, 0x3e	; 62
    2160:	7b 01       	movw	r14, r22
  // Get the user block location (page - index)
  u8 page = userBlockIndex / 8;
    2162:	08 2f       	mov	r16, r24
    2164:	06 95       	lsr	r16
    2166:	06 95       	lsr	r16
    2168:	06 95       	lsr	r16
  u8 blockNumber = userBlockIndex % 8;
    216a:	18 2f       	mov	r17, r24
    216c:	17 70       	andi	r17, 0x07	; 7
  // Read and update the block status (reserve the block). And update the user authority level flag if the user is admin
  u8 usersBlockStatus, usersAuthorityLevel;
  EEPROM_read_byte(page, 0, &usersBlockStatus);
    216e:	ae 01       	movw	r20, r28
    2170:	4f 5f       	subi	r20, 0xFF	; 255
    2172:	5f 4f       	sbci	r21, 0xFF	; 255
    2174:	60 e0       	ldi	r22, 0x00	; 0
    2176:	80 2f       	mov	r24, r16
    2178:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
  EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    217c:	ae 01       	movw	r20, r28
    217e:	4e 5f       	subi	r20, 0xFE	; 254
    2180:	5f 4f       	sbci	r21, 0xFF	; 255
    2182:	61 e0       	ldi	r22, 0x01	; 1
    2184:	80 2f       	mov	r24, r16
    2186:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
  set_bit(usersBlockStatus, blockNumber);
    218a:	81 e0       	ldi	r24, 0x01	; 1
    218c:	90 e0       	ldi	r25, 0x00	; 0
    218e:	01 2e       	mov	r0, r17
    2190:	02 c0       	rjmp	.+4      	; 0x2196 <write_user+0x48>
    2192:	88 0f       	add	r24, r24
    2194:	99 1f       	adc	r25, r25
    2196:	0a 94       	dec	r0
    2198:	e2 f7       	brpl	.-8      	; 0x2192 <write_user+0x44>
    219a:	49 81       	ldd	r20, Y+1	; 0x01
    219c:	48 2b       	or	r20, r24
    219e:	49 83       	std	Y+1, r20	; 0x01
  if (user->isAdmin) set_bit(usersAuthorityLevel, blockNumber);
    21a0:	f7 01       	movw	r30, r14
    21a2:	20 81       	ld	r18, Z
    21a4:	22 23       	and	r18, r18
    21a6:	19 f0       	breq	.+6      	; 0x21ae <write_user+0x60>
    21a8:	9a 81       	ldd	r25, Y+2	; 0x02
    21aa:	89 2b       	or	r24, r25
    21ac:	8a 83       	std	Y+2, r24	; 0x02
  EEPROM_write_byte(page, 0, usersBlockStatus);
    21ae:	60 e0       	ldi	r22, 0x00	; 0
    21b0:	80 2f       	mov	r24, r16
    21b2:	0e 94 06 01 	call	0x20c	; 0x20c <EEPROM_write_byte>
  EEPROM_write_byte(page, 1, usersAuthorityLevel);
    21b6:	4a 81       	ldd	r20, Y+2	; 0x02
    21b8:	61 e0       	ldi	r22, 0x01	; 1
    21ba:	80 2f       	mov	r24, r16
    21bc:	0e 94 06 01 	call	0x20c	; 0x20c <EEPROM_write_byte>
  // Write the user data
  EEPROM_write_block(page, 8 + 31 * blockNumber, 13, user->name);
    21c0:	97 01       	movw	r18, r14
    21c2:	2f 5f       	subi	r18, 0xFF	; 255
    21c4:	3f 4f       	sbci	r19, 0xFF	; 255
    21c6:	6f e1       	ldi	r22, 0x1F	; 31
    21c8:	16 9f       	mul	r17, r22
    21ca:	10 2d       	mov	r17, r0
    21cc:	11 24       	eor	r1, r1
    21ce:	68 e0       	ldi	r22, 0x08	; 8
    21d0:	61 0f       	add	r22, r17
    21d2:	4d e0       	ldi	r20, 0x0D	; 13
    21d4:	50 e0       	ldi	r21, 0x00	; 0
    21d6:	80 2f       	mov	r24, r16
    21d8:	0e 94 25 01 	call	0x24a	; 0x24a <EEPROM_write_block>
  EEPROM_write_block(page, 21 + 31 * blockNumber, 7, user->code);
    21dc:	97 01       	movw	r18, r14
    21de:	22 5f       	subi	r18, 0xF2	; 242
    21e0:	3f 4f       	sbci	r19, 0xFF	; 255
    21e2:	65 e1       	ldi	r22, 0x15	; 21
    21e4:	61 0f       	add	r22, r17
    21e6:	47 e0       	ldi	r20, 0x07	; 7
    21e8:	50 e0       	ldi	r21, 0x00	; 0
    21ea:	80 2f       	mov	r24, r16
    21ec:	0e 94 25 01 	call	0x24a	; 0x24a <EEPROM_write_block>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
    21f0:	97 01       	movw	r18, r14
    21f2:	2b 5e       	subi	r18, 0xEB	; 235
    21f4:	3f 4f       	sbci	r19, 0xFF	; 255
    21f6:	6c e1       	ldi	r22, 0x1C	; 28
    21f8:	61 0f       	add	r22, r17
    21fa:	4b e0       	ldi	r20, 0x0B	; 11
    21fc:	50 e0       	ldi	r21, 0x00	; 0
    21fe:	80 2f       	mov	r24, r16
    2200:	0e 94 25 01 	call	0x24a	; 0x24a <EEPROM_write_block>
  }
    2204:	0f 90       	pop	r0
    2206:	0f 90       	pop	r0
    2208:	df 91       	pop	r29
    220a:	cf 91       	pop	r28
    220c:	1f 91       	pop	r17
    220e:	0f 91       	pop	r16
    2210:	ff 90       	pop	r15
    2212:	ef 90       	pop	r14
    2214:	08 95       	ret

00002216 <add_user>:

EN_UserStatusCode_t add_user(ST_User_t* user) {
    2216:	ef 92       	push	r14
    2218:	ff 92       	push	r15
    221a:	1f 93       	push	r17
    221c:	cf 93       	push	r28
    221e:	df 93       	push	r29
    2220:	1f 92       	push	r1
    2222:	cd b7       	in	r28, 0x3d	; 61
    2224:	de b7       	in	r29, 0x3e	; 62
    2226:	7c 01       	movw	r14, r24
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    2228:	10 e0       	ldi	r17, 0x00	; 0
    222a:	1a c0       	rjmp	.+52     	; 0x2260 <add_user+0x4a>
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    222c:	ae 01       	movw	r20, r28
    222e:	4f 5f       	subi	r20, 0xFF	; 255
    2230:	5f 4f       	sbci	r21, 0xFF	; 255
    2232:	60 e0       	ldi	r22, 0x00	; 0
    2234:	81 2f       	mov	r24, r17
    2236:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    if (usersBlockStatus != 0xFF) {
    223a:	99 81       	ldd	r25, Y+1	; 0x01
    223c:	9f 3f       	cpi	r25, 0xFF	; 255
    223e:	79 f0       	breq	.+30     	; 0x225e <add_user+0x48>
    2240:	02 c0       	rjmp	.+4      	; 0x2246 <add_user+0x30>
      // Find the block number in the page
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
    2242:	8f 5f       	subi	r24, 0xFF	; 255
    2244:	01 c0       	rjmp	.+2      	; 0x2248 <add_user+0x32>
    2246:	80 e0       	ldi	r24, 0x00	; 0
    2248:	29 2f       	mov	r18, r25
    224a:	30 e0       	ldi	r19, 0x00	; 0
    224c:	08 2e       	mov	r0, r24
    224e:	02 c0       	rjmp	.+4      	; 0x2254 <add_user+0x3e>
    2250:	35 95       	asr	r19
    2252:	27 95       	ror	r18
    2254:	0a 94       	dec	r0
    2256:	e2 f7       	brpl	.-8      	; 0x2250 <add_user+0x3a>
    2258:	20 fd       	sbrc	r18, 0
    225a:	f3 cf       	rjmp	.-26     	; 0x2242 <add_user+0x2c>
    225c:	04 c0       	rjmp	.+8      	; 0x2266 <add_user+0x50>
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    225e:	1f 5f       	subi	r17, 0xFF	; 255
    2260:	18 30       	cpi	r17, 0x08	; 8
    2262:	20 f3       	brcs	.-56     	; 0x222c <add_user+0x16>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
    2264:	80 e0       	ldi	r24, 0x00	; 0
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    2266:	18 30       	cpi	r17, 0x08	; 8
    2268:	49 f0       	breq	.+18     	; 0x227c <add_user+0x66>
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
    226a:	11 0f       	add	r17, r17
    226c:	11 0f       	add	r17, r17
    226e:	11 0f       	add	r17, r17
  write_user(availableUserBlockIndex, user);
    2270:	b7 01       	movw	r22, r14
    2272:	81 0f       	add	r24, r17
    2274:	0e 94 a7 10 	call	0x214e	; 0x214e <write_user>
  return USER_ADDED_SUCCESSFULLY;
    2278:	89 e0       	ldi	r24, 0x09	; 9
    227a:	01 c0       	rjmp	.+2      	; 0x227e <add_user+0x68>
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    227c:	8b e0       	ldi	r24, 0x0B	; 11
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
  write_user(availableUserBlockIndex, user);
  return USER_ADDED_SUCCESSFULLY;
  }
    227e:	0f 90       	pop	r0
    2280:	df 91       	pop	r29
    2282:	cf 91       	pop	r28
    2284:	1f 91       	pop	r17
    2286:	ff 90       	pop	r15
    2288:	ef 90       	pop	r14
    228a:	08 95       	ret

0000228c <delete_user>:

EN_UserStatusCode_t delete_user(ST_User_t* user) {
    228c:	cf 92       	push	r12
    228e:	df 92       	push	r13
    2290:	ef 92       	push	r14
    2292:	ff 92       	push	r15
    2294:	0f 93       	push	r16
    2296:	1f 93       	push	r17
    2298:	cf 93       	push	r28
    229a:	df 93       	push	r29
    229c:	cd b7       	in	r28, 0x3d	; 61
    229e:	de b7       	in	r29, 0x3e	; 62
    22a0:	29 97       	sbiw	r28, 0x09	; 9
    22a2:	0f b6       	in	r0, 0x3f	; 63
    22a4:	f8 94       	cli
    22a6:	de bf       	out	0x3e, r29	; 62
    22a8:	0f be       	out	0x3f, r0	; 63
    22aa:	cd bf       	out	0x3d, r28	; 61
    22ac:	6c 01       	movw	r12, r24
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    22ae:	00 e0       	ldi	r16, 0x00	; 0
    22b0:	4d c0       	rjmp	.+154    	; 0x234c <delete_user+0xc0>
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    22b2:	ae 01       	movw	r20, r28
    22b4:	4f 5f       	subi	r20, 0xFF	; 255
    22b6:	5f 4f       	sbci	r21, 0xFF	; 255
    22b8:	60 e0       	ldi	r22, 0x00	; 0
    22ba:	80 2f       	mov	r24, r16
    22bc:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    22c0:	ae 01       	movw	r20, r28
    22c2:	4e 5f       	subi	r20, 0xFE	; 254
    22c4:	5f 4f       	sbci	r21, 0xFF	; 255
    22c6:	61 e0       	ldi	r22, 0x01	; 1
    22c8:	80 2f       	mov	r24, r16
    22ca:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    for (userIndex = 0; userIndex < 8;userIndex++) {
    22ce:	10 e0       	ldi	r17, 0x00	; 0
    22d0:	3a c0       	rjmp	.+116    	; 0x2346 <delete_user+0xba>
      if (read_bit(usersBlockStatus, userIndex)) {  // If the user isn't deleted
    22d2:	89 81       	ldd	r24, Y+1	; 0x01
    22d4:	90 e0       	ldi	r25, 0x00	; 0
    22d6:	01 2e       	mov	r0, r17
    22d8:	02 c0       	rjmp	.+4      	; 0x22de <delete_user+0x52>
    22da:	95 95       	asr	r25
    22dc:	87 95       	ror	r24
    22de:	0a 94       	dec	r0
    22e0:	e2 f7       	brpl	.-8      	; 0x22da <delete_user+0x4e>
    22e2:	80 ff       	sbrs	r24, 0
    22e4:	2f c0       	rjmp	.+94     	; 0x2344 <delete_user+0xb8>
        EEPROM_read_block(page, 21 + 31 * userIndex, 7, tempUserCode);
    22e6:	6f e1       	ldi	r22, 0x1F	; 31
    22e8:	16 9f       	mul	r17, r22
    22ea:	60 2d       	mov	r22, r0
    22ec:	11 24       	eor	r1, r1
    22ee:	6b 5e       	subi	r22, 0xEB	; 235
    22f0:	9e 01       	movw	r18, r28
    22f2:	2d 5f       	subi	r18, 0xFD	; 253
    22f4:	3f 4f       	sbci	r19, 0xFF	; 255
    22f6:	47 e0       	ldi	r20, 0x07	; 7
    22f8:	50 e0       	ldi	r21, 0x00	; 0
    22fa:	80 2f       	mov	r24, r16
    22fc:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
        if (strcmp(user->code, tempUserCode) == 0) { // User has been found
    2300:	be 01       	movw	r22, r28
    2302:	6d 5f       	subi	r22, 0xFD	; 253
    2304:	7f 4f       	sbci	r23, 0xFF	; 255
    2306:	c6 01       	movw	r24, r12
    2308:	0e 96       	adiw	r24, 0x0e	; 14
    230a:	0e 94 d7 13 	call	0x27ae	; 0x27ae <strcmp>
    230e:	89 2b       	or	r24, r25
    2310:	c9 f4       	brne	.+50     	; 0x2344 <delete_user+0xb8>
          // Mark it as deleted
          clear_bit(usersBlockStatus, userIndex);
    2312:	81 e0       	ldi	r24, 0x01	; 1
    2314:	90 e0       	ldi	r25, 0x00	; 0
    2316:	02 c0       	rjmp	.+4      	; 0x231c <delete_user+0x90>
    2318:	88 0f       	add	r24, r24
    231a:	99 1f       	adc	r25, r25
    231c:	1a 95       	dec	r17
    231e:	e2 f7       	brpl	.-8      	; 0x2318 <delete_user+0x8c>
    2320:	80 95       	com	r24
    2322:	49 81       	ldd	r20, Y+1	; 0x01
    2324:	48 23       	and	r20, r24
    2326:	49 83       	std	Y+1, r20	; 0x01
          clear_bit(usersAuthorityLevel, userIndex);
    2328:	9a 81       	ldd	r25, Y+2	; 0x02
    232a:	89 23       	and	r24, r25
    232c:	8a 83       	std	Y+2, r24	; 0x02
          EEPROM_write_byte(page, 0, usersBlockStatus);
    232e:	60 e0       	ldi	r22, 0x00	; 0
    2330:	80 2f       	mov	r24, r16
    2332:	0e 94 06 01 	call	0x20c	; 0x20c <EEPROM_write_byte>
          EEPROM_write_byte(page, 1, usersAuthorityLevel);
    2336:	4a 81       	ldd	r20, Y+2	; 0x02
    2338:	61 e0       	ldi	r22, 0x01	; 1
    233a:	80 2f       	mov	r24, r16
    233c:	0e 94 06 01 	call	0x20c	; 0x20c <EEPROM_write_byte>
          return USER_DELETED_SUCCESSFULLY;
    2340:	8a e0       	ldi	r24, 0x0A	; 10
    2342:	08 c0       	rjmp	.+16     	; 0x2354 <delete_user+0xc8>
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    for (userIndex = 0; userIndex < 8;userIndex++) {
    2344:	1f 5f       	subi	r17, 0xFF	; 255
    2346:	18 30       	cpi	r17, 0x08	; 8
    2348:	20 f2       	brcs	.-120    	; 0x22d2 <delete_user+0x46>
EN_UserStatusCode_t delete_user(ST_User_t* user) {
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    234a:	0f 5f       	subi	r16, 0xFF	; 255
    234c:	08 30       	cpi	r16, 0x08	; 8
    234e:	08 f4       	brcc	.+2      	; 0x2352 <delete_user+0xc6>
    2350:	b0 cf       	rjmp	.-160    	; 0x22b2 <delete_user+0x26>
          return USER_DELETED_SUCCESSFULLY;
          }
        }
      }
    }
  return USER_NOT_FOUND;
    2352:	83 e0       	ldi	r24, 0x03	; 3
  }
    2354:	29 96       	adiw	r28, 0x09	; 9
    2356:	0f b6       	in	r0, 0x3f	; 63
    2358:	f8 94       	cli
    235a:	de bf       	out	0x3e, r29	; 62
    235c:	0f be       	out	0x3f, r0	; 63
    235e:	cd bf       	out	0x3d, r28	; 61
    2360:	df 91       	pop	r29
    2362:	cf 91       	pop	r28
    2364:	1f 91       	pop	r17
    2366:	0f 91       	pop	r16
    2368:	ff 90       	pop	r15
    236a:	ef 90       	pop	r14
    236c:	df 90       	pop	r13
    236e:	cf 90       	pop	r12
    2370:	08 95       	ret

00002372 <__subsf3>:
    2372:	50 58       	subi	r21, 0x80	; 128

00002374 <__addsf3>:
    2374:	bb 27       	eor	r27, r27
    2376:	aa 27       	eor	r26, r26
    2378:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <__addsf3x>
    237c:	0c 94 1b 13 	jmp	0x2636	; 0x2636 <__fp_round>
    2380:	0e 94 0d 13 	call	0x261a	; 0x261a <__fp_pscA>
    2384:	38 f0       	brcs	.+14     	; 0x2394 <__addsf3+0x20>
    2386:	0e 94 14 13 	call	0x2628	; 0x2628 <__fp_pscB>
    238a:	20 f0       	brcs	.+8      	; 0x2394 <__addsf3+0x20>
    238c:	39 f4       	brne	.+14     	; 0x239c <__addsf3+0x28>
    238e:	9f 3f       	cpi	r25, 0xFF	; 255
    2390:	19 f4       	brne	.+6      	; 0x2398 <__addsf3+0x24>
    2392:	26 f4       	brtc	.+8      	; 0x239c <__addsf3+0x28>
    2394:	0c 94 0a 13 	jmp	0x2614	; 0x2614 <__fp_nan>
    2398:	0e f4       	brtc	.+2      	; 0x239c <__addsf3+0x28>
    239a:	e0 95       	com	r30
    239c:	e7 fb       	bst	r30, 7
    239e:	0c 94 04 13 	jmp	0x2608	; 0x2608 <__fp_inf>

000023a2 <__addsf3x>:
    23a2:	e9 2f       	mov	r30, r25
    23a4:	0e 94 2c 13 	call	0x2658	; 0x2658 <__fp_split3>
    23a8:	58 f3       	brcs	.-42     	; 0x2380 <__addsf3+0xc>
    23aa:	ba 17       	cp	r27, r26
    23ac:	62 07       	cpc	r22, r18
    23ae:	73 07       	cpc	r23, r19
    23b0:	84 07       	cpc	r24, r20
    23b2:	95 07       	cpc	r25, r21
    23b4:	20 f0       	brcs	.+8      	; 0x23be <__addsf3x+0x1c>
    23b6:	79 f4       	brne	.+30     	; 0x23d6 <__addsf3x+0x34>
    23b8:	a6 f5       	brtc	.+104    	; 0x2422 <__addsf3x+0x80>
    23ba:	0c 94 4e 13 	jmp	0x269c	; 0x269c <__fp_zero>
    23be:	0e f4       	brtc	.+2      	; 0x23c2 <__addsf3x+0x20>
    23c0:	e0 95       	com	r30
    23c2:	0b 2e       	mov	r0, r27
    23c4:	ba 2f       	mov	r27, r26
    23c6:	a0 2d       	mov	r26, r0
    23c8:	0b 01       	movw	r0, r22
    23ca:	b9 01       	movw	r22, r18
    23cc:	90 01       	movw	r18, r0
    23ce:	0c 01       	movw	r0, r24
    23d0:	ca 01       	movw	r24, r20
    23d2:	a0 01       	movw	r20, r0
    23d4:	11 24       	eor	r1, r1
    23d6:	ff 27       	eor	r31, r31
    23d8:	59 1b       	sub	r21, r25
    23da:	99 f0       	breq	.+38     	; 0x2402 <__addsf3x+0x60>
    23dc:	59 3f       	cpi	r21, 0xF9	; 249
    23de:	50 f4       	brcc	.+20     	; 0x23f4 <__addsf3x+0x52>
    23e0:	50 3e       	cpi	r21, 0xE0	; 224
    23e2:	68 f1       	brcs	.+90     	; 0x243e <__addsf3x+0x9c>
    23e4:	1a 16       	cp	r1, r26
    23e6:	f0 40       	sbci	r31, 0x00	; 0
    23e8:	a2 2f       	mov	r26, r18
    23ea:	23 2f       	mov	r18, r19
    23ec:	34 2f       	mov	r19, r20
    23ee:	44 27       	eor	r20, r20
    23f0:	58 5f       	subi	r21, 0xF8	; 248
    23f2:	f3 cf       	rjmp	.-26     	; 0x23da <__addsf3x+0x38>
    23f4:	46 95       	lsr	r20
    23f6:	37 95       	ror	r19
    23f8:	27 95       	ror	r18
    23fa:	a7 95       	ror	r26
    23fc:	f0 40       	sbci	r31, 0x00	; 0
    23fe:	53 95       	inc	r21
    2400:	c9 f7       	brne	.-14     	; 0x23f4 <__addsf3x+0x52>
    2402:	7e f4       	brtc	.+30     	; 0x2422 <__addsf3x+0x80>
    2404:	1f 16       	cp	r1, r31
    2406:	ba 0b       	sbc	r27, r26
    2408:	62 0b       	sbc	r22, r18
    240a:	73 0b       	sbc	r23, r19
    240c:	84 0b       	sbc	r24, r20
    240e:	ba f0       	brmi	.+46     	; 0x243e <__addsf3x+0x9c>
    2410:	91 50       	subi	r25, 0x01	; 1
    2412:	a1 f0       	breq	.+40     	; 0x243c <__addsf3x+0x9a>
    2414:	ff 0f       	add	r31, r31
    2416:	bb 1f       	adc	r27, r27
    2418:	66 1f       	adc	r22, r22
    241a:	77 1f       	adc	r23, r23
    241c:	88 1f       	adc	r24, r24
    241e:	c2 f7       	brpl	.-16     	; 0x2410 <__addsf3x+0x6e>
    2420:	0e c0       	rjmp	.+28     	; 0x243e <__addsf3x+0x9c>
    2422:	ba 0f       	add	r27, r26
    2424:	62 1f       	adc	r22, r18
    2426:	73 1f       	adc	r23, r19
    2428:	84 1f       	adc	r24, r20
    242a:	48 f4       	brcc	.+18     	; 0x243e <__addsf3x+0x9c>
    242c:	87 95       	ror	r24
    242e:	77 95       	ror	r23
    2430:	67 95       	ror	r22
    2432:	b7 95       	ror	r27
    2434:	f7 95       	ror	r31
    2436:	9e 3f       	cpi	r25, 0xFE	; 254
    2438:	08 f0       	brcs	.+2      	; 0x243c <__addsf3x+0x9a>
    243a:	b0 cf       	rjmp	.-160    	; 0x239c <__addsf3+0x28>
    243c:	93 95       	inc	r25
    243e:	88 0f       	add	r24, r24
    2440:	08 f0       	brcs	.+2      	; 0x2444 <__addsf3x+0xa2>
    2442:	99 27       	eor	r25, r25
    2444:	ee 0f       	add	r30, r30
    2446:	97 95       	ror	r25
    2448:	87 95       	ror	r24
    244a:	08 95       	ret

0000244c <__divsf3>:
    244c:	0e 94 3a 12 	call	0x2474	; 0x2474 <__divsf3x>
    2450:	0c 94 1b 13 	jmp	0x2636	; 0x2636 <__fp_round>
    2454:	0e 94 14 13 	call	0x2628	; 0x2628 <__fp_pscB>
    2458:	58 f0       	brcs	.+22     	; 0x2470 <__divsf3+0x24>
    245a:	0e 94 0d 13 	call	0x261a	; 0x261a <__fp_pscA>
    245e:	40 f0       	brcs	.+16     	; 0x2470 <__divsf3+0x24>
    2460:	29 f4       	brne	.+10     	; 0x246c <__divsf3+0x20>
    2462:	5f 3f       	cpi	r21, 0xFF	; 255
    2464:	29 f0       	breq	.+10     	; 0x2470 <__divsf3+0x24>
    2466:	0c 94 04 13 	jmp	0x2608	; 0x2608 <__fp_inf>
    246a:	51 11       	cpse	r21, r1
    246c:	0c 94 4f 13 	jmp	0x269e	; 0x269e <__fp_szero>
    2470:	0c 94 0a 13 	jmp	0x2614	; 0x2614 <__fp_nan>

00002474 <__divsf3x>:
    2474:	0e 94 2c 13 	call	0x2658	; 0x2658 <__fp_split3>
    2478:	68 f3       	brcs	.-38     	; 0x2454 <__divsf3+0x8>

0000247a <__divsf3_pse>:
    247a:	99 23       	and	r25, r25
    247c:	b1 f3       	breq	.-20     	; 0x246a <__divsf3+0x1e>
    247e:	55 23       	and	r21, r21
    2480:	91 f3       	breq	.-28     	; 0x2466 <__divsf3+0x1a>
    2482:	95 1b       	sub	r25, r21
    2484:	55 0b       	sbc	r21, r21
    2486:	bb 27       	eor	r27, r27
    2488:	aa 27       	eor	r26, r26
    248a:	62 17       	cp	r22, r18
    248c:	73 07       	cpc	r23, r19
    248e:	84 07       	cpc	r24, r20
    2490:	38 f0       	brcs	.+14     	; 0x24a0 <__divsf3_pse+0x26>
    2492:	9f 5f       	subi	r25, 0xFF	; 255
    2494:	5f 4f       	sbci	r21, 0xFF	; 255
    2496:	22 0f       	add	r18, r18
    2498:	33 1f       	adc	r19, r19
    249a:	44 1f       	adc	r20, r20
    249c:	aa 1f       	adc	r26, r26
    249e:	a9 f3       	breq	.-22     	; 0x248a <__divsf3_pse+0x10>
    24a0:	35 d0       	rcall	.+106    	; 0x250c <__divsf3_pse+0x92>
    24a2:	0e 2e       	mov	r0, r30
    24a4:	3a f0       	brmi	.+14     	; 0x24b4 <__divsf3_pse+0x3a>
    24a6:	e0 e8       	ldi	r30, 0x80	; 128
    24a8:	32 d0       	rcall	.+100    	; 0x250e <__divsf3_pse+0x94>
    24aa:	91 50       	subi	r25, 0x01	; 1
    24ac:	50 40       	sbci	r21, 0x00	; 0
    24ae:	e6 95       	lsr	r30
    24b0:	00 1c       	adc	r0, r0
    24b2:	ca f7       	brpl	.-14     	; 0x24a6 <__divsf3_pse+0x2c>
    24b4:	2b d0       	rcall	.+86     	; 0x250c <__divsf3_pse+0x92>
    24b6:	fe 2f       	mov	r31, r30
    24b8:	29 d0       	rcall	.+82     	; 0x250c <__divsf3_pse+0x92>
    24ba:	66 0f       	add	r22, r22
    24bc:	77 1f       	adc	r23, r23
    24be:	88 1f       	adc	r24, r24
    24c0:	bb 1f       	adc	r27, r27
    24c2:	26 17       	cp	r18, r22
    24c4:	37 07       	cpc	r19, r23
    24c6:	48 07       	cpc	r20, r24
    24c8:	ab 07       	cpc	r26, r27
    24ca:	b0 e8       	ldi	r27, 0x80	; 128
    24cc:	09 f0       	breq	.+2      	; 0x24d0 <__divsf3_pse+0x56>
    24ce:	bb 0b       	sbc	r27, r27
    24d0:	80 2d       	mov	r24, r0
    24d2:	bf 01       	movw	r22, r30
    24d4:	ff 27       	eor	r31, r31
    24d6:	93 58       	subi	r25, 0x83	; 131
    24d8:	5f 4f       	sbci	r21, 0xFF	; 255
    24da:	3a f0       	brmi	.+14     	; 0x24ea <__divsf3_pse+0x70>
    24dc:	9e 3f       	cpi	r25, 0xFE	; 254
    24de:	51 05       	cpc	r21, r1
    24e0:	78 f0       	brcs	.+30     	; 0x2500 <__divsf3_pse+0x86>
    24e2:	0c 94 04 13 	jmp	0x2608	; 0x2608 <__fp_inf>
    24e6:	0c 94 4f 13 	jmp	0x269e	; 0x269e <__fp_szero>
    24ea:	5f 3f       	cpi	r21, 0xFF	; 255
    24ec:	e4 f3       	brlt	.-8      	; 0x24e6 <__divsf3_pse+0x6c>
    24ee:	98 3e       	cpi	r25, 0xE8	; 232
    24f0:	d4 f3       	brlt	.-12     	; 0x24e6 <__divsf3_pse+0x6c>
    24f2:	86 95       	lsr	r24
    24f4:	77 95       	ror	r23
    24f6:	67 95       	ror	r22
    24f8:	b7 95       	ror	r27
    24fa:	f7 95       	ror	r31
    24fc:	9f 5f       	subi	r25, 0xFF	; 255
    24fe:	c9 f7       	brne	.-14     	; 0x24f2 <__divsf3_pse+0x78>
    2500:	88 0f       	add	r24, r24
    2502:	91 1d       	adc	r25, r1
    2504:	96 95       	lsr	r25
    2506:	87 95       	ror	r24
    2508:	97 f9       	bld	r25, 7
    250a:	08 95       	ret
    250c:	e1 e0       	ldi	r30, 0x01	; 1
    250e:	66 0f       	add	r22, r22
    2510:	77 1f       	adc	r23, r23
    2512:	88 1f       	adc	r24, r24
    2514:	bb 1f       	adc	r27, r27
    2516:	62 17       	cp	r22, r18
    2518:	73 07       	cpc	r23, r19
    251a:	84 07       	cpc	r24, r20
    251c:	ba 07       	cpc	r27, r26
    251e:	20 f0       	brcs	.+8      	; 0x2528 <__divsf3_pse+0xae>
    2520:	62 1b       	sub	r22, r18
    2522:	73 0b       	sbc	r23, r19
    2524:	84 0b       	sbc	r24, r20
    2526:	ba 0b       	sbc	r27, r26
    2528:	ee 1f       	adc	r30, r30
    252a:	88 f7       	brcc	.-30     	; 0x250e <__divsf3_pse+0x94>
    252c:	e0 95       	com	r30
    252e:	08 95       	ret

00002530 <__fixunssfsi>:
    2530:	0e 94 34 13 	call	0x2668	; 0x2668 <__fp_splitA>
    2534:	88 f0       	brcs	.+34     	; 0x2558 <__fixunssfsi+0x28>
    2536:	9f 57       	subi	r25, 0x7F	; 127
    2538:	98 f0       	brcs	.+38     	; 0x2560 <__fixunssfsi+0x30>
    253a:	b9 2f       	mov	r27, r25
    253c:	99 27       	eor	r25, r25
    253e:	b7 51       	subi	r27, 0x17	; 23
    2540:	b0 f0       	brcs	.+44     	; 0x256e <__fixunssfsi+0x3e>
    2542:	e1 f0       	breq	.+56     	; 0x257c <__fixunssfsi+0x4c>
    2544:	66 0f       	add	r22, r22
    2546:	77 1f       	adc	r23, r23
    2548:	88 1f       	adc	r24, r24
    254a:	99 1f       	adc	r25, r25
    254c:	1a f0       	brmi	.+6      	; 0x2554 <__fixunssfsi+0x24>
    254e:	ba 95       	dec	r27
    2550:	c9 f7       	brne	.-14     	; 0x2544 <__fixunssfsi+0x14>
    2552:	14 c0       	rjmp	.+40     	; 0x257c <__fixunssfsi+0x4c>
    2554:	b1 30       	cpi	r27, 0x01	; 1
    2556:	91 f0       	breq	.+36     	; 0x257c <__fixunssfsi+0x4c>
    2558:	0e 94 4e 13 	call	0x269c	; 0x269c <__fp_zero>
    255c:	b1 e0       	ldi	r27, 0x01	; 1
    255e:	08 95       	ret
    2560:	0c 94 4e 13 	jmp	0x269c	; 0x269c <__fp_zero>
    2564:	67 2f       	mov	r22, r23
    2566:	78 2f       	mov	r23, r24
    2568:	88 27       	eor	r24, r24
    256a:	b8 5f       	subi	r27, 0xF8	; 248
    256c:	39 f0       	breq	.+14     	; 0x257c <__fixunssfsi+0x4c>
    256e:	b9 3f       	cpi	r27, 0xF9	; 249
    2570:	cc f3       	brlt	.-14     	; 0x2564 <__fixunssfsi+0x34>
    2572:	86 95       	lsr	r24
    2574:	77 95       	ror	r23
    2576:	67 95       	ror	r22
    2578:	b3 95       	inc	r27
    257a:	d9 f7       	brne	.-10     	; 0x2572 <__fixunssfsi+0x42>
    257c:	3e f4       	brtc	.+14     	; 0x258c <__fixunssfsi+0x5c>
    257e:	90 95       	com	r25
    2580:	80 95       	com	r24
    2582:	70 95       	com	r23
    2584:	61 95       	neg	r22
    2586:	7f 4f       	sbci	r23, 0xFF	; 255
    2588:	8f 4f       	sbci	r24, 0xFF	; 255
    258a:	9f 4f       	sbci	r25, 0xFF	; 255
    258c:	08 95       	ret

0000258e <__floatunsisf>:
    258e:	e8 94       	clt
    2590:	09 c0       	rjmp	.+18     	; 0x25a4 <__floatsisf+0x12>

00002592 <__floatsisf>:
    2592:	97 fb       	bst	r25, 7
    2594:	3e f4       	brtc	.+14     	; 0x25a4 <__floatsisf+0x12>
    2596:	90 95       	com	r25
    2598:	80 95       	com	r24
    259a:	70 95       	com	r23
    259c:	61 95       	neg	r22
    259e:	7f 4f       	sbci	r23, 0xFF	; 255
    25a0:	8f 4f       	sbci	r24, 0xFF	; 255
    25a2:	9f 4f       	sbci	r25, 0xFF	; 255
    25a4:	99 23       	and	r25, r25
    25a6:	a9 f0       	breq	.+42     	; 0x25d2 <__floatsisf+0x40>
    25a8:	f9 2f       	mov	r31, r25
    25aa:	96 e9       	ldi	r25, 0x96	; 150
    25ac:	bb 27       	eor	r27, r27
    25ae:	93 95       	inc	r25
    25b0:	f6 95       	lsr	r31
    25b2:	87 95       	ror	r24
    25b4:	77 95       	ror	r23
    25b6:	67 95       	ror	r22
    25b8:	b7 95       	ror	r27
    25ba:	f1 11       	cpse	r31, r1
    25bc:	f8 cf       	rjmp	.-16     	; 0x25ae <__floatsisf+0x1c>
    25be:	fa f4       	brpl	.+62     	; 0x25fe <__floatsisf+0x6c>
    25c0:	bb 0f       	add	r27, r27
    25c2:	11 f4       	brne	.+4      	; 0x25c8 <__floatsisf+0x36>
    25c4:	60 ff       	sbrs	r22, 0
    25c6:	1b c0       	rjmp	.+54     	; 0x25fe <__floatsisf+0x6c>
    25c8:	6f 5f       	subi	r22, 0xFF	; 255
    25ca:	7f 4f       	sbci	r23, 0xFF	; 255
    25cc:	8f 4f       	sbci	r24, 0xFF	; 255
    25ce:	9f 4f       	sbci	r25, 0xFF	; 255
    25d0:	16 c0       	rjmp	.+44     	; 0x25fe <__floatsisf+0x6c>
    25d2:	88 23       	and	r24, r24
    25d4:	11 f0       	breq	.+4      	; 0x25da <__floatsisf+0x48>
    25d6:	96 e9       	ldi	r25, 0x96	; 150
    25d8:	11 c0       	rjmp	.+34     	; 0x25fc <__floatsisf+0x6a>
    25da:	77 23       	and	r23, r23
    25dc:	21 f0       	breq	.+8      	; 0x25e6 <__floatsisf+0x54>
    25de:	9e e8       	ldi	r25, 0x8E	; 142
    25e0:	87 2f       	mov	r24, r23
    25e2:	76 2f       	mov	r23, r22
    25e4:	05 c0       	rjmp	.+10     	; 0x25f0 <__floatsisf+0x5e>
    25e6:	66 23       	and	r22, r22
    25e8:	71 f0       	breq	.+28     	; 0x2606 <__floatsisf+0x74>
    25ea:	96 e8       	ldi	r25, 0x86	; 134
    25ec:	86 2f       	mov	r24, r22
    25ee:	70 e0       	ldi	r23, 0x00	; 0
    25f0:	60 e0       	ldi	r22, 0x00	; 0
    25f2:	2a f0       	brmi	.+10     	; 0x25fe <__floatsisf+0x6c>
    25f4:	9a 95       	dec	r25
    25f6:	66 0f       	add	r22, r22
    25f8:	77 1f       	adc	r23, r23
    25fa:	88 1f       	adc	r24, r24
    25fc:	da f7       	brpl	.-10     	; 0x25f4 <__floatsisf+0x62>
    25fe:	88 0f       	add	r24, r24
    2600:	96 95       	lsr	r25
    2602:	87 95       	ror	r24
    2604:	97 f9       	bld	r25, 7
    2606:	08 95       	ret

00002608 <__fp_inf>:
    2608:	97 f9       	bld	r25, 7
    260a:	9f 67       	ori	r25, 0x7F	; 127
    260c:	80 e8       	ldi	r24, 0x80	; 128
    260e:	70 e0       	ldi	r23, 0x00	; 0
    2610:	60 e0       	ldi	r22, 0x00	; 0
    2612:	08 95       	ret

00002614 <__fp_nan>:
    2614:	9f ef       	ldi	r25, 0xFF	; 255
    2616:	80 ec       	ldi	r24, 0xC0	; 192
    2618:	08 95       	ret

0000261a <__fp_pscA>:
    261a:	00 24       	eor	r0, r0
    261c:	0a 94       	dec	r0
    261e:	16 16       	cp	r1, r22
    2620:	17 06       	cpc	r1, r23
    2622:	18 06       	cpc	r1, r24
    2624:	09 06       	cpc	r0, r25
    2626:	08 95       	ret

00002628 <__fp_pscB>:
    2628:	00 24       	eor	r0, r0
    262a:	0a 94       	dec	r0
    262c:	12 16       	cp	r1, r18
    262e:	13 06       	cpc	r1, r19
    2630:	14 06       	cpc	r1, r20
    2632:	05 06       	cpc	r0, r21
    2634:	08 95       	ret

00002636 <__fp_round>:
    2636:	09 2e       	mov	r0, r25
    2638:	03 94       	inc	r0
    263a:	00 0c       	add	r0, r0
    263c:	11 f4       	brne	.+4      	; 0x2642 <__fp_round+0xc>
    263e:	88 23       	and	r24, r24
    2640:	52 f0       	brmi	.+20     	; 0x2656 <__fp_round+0x20>
    2642:	bb 0f       	add	r27, r27
    2644:	40 f4       	brcc	.+16     	; 0x2656 <__fp_round+0x20>
    2646:	bf 2b       	or	r27, r31
    2648:	11 f4       	brne	.+4      	; 0x264e <__fp_round+0x18>
    264a:	60 ff       	sbrs	r22, 0
    264c:	04 c0       	rjmp	.+8      	; 0x2656 <__fp_round+0x20>
    264e:	6f 5f       	subi	r22, 0xFF	; 255
    2650:	7f 4f       	sbci	r23, 0xFF	; 255
    2652:	8f 4f       	sbci	r24, 0xFF	; 255
    2654:	9f 4f       	sbci	r25, 0xFF	; 255
    2656:	08 95       	ret

00002658 <__fp_split3>:
    2658:	57 fd       	sbrc	r21, 7
    265a:	90 58       	subi	r25, 0x80	; 128
    265c:	44 0f       	add	r20, r20
    265e:	55 1f       	adc	r21, r21
    2660:	59 f0       	breq	.+22     	; 0x2678 <__fp_splitA+0x10>
    2662:	5f 3f       	cpi	r21, 0xFF	; 255
    2664:	71 f0       	breq	.+28     	; 0x2682 <__fp_splitA+0x1a>
    2666:	47 95       	ror	r20

00002668 <__fp_splitA>:
    2668:	88 0f       	add	r24, r24
    266a:	97 fb       	bst	r25, 7
    266c:	99 1f       	adc	r25, r25
    266e:	61 f0       	breq	.+24     	; 0x2688 <__fp_splitA+0x20>
    2670:	9f 3f       	cpi	r25, 0xFF	; 255
    2672:	79 f0       	breq	.+30     	; 0x2692 <__fp_splitA+0x2a>
    2674:	87 95       	ror	r24
    2676:	08 95       	ret
    2678:	12 16       	cp	r1, r18
    267a:	13 06       	cpc	r1, r19
    267c:	14 06       	cpc	r1, r20
    267e:	55 1f       	adc	r21, r21
    2680:	f2 cf       	rjmp	.-28     	; 0x2666 <__fp_split3+0xe>
    2682:	46 95       	lsr	r20
    2684:	f1 df       	rcall	.-30     	; 0x2668 <__fp_splitA>
    2686:	08 c0       	rjmp	.+16     	; 0x2698 <__fp_splitA+0x30>
    2688:	16 16       	cp	r1, r22
    268a:	17 06       	cpc	r1, r23
    268c:	18 06       	cpc	r1, r24
    268e:	99 1f       	adc	r25, r25
    2690:	f1 cf       	rjmp	.-30     	; 0x2674 <__fp_splitA+0xc>
    2692:	86 95       	lsr	r24
    2694:	71 05       	cpc	r23, r1
    2696:	61 05       	cpc	r22, r1
    2698:	08 94       	sec
    269a:	08 95       	ret

0000269c <__fp_zero>:
    269c:	e8 94       	clt

0000269e <__fp_szero>:
    269e:	bb 27       	eor	r27, r27
    26a0:	66 27       	eor	r22, r22
    26a2:	77 27       	eor	r23, r23
    26a4:	cb 01       	movw	r24, r22
    26a6:	97 f9       	bld	r25, 7
    26a8:	08 95       	ret

000026aa <__mulsf3>:
    26aa:	0e 94 68 13 	call	0x26d0	; 0x26d0 <__mulsf3x>
    26ae:	0c 94 1b 13 	jmp	0x2636	; 0x2636 <__fp_round>
    26b2:	0e 94 0d 13 	call	0x261a	; 0x261a <__fp_pscA>
    26b6:	38 f0       	brcs	.+14     	; 0x26c6 <__mulsf3+0x1c>
    26b8:	0e 94 14 13 	call	0x2628	; 0x2628 <__fp_pscB>
    26bc:	20 f0       	brcs	.+8      	; 0x26c6 <__mulsf3+0x1c>
    26be:	95 23       	and	r25, r21
    26c0:	11 f0       	breq	.+4      	; 0x26c6 <__mulsf3+0x1c>
    26c2:	0c 94 04 13 	jmp	0x2608	; 0x2608 <__fp_inf>
    26c6:	0c 94 0a 13 	jmp	0x2614	; 0x2614 <__fp_nan>
    26ca:	11 24       	eor	r1, r1
    26cc:	0c 94 4f 13 	jmp	0x269e	; 0x269e <__fp_szero>

000026d0 <__mulsf3x>:
    26d0:	0e 94 2c 13 	call	0x2658	; 0x2658 <__fp_split3>
    26d4:	70 f3       	brcs	.-36     	; 0x26b2 <__mulsf3+0x8>

000026d6 <__mulsf3_pse>:
    26d6:	95 9f       	mul	r25, r21
    26d8:	c1 f3       	breq	.-16     	; 0x26ca <__mulsf3+0x20>
    26da:	95 0f       	add	r25, r21
    26dc:	50 e0       	ldi	r21, 0x00	; 0
    26de:	55 1f       	adc	r21, r21
    26e0:	62 9f       	mul	r22, r18
    26e2:	f0 01       	movw	r30, r0
    26e4:	72 9f       	mul	r23, r18
    26e6:	bb 27       	eor	r27, r27
    26e8:	f0 0d       	add	r31, r0
    26ea:	b1 1d       	adc	r27, r1
    26ec:	63 9f       	mul	r22, r19
    26ee:	aa 27       	eor	r26, r26
    26f0:	f0 0d       	add	r31, r0
    26f2:	b1 1d       	adc	r27, r1
    26f4:	aa 1f       	adc	r26, r26
    26f6:	64 9f       	mul	r22, r20
    26f8:	66 27       	eor	r22, r22
    26fa:	b0 0d       	add	r27, r0
    26fc:	a1 1d       	adc	r26, r1
    26fe:	66 1f       	adc	r22, r22
    2700:	82 9f       	mul	r24, r18
    2702:	22 27       	eor	r18, r18
    2704:	b0 0d       	add	r27, r0
    2706:	a1 1d       	adc	r26, r1
    2708:	62 1f       	adc	r22, r18
    270a:	73 9f       	mul	r23, r19
    270c:	b0 0d       	add	r27, r0
    270e:	a1 1d       	adc	r26, r1
    2710:	62 1f       	adc	r22, r18
    2712:	83 9f       	mul	r24, r19
    2714:	a0 0d       	add	r26, r0
    2716:	61 1d       	adc	r22, r1
    2718:	22 1f       	adc	r18, r18
    271a:	74 9f       	mul	r23, r20
    271c:	33 27       	eor	r19, r19
    271e:	a0 0d       	add	r26, r0
    2720:	61 1d       	adc	r22, r1
    2722:	23 1f       	adc	r18, r19
    2724:	84 9f       	mul	r24, r20
    2726:	60 0d       	add	r22, r0
    2728:	21 1d       	adc	r18, r1
    272a:	82 2f       	mov	r24, r18
    272c:	76 2f       	mov	r23, r22
    272e:	6a 2f       	mov	r22, r26
    2730:	11 24       	eor	r1, r1
    2732:	9f 57       	subi	r25, 0x7F	; 127
    2734:	50 40       	sbci	r21, 0x00	; 0
    2736:	9a f0       	brmi	.+38     	; 0x275e <__mulsf3_pse+0x88>
    2738:	f1 f0       	breq	.+60     	; 0x2776 <__mulsf3_pse+0xa0>
    273a:	88 23       	and	r24, r24
    273c:	4a f0       	brmi	.+18     	; 0x2750 <__mulsf3_pse+0x7a>
    273e:	ee 0f       	add	r30, r30
    2740:	ff 1f       	adc	r31, r31
    2742:	bb 1f       	adc	r27, r27
    2744:	66 1f       	adc	r22, r22
    2746:	77 1f       	adc	r23, r23
    2748:	88 1f       	adc	r24, r24
    274a:	91 50       	subi	r25, 0x01	; 1
    274c:	50 40       	sbci	r21, 0x00	; 0
    274e:	a9 f7       	brne	.-22     	; 0x273a <__mulsf3_pse+0x64>
    2750:	9e 3f       	cpi	r25, 0xFE	; 254
    2752:	51 05       	cpc	r21, r1
    2754:	80 f0       	brcs	.+32     	; 0x2776 <__mulsf3_pse+0xa0>
    2756:	0c 94 04 13 	jmp	0x2608	; 0x2608 <__fp_inf>
    275a:	0c 94 4f 13 	jmp	0x269e	; 0x269e <__fp_szero>
    275e:	5f 3f       	cpi	r21, 0xFF	; 255
    2760:	e4 f3       	brlt	.-8      	; 0x275a <__mulsf3_pse+0x84>
    2762:	98 3e       	cpi	r25, 0xE8	; 232
    2764:	d4 f3       	brlt	.-12     	; 0x275a <__mulsf3_pse+0x84>
    2766:	86 95       	lsr	r24
    2768:	77 95       	ror	r23
    276a:	67 95       	ror	r22
    276c:	b7 95       	ror	r27
    276e:	f7 95       	ror	r31
    2770:	e7 95       	ror	r30
    2772:	9f 5f       	subi	r25, 0xFF	; 255
    2774:	c1 f7       	brne	.-16     	; 0x2766 <__mulsf3_pse+0x90>
    2776:	fe 2b       	or	r31, r30
    2778:	88 0f       	add	r24, r24
    277a:	91 1d       	adc	r25, r1
    277c:	96 95       	lsr	r25
    277e:	87 95       	ror	r24
    2780:	97 f9       	bld	r25, 7
    2782:	08 95       	ret

00002784 <__tablejump2__>:
    2784:	ee 0f       	add	r30, r30
    2786:	ff 1f       	adc	r31, r31
    2788:	05 90       	lpm	r0, Z+
    278a:	f4 91       	lpm	r31, Z
    278c:	e0 2d       	mov	r30, r0
    278e:	09 94       	ijmp

00002790 <__umulhisi3>:
    2790:	a2 9f       	mul	r26, r18
    2792:	b0 01       	movw	r22, r0
    2794:	b3 9f       	mul	r27, r19
    2796:	c0 01       	movw	r24, r0
    2798:	a3 9f       	mul	r26, r19
    279a:	70 0d       	add	r23, r0
    279c:	81 1d       	adc	r24, r1
    279e:	11 24       	eor	r1, r1
    27a0:	91 1d       	adc	r25, r1
    27a2:	b2 9f       	mul	r27, r18
    27a4:	70 0d       	add	r23, r0
    27a6:	81 1d       	adc	r24, r1
    27a8:	11 24       	eor	r1, r1
    27aa:	91 1d       	adc	r25, r1
    27ac:	08 95       	ret

000027ae <strcmp>:
    27ae:	fb 01       	movw	r30, r22
    27b0:	dc 01       	movw	r26, r24
    27b2:	8d 91       	ld	r24, X+
    27b4:	01 90       	ld	r0, Z+
    27b6:	80 19       	sub	r24, r0
    27b8:	01 10       	cpse	r0, r1
    27ba:	d9 f3       	breq	.-10     	; 0x27b2 <strcmp+0x4>
    27bc:	99 0b       	sbc	r25, r25
    27be:	08 95       	ret

000027c0 <strcpy>:
    27c0:	fb 01       	movw	r30, r22
    27c2:	dc 01       	movw	r26, r24
    27c4:	01 90       	ld	r0, Z+
    27c6:	0d 92       	st	X+, r0
    27c8:	00 20       	and	r0, r0
    27ca:	e1 f7       	brne	.-8      	; 0x27c4 <strcpy+0x4>
    27cc:	08 95       	ret

000027ce <sprintf>:
    27ce:	ae e0       	ldi	r26, 0x0E	; 14
    27d0:	b0 e0       	ldi	r27, 0x00	; 0
    27d2:	ed ee       	ldi	r30, 0xED	; 237
    27d4:	f3 e1       	ldi	r31, 0x13	; 19
    27d6:	0c 94 a8 16 	jmp	0x2d50	; 0x2d50 <__prologue_saves__+0x1c>
    27da:	0d 89       	ldd	r16, Y+21	; 0x15
    27dc:	1e 89       	ldd	r17, Y+22	; 0x16
    27de:	86 e0       	ldi	r24, 0x06	; 6
    27e0:	8c 83       	std	Y+4, r24	; 0x04
    27e2:	1a 83       	std	Y+2, r17	; 0x02
    27e4:	09 83       	std	Y+1, r16	; 0x01
    27e6:	8f ef       	ldi	r24, 0xFF	; 255
    27e8:	9f e7       	ldi	r25, 0x7F	; 127
    27ea:	9e 83       	std	Y+6, r25	; 0x06
    27ec:	8d 83       	std	Y+5, r24	; 0x05
    27ee:	ae 01       	movw	r20, r28
    27f0:	47 5e       	subi	r20, 0xE7	; 231
    27f2:	5f 4f       	sbci	r21, 0xFF	; 255
    27f4:	6f 89       	ldd	r22, Y+23	; 0x17
    27f6:	78 8d       	ldd	r23, Y+24	; 0x18
    27f8:	ce 01       	movw	r24, r28
    27fa:	01 96       	adiw	r24, 0x01	; 1
    27fc:	0e 94 09 14 	call	0x2812	; 0x2812 <vfprintf>
    2800:	ef 81       	ldd	r30, Y+7	; 0x07
    2802:	f8 85       	ldd	r31, Y+8	; 0x08
    2804:	e0 0f       	add	r30, r16
    2806:	f1 1f       	adc	r31, r17
    2808:	10 82       	st	Z, r1
    280a:	2e 96       	adiw	r28, 0x0e	; 14
    280c:	e4 e0       	ldi	r30, 0x04	; 4
    280e:	0c 94 c4 16 	jmp	0x2d88	; 0x2d88 <__epilogue_restores__+0x1c>

00002812 <vfprintf>:
    2812:	ab e0       	ldi	r26, 0x0B	; 11
    2814:	b0 e0       	ldi	r27, 0x00	; 0
    2816:	ef e0       	ldi	r30, 0x0F	; 15
    2818:	f4 e1       	ldi	r31, 0x14	; 20
    281a:	0c 94 9a 16 	jmp	0x2d34	; 0x2d34 <__prologue_saves__>
    281e:	6c 01       	movw	r12, r24
    2820:	7b 01       	movw	r14, r22
    2822:	8a 01       	movw	r16, r20
    2824:	fc 01       	movw	r30, r24
    2826:	17 82       	std	Z+7, r1	; 0x07
    2828:	16 82       	std	Z+6, r1	; 0x06
    282a:	83 81       	ldd	r24, Z+3	; 0x03
    282c:	81 ff       	sbrs	r24, 1
    282e:	cc c1       	rjmp	.+920    	; 0x2bc8 <vfprintf+0x3b6>
    2830:	ce 01       	movw	r24, r28
    2832:	01 96       	adiw	r24, 0x01	; 1
    2834:	3c 01       	movw	r6, r24
    2836:	f6 01       	movw	r30, r12
    2838:	93 81       	ldd	r25, Z+3	; 0x03
    283a:	f7 01       	movw	r30, r14
    283c:	93 fd       	sbrc	r25, 3
    283e:	85 91       	lpm	r24, Z+
    2840:	93 ff       	sbrs	r25, 3
    2842:	81 91       	ld	r24, Z+
    2844:	7f 01       	movw	r14, r30
    2846:	88 23       	and	r24, r24
    2848:	09 f4       	brne	.+2      	; 0x284c <vfprintf+0x3a>
    284a:	ba c1       	rjmp	.+884    	; 0x2bc0 <vfprintf+0x3ae>
    284c:	85 32       	cpi	r24, 0x25	; 37
    284e:	39 f4       	brne	.+14     	; 0x285e <vfprintf+0x4c>
    2850:	93 fd       	sbrc	r25, 3
    2852:	85 91       	lpm	r24, Z+
    2854:	93 ff       	sbrs	r25, 3
    2856:	81 91       	ld	r24, Z+
    2858:	7f 01       	movw	r14, r30
    285a:	85 32       	cpi	r24, 0x25	; 37
    285c:	29 f4       	brne	.+10     	; 0x2868 <vfprintf+0x56>
    285e:	b6 01       	movw	r22, r12
    2860:	90 e0       	ldi	r25, 0x00	; 0
    2862:	0e 94 00 16 	call	0x2c00	; 0x2c00 <fputc>
    2866:	e7 cf       	rjmp	.-50     	; 0x2836 <vfprintf+0x24>
    2868:	91 2c       	mov	r9, r1
    286a:	21 2c       	mov	r2, r1
    286c:	31 2c       	mov	r3, r1
    286e:	ff e1       	ldi	r31, 0x1F	; 31
    2870:	f3 15       	cp	r31, r3
    2872:	d8 f0       	brcs	.+54     	; 0x28aa <vfprintf+0x98>
    2874:	8b 32       	cpi	r24, 0x2B	; 43
    2876:	79 f0       	breq	.+30     	; 0x2896 <vfprintf+0x84>
    2878:	38 f4       	brcc	.+14     	; 0x2888 <vfprintf+0x76>
    287a:	80 32       	cpi	r24, 0x20	; 32
    287c:	79 f0       	breq	.+30     	; 0x289c <vfprintf+0x8a>
    287e:	83 32       	cpi	r24, 0x23	; 35
    2880:	a1 f4       	brne	.+40     	; 0x28aa <vfprintf+0x98>
    2882:	23 2d       	mov	r18, r3
    2884:	20 61       	ori	r18, 0x10	; 16
    2886:	1d c0       	rjmp	.+58     	; 0x28c2 <vfprintf+0xb0>
    2888:	8d 32       	cpi	r24, 0x2D	; 45
    288a:	61 f0       	breq	.+24     	; 0x28a4 <vfprintf+0x92>
    288c:	80 33       	cpi	r24, 0x30	; 48
    288e:	69 f4       	brne	.+26     	; 0x28aa <vfprintf+0x98>
    2890:	23 2d       	mov	r18, r3
    2892:	21 60       	ori	r18, 0x01	; 1
    2894:	16 c0       	rjmp	.+44     	; 0x28c2 <vfprintf+0xb0>
    2896:	83 2d       	mov	r24, r3
    2898:	82 60       	ori	r24, 0x02	; 2
    289a:	38 2e       	mov	r3, r24
    289c:	e3 2d       	mov	r30, r3
    289e:	e4 60       	ori	r30, 0x04	; 4
    28a0:	3e 2e       	mov	r3, r30
    28a2:	2a c0       	rjmp	.+84     	; 0x28f8 <vfprintf+0xe6>
    28a4:	f3 2d       	mov	r31, r3
    28a6:	f8 60       	ori	r31, 0x08	; 8
    28a8:	1d c0       	rjmp	.+58     	; 0x28e4 <vfprintf+0xd2>
    28aa:	37 fc       	sbrc	r3, 7
    28ac:	2d c0       	rjmp	.+90     	; 0x2908 <vfprintf+0xf6>
    28ae:	20 ed       	ldi	r18, 0xD0	; 208
    28b0:	28 0f       	add	r18, r24
    28b2:	2a 30       	cpi	r18, 0x0A	; 10
    28b4:	40 f0       	brcs	.+16     	; 0x28c6 <vfprintf+0xb4>
    28b6:	8e 32       	cpi	r24, 0x2E	; 46
    28b8:	b9 f4       	brne	.+46     	; 0x28e8 <vfprintf+0xd6>
    28ba:	36 fc       	sbrc	r3, 6
    28bc:	81 c1       	rjmp	.+770    	; 0x2bc0 <vfprintf+0x3ae>
    28be:	23 2d       	mov	r18, r3
    28c0:	20 64       	ori	r18, 0x40	; 64
    28c2:	32 2e       	mov	r3, r18
    28c4:	19 c0       	rjmp	.+50     	; 0x28f8 <vfprintf+0xe6>
    28c6:	36 fe       	sbrs	r3, 6
    28c8:	06 c0       	rjmp	.+12     	; 0x28d6 <vfprintf+0xc4>
    28ca:	8a e0       	ldi	r24, 0x0A	; 10
    28cc:	98 9e       	mul	r9, r24
    28ce:	20 0d       	add	r18, r0
    28d0:	11 24       	eor	r1, r1
    28d2:	92 2e       	mov	r9, r18
    28d4:	11 c0       	rjmp	.+34     	; 0x28f8 <vfprintf+0xe6>
    28d6:	ea e0       	ldi	r30, 0x0A	; 10
    28d8:	2e 9e       	mul	r2, r30
    28da:	20 0d       	add	r18, r0
    28dc:	11 24       	eor	r1, r1
    28de:	22 2e       	mov	r2, r18
    28e0:	f3 2d       	mov	r31, r3
    28e2:	f0 62       	ori	r31, 0x20	; 32
    28e4:	3f 2e       	mov	r3, r31
    28e6:	08 c0       	rjmp	.+16     	; 0x28f8 <vfprintf+0xe6>
    28e8:	8c 36       	cpi	r24, 0x6C	; 108
    28ea:	21 f4       	brne	.+8      	; 0x28f4 <vfprintf+0xe2>
    28ec:	83 2d       	mov	r24, r3
    28ee:	80 68       	ori	r24, 0x80	; 128
    28f0:	38 2e       	mov	r3, r24
    28f2:	02 c0       	rjmp	.+4      	; 0x28f8 <vfprintf+0xe6>
    28f4:	88 36       	cpi	r24, 0x68	; 104
    28f6:	41 f4       	brne	.+16     	; 0x2908 <vfprintf+0xf6>
    28f8:	f7 01       	movw	r30, r14
    28fa:	93 fd       	sbrc	r25, 3
    28fc:	85 91       	lpm	r24, Z+
    28fe:	93 ff       	sbrs	r25, 3
    2900:	81 91       	ld	r24, Z+
    2902:	7f 01       	movw	r14, r30
    2904:	81 11       	cpse	r24, r1
    2906:	b3 cf       	rjmp	.-154    	; 0x286e <vfprintf+0x5c>
    2908:	98 2f       	mov	r25, r24
    290a:	9f 7d       	andi	r25, 0xDF	; 223
    290c:	95 54       	subi	r25, 0x45	; 69
    290e:	93 30       	cpi	r25, 0x03	; 3
    2910:	28 f4       	brcc	.+10     	; 0x291c <vfprintf+0x10a>
    2912:	0c 5f       	subi	r16, 0xFC	; 252
    2914:	1f 4f       	sbci	r17, 0xFF	; 255
    2916:	9f e3       	ldi	r25, 0x3F	; 63
    2918:	99 83       	std	Y+1, r25	; 0x01
    291a:	0d c0       	rjmp	.+26     	; 0x2936 <vfprintf+0x124>
    291c:	83 36       	cpi	r24, 0x63	; 99
    291e:	31 f0       	breq	.+12     	; 0x292c <vfprintf+0x11a>
    2920:	83 37       	cpi	r24, 0x73	; 115
    2922:	71 f0       	breq	.+28     	; 0x2940 <vfprintf+0x12e>
    2924:	83 35       	cpi	r24, 0x53	; 83
    2926:	09 f0       	breq	.+2      	; 0x292a <vfprintf+0x118>
    2928:	59 c0       	rjmp	.+178    	; 0x29dc <vfprintf+0x1ca>
    292a:	21 c0       	rjmp	.+66     	; 0x296e <vfprintf+0x15c>
    292c:	f8 01       	movw	r30, r16
    292e:	80 81       	ld	r24, Z
    2930:	89 83       	std	Y+1, r24	; 0x01
    2932:	0e 5f       	subi	r16, 0xFE	; 254
    2934:	1f 4f       	sbci	r17, 0xFF	; 255
    2936:	88 24       	eor	r8, r8
    2938:	83 94       	inc	r8
    293a:	91 2c       	mov	r9, r1
    293c:	53 01       	movw	r10, r6
    293e:	13 c0       	rjmp	.+38     	; 0x2966 <vfprintf+0x154>
    2940:	28 01       	movw	r4, r16
    2942:	f2 e0       	ldi	r31, 0x02	; 2
    2944:	4f 0e       	add	r4, r31
    2946:	51 1c       	adc	r5, r1
    2948:	f8 01       	movw	r30, r16
    294a:	a0 80       	ld	r10, Z
    294c:	b1 80       	ldd	r11, Z+1	; 0x01
    294e:	36 fe       	sbrs	r3, 6
    2950:	03 c0       	rjmp	.+6      	; 0x2958 <vfprintf+0x146>
    2952:	69 2d       	mov	r22, r9
    2954:	70 e0       	ldi	r23, 0x00	; 0
    2956:	02 c0       	rjmp	.+4      	; 0x295c <vfprintf+0x14a>
    2958:	6f ef       	ldi	r22, 0xFF	; 255
    295a:	7f ef       	ldi	r23, 0xFF	; 255
    295c:	c5 01       	movw	r24, r10
    295e:	0e 94 f5 15 	call	0x2bea	; 0x2bea <strnlen>
    2962:	4c 01       	movw	r8, r24
    2964:	82 01       	movw	r16, r4
    2966:	f3 2d       	mov	r31, r3
    2968:	ff 77       	andi	r31, 0x7F	; 127
    296a:	3f 2e       	mov	r3, r31
    296c:	16 c0       	rjmp	.+44     	; 0x299a <vfprintf+0x188>
    296e:	28 01       	movw	r4, r16
    2970:	22 e0       	ldi	r18, 0x02	; 2
    2972:	42 0e       	add	r4, r18
    2974:	51 1c       	adc	r5, r1
    2976:	f8 01       	movw	r30, r16
    2978:	a0 80       	ld	r10, Z
    297a:	b1 80       	ldd	r11, Z+1	; 0x01
    297c:	36 fe       	sbrs	r3, 6
    297e:	03 c0       	rjmp	.+6      	; 0x2986 <vfprintf+0x174>
    2980:	69 2d       	mov	r22, r9
    2982:	70 e0       	ldi	r23, 0x00	; 0
    2984:	02 c0       	rjmp	.+4      	; 0x298a <vfprintf+0x178>
    2986:	6f ef       	ldi	r22, 0xFF	; 255
    2988:	7f ef       	ldi	r23, 0xFF	; 255
    298a:	c5 01       	movw	r24, r10
    298c:	0e 94 ea 15 	call	0x2bd4	; 0x2bd4 <strnlen_P>
    2990:	4c 01       	movw	r8, r24
    2992:	f3 2d       	mov	r31, r3
    2994:	f0 68       	ori	r31, 0x80	; 128
    2996:	3f 2e       	mov	r3, r31
    2998:	82 01       	movw	r16, r4
    299a:	33 fc       	sbrc	r3, 3
    299c:	1b c0       	rjmp	.+54     	; 0x29d4 <vfprintf+0x1c2>
    299e:	82 2d       	mov	r24, r2
    29a0:	90 e0       	ldi	r25, 0x00	; 0
    29a2:	88 16       	cp	r8, r24
    29a4:	99 06       	cpc	r9, r25
    29a6:	b0 f4       	brcc	.+44     	; 0x29d4 <vfprintf+0x1c2>
    29a8:	b6 01       	movw	r22, r12
    29aa:	80 e2       	ldi	r24, 0x20	; 32
    29ac:	90 e0       	ldi	r25, 0x00	; 0
    29ae:	0e 94 00 16 	call	0x2c00	; 0x2c00 <fputc>
    29b2:	2a 94       	dec	r2
    29b4:	f4 cf       	rjmp	.-24     	; 0x299e <vfprintf+0x18c>
    29b6:	f5 01       	movw	r30, r10
    29b8:	37 fc       	sbrc	r3, 7
    29ba:	85 91       	lpm	r24, Z+
    29bc:	37 fe       	sbrs	r3, 7
    29be:	81 91       	ld	r24, Z+
    29c0:	5f 01       	movw	r10, r30
    29c2:	b6 01       	movw	r22, r12
    29c4:	90 e0       	ldi	r25, 0x00	; 0
    29c6:	0e 94 00 16 	call	0x2c00	; 0x2c00 <fputc>
    29ca:	21 10       	cpse	r2, r1
    29cc:	2a 94       	dec	r2
    29ce:	21 e0       	ldi	r18, 0x01	; 1
    29d0:	82 1a       	sub	r8, r18
    29d2:	91 08       	sbc	r9, r1
    29d4:	81 14       	cp	r8, r1
    29d6:	91 04       	cpc	r9, r1
    29d8:	71 f7       	brne	.-36     	; 0x29b6 <vfprintf+0x1a4>
    29da:	e8 c0       	rjmp	.+464    	; 0x2bac <vfprintf+0x39a>
    29dc:	84 36       	cpi	r24, 0x64	; 100
    29de:	11 f0       	breq	.+4      	; 0x29e4 <vfprintf+0x1d2>
    29e0:	89 36       	cpi	r24, 0x69	; 105
    29e2:	41 f5       	brne	.+80     	; 0x2a34 <vfprintf+0x222>
    29e4:	f8 01       	movw	r30, r16
    29e6:	37 fe       	sbrs	r3, 7
    29e8:	07 c0       	rjmp	.+14     	; 0x29f8 <vfprintf+0x1e6>
    29ea:	60 81       	ld	r22, Z
    29ec:	71 81       	ldd	r23, Z+1	; 0x01
    29ee:	82 81       	ldd	r24, Z+2	; 0x02
    29f0:	93 81       	ldd	r25, Z+3	; 0x03
    29f2:	0c 5f       	subi	r16, 0xFC	; 252
    29f4:	1f 4f       	sbci	r17, 0xFF	; 255
    29f6:	08 c0       	rjmp	.+16     	; 0x2a08 <vfprintf+0x1f6>
    29f8:	60 81       	ld	r22, Z
    29fa:	71 81       	ldd	r23, Z+1	; 0x01
    29fc:	07 2e       	mov	r0, r23
    29fe:	00 0c       	add	r0, r0
    2a00:	88 0b       	sbc	r24, r24
    2a02:	99 0b       	sbc	r25, r25
    2a04:	0e 5f       	subi	r16, 0xFE	; 254
    2a06:	1f 4f       	sbci	r17, 0xFF	; 255
    2a08:	f3 2d       	mov	r31, r3
    2a0a:	ff 76       	andi	r31, 0x6F	; 111
    2a0c:	3f 2e       	mov	r3, r31
    2a0e:	97 ff       	sbrs	r25, 7
    2a10:	09 c0       	rjmp	.+18     	; 0x2a24 <vfprintf+0x212>
    2a12:	90 95       	com	r25
    2a14:	80 95       	com	r24
    2a16:	70 95       	com	r23
    2a18:	61 95       	neg	r22
    2a1a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a1c:	8f 4f       	sbci	r24, 0xFF	; 255
    2a1e:	9f 4f       	sbci	r25, 0xFF	; 255
    2a20:	f0 68       	ori	r31, 0x80	; 128
    2a22:	3f 2e       	mov	r3, r31
    2a24:	2a e0       	ldi	r18, 0x0A	; 10
    2a26:	30 e0       	ldi	r19, 0x00	; 0
    2a28:	a3 01       	movw	r20, r6
    2a2a:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <__ultoa_invert>
    2a2e:	88 2e       	mov	r8, r24
    2a30:	86 18       	sub	r8, r6
    2a32:	45 c0       	rjmp	.+138    	; 0x2abe <vfprintf+0x2ac>
    2a34:	85 37       	cpi	r24, 0x75	; 117
    2a36:	31 f4       	brne	.+12     	; 0x2a44 <vfprintf+0x232>
    2a38:	23 2d       	mov	r18, r3
    2a3a:	2f 7e       	andi	r18, 0xEF	; 239
    2a3c:	b2 2e       	mov	r11, r18
    2a3e:	2a e0       	ldi	r18, 0x0A	; 10
    2a40:	30 e0       	ldi	r19, 0x00	; 0
    2a42:	25 c0       	rjmp	.+74     	; 0x2a8e <vfprintf+0x27c>
    2a44:	93 2d       	mov	r25, r3
    2a46:	99 7f       	andi	r25, 0xF9	; 249
    2a48:	b9 2e       	mov	r11, r25
    2a4a:	8f 36       	cpi	r24, 0x6F	; 111
    2a4c:	c1 f0       	breq	.+48     	; 0x2a7e <vfprintf+0x26c>
    2a4e:	18 f4       	brcc	.+6      	; 0x2a56 <vfprintf+0x244>
    2a50:	88 35       	cpi	r24, 0x58	; 88
    2a52:	79 f0       	breq	.+30     	; 0x2a72 <vfprintf+0x260>
    2a54:	b5 c0       	rjmp	.+362    	; 0x2bc0 <vfprintf+0x3ae>
    2a56:	80 37       	cpi	r24, 0x70	; 112
    2a58:	19 f0       	breq	.+6      	; 0x2a60 <vfprintf+0x24e>
    2a5a:	88 37       	cpi	r24, 0x78	; 120
    2a5c:	21 f0       	breq	.+8      	; 0x2a66 <vfprintf+0x254>
    2a5e:	b0 c0       	rjmp	.+352    	; 0x2bc0 <vfprintf+0x3ae>
    2a60:	e9 2f       	mov	r30, r25
    2a62:	e0 61       	ori	r30, 0x10	; 16
    2a64:	be 2e       	mov	r11, r30
    2a66:	b4 fe       	sbrs	r11, 4
    2a68:	0d c0       	rjmp	.+26     	; 0x2a84 <vfprintf+0x272>
    2a6a:	fb 2d       	mov	r31, r11
    2a6c:	f4 60       	ori	r31, 0x04	; 4
    2a6e:	bf 2e       	mov	r11, r31
    2a70:	09 c0       	rjmp	.+18     	; 0x2a84 <vfprintf+0x272>
    2a72:	34 fe       	sbrs	r3, 4
    2a74:	0a c0       	rjmp	.+20     	; 0x2a8a <vfprintf+0x278>
    2a76:	29 2f       	mov	r18, r25
    2a78:	26 60       	ori	r18, 0x06	; 6
    2a7a:	b2 2e       	mov	r11, r18
    2a7c:	06 c0       	rjmp	.+12     	; 0x2a8a <vfprintf+0x278>
    2a7e:	28 e0       	ldi	r18, 0x08	; 8
    2a80:	30 e0       	ldi	r19, 0x00	; 0
    2a82:	05 c0       	rjmp	.+10     	; 0x2a8e <vfprintf+0x27c>
    2a84:	20 e1       	ldi	r18, 0x10	; 16
    2a86:	30 e0       	ldi	r19, 0x00	; 0
    2a88:	02 c0       	rjmp	.+4      	; 0x2a8e <vfprintf+0x27c>
    2a8a:	20 e1       	ldi	r18, 0x10	; 16
    2a8c:	32 e0       	ldi	r19, 0x02	; 2
    2a8e:	f8 01       	movw	r30, r16
    2a90:	b7 fe       	sbrs	r11, 7
    2a92:	07 c0       	rjmp	.+14     	; 0x2aa2 <vfprintf+0x290>
    2a94:	60 81       	ld	r22, Z
    2a96:	71 81       	ldd	r23, Z+1	; 0x01
    2a98:	82 81       	ldd	r24, Z+2	; 0x02
    2a9a:	93 81       	ldd	r25, Z+3	; 0x03
    2a9c:	0c 5f       	subi	r16, 0xFC	; 252
    2a9e:	1f 4f       	sbci	r17, 0xFF	; 255
    2aa0:	06 c0       	rjmp	.+12     	; 0x2aae <vfprintf+0x29c>
    2aa2:	60 81       	ld	r22, Z
    2aa4:	71 81       	ldd	r23, Z+1	; 0x01
    2aa6:	80 e0       	ldi	r24, 0x00	; 0
    2aa8:	90 e0       	ldi	r25, 0x00	; 0
    2aaa:	0e 5f       	subi	r16, 0xFE	; 254
    2aac:	1f 4f       	sbci	r17, 0xFF	; 255
    2aae:	a3 01       	movw	r20, r6
    2ab0:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <__ultoa_invert>
    2ab4:	88 2e       	mov	r8, r24
    2ab6:	86 18       	sub	r8, r6
    2ab8:	fb 2d       	mov	r31, r11
    2aba:	ff 77       	andi	r31, 0x7F	; 127
    2abc:	3f 2e       	mov	r3, r31
    2abe:	36 fe       	sbrs	r3, 6
    2ac0:	0d c0       	rjmp	.+26     	; 0x2adc <vfprintf+0x2ca>
    2ac2:	23 2d       	mov	r18, r3
    2ac4:	2e 7f       	andi	r18, 0xFE	; 254
    2ac6:	a2 2e       	mov	r10, r18
    2ac8:	89 14       	cp	r8, r9
    2aca:	58 f4       	brcc	.+22     	; 0x2ae2 <vfprintf+0x2d0>
    2acc:	34 fe       	sbrs	r3, 4
    2ace:	0b c0       	rjmp	.+22     	; 0x2ae6 <vfprintf+0x2d4>
    2ad0:	32 fc       	sbrc	r3, 2
    2ad2:	09 c0       	rjmp	.+18     	; 0x2ae6 <vfprintf+0x2d4>
    2ad4:	83 2d       	mov	r24, r3
    2ad6:	8e 7e       	andi	r24, 0xEE	; 238
    2ad8:	a8 2e       	mov	r10, r24
    2ada:	05 c0       	rjmp	.+10     	; 0x2ae6 <vfprintf+0x2d4>
    2adc:	b8 2c       	mov	r11, r8
    2ade:	a3 2c       	mov	r10, r3
    2ae0:	03 c0       	rjmp	.+6      	; 0x2ae8 <vfprintf+0x2d6>
    2ae2:	b8 2c       	mov	r11, r8
    2ae4:	01 c0       	rjmp	.+2      	; 0x2ae8 <vfprintf+0x2d6>
    2ae6:	b9 2c       	mov	r11, r9
    2ae8:	a4 fe       	sbrs	r10, 4
    2aea:	0f c0       	rjmp	.+30     	; 0x2b0a <vfprintf+0x2f8>
    2aec:	fe 01       	movw	r30, r28
    2aee:	e8 0d       	add	r30, r8
    2af0:	f1 1d       	adc	r31, r1
    2af2:	80 81       	ld	r24, Z
    2af4:	80 33       	cpi	r24, 0x30	; 48
    2af6:	21 f4       	brne	.+8      	; 0x2b00 <vfprintf+0x2ee>
    2af8:	9a 2d       	mov	r25, r10
    2afa:	99 7e       	andi	r25, 0xE9	; 233
    2afc:	a9 2e       	mov	r10, r25
    2afe:	09 c0       	rjmp	.+18     	; 0x2b12 <vfprintf+0x300>
    2b00:	a2 fe       	sbrs	r10, 2
    2b02:	06 c0       	rjmp	.+12     	; 0x2b10 <vfprintf+0x2fe>
    2b04:	b3 94       	inc	r11
    2b06:	b3 94       	inc	r11
    2b08:	04 c0       	rjmp	.+8      	; 0x2b12 <vfprintf+0x300>
    2b0a:	8a 2d       	mov	r24, r10
    2b0c:	86 78       	andi	r24, 0x86	; 134
    2b0e:	09 f0       	breq	.+2      	; 0x2b12 <vfprintf+0x300>
    2b10:	b3 94       	inc	r11
    2b12:	a3 fc       	sbrc	r10, 3
    2b14:	11 c0       	rjmp	.+34     	; 0x2b38 <vfprintf+0x326>
    2b16:	a0 fe       	sbrs	r10, 0
    2b18:	06 c0       	rjmp	.+12     	; 0x2b26 <vfprintf+0x314>
    2b1a:	b2 14       	cp	r11, r2
    2b1c:	88 f4       	brcc	.+34     	; 0x2b40 <vfprintf+0x32e>
    2b1e:	28 0c       	add	r2, r8
    2b20:	92 2c       	mov	r9, r2
    2b22:	9b 18       	sub	r9, r11
    2b24:	0e c0       	rjmp	.+28     	; 0x2b42 <vfprintf+0x330>
    2b26:	b2 14       	cp	r11, r2
    2b28:	60 f4       	brcc	.+24     	; 0x2b42 <vfprintf+0x330>
    2b2a:	b6 01       	movw	r22, r12
    2b2c:	80 e2       	ldi	r24, 0x20	; 32
    2b2e:	90 e0       	ldi	r25, 0x00	; 0
    2b30:	0e 94 00 16 	call	0x2c00	; 0x2c00 <fputc>
    2b34:	b3 94       	inc	r11
    2b36:	f7 cf       	rjmp	.-18     	; 0x2b26 <vfprintf+0x314>
    2b38:	b2 14       	cp	r11, r2
    2b3a:	18 f4       	brcc	.+6      	; 0x2b42 <vfprintf+0x330>
    2b3c:	2b 18       	sub	r2, r11
    2b3e:	02 c0       	rjmp	.+4      	; 0x2b44 <vfprintf+0x332>
    2b40:	98 2c       	mov	r9, r8
    2b42:	21 2c       	mov	r2, r1
    2b44:	a4 fe       	sbrs	r10, 4
    2b46:	10 c0       	rjmp	.+32     	; 0x2b68 <vfprintf+0x356>
    2b48:	b6 01       	movw	r22, r12
    2b4a:	80 e3       	ldi	r24, 0x30	; 48
    2b4c:	90 e0       	ldi	r25, 0x00	; 0
    2b4e:	0e 94 00 16 	call	0x2c00	; 0x2c00 <fputc>
    2b52:	a2 fe       	sbrs	r10, 2
    2b54:	17 c0       	rjmp	.+46     	; 0x2b84 <vfprintf+0x372>
    2b56:	a1 fc       	sbrc	r10, 1
    2b58:	03 c0       	rjmp	.+6      	; 0x2b60 <vfprintf+0x34e>
    2b5a:	88 e7       	ldi	r24, 0x78	; 120
    2b5c:	90 e0       	ldi	r25, 0x00	; 0
    2b5e:	02 c0       	rjmp	.+4      	; 0x2b64 <vfprintf+0x352>
    2b60:	88 e5       	ldi	r24, 0x58	; 88
    2b62:	90 e0       	ldi	r25, 0x00	; 0
    2b64:	b6 01       	movw	r22, r12
    2b66:	0c c0       	rjmp	.+24     	; 0x2b80 <vfprintf+0x36e>
    2b68:	8a 2d       	mov	r24, r10
    2b6a:	86 78       	andi	r24, 0x86	; 134
    2b6c:	59 f0       	breq	.+22     	; 0x2b84 <vfprintf+0x372>
    2b6e:	a1 fe       	sbrs	r10, 1
    2b70:	02 c0       	rjmp	.+4      	; 0x2b76 <vfprintf+0x364>
    2b72:	8b e2       	ldi	r24, 0x2B	; 43
    2b74:	01 c0       	rjmp	.+2      	; 0x2b78 <vfprintf+0x366>
    2b76:	80 e2       	ldi	r24, 0x20	; 32
    2b78:	a7 fc       	sbrc	r10, 7
    2b7a:	8d e2       	ldi	r24, 0x2D	; 45
    2b7c:	b6 01       	movw	r22, r12
    2b7e:	90 e0       	ldi	r25, 0x00	; 0
    2b80:	0e 94 00 16 	call	0x2c00	; 0x2c00 <fputc>
    2b84:	89 14       	cp	r8, r9
    2b86:	38 f4       	brcc	.+14     	; 0x2b96 <vfprintf+0x384>
    2b88:	b6 01       	movw	r22, r12
    2b8a:	80 e3       	ldi	r24, 0x30	; 48
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	0e 94 00 16 	call	0x2c00	; 0x2c00 <fputc>
    2b92:	9a 94       	dec	r9
    2b94:	f7 cf       	rjmp	.-18     	; 0x2b84 <vfprintf+0x372>
    2b96:	8a 94       	dec	r8
    2b98:	f3 01       	movw	r30, r6
    2b9a:	e8 0d       	add	r30, r8
    2b9c:	f1 1d       	adc	r31, r1
    2b9e:	80 81       	ld	r24, Z
    2ba0:	b6 01       	movw	r22, r12
    2ba2:	90 e0       	ldi	r25, 0x00	; 0
    2ba4:	0e 94 00 16 	call	0x2c00	; 0x2c00 <fputc>
    2ba8:	81 10       	cpse	r8, r1
    2baa:	f5 cf       	rjmp	.-22     	; 0x2b96 <vfprintf+0x384>
    2bac:	22 20       	and	r2, r2
    2bae:	09 f4       	brne	.+2      	; 0x2bb2 <vfprintf+0x3a0>
    2bb0:	42 ce       	rjmp	.-892    	; 0x2836 <vfprintf+0x24>
    2bb2:	b6 01       	movw	r22, r12
    2bb4:	80 e2       	ldi	r24, 0x20	; 32
    2bb6:	90 e0       	ldi	r25, 0x00	; 0
    2bb8:	0e 94 00 16 	call	0x2c00	; 0x2c00 <fputc>
    2bbc:	2a 94       	dec	r2
    2bbe:	f6 cf       	rjmp	.-20     	; 0x2bac <vfprintf+0x39a>
    2bc0:	f6 01       	movw	r30, r12
    2bc2:	86 81       	ldd	r24, Z+6	; 0x06
    2bc4:	97 81       	ldd	r25, Z+7	; 0x07
    2bc6:	02 c0       	rjmp	.+4      	; 0x2bcc <vfprintf+0x3ba>
    2bc8:	8f ef       	ldi	r24, 0xFF	; 255
    2bca:	9f ef       	ldi	r25, 0xFF	; 255
    2bcc:	2b 96       	adiw	r28, 0x0b	; 11
    2bce:	e2 e1       	ldi	r30, 0x12	; 18
    2bd0:	0c 94 b6 16 	jmp	0x2d6c	; 0x2d6c <__epilogue_restores__>

00002bd4 <strnlen_P>:
    2bd4:	fc 01       	movw	r30, r24
    2bd6:	05 90       	lpm	r0, Z+
    2bd8:	61 50       	subi	r22, 0x01	; 1
    2bda:	70 40       	sbci	r23, 0x00	; 0
    2bdc:	01 10       	cpse	r0, r1
    2bde:	d8 f7       	brcc	.-10     	; 0x2bd6 <strnlen_P+0x2>
    2be0:	80 95       	com	r24
    2be2:	90 95       	com	r25
    2be4:	8e 0f       	add	r24, r30
    2be6:	9f 1f       	adc	r25, r31
    2be8:	08 95       	ret

00002bea <strnlen>:
    2bea:	fc 01       	movw	r30, r24
    2bec:	61 50       	subi	r22, 0x01	; 1
    2bee:	70 40       	sbci	r23, 0x00	; 0
    2bf0:	01 90       	ld	r0, Z+
    2bf2:	01 10       	cpse	r0, r1
    2bf4:	d8 f7       	brcc	.-10     	; 0x2bec <strnlen+0x2>
    2bf6:	80 95       	com	r24
    2bf8:	90 95       	com	r25
    2bfa:	8e 0f       	add	r24, r30
    2bfc:	9f 1f       	adc	r25, r31
    2bfe:	08 95       	ret

00002c00 <fputc>:
    2c00:	0f 93       	push	r16
    2c02:	1f 93       	push	r17
    2c04:	cf 93       	push	r28
    2c06:	df 93       	push	r29
    2c08:	fb 01       	movw	r30, r22
    2c0a:	23 81       	ldd	r18, Z+3	; 0x03
    2c0c:	21 fd       	sbrc	r18, 1
    2c0e:	03 c0       	rjmp	.+6      	; 0x2c16 <fputc+0x16>
    2c10:	8f ef       	ldi	r24, 0xFF	; 255
    2c12:	9f ef       	ldi	r25, 0xFF	; 255
    2c14:	2c c0       	rjmp	.+88     	; 0x2c6e <fputc+0x6e>
    2c16:	22 ff       	sbrs	r18, 2
    2c18:	16 c0       	rjmp	.+44     	; 0x2c46 <fputc+0x46>
    2c1a:	46 81       	ldd	r20, Z+6	; 0x06
    2c1c:	57 81       	ldd	r21, Z+7	; 0x07
    2c1e:	24 81       	ldd	r18, Z+4	; 0x04
    2c20:	35 81       	ldd	r19, Z+5	; 0x05
    2c22:	42 17       	cp	r20, r18
    2c24:	53 07       	cpc	r21, r19
    2c26:	44 f4       	brge	.+16     	; 0x2c38 <fputc+0x38>
    2c28:	a0 81       	ld	r26, Z
    2c2a:	b1 81       	ldd	r27, Z+1	; 0x01
    2c2c:	9d 01       	movw	r18, r26
    2c2e:	2f 5f       	subi	r18, 0xFF	; 255
    2c30:	3f 4f       	sbci	r19, 0xFF	; 255
    2c32:	31 83       	std	Z+1, r19	; 0x01
    2c34:	20 83       	st	Z, r18
    2c36:	8c 93       	st	X, r24
    2c38:	26 81       	ldd	r18, Z+6	; 0x06
    2c3a:	37 81       	ldd	r19, Z+7	; 0x07
    2c3c:	2f 5f       	subi	r18, 0xFF	; 255
    2c3e:	3f 4f       	sbci	r19, 0xFF	; 255
    2c40:	37 83       	std	Z+7, r19	; 0x07
    2c42:	26 83       	std	Z+6, r18	; 0x06
    2c44:	14 c0       	rjmp	.+40     	; 0x2c6e <fputc+0x6e>
    2c46:	8b 01       	movw	r16, r22
    2c48:	ec 01       	movw	r28, r24
    2c4a:	fb 01       	movw	r30, r22
    2c4c:	00 84       	ldd	r0, Z+8	; 0x08
    2c4e:	f1 85       	ldd	r31, Z+9	; 0x09
    2c50:	e0 2d       	mov	r30, r0
    2c52:	09 95       	icall
    2c54:	89 2b       	or	r24, r25
    2c56:	e1 f6       	brne	.-72     	; 0x2c10 <fputc+0x10>
    2c58:	d8 01       	movw	r26, r16
    2c5a:	16 96       	adiw	r26, 0x06	; 6
    2c5c:	8d 91       	ld	r24, X+
    2c5e:	9c 91       	ld	r25, X
    2c60:	17 97       	sbiw	r26, 0x07	; 7
    2c62:	01 96       	adiw	r24, 0x01	; 1
    2c64:	17 96       	adiw	r26, 0x07	; 7
    2c66:	9c 93       	st	X, r25
    2c68:	8e 93       	st	-X, r24
    2c6a:	16 97       	sbiw	r26, 0x06	; 6
    2c6c:	ce 01       	movw	r24, r28
    2c6e:	df 91       	pop	r29
    2c70:	cf 91       	pop	r28
    2c72:	1f 91       	pop	r17
    2c74:	0f 91       	pop	r16
    2c76:	08 95       	ret

00002c78 <__ultoa_invert>:
    2c78:	fa 01       	movw	r30, r20
    2c7a:	aa 27       	eor	r26, r26
    2c7c:	28 30       	cpi	r18, 0x08	; 8
    2c7e:	51 f1       	breq	.+84     	; 0x2cd4 <__ultoa_invert+0x5c>
    2c80:	20 31       	cpi	r18, 0x10	; 16
    2c82:	81 f1       	breq	.+96     	; 0x2ce4 <__ultoa_invert+0x6c>
    2c84:	e8 94       	clt
    2c86:	6f 93       	push	r22
    2c88:	6e 7f       	andi	r22, 0xFE	; 254
    2c8a:	6e 5f       	subi	r22, 0xFE	; 254
    2c8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c8e:	8f 4f       	sbci	r24, 0xFF	; 255
    2c90:	9f 4f       	sbci	r25, 0xFF	; 255
    2c92:	af 4f       	sbci	r26, 0xFF	; 255
    2c94:	b1 e0       	ldi	r27, 0x01	; 1
    2c96:	3e d0       	rcall	.+124    	; 0x2d14 <__ultoa_invert+0x9c>
    2c98:	b4 e0       	ldi	r27, 0x04	; 4
    2c9a:	3c d0       	rcall	.+120    	; 0x2d14 <__ultoa_invert+0x9c>
    2c9c:	67 0f       	add	r22, r23
    2c9e:	78 1f       	adc	r23, r24
    2ca0:	89 1f       	adc	r24, r25
    2ca2:	9a 1f       	adc	r25, r26
    2ca4:	a1 1d       	adc	r26, r1
    2ca6:	68 0f       	add	r22, r24
    2ca8:	79 1f       	adc	r23, r25
    2caa:	8a 1f       	adc	r24, r26
    2cac:	91 1d       	adc	r25, r1
    2cae:	a1 1d       	adc	r26, r1
    2cb0:	6a 0f       	add	r22, r26
    2cb2:	71 1d       	adc	r23, r1
    2cb4:	81 1d       	adc	r24, r1
    2cb6:	91 1d       	adc	r25, r1
    2cb8:	a1 1d       	adc	r26, r1
    2cba:	20 d0       	rcall	.+64     	; 0x2cfc <__ultoa_invert+0x84>
    2cbc:	09 f4       	brne	.+2      	; 0x2cc0 <__ultoa_invert+0x48>
    2cbe:	68 94       	set
    2cc0:	3f 91       	pop	r19
    2cc2:	2a e0       	ldi	r18, 0x0A	; 10
    2cc4:	26 9f       	mul	r18, r22
    2cc6:	11 24       	eor	r1, r1
    2cc8:	30 19       	sub	r19, r0
    2cca:	30 5d       	subi	r19, 0xD0	; 208
    2ccc:	31 93       	st	Z+, r19
    2cce:	de f6       	brtc	.-74     	; 0x2c86 <__ultoa_invert+0xe>
    2cd0:	cf 01       	movw	r24, r30
    2cd2:	08 95       	ret
    2cd4:	46 2f       	mov	r20, r22
    2cd6:	47 70       	andi	r20, 0x07	; 7
    2cd8:	40 5d       	subi	r20, 0xD0	; 208
    2cda:	41 93       	st	Z+, r20
    2cdc:	b3 e0       	ldi	r27, 0x03	; 3
    2cde:	0f d0       	rcall	.+30     	; 0x2cfe <__ultoa_invert+0x86>
    2ce0:	c9 f7       	brne	.-14     	; 0x2cd4 <__ultoa_invert+0x5c>
    2ce2:	f6 cf       	rjmp	.-20     	; 0x2cd0 <__ultoa_invert+0x58>
    2ce4:	46 2f       	mov	r20, r22
    2ce6:	4f 70       	andi	r20, 0x0F	; 15
    2ce8:	40 5d       	subi	r20, 0xD0	; 208
    2cea:	4a 33       	cpi	r20, 0x3A	; 58
    2cec:	18 f0       	brcs	.+6      	; 0x2cf4 <__ultoa_invert+0x7c>
    2cee:	49 5d       	subi	r20, 0xD9	; 217
    2cf0:	31 fd       	sbrc	r19, 1
    2cf2:	40 52       	subi	r20, 0x20	; 32
    2cf4:	41 93       	st	Z+, r20
    2cf6:	02 d0       	rcall	.+4      	; 0x2cfc <__ultoa_invert+0x84>
    2cf8:	a9 f7       	brne	.-22     	; 0x2ce4 <__ultoa_invert+0x6c>
    2cfa:	ea cf       	rjmp	.-44     	; 0x2cd0 <__ultoa_invert+0x58>
    2cfc:	b4 e0       	ldi	r27, 0x04	; 4
    2cfe:	a6 95       	lsr	r26
    2d00:	97 95       	ror	r25
    2d02:	87 95       	ror	r24
    2d04:	77 95       	ror	r23
    2d06:	67 95       	ror	r22
    2d08:	ba 95       	dec	r27
    2d0a:	c9 f7       	brne	.-14     	; 0x2cfe <__ultoa_invert+0x86>
    2d0c:	00 97       	sbiw	r24, 0x00	; 0
    2d0e:	61 05       	cpc	r22, r1
    2d10:	71 05       	cpc	r23, r1
    2d12:	08 95       	ret
    2d14:	9b 01       	movw	r18, r22
    2d16:	ac 01       	movw	r20, r24
    2d18:	0a 2e       	mov	r0, r26
    2d1a:	06 94       	lsr	r0
    2d1c:	57 95       	ror	r21
    2d1e:	47 95       	ror	r20
    2d20:	37 95       	ror	r19
    2d22:	27 95       	ror	r18
    2d24:	ba 95       	dec	r27
    2d26:	c9 f7       	brne	.-14     	; 0x2d1a <__ultoa_invert+0xa2>
    2d28:	62 0f       	add	r22, r18
    2d2a:	73 1f       	adc	r23, r19
    2d2c:	84 1f       	adc	r24, r20
    2d2e:	95 1f       	adc	r25, r21
    2d30:	a0 1d       	adc	r26, r0
    2d32:	08 95       	ret

00002d34 <__prologue_saves__>:
    2d34:	2f 92       	push	r2
    2d36:	3f 92       	push	r3
    2d38:	4f 92       	push	r4
    2d3a:	5f 92       	push	r5
    2d3c:	6f 92       	push	r6
    2d3e:	7f 92       	push	r7
    2d40:	8f 92       	push	r8
    2d42:	9f 92       	push	r9
    2d44:	af 92       	push	r10
    2d46:	bf 92       	push	r11
    2d48:	cf 92       	push	r12
    2d4a:	df 92       	push	r13
    2d4c:	ef 92       	push	r14
    2d4e:	ff 92       	push	r15
    2d50:	0f 93       	push	r16
    2d52:	1f 93       	push	r17
    2d54:	cf 93       	push	r28
    2d56:	df 93       	push	r29
    2d58:	cd b7       	in	r28, 0x3d	; 61
    2d5a:	de b7       	in	r29, 0x3e	; 62
    2d5c:	ca 1b       	sub	r28, r26
    2d5e:	db 0b       	sbc	r29, r27
    2d60:	0f b6       	in	r0, 0x3f	; 63
    2d62:	f8 94       	cli
    2d64:	de bf       	out	0x3e, r29	; 62
    2d66:	0f be       	out	0x3f, r0	; 63
    2d68:	cd bf       	out	0x3d, r28	; 61
    2d6a:	09 94       	ijmp

00002d6c <__epilogue_restores__>:
    2d6c:	2a 88       	ldd	r2, Y+18	; 0x12
    2d6e:	39 88       	ldd	r3, Y+17	; 0x11
    2d70:	48 88       	ldd	r4, Y+16	; 0x10
    2d72:	5f 84       	ldd	r5, Y+15	; 0x0f
    2d74:	6e 84       	ldd	r6, Y+14	; 0x0e
    2d76:	7d 84       	ldd	r7, Y+13	; 0x0d
    2d78:	8c 84       	ldd	r8, Y+12	; 0x0c
    2d7a:	9b 84       	ldd	r9, Y+11	; 0x0b
    2d7c:	aa 84       	ldd	r10, Y+10	; 0x0a
    2d7e:	b9 84       	ldd	r11, Y+9	; 0x09
    2d80:	c8 84       	ldd	r12, Y+8	; 0x08
    2d82:	df 80       	ldd	r13, Y+7	; 0x07
    2d84:	ee 80       	ldd	r14, Y+6	; 0x06
    2d86:	fd 80       	ldd	r15, Y+5	; 0x05
    2d88:	0c 81       	ldd	r16, Y+4	; 0x04
    2d8a:	1b 81       	ldd	r17, Y+3	; 0x03
    2d8c:	aa 81       	ldd	r26, Y+2	; 0x02
    2d8e:	b9 81       	ldd	r27, Y+1	; 0x01
    2d90:	ce 0f       	add	r28, r30
    2d92:	d1 1d       	adc	r29, r1
    2d94:	0f b6       	in	r0, 0x3f	; 63
    2d96:	f8 94       	cli
    2d98:	de bf       	out	0x3e, r29	; 62
    2d9a:	0f be       	out	0x3f, r0	; 63
    2d9c:	cd bf       	out	0x3d, r28	; 61
    2d9e:	ed 01       	movw	r28, r26
    2da0:	08 95       	ret

00002da2 <_exit>:
    2da2:	f8 94       	cli

00002da4 <__stop_program>:
    2da4:	ff cf       	rjmp	.-2      	; 0x2da4 <__stop_program>
