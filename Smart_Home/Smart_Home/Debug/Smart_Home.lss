
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002d08  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000006b2  00800060  00002d08  00002d9c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000ba  00800712  00800712  0000344e  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000344e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000034ac  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000598  00000000  00000000  000034e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000666f  00000000  00000000  00003a80  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017f1  00000000  00000000  0000a0ef  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003f12  00000000  00000000  0000b8e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000dac  00000000  00000000  0000f7f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001433  00000000  00000000  000105a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000034a6  00000000  00000000  000119d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000468  00000000  00000000  00014e79  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 84 00 	jmp	0x108	; 0x108 <__ctors_end>
       4:	0c 94 ba 0e 	jmp	0x1d74	; 0x1d74 <__vector_1>
       8:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
       c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      10:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      14:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      18:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      1c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      20:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      24:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      28:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      2c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      30:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      34:	0c 94 43 0e 	jmp	0x1c86	; 0x1c86 <__vector_13>
      38:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      3c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      40:	0c 94 de 0e 	jmp	0x1dbc	; 0x1dbc <__vector_16>
      44:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      48:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      4c:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      50:	0c 94 a1 00 	jmp	0x142	; 0x142 <__bad_interrupt>
      54:	16 06       	cpc	r1, r22
      56:	2a 06       	cpc	r2, r26
      58:	2a 06       	cpc	r2, r26
      5a:	2a 06       	cpc	r2, r26
      5c:	2a 06       	cpc	r2, r26
      5e:	2a 06       	cpc	r2, r26
      60:	2a 06       	cpc	r2, r26
      62:	2a 06       	cpc	r2, r26
      64:	2c 06       	cpc	r2, r28
      66:	2a 06       	cpc	r2, r26
      68:	2a 06       	cpc	r2, r26
      6a:	2a 06       	cpc	r2, r26
      6c:	2a 06       	cpc	r2, r26
      6e:	2a 06       	cpc	r2, r26
      70:	2a 06       	cpc	r2, r26
      72:	2a 06       	cpc	r2, r26
      74:	18 06       	cpc	r1, r24
      76:	2a 06       	cpc	r2, r26
      78:	2a 06       	cpc	r2, r26
      7a:	2a 06       	cpc	r2, r26
      7c:	2a 06       	cpc	r2, r26
      7e:	2a 06       	cpc	r2, r26
      80:	2a 06       	cpc	r2, r26
      82:	2a 06       	cpc	r2, r26
      84:	1a 06       	cpc	r1, r26
      86:	2a 06       	cpc	r2, r26
      88:	2a 06       	cpc	r2, r26
      8a:	2a 06       	cpc	r2, r26
      8c:	2a 06       	cpc	r2, r26
      8e:	2a 06       	cpc	r2, r26
      90:	2a 06       	cpc	r2, r26
      92:	2a 06       	cpc	r2, r26
      94:	1c 06       	cpc	r1, r28
      96:	2a 06       	cpc	r2, r26
      98:	2a 06       	cpc	r2, r26
      9a:	2a 06       	cpc	r2, r26
      9c:	2a 06       	cpc	r2, r26
      9e:	2a 06       	cpc	r2, r26
      a0:	2a 06       	cpc	r2, r26
      a2:	2a 06       	cpc	r2, r26
      a4:	1e 06       	cpc	r1, r30
      a6:	2a 06       	cpc	r2, r26
      a8:	2a 06       	cpc	r2, r26
      aa:	2a 06       	cpc	r2, r26
      ac:	2a 06       	cpc	r2, r26
      ae:	2a 06       	cpc	r2, r26
      b0:	2a 06       	cpc	r2, r26
      b2:	2a 06       	cpc	r2, r26
      b4:	20 06       	cpc	r2, r16
      b6:	2a 06       	cpc	r2, r26
      b8:	2a 06       	cpc	r2, r26
      ba:	2a 06       	cpc	r2, r26
      bc:	2a 06       	cpc	r2, r26
      be:	2a 06       	cpc	r2, r26
      c0:	2a 06       	cpc	r2, r26
      c2:	2a 06       	cpc	r2, r26
      c4:	22 06       	cpc	r2, r18
      c6:	2a 06       	cpc	r2, r26
      c8:	2a 06       	cpc	r2, r26
      ca:	2a 06       	cpc	r2, r26
      cc:	2a 06       	cpc	r2, r26
      ce:	2a 06       	cpc	r2, r26
      d0:	2a 06       	cpc	r2, r26
      d2:	2a 06       	cpc	r2, r26
      d4:	24 06       	cpc	r2, r20
      d6:	2a 06       	cpc	r2, r26
      d8:	2a 06       	cpc	r2, r26
      da:	2a 06       	cpc	r2, r26
      dc:	2a 06       	cpc	r2, r26
      de:	2a 06       	cpc	r2, r26
      e0:	2a 06       	cpc	r2, r26
      e2:	2a 06       	cpc	r2, r26
      e4:	26 06       	cpc	r2, r22
      e6:	2a 06       	cpc	r2, r26
      e8:	2a 06       	cpc	r2, r26
      ea:	2a 06       	cpc	r2, r26
      ec:	2a 06       	cpc	r2, r26
      ee:	2a 06       	cpc	r2, r26
      f0:	2a 06       	cpc	r2, r26
      f2:	2a 06       	cpc	r2, r26
      f4:	28 06       	cpc	r2, r24
      f6:	e6 07       	cpc	r30, r22
      f8:	ed 07       	cpc	r30, r29
      fa:	f4 07       	cpc	r31, r20
      fc:	fb 07       	cpc	r31, r27
      fe:	02 08       	sbc	r0, r2
     100:	09 08       	sbc	r0, r9
     102:	10 08       	sbc	r1, r0
     104:	17 08       	sbc	r1, r7
     106:	1e 08       	sbc	r1, r14

00000108 <__ctors_end>:
     108:	11 24       	eor	r1, r1
     10a:	1f be       	out	0x3f, r1	; 63
     10c:	cf e5       	ldi	r28, 0x5F	; 95
     10e:	d8 e0       	ldi	r29, 0x08	; 8
     110:	de bf       	out	0x3e, r29	; 62
     112:	cd bf       	out	0x3d, r28	; 61

00000114 <__do_copy_data>:
     114:	17 e0       	ldi	r17, 0x07	; 7
     116:	a0 e6       	ldi	r26, 0x60	; 96
     118:	b0 e0       	ldi	r27, 0x00	; 0
     11a:	e8 e0       	ldi	r30, 0x08	; 8
     11c:	fd e2       	ldi	r31, 0x2D	; 45
     11e:	02 c0       	rjmp	.+4      	; 0x124 <__do_copy_data+0x10>
     120:	05 90       	lpm	r0, Z+
     122:	0d 92       	st	X+, r0
     124:	a2 31       	cpi	r26, 0x12	; 18
     126:	b1 07       	cpc	r27, r17
     128:	d9 f7       	brne	.-10     	; 0x120 <__do_copy_data+0xc>

0000012a <__do_clear_bss>:
     12a:	27 e0       	ldi	r18, 0x07	; 7
     12c:	a2 e1       	ldi	r26, 0x12	; 18
     12e:	b7 e0       	ldi	r27, 0x07	; 7
     130:	01 c0       	rjmp	.+2      	; 0x134 <.do_clear_bss_start>

00000132 <.do_clear_bss_loop>:
     132:	1d 92       	st	X+, r1

00000134 <.do_clear_bss_start>:
     134:	ac 3c       	cpi	r26, 0xCC	; 204
     136:	b2 07       	cpc	r27, r18
     138:	e1 f7       	brne	.-8      	; 0x132 <.do_clear_bss_loop>
     13a:	0e 94 0f 04 	call	0x81e	; 0x81e <main>
     13e:	0c 94 82 16 	jmp	0x2d04	; 0x2d04 <_exit>

00000142 <__bad_interrupt>:
     142:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000146 <Buzzer_on>:
  // Return error code to indicate that the buzzer initialization failed
  return BUZZER_ERROR_INIT;
  }

// Turn on the buzzer
EN_BuzzerError_t Buzzer_on(u8 buzzerPort, u8 buzzerPin) {
     146:	98 2f       	mov	r25, r24
     148:	86 2f       	mov	r24, r22
  if (DIO_write(buzzerPin, buzzerPort, HIGH) == DIO_OK) {
     14a:	41 e0       	ldi	r20, 0x01	; 1
     14c:	69 2f       	mov	r22, r25
     14e:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
     152:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that attempting to turn on the buzzer has failed
  return BUZZER_ERROR_ON;
     154:	82 e0       	ldi	r24, 0x02	; 2
  }
     156:	08 95       	ret

00000158 <EEPROM_init>:
 */

#include "eeprom.h"

void EEPROM_init() {
  I2C_init();
     158:	0e 94 2e 06 	call	0xc5c	; 0xc5c <I2C_init>
     15c:	08 95       	ret

0000015e <EEPROM_read_byte>:
  }

void EEPROM_read_byte(u8 page, u8 address, s8* data) {
     15e:	0f 93       	push	r16
     160:	1f 93       	push	r17
     162:	cf 93       	push	r28
     164:	df 93       	push	r29
     166:	c8 2f       	mov	r28, r24
     168:	d6 2f       	mov	r29, r22
     16a:	8a 01       	movw	r16, r20
  I2C_start();
     16c:	0e 94 32 06 	call	0xc64	; 0xc64 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     170:	cc 0f       	add	r28, r28
     172:	80 ea       	ldi	r24, 0xA0	; 160
     174:	8c 0f       	add	r24, r28
     176:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  I2C_write(address);
     17a:	8d 2f       	mov	r24, r29
     17c:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  I2C_start();
     180:	0e 94 32 06 	call	0xc64	; 0xc64 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     184:	81 ea       	ldi	r24, 0xA1	; 161
     186:	8c 0f       	add	r24, r28
     188:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  // read_Ack will halt the reading here, because it will send the next byte, which will not be received and wait for ack, which will not be sent. 
  // Nack must be sent after the arrival of the last requested byte. It's used basically to indicate that no further data transmission is required and then the stop condition is sent
  I2C_read_Nack(data);
     18c:	c8 01       	movw	r24, r16
     18e:	0e 94 4e 06 	call	0xc9c	; 0xc9c <I2C_read_Nack>
  I2C_stop();
     192:	0e 94 59 06 	call	0xcb2	; 0xcb2 <I2C_stop>
  }
     196:	df 91       	pop	r29
     198:	cf 91       	pop	r28
     19a:	1f 91       	pop	r17
     19c:	0f 91       	pop	r16
     19e:	08 95       	ret

000001a0 <EEPROM_read_block>:

void EEPROM_read_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     1a0:	ef 92       	push	r14
     1a2:	ff 92       	push	r15
     1a4:	0f 93       	push	r16
     1a6:	1f 93       	push	r17
     1a8:	cf 93       	push	r28
     1aa:	df 93       	push	r29
     1ac:	c8 2f       	mov	r28, r24
     1ae:	d6 2f       	mov	r29, r22
     1b0:	7a 01       	movw	r14, r20
     1b2:	89 01       	movw	r16, r18
  u16 i;
  for (i = 0;i < bytes_number;i++) {
    EEPROM_read_byte(page, address + i, &data[i]);
    }
#elif READ_BLOCK_METHOD == MULTIBYTE
  I2C_start();
     1b4:	0e 94 32 06 	call	0xc64	; 0xc64 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     1b8:	cc 0f       	add	r28, r28
     1ba:	80 ea       	ldi	r24, 0xA0	; 160
     1bc:	8c 0f       	add	r24, r28
     1be:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  I2C_write(address);
     1c2:	8d 2f       	mov	r24, r29
     1c4:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  I2C_start();
     1c8:	0e 94 32 06 	call	0xc64	; 0xc64 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     1cc:	81 ea       	ldi	r24, 0xA1	; 161
     1ce:	8c 0f       	add	r24, r28
     1d0:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1d4:	c0 e0       	ldi	r28, 0x00	; 0
     1d6:	d0 e0       	ldi	r29, 0x00	; 0
     1d8:	06 c0       	rjmp	.+12     	; 0x1e6 <EEPROM_read_block+0x46>
    I2C_read_Ack(&data[i]);
     1da:	c8 01       	movw	r24, r16
     1dc:	8c 0f       	add	r24, r28
     1de:	9d 1f       	adc	r25, r29
     1e0:	0e 94 43 06 	call	0xc86	; 0xc86 <I2C_read_Ack>
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  I2C_start();
  I2C_write(0xA0 + (page << 1) + 1);
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1e4:	21 96       	adiw	r28, 0x01	; 1
     1e6:	c7 01       	movw	r24, r14
     1e8:	01 97       	sbiw	r24, 0x01	; 1
     1ea:	c8 17       	cp	r28, r24
     1ec:	d9 07       	cpc	r29, r25
     1ee:	a8 f3       	brcs	.-22     	; 0x1da <EEPROM_read_block+0x3a>
    I2C_read_Ack(&data[i]);
    }
  I2C_read_Nack(&data[i]);
     1f0:	c8 01       	movw	r24, r16
     1f2:	8c 0f       	add	r24, r28
     1f4:	9d 1f       	adc	r25, r29
     1f6:	0e 94 4e 06 	call	0xc9c	; 0xc9c <I2C_read_Nack>
  I2C_stop();
     1fa:	0e 94 59 06 	call	0xcb2	; 0xcb2 <I2C_stop>
#endif
  }
     1fe:	df 91       	pop	r29
     200:	cf 91       	pop	r28
     202:	1f 91       	pop	r17
     204:	0f 91       	pop	r16
     206:	ff 90       	pop	r15
     208:	ef 90       	pop	r14
     20a:	08 95       	ret

0000020c <EEPROM_write_byte>:

void EEPROM_write_byte(u8 page, u8 address, s8 data) {
     20c:	1f 93       	push	r17
     20e:	cf 93       	push	r28
     210:	df 93       	push	r29
     212:	c8 2f       	mov	r28, r24
     214:	16 2f       	mov	r17, r22
     216:	d4 2f       	mov	r29, r20
  I2C_start();
     218:	0e 94 32 06 	call	0xc64	; 0xc64 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     21c:	8c 2f       	mov	r24, r28
     21e:	88 0f       	add	r24, r24
     220:	80 56       	subi	r24, 0x60	; 96
     222:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  I2C_write(address);
     226:	81 2f       	mov	r24, r17
     228:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  I2C_write(data);
     22c:	8d 2f       	mov	r24, r29
     22e:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  I2C_stop();
     232:	0e 94 59 06 	call	0xcb2	; 0xcb2 <I2C_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     236:	8f e3       	ldi	r24, 0x3F	; 63
     238:	9c e9       	ldi	r25, 0x9C	; 156
     23a:	01 97       	sbiw	r24, 0x01	; 1
     23c:	f1 f7       	brne	.-4      	; 0x23a <EEPROM_write_byte+0x2e>
     23e:	00 c0       	rjmp	.+0      	; 0x240 <EEPROM_write_byte+0x34>
     240:	00 00       	nop

#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
  }
     242:	df 91       	pop	r29
     244:	cf 91       	pop	r28
     246:	1f 91       	pop	r17
     248:	08 95       	ret

0000024a <EEPROM_write_block>:

// bytes_number must be within page size (256 bytes)
void EEPROM_write_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     24a:	6f 92       	push	r6
     24c:	7f 92       	push	r7
     24e:	8f 92       	push	r8
     250:	9f 92       	push	r9
     252:	af 92       	push	r10
     254:	bf 92       	push	r11
     256:	cf 92       	push	r12
     258:	df 92       	push	r13
     25a:	ef 92       	push	r14
     25c:	ff 92       	push	r15
     25e:	0f 93       	push	r16
     260:	1f 93       	push	r17
     262:	cf 93       	push	r28
     264:	df 93       	push	r29
     266:	78 2e       	mov	r7, r24
     268:	66 2e       	mov	r6, r22
     26a:	6a 01       	movw	r12, r20
     26c:	89 01       	movw	r16, r18
  //! If data is required to be written in the first 16 bytes starting from byte 10 for example, the data will be stored starting from bytes 10, 
  //! and if the data exceeds the row limit ** IT WILL ROLL OVER AND OVERWRITE THE ROW **. Therefore, in a single multibyte write cycle, we can't write more than 16 bytes at maximum if starting from the first byte in the row
  //! or the remaining bytes till the end of the row from the starting position. The remaining bytes must be written in another write cycle to avoind the roll over problem.

  u16 dataIndex, blockNumber, i;
  u16 first_block_size = 16 - (address % 16);
     26e:	86 2f       	mov	r24, r22
     270:	8f 70       	andi	r24, 0x0F	; 15
     272:	20 e1       	ldi	r18, 0x10	; 16
     274:	30 e0       	ldi	r19, 0x00	; 0
     276:	79 01       	movw	r14, r18
     278:	e8 1a       	sub	r14, r24
     27a:	f1 08       	sbc	r15, r1
  if (16 - (address % 16) > bytes_number) first_block_size = bytes_number;
     27c:	4e 15       	cp	r20, r14
     27e:	5f 05       	cpc	r21, r15
     280:	08 f4       	brcc	.+2      	; 0x284 <EEPROM_write_block+0x3a>
     282:	7a 01       	movw	r14, r20

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
     284:	0e 94 32 06 	call	0xc64	; 0xc64 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     288:	87 2d       	mov	r24, r7
     28a:	88 0f       	add	r24, r24
     28c:	0f 2e       	mov	r0, r31
     28e:	f0 ea       	ldi	r31, 0xA0	; 160
     290:	7f 2e       	mov	r7, r31
     292:	f0 2d       	mov	r31, r0
     294:	78 0e       	add	r7, r24
     296:	87 2d       	mov	r24, r7
     298:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  I2C_write(address);
     29c:	86 2d       	mov	r24, r6
     29e:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2a2:	c0 e0       	ldi	r28, 0x00	; 0
     2a4:	d0 e0       	ldi	r29, 0x00	; 0
     2a6:	07 c0       	rjmp	.+14     	; 0x2b6 <EEPROM_write_block+0x6c>
    I2C_write(data[dataIndex]);
     2a8:	f8 01       	movw	r30, r16
     2aa:	ec 0f       	add	r30, r28
     2ac:	fd 1f       	adc	r31, r29
     2ae:	80 81       	ld	r24, Z
     2b0:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2b4:	21 96       	adiw	r28, 0x01	; 1
     2b6:	ce 15       	cp	r28, r14
     2b8:	df 05       	cpc	r29, r15
     2ba:	b0 f3       	brcs	.-20     	; 0x2a8 <EEPROM_write_block+0x5e>
    I2C_write(data[dataIndex]);
    }
  I2C_stop();
     2bc:	0e 94 59 06 	call	0xcb2	; 0xcb2 <I2C_stop>
     2c0:	8f e3       	ldi	r24, 0x3F	; 63
     2c2:	9c e9       	ldi	r25, 0x9C	; 156
     2c4:	01 97       	sbiw	r24, 0x01	; 1
     2c6:	f1 f7       	brne	.-4      	; 0x2c4 <EEPROM_write_block+0x7a>
     2c8:	00 c0       	rjmp	.+0      	; 0x2ca <EEPROM_write_block+0x80>
     2ca:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif

  // Return if the data fits in the row (data fits in a single row or the remaining part of it after the address)
  if (first_block_size == bytes_number) return;
     2cc:	ec 14       	cp	r14, r12
     2ce:	fd 04       	cpc	r15, r13
     2d0:	09 f4       	brne	.+2      	; 0x2d4 <EEPROM_write_block+0x8a>
     2d2:	61 c0       	rjmp	.+194    	; 0x396 <EEPROM_write_block+0x14c>

  u16 last_block_size = (address + bytes_number) % 16;
     2d4:	56 01       	movw	r10, r12
     2d6:	a6 0c       	add	r10, r6
     2d8:	b1 1c       	adc	r11, r1
     2da:	9f e0       	ldi	r25, 0x0F	; 15
     2dc:	a9 22       	and	r10, r25
     2de:	bb 24       	eor	r11, r11
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
     2e0:	ce 18       	sub	r12, r14
     2e2:	df 08       	sbc	r13, r15
     2e4:	ca 18       	sub	r12, r10
     2e6:	db 08       	sbc	r13, r11
     2e8:	d6 94       	lsr	r13
     2ea:	c7 94       	ror	r12
     2ec:	d6 94       	lsr	r13
     2ee:	c7 94       	ror	r12
     2f0:	d6 94       	lsr	r13
     2f2:	c7 94       	ror	r12
     2f4:	d6 94       	lsr	r13
     2f6:	c7 94       	ror	r12
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     2f8:	e1 2c       	mov	r14, r1
     2fa:	f1 2c       	mov	r15, r1
     2fc:	27 c0       	rjmp	.+78     	; 0x34c <EEPROM_write_block+0x102>
    I2C_start();
     2fe:	0e 94 32 06 	call	0xc64	; 0xc64 <I2C_start>
    I2C_write(0xA0 + (page << 1));
     302:	87 2d       	mov	r24, r7
     304:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
    I2C_write(address + dataIndex);
     308:	8c 2f       	mov	r24, r28
     30a:	86 0d       	add	r24, r6
     30c:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
    for (i = 0;i < 16;i++) {
     310:	81 2c       	mov	r8, r1
     312:	91 2c       	mov	r9, r1
     314:	0b c0       	rjmp	.+22     	; 0x32c <EEPROM_write_block+0xe2>
      I2C_write(data[dataIndex + i]);
     316:	fe 01       	movw	r30, r28
     318:	e8 0d       	add	r30, r8
     31a:	f9 1d       	adc	r31, r9
     31c:	e0 0f       	add	r30, r16
     31e:	f1 1f       	adc	r31, r17
     320:	80 81       	ld	r24, Z
     322:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
    I2C_start();
    I2C_write(0xA0 + (page << 1));
    I2C_write(address + dataIndex);
    for (i = 0;i < 16;i++) {
     326:	8f ef       	ldi	r24, 0xFF	; 255
     328:	88 1a       	sub	r8, r24
     32a:	98 0a       	sbc	r9, r24
     32c:	90 e1       	ldi	r25, 0x10	; 16
     32e:	89 16       	cp	r8, r25
     330:	91 04       	cpc	r9, r1
     332:	88 f3       	brcs	.-30     	; 0x316 <EEPROM_write_block+0xcc>
      I2C_write(data[dataIndex + i]);
      }
    dataIndex += 16;
     334:	60 96       	adiw	r28, 0x10	; 16
    I2C_stop();
     336:	0e 94 59 06 	call	0xcb2	; 0xcb2 <I2C_stop>
     33a:	8f e3       	ldi	r24, 0x3F	; 63
     33c:	9c e9       	ldi	r25, 0x9C	; 156
     33e:	01 97       	sbiw	r24, 0x01	; 1
     340:	f1 f7       	brne	.-4      	; 0x33e <EEPROM_write_block+0xf4>
     342:	00 c0       	rjmp	.+0      	; 0x344 <EEPROM_write_block+0xfa>
     344:	00 00       	nop
  if (first_block_size == bytes_number) return;

  u16 last_block_size = (address + bytes_number) % 16;
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     346:	9f ef       	ldi	r25, 0xFF	; 255
     348:	e9 1a       	sub	r14, r25
     34a:	f9 0a       	sbc	r15, r25
     34c:	ec 14       	cp	r14, r12
     34e:	fd 04       	cpc	r15, r13
     350:	b0 f2       	brcs	.-84     	; 0x2fe <EEPROM_write_block+0xb4>
    _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
    }

  // Write the last part of the data
  I2C_start();
     352:	0e 94 32 06 	call	0xc64	; 0xc64 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     356:	87 2d       	mov	r24, r7
     358:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  I2C_write(address + dataIndex);
     35c:	8c 2f       	mov	r24, r28
     35e:	86 0d       	add	r24, r6
     360:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>
  for (i = 0;i < last_block_size;i++) {
     364:	e1 2c       	mov	r14, r1
     366:	f1 2c       	mov	r15, r1
     368:	0b c0       	rjmp	.+22     	; 0x380 <EEPROM_write_block+0x136>
    I2C_write(data[dataIndex + i]);
     36a:	fe 01       	movw	r30, r28
     36c:	ee 0d       	add	r30, r14
     36e:	ff 1d       	adc	r31, r15
     370:	e0 0f       	add	r30, r16
     372:	f1 1f       	adc	r31, r17
     374:	80 81       	ld	r24, Z
     376:	0e 94 3a 06 	call	0xc74	; 0xc74 <I2C_write>

  // Write the last part of the data
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address + dataIndex);
  for (i = 0;i < last_block_size;i++) {
     37a:	8f ef       	ldi	r24, 0xFF	; 255
     37c:	e8 1a       	sub	r14, r24
     37e:	f8 0a       	sbc	r15, r24
     380:	ea 14       	cp	r14, r10
     382:	fb 04       	cpc	r15, r11
     384:	90 f3       	brcs	.-28     	; 0x36a <EEPROM_write_block+0x120>
    I2C_write(data[dataIndex + i]);
    }
  I2C_stop();
     386:	0e 94 59 06 	call	0xcb2	; 0xcb2 <I2C_stop>
     38a:	8f e3       	ldi	r24, 0x3F	; 63
     38c:	9c e9       	ldi	r25, 0x9C	; 156
     38e:	01 97       	sbiw	r24, 0x01	; 1
     390:	f1 f7       	brne	.-4      	; 0x38e <EEPROM_write_block+0x144>
     392:	00 c0       	rjmp	.+0      	; 0x394 <EEPROM_write_block+0x14a>
     394:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
#endif
     396:	df 91       	pop	r29
     398:	cf 91       	pop	r28
     39a:	1f 91       	pop	r17
     39c:	0f 91       	pop	r16
     39e:	ff 90       	pop	r15
     3a0:	ef 90       	pop	r14
     3a2:	df 90       	pop	r13
     3a4:	cf 90       	pop	r12
     3a6:	bf 90       	pop	r11
     3a8:	af 90       	pop	r10
     3aa:	9f 90       	pop	r9
     3ac:	8f 90       	pop	r8
     3ae:	7f 90       	pop	r7
     3b0:	6f 90       	pop	r6
     3b2:	08 95       	ret

000003b4 <BT_sendChar>:
  DIO_init(HC_05_STATUS_PIN, HC_05_STATUS_PORT, IN);
  UART_init(baudRate);
  }

void BT_sendChar(s8 data) {
  UART_sendChar(data);
     3b4:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <UART_sendChar>
     3b8:	08 95       	ret

000003ba <BT_sendString>:
  }

void BT_sendString(s8* str) {
  UART_sendString(str);
     3ba:	0e 94 00 07 	call	0xe00	; 0xe00 <UART_sendString>
     3be:	08 95       	ret

000003c0 <Keypad_init>:

#include "keypad.h"

EN_KeypadStatusCode_t Keypad_init(void) {
  // Set rows as outputs
  DIO_init(KEYPAD_R0_PIN, KEYPAD_PORT, OUT);
     3c0:	41 e0       	ldi	r20, 0x01	; 1
     3c2:	62 e4       	ldi	r22, 0x42	; 66
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  DIO_init(KEYPAD_R1_PIN, KEYPAD_PORT, OUT);
     3ca:	41 e0       	ldi	r20, 0x01	; 1
     3cc:	62 e4       	ldi	r22, 0x42	; 66
     3ce:	81 e0       	ldi	r24, 0x01	; 1
     3d0:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  DIO_init(KEYPAD_R2_PIN, KEYPAD_PORT, OUT);
     3d4:	41 e0       	ldi	r20, 0x01	; 1
     3d6:	62 e4       	ldi	r22, 0x42	; 66
     3d8:	82 e0       	ldi	r24, 0x02	; 2
     3da:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  DIO_init(KEYPAD_R3_PIN, KEYPAD_PORT, OUT);
     3de:	41 e0       	ldi	r20, 0x01	; 1
     3e0:	62 e4       	ldi	r22, 0x42	; 66
     3e2:	83 e0       	ldi	r24, 0x03	; 3
     3e4:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  // Set all high
  DIO_write(KEYPAD_R0_PIN, KEYPAD_PORT, HIGH);
     3e8:	41 e0       	ldi	r20, 0x01	; 1
     3ea:	62 e4       	ldi	r22, 0x42	; 66
     3ec:	80 e0       	ldi	r24, 0x00	; 0
     3ee:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  DIO_write(KEYPAD_R1_PIN, KEYPAD_PORT, HIGH);
     3f2:	41 e0       	ldi	r20, 0x01	; 1
     3f4:	62 e4       	ldi	r22, 0x42	; 66
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  DIO_write(KEYPAD_R2_PIN, KEYPAD_PORT, HIGH);
     3fc:	41 e0       	ldi	r20, 0x01	; 1
     3fe:	62 e4       	ldi	r22, 0x42	; 66
     400:	82 e0       	ldi	r24, 0x02	; 2
     402:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  DIO_write(KEYPAD_R3_PIN, KEYPAD_PORT, HIGH);
     406:	41 e0       	ldi	r20, 0x01	; 1
     408:	62 e4       	ldi	r22, 0x42	; 66
     40a:	83 e0       	ldi	r24, 0x03	; 3
     40c:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  // Set columns as inputs
  DIO_init(KEYPAD_C0_PIN, KEYPAD_PORT, IN);
     410:	40 e0       	ldi	r20, 0x00	; 0
     412:	62 e4       	ldi	r22, 0x42	; 66
     414:	84 e0       	ldi	r24, 0x04	; 4
     416:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  DIO_init(KEYPAD_C1_PIN, KEYPAD_PORT, IN);
     41a:	40 e0       	ldi	r20, 0x00	; 0
     41c:	62 e4       	ldi	r22, 0x42	; 66
     41e:	85 e0       	ldi	r24, 0x05	; 5
     420:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  DIO_init(KEYPAD_C2_PIN, KEYPAD_PORT, IN);
     424:	40 e0       	ldi	r20, 0x00	; 0
     426:	62 e4       	ldi	r22, 0x42	; 66
     428:	86 e0       	ldi	r24, 0x06	; 6
     42a:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  DIO_init(KEYPAD_C3_PIN, KEYPAD_PORT, IN);
     42e:	40 e0       	ldi	r20, 0x00	; 0
     430:	62 e4       	ldi	r22, 0x42	; 66
     432:	87 e0       	ldi	r24, 0x07	; 7
     434:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  // Activate the pull up resistors
  DIO_write(KEYPAD_C0_PIN, KEYPAD_PORT, HIGH);
     438:	41 e0       	ldi	r20, 0x01	; 1
     43a:	62 e4       	ldi	r22, 0x42	; 66
     43c:	84 e0       	ldi	r24, 0x04	; 4
     43e:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  DIO_write(KEYPAD_C1_PIN, KEYPAD_PORT, HIGH);
     442:	41 e0       	ldi	r20, 0x01	; 1
     444:	62 e4       	ldi	r22, 0x42	; 66
     446:	85 e0       	ldi	r24, 0x05	; 5
     448:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  DIO_write(KEYPAD_C2_PIN, KEYPAD_PORT, HIGH);
     44c:	41 e0       	ldi	r20, 0x01	; 1
     44e:	62 e4       	ldi	r22, 0x42	; 66
     450:	86 e0       	ldi	r24, 0x06	; 6
     452:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  DIO_write(KEYPAD_C3_PIN, KEYPAD_PORT, HIGH);
     456:	41 e0       	ldi	r20, 0x01	; 1
     458:	62 e4       	ldi	r22, 0x42	; 66
     45a:	87 e0       	ldi	r24, 0x07	; 7
     45c:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>

  return KEYPAD_INIT_OK;
  }
     460:	80 e0       	ldi	r24, 0x00	; 0
     462:	08 95       	ret

00000464 <toggle_row>:

void toggle_row(u8 row) {
  switch (row) {
     464:	81 30       	cpi	r24, 0x01	; 1
     466:	59 f0       	breq	.+22     	; 0x47e <toggle_row+0x1a>
     468:	28 f0       	brcs	.+10     	; 0x474 <toggle_row+0x10>
     46a:	82 30       	cpi	r24, 0x02	; 2
     46c:	69 f0       	breq	.+26     	; 0x488 <toggle_row+0x24>
     46e:	83 30       	cpi	r24, 0x03	; 3
     470:	81 f0       	breq	.+32     	; 0x492 <toggle_row+0x2e>
     472:	08 95       	ret
      case 0:
        DIO_toggle(KEYPAD_R0_PIN, KEYPAD_PORT);
     474:	62 e4       	ldi	r22, 0x42	; 66
     476:	80 e0       	ldi	r24, 0x00	; 0
     478:	0e 94 b7 05 	call	0xb6e	; 0xb6e <DIO_toggle>
        break;
     47c:	08 95       	ret
      case 1:
        DIO_toggle(KEYPAD_R1_PIN, KEYPAD_PORT);
     47e:	62 e4       	ldi	r22, 0x42	; 66
     480:	81 e0       	ldi	r24, 0x01	; 1
     482:	0e 94 b7 05 	call	0xb6e	; 0xb6e <DIO_toggle>
        break;
     486:	08 95       	ret
      case 2:
        DIO_toggle(KEYPAD_R2_PIN, KEYPAD_PORT);
     488:	62 e4       	ldi	r22, 0x42	; 66
     48a:	82 e0       	ldi	r24, 0x02	; 2
     48c:	0e 94 b7 05 	call	0xb6e	; 0xb6e <DIO_toggle>
        break;
     490:	08 95       	ret
      case 3:
        DIO_toggle(KEYPAD_R3_PIN, KEYPAD_PORT);
     492:	62 e4       	ldi	r22, 0x42	; 66
     494:	83 e0       	ldi	r24, 0x03	; 3
     496:	0e 94 b7 05 	call	0xb6e	; 0xb6e <DIO_toggle>
     49a:	08 95       	ret

0000049c <check_col>:
        break;
    }
  }

void check_col(u8 col, u8* res) {
  switch (col) {
     49c:	81 30       	cpi	r24, 0x01	; 1
     49e:	61 f0       	breq	.+24     	; 0x4b8 <check_col+0x1c>
     4a0:	28 f0       	brcs	.+10     	; 0x4ac <check_col+0x10>
     4a2:	82 30       	cpi	r24, 0x02	; 2
     4a4:	79 f0       	breq	.+30     	; 0x4c4 <check_col+0x28>
     4a6:	83 30       	cpi	r24, 0x03	; 3
     4a8:	99 f0       	breq	.+38     	; 0x4d0 <check_col+0x34>
     4aa:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_C0_PIN, KEYPAD_PORT, res);
     4ac:	ab 01       	movw	r20, r22
     4ae:	62 e4       	ldi	r22, 0x42	; 66
     4b0:	84 e0       	ldi	r24, 0x04	; 4
     4b2:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_Read>
        break;
     4b6:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_C1_PIN, KEYPAD_PORT, res);
     4b8:	ab 01       	movw	r20, r22
     4ba:	62 e4       	ldi	r22, 0x42	; 66
     4bc:	85 e0       	ldi	r24, 0x05	; 5
     4be:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_Read>
        break;
     4c2:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_C2_PIN, KEYPAD_PORT, res);
     4c4:	ab 01       	movw	r20, r22
     4c6:	62 e4       	ldi	r22, 0x42	; 66
     4c8:	86 e0       	ldi	r24, 0x06	; 6
     4ca:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_Read>
        break;
     4ce:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_C3_PIN, KEYPAD_PORT, res);
     4d0:	ab 01       	movw	r20, r22
     4d2:	62 e4       	ldi	r22, 0x42	; 66
     4d4:	87 e0       	ldi	r24, 0x07	; 7
     4d6:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_Read>
     4da:	08 95       	ret

000004dc <check_row>:
        break;
    }
  }

void check_row(u8 row, u8* res) {
  switch (row) {
     4dc:	81 30       	cpi	r24, 0x01	; 1
     4de:	61 f0       	breq	.+24     	; 0x4f8 <check_row+0x1c>
     4e0:	28 f0       	brcs	.+10     	; 0x4ec <check_row+0x10>
     4e2:	82 30       	cpi	r24, 0x02	; 2
     4e4:	79 f0       	breq	.+30     	; 0x504 <check_row+0x28>
     4e6:	83 30       	cpi	r24, 0x03	; 3
     4e8:	99 f0       	breq	.+38     	; 0x510 <check_row+0x34>
     4ea:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_R0_PIN, KEYPAD_PORT, res);
     4ec:	ab 01       	movw	r20, r22
     4ee:	62 e4       	ldi	r22, 0x42	; 66
     4f0:	80 e0       	ldi	r24, 0x00	; 0
     4f2:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_Read>
        break;
     4f6:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_R1_PIN, KEYPAD_PORT, res);
     4f8:	ab 01       	movw	r20, r22
     4fa:	62 e4       	ldi	r22, 0x42	; 66
     4fc:	81 e0       	ldi	r24, 0x01	; 1
     4fe:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_Read>
        break;
     502:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_R2_PIN, KEYPAD_PORT, res);
     504:	ab 01       	movw	r20, r22
     506:	62 e4       	ldi	r22, 0x42	; 66
     508:	82 e0       	ldi	r24, 0x02	; 2
     50a:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_Read>
        break;
     50e:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_R3_PIN, KEYPAD_PORT, res);
     510:	ab 01       	movw	r20, r22
     512:	62 e4       	ldi	r22, 0x42	; 66
     514:	83 e0       	ldi	r24, 0x03	; 3
     516:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_Read>
     51a:	08 95       	ret

0000051c <Keypad_getPressedKey>:
        break;
    }
  }

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
     51c:	ef 92       	push	r14
     51e:	ff 92       	push	r15
     520:	0f 93       	push	r16
     522:	1f 93       	push	r17
     524:	cf 93       	push	r28
     526:	df 93       	push	r29
     528:	cd b7       	in	r28, 0x3d	; 61
     52a:	de b7       	in	r29, 0x3e	; 62
     52c:	62 97       	sbiw	r28, 0x12	; 18
     52e:	0f b6       	in	r0, 0x3f	; 63
     530:	f8 94       	cli
     532:	de bf       	out	0x3e, r29	; 62
     534:	0f be       	out	0x3f, r0	; 63
     536:	cd bf       	out	0x3d, r28	; 61
     538:	7c 01       	movw	r14, r24
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
     53a:	80 e1       	ldi	r24, 0x10	; 16
     53c:	e1 e6       	ldi	r30, 0x61	; 97
     53e:	f0 e0       	ldi	r31, 0x00	; 0
     540:	de 01       	movw	r26, r28
     542:	11 96       	adiw	r26, 0x01	; 1
     544:	01 90       	ld	r0, Z+
     546:	0d 92       	st	X+, r0
     548:	8a 95       	dec	r24
     54a:	e1 f7       	brne	.-8      	; 0x544 <Keypad_getPressedKey+0x28>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     54c:	00 e0       	ldi	r16, 0x00	; 0
     54e:	1c c0       	rjmp	.+56     	; 0x588 <Keypad_getPressedKey+0x6c>
    check_row(row, &row_state);
     550:	be 01       	movw	r22, r28
     552:	6e 5e       	subi	r22, 0xEE	; 238
     554:	7f 4f       	sbci	r23, 0xFF	; 255
     556:	80 2f       	mov	r24, r16
     558:	0e 94 6e 02 	call	0x4dc	; 0x4dc <check_row>
    if (row_state == LOW) {
     55c:	8a 89       	ldd	r24, Y+18	; 0x12
     55e:	88 23       	and	r24, r24
     560:	61 f0       	breq	.+24     	; 0x57a <Keypad_getPressedKey+0x5e>
     562:	11 c0       	rjmp	.+34     	; 0x586 <Keypad_getPressedKey+0x6a>
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
     564:	be 01       	movw	r22, r28
     566:	6f 5e       	subi	r22, 0xEF	; 239
     568:	7f 4f       	sbci	r23, 0xFF	; 255
     56a:	81 2f       	mov	r24, r17
     56c:	0e 94 4e 02 	call	0x49c	; 0x49c <check_col>
        if (col_state == LOW) {
     570:	89 89       	ldd	r24, Y+17	; 0x11
     572:	88 23       	and	r24, r24
     574:	c9 f1       	breq	.+114    	; 0x5e8 <Keypad_getPressedKey+0xcc>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
     576:	1f 5f       	subi	r17, 0xFF	; 255
     578:	01 c0       	rjmp	.+2      	; 0x57c <Keypad_getPressedKey+0x60>
     57a:	10 e0       	ldi	r17, 0x00	; 0
     57c:	14 30       	cpi	r17, 0x04	; 4
     57e:	90 f3       	brcs	.-28     	; 0x564 <Keypad_getPressedKey+0x48>
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
          }
        }
      toggle_row(row);
     580:	80 2f       	mov	r24, r16
     582:	0e 94 32 02 	call	0x464	; 0x464 <toggle_row>

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     586:	0f 5f       	subi	r16, 0xFF	; 255
     588:	04 30       	cpi	r16, 0x04	; 4
     58a:	10 f3       	brcs	.-60     	; 0x550 <Keypad_getPressedKey+0x34>
     58c:	00 e0       	ldi	r16, 0x00	; 0
     58e:	28 c0       	rjmp	.+80     	; 0x5e0 <Keypad_getPressedKey+0xc4>
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
     590:	80 2f       	mov	r24, r16
     592:	0e 94 32 02 	call	0x464	; 0x464 <toggle_row>
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     596:	10 e0       	ldi	r17, 0x00	; 0
     598:	1d c0       	rjmp	.+58     	; 0x5d4 <Keypad_getPressedKey+0xb8>
      check_col(col, &col_state);
     59a:	be 01       	movw	r22, r28
     59c:	6f 5e       	subi	r22, 0xEF	; 239
     59e:	7f 4f       	sbci	r23, 0xFF	; 255
     5a0:	81 2f       	mov	r24, r17
     5a2:	0e 94 4e 02 	call	0x49c	; 0x49c <check_col>
      if (col_state == LOW) {
     5a6:	89 89       	ldd	r24, Y+17	; 0x11
     5a8:	81 11       	cpse	r24, r1
     5aa:	13 c0       	rjmp	.+38     	; 0x5d2 <Keypad_getPressedKey+0xb6>
        // while (col_state == LOW) {  // Wait until the key is released (busy waiting - halts the system)
        //   check_col(col, &col_state);
        //   }
        *key = keys[row][col];
     5ac:	e0 2f       	mov	r30, r16
     5ae:	f0 e0       	ldi	r31, 0x00	; 0
     5b0:	ee 0f       	add	r30, r30
     5b2:	ff 1f       	adc	r31, r31
     5b4:	ee 0f       	add	r30, r30
     5b6:	ff 1f       	adc	r31, r31
     5b8:	81 e0       	ldi	r24, 0x01	; 1
     5ba:	90 e0       	ldi	r25, 0x00	; 0
     5bc:	8c 0f       	add	r24, r28
     5be:	9d 1f       	adc	r25, r29
     5c0:	e8 0f       	add	r30, r24
     5c2:	f9 1f       	adc	r31, r25
     5c4:	e1 0f       	add	r30, r17
     5c6:	f1 1d       	adc	r31, r1
     5c8:	80 81       	ld	r24, Z
     5ca:	f7 01       	movw	r30, r14
     5cc:	80 83       	st	Z, r24
        return KEY_PRESSED;
     5ce:	81 e0       	ldi	r24, 0x01	; 1
     5d0:	0c c0       	rjmp	.+24     	; 0x5ea <Keypad_getPressedKey+0xce>
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     5d2:	1f 5f       	subi	r17, 0xFF	; 255
     5d4:	14 30       	cpi	r17, 0x04	; 4
     5d6:	08 f3       	brcs	.-62     	; 0x59a <Keypad_getPressedKey+0x7e>
        //   }
        *key = keys[row][col];
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
     5d8:	80 2f       	mov	r24, r16
     5da:	0e 94 32 02 	call	0x464	; 0x464 <toggle_row>
          }
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
     5de:	0f 5f       	subi	r16, 0xFF	; 255
     5e0:	04 30       	cpi	r16, 0x04	; 4
     5e2:	b0 f2       	brcs	.-84     	; 0x590 <Keypad_getPressedKey+0x74>
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     5e4:	82 e0       	ldi	r24, 0x02	; 2
     5e6:	01 c0       	rjmp	.+2      	; 0x5ea <Keypad_getPressedKey+0xce>
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
     5e8:	82 e0       	ldi	r24, 0x02	; 2
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     5ea:	62 96       	adiw	r28, 0x12	; 18
     5ec:	0f b6       	in	r0, 0x3f	; 63
     5ee:	f8 94       	cli
     5f0:	de bf       	out	0x3e, r29	; 62
     5f2:	0f be       	out	0x3f, r0	; 63
     5f4:	cd bf       	out	0x3d, r28	; 61
     5f6:	df 91       	pop	r29
     5f8:	cf 91       	pop	r28
     5fa:	1f 91       	pop	r17
     5fc:	0f 91       	pop	r16
     5fe:	ff 90       	pop	r15
     600:	ef 90       	pop	r14
     602:	08 95       	ret

00000604 <LCD_sendEnablePulse>:
#include "lcd.h"

 // TODO: implement the eight bit mode

void LCD_sendEnablePulse(void) {
  DIO_write(EN, LCD_CTRL_PORT, HIGH);
     604:	41 e0       	ldi	r20, 0x01	; 1
     606:	61 e4       	ldi	r22, 0x41	; 65
     608:	86 e0       	ldi	r24, 0x06	; 6
     60a:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     60e:	8a e1       	ldi	r24, 0x1A	; 26
     610:	8a 95       	dec	r24
     612:	f1 f7       	brne	.-4      	; 0x610 <LCD_sendEnablePulse+0xc>
     614:	00 c0       	rjmp	.+0      	; 0x616 <LCD_sendEnablePulse+0x12>
  _delay_us(5);
  DIO_write(EN, LCD_CTRL_PORT, LOW);
     616:	40 e0       	ldi	r20, 0x00	; 0
     618:	61 e4       	ldi	r22, 0x41	; 65
     61a:	86 e0       	ldi	r24, 0x06	; 6
     61c:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
     620:	08 95       	ret

00000622 <LCD_write_4bits>:
  }

void LCD_write_4bits(u8 data) {
     622:	cf 93       	push	r28
     624:	c8 2f       	mov	r28, r24
  DIO_write(LCD_DATA_PIN4, LCD_DATA_PORT, read_bit(data, 0));
     626:	48 2f       	mov	r20, r24
     628:	41 70       	andi	r20, 0x01	; 1
     62a:	61 e4       	ldi	r22, 0x41	; 65
     62c:	80 e0       	ldi	r24, 0x00	; 0
     62e:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  DIO_write(LCD_DATA_PIN5, LCD_DATA_PORT, read_bit(data, 1));
     632:	c1 fb       	bst	r28, 1
     634:	44 27       	eor	r20, r20
     636:	40 f9       	bld	r20, 0
     638:	61 e4       	ldi	r22, 0x41	; 65
     63a:	81 e0       	ldi	r24, 0x01	; 1
     63c:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  DIO_write(LCD_DATA_PIN6, LCD_DATA_PORT, read_bit(data, 2));
     640:	c2 fb       	bst	r28, 2
     642:	44 27       	eor	r20, r20
     644:	40 f9       	bld	r20, 0
     646:	61 e4       	ldi	r22, 0x41	; 65
     648:	82 e0       	ldi	r24, 0x02	; 2
     64a:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  DIO_write(LCD_DATA_PIN7, LCD_DATA_PORT, read_bit(data, 3));
     64e:	c3 fb       	bst	r28, 3
     650:	44 27       	eor	r20, r20
     652:	40 f9       	bld	r20, 0
     654:	61 e4       	ldi	r22, 0x41	; 65
     656:	83 e0       	ldi	r24, 0x03	; 3
     658:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  }
     65c:	cf 91       	pop	r28
     65e:	08 95       	ret

00000660 <LCD_sendData>:

void LCD_sendData(u8 data) {
     660:	cf 93       	push	r28
     662:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(data >> 4);
     664:	82 95       	swap	r24
     666:	8f 70       	andi	r24, 0x0F	; 15
     668:	0e 94 11 03 	call	0x622	; 0x622 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, HIGH); // To indicate that this data
     66c:	41 e0       	ldi	r20, 0x01	; 1
     66e:	61 e4       	ldi	r22, 0x41	; 65
     670:	84 e0       	ldi	r24, 0x04	; 4
     672:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>

  LCD_sendEnablePulse();
     676:	0e 94 02 03 	call	0x604	; 0x604 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the data to be sent

  LCD_write_4bits(data);
     67a:	8c 2f       	mov	r24, r28
     67c:	0e 94 11 03 	call	0x622	; 0x622 <LCD_write_4bits>

  LCD_sendEnablePulse();
     680:	0e 94 02 03 	call	0x604	; 0x604 <LCD_sendEnablePulse>
     684:	85 e0       	ldi	r24, 0x05	; 5
     686:	8a 95       	dec	r24
     688:	f1 f7       	brne	.-4      	; 0x686 <LCD_sendData+0x26>
     68a:	00 00       	nop

  _delay_us(1); // wait for the data to be processed
#else

#endif
  }
     68c:	cf 91       	pop	r28
     68e:	08 95       	ret

00000690 <LCD_sendCommand>:

void LCD_sendCommand(u8 cmd) {
     690:	cf 93       	push	r28
     692:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(cmd >> 4);
     694:	82 95       	swap	r24
     696:	8f 70       	andi	r24, 0x0F	; 15
     698:	0e 94 11 03 	call	0x622	; 0x622 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, LOW); // To indicate that this a command
     69c:	40 e0       	ldi	r20, 0x00	; 0
     69e:	61 e4       	ldi	r22, 0x41	; 65
     6a0:	84 e0       	ldi	r24, 0x04	; 4
     6a2:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>

  LCD_sendEnablePulse();
     6a6:	0e 94 02 03 	call	0x604	; 0x604 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the command to be sent

  LCD_write_4bits(cmd);
     6aa:	8c 2f       	mov	r24, r28
     6ac:	0e 94 11 03 	call	0x622	; 0x622 <LCD_write_4bits>

  LCD_sendEnablePulse();
     6b0:	0e 94 02 03 	call	0x604	; 0x604 <LCD_sendEnablePulse>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6b4:	8f ed       	ldi	r24, 0xDF	; 223
     6b6:	9e e2       	ldi	r25, 0x2E	; 46
     6b8:	01 97       	sbiw	r24, 0x01	; 1
     6ba:	f1 f7       	brne	.-4      	; 0x6b8 <LCD_sendCommand+0x28>
     6bc:	00 c0       	rjmp	.+0      	; 0x6be <LCD_sendCommand+0x2e>
     6be:	00 00       	nop

  _delay_ms(3); // wait for the command to be executed
#else

#endif
  }
     6c0:	cf 91       	pop	r28
     6c2:	08 95       	ret

000006c4 <LCD_clear_screen>:

void LCD_clear_screen() {
  LCD_sendCommand(0x01);
     6c4:	81 e0       	ldi	r24, 0x01	; 1
     6c6:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
     6ca:	08 95       	ret

000006cc <LCD_init>:
     6cc:	2f ef       	ldi	r18, 0xFF	; 255
     6ce:	89 ef       	ldi	r24, 0xF9	; 249
     6d0:	90 e0       	ldi	r25, 0x00	; 0
     6d2:	21 50       	subi	r18, 0x01	; 1
     6d4:	80 40       	sbci	r24, 0x00	; 0
     6d6:	90 40       	sbci	r25, 0x00	; 0
     6d8:	e1 f7       	brne	.-8      	; 0x6d2 <LCD_init+0x6>
     6da:	00 c0       	rjmp	.+0      	; 0x6dc <LCD_init+0x10>
     6dc:	00 00       	nop

void LCD_init(void) {
  _delay_ms(20); // wait for the LCD to start up.

#if LCD_MODE == FOUR_BIT_MODE
  DIO_init(LCD_DATA_PIN4, LCD_DATA_PORT, OUT);
     6de:	41 e0       	ldi	r20, 0x01	; 1
     6e0:	61 e4       	ldi	r22, 0x41	; 65
     6e2:	80 e0       	ldi	r24, 0x00	; 0
     6e4:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  DIO_init(LCD_DATA_PIN5, LCD_DATA_PORT, OUT);
     6e8:	41 e0       	ldi	r20, 0x01	; 1
     6ea:	61 e4       	ldi	r22, 0x41	; 65
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  DIO_init(LCD_DATA_PIN6, LCD_DATA_PORT, OUT);
     6f2:	41 e0       	ldi	r20, 0x01	; 1
     6f4:	61 e4       	ldi	r22, 0x41	; 65
     6f6:	82 e0       	ldi	r24, 0x02	; 2
     6f8:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  DIO_init(LCD_DATA_PIN7, LCD_DATA_PORT, OUT);
     6fc:	41 e0       	ldi	r20, 0x01	; 1
     6fe:	61 e4       	ldi	r22, 0x41	; 65
     700:	83 e0       	ldi	r24, 0x03	; 3
     702:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>

  DIO_init(RS, LCD_CTRL_PORT, OUT);
     706:	41 e0       	ldi	r20, 0x01	; 1
     708:	61 e4       	ldi	r22, 0x41	; 65
     70a:	84 e0       	ldi	r24, 0x04	; 4
     70c:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  DIO_init(RW, LCD_CTRL_PORT, OUT);
     710:	41 e0       	ldi	r20, 0x01	; 1
     712:	61 e4       	ldi	r22, 0x41	; 65
     714:	85 e0       	ldi	r24, 0x05	; 5
     716:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>
  DIO_init(EN, LCD_CTRL_PORT, OUT);
     71a:	41 e0       	ldi	r20, 0x01	; 1
     71c:	61 e4       	ldi	r22, 0x41	; 65
     71e:	86 e0       	ldi	r24, 0x06	; 6
     720:	0e 94 2d 04 	call	0x85a	; 0x85a <DIO_init>

  DIO_write(RW, LCD_CTRL_PORT, LOW);
     724:	40 e0       	ldi	r20, 0x00	; 0
     726:	61 e4       	ldi	r22, 0x41	; 65
     728:	85 e0       	ldi	r24, 0x05	; 5
     72a:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>

  LCD_sendCommand(0x02);  // return home 
     72e:	82 e0       	ldi	r24, 0x02	; 2
     730:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
  LCD_sendCommand(0x28);  // 2 line  and 4 bit mode
     734:	88 e2       	ldi	r24, 0x28	; 40
     736:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
  LCD_sendCommand(0x0C);  // display on 
     73a:	8c e0       	ldi	r24, 0x0C	; 12
     73c:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
  LCD_sendCommand(0x06);  // auto increment 
     740:	86 e0       	ldi	r24, 0x06	; 6
     742:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
  LCD_clear_screen();
     746:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
     74a:	08 95       	ret

0000074c <LCD_write_string>:
#else

#endif
  }

void LCD_write_string(s8* str) {
     74c:	cf 92       	push	r12
     74e:	df 92       	push	r13
     750:	ef 92       	push	r14
     752:	ff 92       	push	r15
     754:	cf 93       	push	r28
     756:	df 93       	push	r29
     758:	ec 01       	movw	r28, r24
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     75a:	c1 2c       	mov	r12, r1
     75c:	d1 2c       	mov	r13, r1
     75e:	76 01       	movw	r14, r12
     760:	07 c0       	rjmp	.+14     	; 0x770 <LCD_write_string+0x24>
    LCD_sendData(str[i]);
     762:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
#endif
  }

void LCD_write_string(s8* str) {
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     766:	8f ef       	ldi	r24, 0xFF	; 255
     768:	c8 1a       	sub	r12, r24
     76a:	d8 0a       	sbc	r13, r24
     76c:	e8 0a       	sbc	r14, r24
     76e:	f8 0a       	sbc	r15, r24
     770:	fe 01       	movw	r30, r28
     772:	ec 0d       	add	r30, r12
     774:	fd 1d       	adc	r31, r13
     776:	80 81       	ld	r24, Z
     778:	81 11       	cpse	r24, r1
     77a:	f3 cf       	rjmp	.-26     	; 0x762 <LCD_write_string+0x16>
    LCD_sendData(str[i]);
    }
  }
     77c:	df 91       	pop	r29
     77e:	cf 91       	pop	r28
     780:	ff 90       	pop	r15
     782:	ef 90       	pop	r14
     784:	df 90       	pop	r13
     786:	cf 90       	pop	r12
     788:	08 95       	ret

0000078a <LCD_move_cursor_xy>:

void LCD_move_cursor_xy(u8 x, u8 y) {
  switch (y) {
     78a:	66 23       	and	r22, r22
     78c:	19 f0       	breq	.+6      	; 0x794 <LCD_move_cursor_xy+0xa>
     78e:	61 30       	cpi	r22, 0x01	; 1
     790:	29 f0       	breq	.+10     	; 0x79c <LCD_move_cursor_xy+0x12>
     792:	08 95       	ret
      case 0:
        LCD_sendCommand(0x80 + x);
     794:	80 58       	subi	r24, 0x80	; 128
     796:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
        break;
     79a:	08 95       	ret
      case 1:
        LCD_sendCommand(0xC0 + x);
     79c:	80 54       	subi	r24, 0x40	; 64
     79e:	0e 94 48 03 	call	0x690	; 0x690 <LCD_sendCommand>
     7a2:	08 95       	ret

000007a4 <LCD_write_string_xy>:
        break;
    }
  }

void LCD_write_string_xy(u8 x, u8 y, s8* str) {
     7a4:	cf 93       	push	r28
     7a6:	df 93       	push	r29
     7a8:	ea 01       	movw	r28, r20
  LCD_move_cursor_xy(x, y);
     7aa:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
  LCD_write_string(str);
     7ae:	ce 01       	movw	r24, r28
     7b0:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
  // TODO: Input validation
     7b4:	df 91       	pop	r29
     7b6:	cf 91       	pop	r28
     7b8:	08 95       	ret

000007ba <LED_on>:
  // Return error code to indicate that the led initialization failed
  return LED_ERROR_INIT;
  }

// Turn on the LED
EN_ledError_t LED_on(u8 ledPort, u8 ledPin) {
     7ba:	98 2f       	mov	r25, r24
     7bc:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, HIGH) == DIO_OK) {
     7be:	41 e0       	ldi	r20, 0x01	; 1
     7c0:	69 2f       	mov	r22, r25
     7c2:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
     7c6:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn on the led has failed
  return LED_ERROR_ON;
     7c8:	82 e0       	ldi	r24, 0x02	; 2
  }
     7ca:	08 95       	ret

000007cc <LED_off>:

// Turn off the LED
EN_ledError_t LED_off(u8 ledPort, u8 ledPin) {
     7cc:	98 2f       	mov	r25, r24
     7ce:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, LOW) == DIO_OK) {
     7d0:	40 e0       	ldi	r20, 0x00	; 0
     7d2:	69 2f       	mov	r22, r25
     7d4:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
     7d8:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn off the led has failed
  return LED_ERROR_OFF;
     7da:	83 e0       	ldi	r24, 0x03	; 3
  }
     7dc:	08 95       	ret

000007de <LED_toggle>:

// Toggle the LED
EN_ledError_t LED_toggle(u8 ledPort, u8 ledPin) {
     7de:	98 2f       	mov	r25, r24
     7e0:	86 2f       	mov	r24, r22
  if (DIO_toggle(ledPin, ledPort) == DIO_OK) {
     7e2:	69 2f       	mov	r22, r25
     7e4:	0e 94 b7 05 	call	0xb6e	; 0xb6e <DIO_toggle>
     7e8:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to toggle the led has failed
  return LED_ERROR_TOGGLE;
     7ea:	84 e0       	ldi	r24, 0x04	; 4
     7ec:	08 95       	ret

000007ee <Servo_move_to_angle>:
  Timer_start(TIMER_1, 8);
  }

// Moves the servo to a specific angle (relative to the 0 angle position, not the previous one).
void Servo_move_to_angle(u8 angle) {
  PWM_set_DC(SERVO_PWM_PIN, ((double)angle / ((SERVO_MAX_ANGLE - SERVO_MIN_ANGLE) * (SERVO_PULSE_PERIODIC_TIME_mS / (SERVO_MAX_HIGH_PULSE_DURATION_mS - SERVO_MIN_HIGH_PULSE_DURATION_mS)))) + (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS));
     7ee:	68 2f       	mov	r22, r24
     7f0:	70 e0       	ldi	r23, 0x00	; 0
     7f2:	80 e0       	ldi	r24, 0x00	; 0
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	0e 94 78 12 	call	0x24f0	; 0x24f0 <__floatunsisf>
     7fa:	20 e0       	ldi	r18, 0x00	; 0
     7fc:	30 e0       	ldi	r19, 0x00	; 0
     7fe:	41 ee       	ldi	r20, 0xE1	; 225
     800:	54 e4       	ldi	r21, 0x44	; 68
     802:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__divsf3>
     806:	2d ec       	ldi	r18, 0xCD	; 205
     808:	3c ec       	ldi	r19, 0xCC	; 204
     80a:	4c ec       	ldi	r20, 0xCC	; 204
     80c:	5c e3       	ldi	r21, 0x3C	; 60
     80e:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__addsf3>
     812:	ab 01       	movw	r20, r22
     814:	bc 01       	movw	r22, r24
     816:	81 e0       	ldi	r24, 0x01	; 1
     818:	0e 94 bb 06 	call	0xd76	; 0xd76 <PWM_set_DC>
     81c:	08 95       	ret

0000081e <main>:
 */

#include "Application/app.h"

int main(void) {
	Local_access_init();
     81e:	0e 94 b7 07 	call	0xf6e	; 0xf6e <Local_access_init>
	
	// App_init();

	// App_start();
	while (1) {
		Local_control_input_handler();
     822:	0e 94 1d 09 	call	0x123a	; 0x123a <Local_control_input_handler>
     826:	fd cf       	rjmp	.-6      	; 0x822 <main+0x4>

00000828 <isValidPinNumber>:
 */

#include "dio.h"

bool isValidPinNumber(u8 pinNumber) {
	if (pinNumber < 8) {
     828:	88 30       	cpi	r24, 0x08	; 8
     82a:	10 f4       	brcc	.+4      	; 0x830 <isValidPinNumber+0x8>
		return true;
     82c:	81 e0       	ldi	r24, 0x01	; 1
     82e:	08 95       	ret
		}
	return false;
     830:	80 e0       	ldi	r24, 0x00	; 0
	}
     832:	08 95       	ret

00000834 <isValidPortNumber>:

bool isValidPortNumber(u8 portNumber) {
	if (portNumber == PORT_A || portNumber == PORT_B || portNumber == PORT_C || portNumber == PORT_D) {
     834:	81 54       	subi	r24, 0x41	; 65
     836:	84 30       	cpi	r24, 0x04	; 4
     838:	10 f4       	brcc	.+4      	; 0x83e <isValidPortNumber+0xa>
		return true;
     83a:	81 e0       	ldi	r24, 0x01	; 1
     83c:	08 95       	ret
		}
	return false;
     83e:	80 e0       	ldi	r24, 0x00	; 0
	}
     840:	08 95       	ret

00000842 <isValidDirection>:

bool isValidDirection(u8 direction) {
	if (direction == IN || direction == OUT) {
     842:	82 30       	cpi	r24, 0x02	; 2
     844:	10 f4       	brcc	.+4      	; 0x84a <isValidDirection+0x8>
		return true;
     846:	81 e0       	ldi	r24, 0x01	; 1
     848:	08 95       	ret
		}
	return false;
     84a:	80 e0       	ldi	r24, 0x00	; 0
	}
     84c:	08 95       	ret

0000084e <isValidState>:

bool isValidState(u8 state) {
	if (state == HIGH || state == LOW) {
     84e:	82 30       	cpi	r24, 0x02	; 2
     850:	10 f4       	brcc	.+4      	; 0x856 <isValidState+0x8>
		return true;
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	08 95       	ret
		}
	return false;
     856:	80 e0       	ldi	r24, 0x00	; 0
	}
     858:	08 95       	ret

0000085a <DIO_init>:

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
     85a:	1f 93       	push	r17
     85c:	cf 93       	push	r28
     85e:	df 93       	push	r29
     860:	c8 2f       	mov	r28, r24
     862:	d6 2f       	mov	r29, r22
     864:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     866:	0e 94 14 04 	call	0x828	; 0x828 <isValidPinNumber>
     86a:	88 23       	and	r24, r24
     86c:	09 f4       	brne	.+2      	; 0x870 <__stack+0x11>
     86e:	84 c0       	rjmp	.+264    	; 0x978 <__stack+0x119>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     870:	8d 2f       	mov	r24, r29
     872:	0e 94 1a 04 	call	0x834	; 0x834 <isValidPortNumber>
     876:	88 23       	and	r24, r24
     878:	09 f4       	brne	.+2      	; 0x87c <__stack+0x1d>
     87a:	80 c0       	rjmp	.+256    	; 0x97c <__stack+0x11d>
		return WRONG_PORT;
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
     87c:	81 2f       	mov	r24, r17
     87e:	0e 94 21 04 	call	0x842	; 0x842 <isValidDirection>
     882:	88 23       	and	r24, r24
     884:	09 f4       	brne	.+2      	; 0x888 <__stack+0x29>
     886:	7c c0       	rjmp	.+248    	; 0x980 <__stack+0x121>
		return WRONG_DIRECTION;
		}
	switch (portNumber) {
     888:	d2 34       	cpi	r29, 0x42	; 66
     88a:	29 f1       	breq	.+74     	; 0x8d6 <__stack+0x77>
     88c:	18 f4       	brcc	.+6      	; 0x894 <__stack+0x35>
     88e:	d1 34       	cpi	r29, 0x41	; 65
     890:	39 f0       	breq	.+14     	; 0x8a0 <__stack+0x41>
     892:	78 c0       	rjmp	.+240    	; 0x984 <__stack+0x125>
     894:	d3 34       	cpi	r29, 0x43	; 67
     896:	d1 f1       	breq	.+116    	; 0x90c <__stack+0xad>
     898:	d4 34       	cpi	r29, 0x44	; 68
     89a:	09 f4       	brne	.+2      	; 0x89e <__stack+0x3f>
     89c:	52 c0       	rjmp	.+164    	; 0x942 <__stack+0xe3>
     89e:	72 c0       	rjmp	.+228    	; 0x984 <__stack+0x125>
			case PORT_A:
				if (direction == OUT) {
     8a0:	11 30       	cpi	r17, 0x01	; 1
     8a2:	61 f4       	brne	.+24     	; 0x8bc <__stack+0x5d>
					set_bit(DDRA, pinNumber);
     8a4:	2a b3       	in	r18, 0x1a	; 26
     8a6:	81 e0       	ldi	r24, 0x01	; 1
     8a8:	90 e0       	ldi	r25, 0x00	; 0
     8aa:	02 c0       	rjmp	.+4      	; 0x8b0 <__stack+0x51>
     8ac:	88 0f       	add	r24, r24
     8ae:	99 1f       	adc	r25, r25
     8b0:	ca 95       	dec	r28
     8b2:	e2 f7       	brpl	.-8      	; 0x8ac <__stack+0x4d>
     8b4:	82 2b       	or	r24, r18
     8b6:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     8b8:	80 e0       	ldi	r24, 0x00	; 0
     8ba:	65 c0       	rjmp	.+202    	; 0x986 <__stack+0x127>
			case PORT_A:
				if (direction == OUT) {
					set_bit(DDRA, pinNumber);
					}
				else {
					clear_bit(DDRA, pinNumber);
     8bc:	2a b3       	in	r18, 0x1a	; 26
     8be:	81 e0       	ldi	r24, 0x01	; 1
     8c0:	90 e0       	ldi	r25, 0x00	; 0
     8c2:	02 c0       	rjmp	.+4      	; 0x8c8 <__stack+0x69>
     8c4:	88 0f       	add	r24, r24
     8c6:	99 1f       	adc	r25, r25
     8c8:	ca 95       	dec	r28
     8ca:	e2 f7       	brpl	.-8      	; 0x8c4 <__stack+0x65>
     8cc:	80 95       	com	r24
     8ce:	82 23       	and	r24, r18
     8d0:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     8d2:	80 e0       	ldi	r24, 0x00	; 0
     8d4:	58 c0       	rjmp	.+176    	; 0x986 <__stack+0x127>
				else {
					clear_bit(DDRA, pinNumber);
					}
				break;
			case PORT_B:
				if (direction == OUT) {
     8d6:	11 30       	cpi	r17, 0x01	; 1
     8d8:	61 f4       	brne	.+24     	; 0x8f2 <__stack+0x93>
					set_bit(DDRB, pinNumber);
     8da:	27 b3       	in	r18, 0x17	; 23
     8dc:	81 e0       	ldi	r24, 0x01	; 1
     8de:	90 e0       	ldi	r25, 0x00	; 0
     8e0:	02 c0       	rjmp	.+4      	; 0x8e6 <__stack+0x87>
     8e2:	88 0f       	add	r24, r24
     8e4:	99 1f       	adc	r25, r25
     8e6:	ca 95       	dec	r28
     8e8:	e2 f7       	brpl	.-8      	; 0x8e2 <__stack+0x83>
     8ea:	82 2b       	or	r24, r18
     8ec:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     8ee:	80 e0       	ldi	r24, 0x00	; 0
     8f0:	4a c0       	rjmp	.+148    	; 0x986 <__stack+0x127>
			case PORT_B:
				if (direction == OUT) {
					set_bit(DDRB, pinNumber);
					}
				else {
					clear_bit(DDRB, pinNumber);
     8f2:	27 b3       	in	r18, 0x17	; 23
     8f4:	81 e0       	ldi	r24, 0x01	; 1
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	02 c0       	rjmp	.+4      	; 0x8fe <__stack+0x9f>
     8fa:	88 0f       	add	r24, r24
     8fc:	99 1f       	adc	r25, r25
     8fe:	ca 95       	dec	r28
     900:	e2 f7       	brpl	.-8      	; 0x8fa <__stack+0x9b>
     902:	80 95       	com	r24
     904:	82 23       	and	r24, r18
     906:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     908:	80 e0       	ldi	r24, 0x00	; 0
     90a:	3d c0       	rjmp	.+122    	; 0x986 <__stack+0x127>
				else {
					clear_bit(DDRB, pinNumber);
					}
				break;
			case PORT_C:
				if (direction == OUT) {
     90c:	11 30       	cpi	r17, 0x01	; 1
     90e:	61 f4       	brne	.+24     	; 0x928 <__stack+0xc9>
					set_bit(DDRC, pinNumber);
     910:	24 b3       	in	r18, 0x14	; 20
     912:	81 e0       	ldi	r24, 0x01	; 1
     914:	90 e0       	ldi	r25, 0x00	; 0
     916:	02 c0       	rjmp	.+4      	; 0x91c <__stack+0xbd>
     918:	88 0f       	add	r24, r24
     91a:	99 1f       	adc	r25, r25
     91c:	ca 95       	dec	r28
     91e:	e2 f7       	brpl	.-8      	; 0x918 <__stack+0xb9>
     920:	82 2b       	or	r24, r18
     922:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     924:	80 e0       	ldi	r24, 0x00	; 0
     926:	2f c0       	rjmp	.+94     	; 0x986 <__stack+0x127>
			case PORT_C:
				if (direction == OUT) {
					set_bit(DDRC, pinNumber);
					}
				else {
					clear_bit(DDRC, pinNumber);
     928:	24 b3       	in	r18, 0x14	; 20
     92a:	81 e0       	ldi	r24, 0x01	; 1
     92c:	90 e0       	ldi	r25, 0x00	; 0
     92e:	02 c0       	rjmp	.+4      	; 0x934 <__stack+0xd5>
     930:	88 0f       	add	r24, r24
     932:	99 1f       	adc	r25, r25
     934:	ca 95       	dec	r28
     936:	e2 f7       	brpl	.-8      	; 0x930 <__stack+0xd1>
     938:	80 95       	com	r24
     93a:	82 23       	and	r24, r18
     93c:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     93e:	80 e0       	ldi	r24, 0x00	; 0
     940:	22 c0       	rjmp	.+68     	; 0x986 <__stack+0x127>
				else {
					clear_bit(DDRC, pinNumber);
					}
				break;
			case PORT_D:
				if (direction == OUT) {
     942:	11 30       	cpi	r17, 0x01	; 1
     944:	61 f4       	brne	.+24     	; 0x95e <__stack+0xff>
					set_bit(DDRD, pinNumber);
     946:	21 b3       	in	r18, 0x11	; 17
     948:	81 e0       	ldi	r24, 0x01	; 1
     94a:	90 e0       	ldi	r25, 0x00	; 0
     94c:	02 c0       	rjmp	.+4      	; 0x952 <__stack+0xf3>
     94e:	88 0f       	add	r24, r24
     950:	99 1f       	adc	r25, r25
     952:	ca 95       	dec	r28
     954:	e2 f7       	brpl	.-8      	; 0x94e <__stack+0xef>
     956:	82 2b       	or	r24, r18
     958:	81 bb       	out	0x11, r24	; 17
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     95a:	80 e0       	ldi	r24, 0x00	; 0
     95c:	14 c0       	rjmp	.+40     	; 0x986 <__stack+0x127>
			case PORT_D:
				if (direction == OUT) {
					set_bit(DDRD, pinNumber);
					}
				else {
					clear_bit(DDRD, pinNumber);
     95e:	21 b3       	in	r18, 0x11	; 17
     960:	81 e0       	ldi	r24, 0x01	; 1
     962:	90 e0       	ldi	r25, 0x00	; 0
     964:	02 c0       	rjmp	.+4      	; 0x96a <__stack+0x10b>
     966:	88 0f       	add	r24, r24
     968:	99 1f       	adc	r25, r25
     96a:	ca 95       	dec	r28
     96c:	e2 f7       	brpl	.-8      	; 0x966 <__stack+0x107>
     96e:	80 95       	com	r24
     970:	82 23       	and	r24, r18
     972:	81 bb       	out	0x11, r24	; 17
					}
				break;
		}
	return DIO_OK;
     974:	80 e0       	ldi	r24, 0x00	; 0
     976:	07 c0       	rjmp	.+14     	; 0x986 <__stack+0x127>

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     978:	81 e0       	ldi	r24, 0x01	; 1
     97a:	05 c0       	rjmp	.+10     	; 0x986 <__stack+0x127>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     97c:	82 e0       	ldi	r24, 0x02	; 2
     97e:	03 c0       	rjmp	.+6      	; 0x986 <__stack+0x127>
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
		return WRONG_DIRECTION;
     980:	83 e0       	ldi	r24, 0x03	; 3
     982:	01 c0       	rjmp	.+2      	; 0x986 <__stack+0x127>
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     984:	80 e0       	ldi	r24, 0x00	; 0
	}
     986:	df 91       	pop	r29
     988:	cf 91       	pop	r28
     98a:	1f 91       	pop	r17
     98c:	08 95       	ret

0000098e <DIO_write>:

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
     98e:	1f 93       	push	r17
     990:	cf 93       	push	r28
     992:	df 93       	push	r29
     994:	c8 2f       	mov	r28, r24
     996:	d6 2f       	mov	r29, r22
     998:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     99a:	0e 94 14 04 	call	0x828	; 0x828 <isValidPinNumber>
     99e:	88 23       	and	r24, r24
     9a0:	09 f4       	brne	.+2      	; 0x9a4 <DIO_write+0x16>
     9a2:	84 c0       	rjmp	.+264    	; 0xaac <DIO_write+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     9a4:	8d 2f       	mov	r24, r29
     9a6:	0e 94 1a 04 	call	0x834	; 0x834 <isValidPortNumber>
     9aa:	88 23       	and	r24, r24
     9ac:	09 f4       	brne	.+2      	; 0x9b0 <DIO_write+0x22>
     9ae:	80 c0       	rjmp	.+256    	; 0xab0 <DIO_write+0x122>
		return WRONG_PORT;
		}
	// Validate the pin state
	if (!isValidState(state)) {
     9b0:	81 2f       	mov	r24, r17
     9b2:	0e 94 27 04 	call	0x84e	; 0x84e <isValidState>
     9b6:	88 23       	and	r24, r24
     9b8:	09 f4       	brne	.+2      	; 0x9bc <DIO_write+0x2e>
     9ba:	7c c0       	rjmp	.+248    	; 0xab4 <DIO_write+0x126>
		return WRONG_STATE;
		}
	switch (portNumber) {
     9bc:	d2 34       	cpi	r29, 0x42	; 66
     9be:	29 f1       	breq	.+74     	; 0xa0a <DIO_write+0x7c>
     9c0:	18 f4       	brcc	.+6      	; 0x9c8 <DIO_write+0x3a>
     9c2:	d1 34       	cpi	r29, 0x41	; 65
     9c4:	39 f0       	breq	.+14     	; 0x9d4 <DIO_write+0x46>
     9c6:	78 c0       	rjmp	.+240    	; 0xab8 <DIO_write+0x12a>
     9c8:	d3 34       	cpi	r29, 0x43	; 67
     9ca:	d1 f1       	breq	.+116    	; 0xa40 <DIO_write+0xb2>
     9cc:	d4 34       	cpi	r29, 0x44	; 68
     9ce:	09 f4       	brne	.+2      	; 0x9d2 <DIO_write+0x44>
     9d0:	52 c0       	rjmp	.+164    	; 0xa76 <DIO_write+0xe8>
     9d2:	72 c0       	rjmp	.+228    	; 0xab8 <DIO_write+0x12a>
			case PORT_A:
				if (state == HIGH) {
     9d4:	11 30       	cpi	r17, 0x01	; 1
     9d6:	61 f4       	brne	.+24     	; 0x9f0 <DIO_write+0x62>
					set_bit(PORTA, pinNumber);
     9d8:	2b b3       	in	r18, 0x1b	; 27
     9da:	81 e0       	ldi	r24, 0x01	; 1
     9dc:	90 e0       	ldi	r25, 0x00	; 0
     9de:	02 c0       	rjmp	.+4      	; 0x9e4 <DIO_write+0x56>
     9e0:	88 0f       	add	r24, r24
     9e2:	99 1f       	adc	r25, r25
     9e4:	ca 95       	dec	r28
     9e6:	e2 f7       	brpl	.-8      	; 0x9e0 <DIO_write+0x52>
     9e8:	82 2b       	or	r24, r18
     9ea:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     9ec:	80 e0       	ldi	r24, 0x00	; 0
     9ee:	65 c0       	rjmp	.+202    	; 0xaba <DIO_write+0x12c>
			case PORT_A:
				if (state == HIGH) {
					set_bit(PORTA, pinNumber);
					}
				else {
					clear_bit(PORTA, pinNumber);
     9f0:	2b b3       	in	r18, 0x1b	; 27
     9f2:	81 e0       	ldi	r24, 0x01	; 1
     9f4:	90 e0       	ldi	r25, 0x00	; 0
     9f6:	02 c0       	rjmp	.+4      	; 0x9fc <DIO_write+0x6e>
     9f8:	88 0f       	add	r24, r24
     9fa:	99 1f       	adc	r25, r25
     9fc:	ca 95       	dec	r28
     9fe:	e2 f7       	brpl	.-8      	; 0x9f8 <DIO_write+0x6a>
     a00:	80 95       	com	r24
     a02:	82 23       	and	r24, r18
     a04:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a06:	80 e0       	ldi	r24, 0x00	; 0
     a08:	58 c0       	rjmp	.+176    	; 0xaba <DIO_write+0x12c>
				else {
					clear_bit(PORTA, pinNumber);
					}
				break;
			case PORT_B:
				if (state == HIGH) {
     a0a:	11 30       	cpi	r17, 0x01	; 1
     a0c:	61 f4       	brne	.+24     	; 0xa26 <DIO_write+0x98>
					set_bit(PORTB, pinNumber);
     a0e:	28 b3       	in	r18, 0x18	; 24
     a10:	81 e0       	ldi	r24, 0x01	; 1
     a12:	90 e0       	ldi	r25, 0x00	; 0
     a14:	02 c0       	rjmp	.+4      	; 0xa1a <DIO_write+0x8c>
     a16:	88 0f       	add	r24, r24
     a18:	99 1f       	adc	r25, r25
     a1a:	ca 95       	dec	r28
     a1c:	e2 f7       	brpl	.-8      	; 0xa16 <DIO_write+0x88>
     a1e:	82 2b       	or	r24, r18
     a20:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a22:	80 e0       	ldi	r24, 0x00	; 0
     a24:	4a c0       	rjmp	.+148    	; 0xaba <DIO_write+0x12c>
			case PORT_B:
				if (state == HIGH) {
					set_bit(PORTB, pinNumber);
					}
				else {
					clear_bit(PORTB, pinNumber);
     a26:	28 b3       	in	r18, 0x18	; 24
     a28:	81 e0       	ldi	r24, 0x01	; 1
     a2a:	90 e0       	ldi	r25, 0x00	; 0
     a2c:	02 c0       	rjmp	.+4      	; 0xa32 <DIO_write+0xa4>
     a2e:	88 0f       	add	r24, r24
     a30:	99 1f       	adc	r25, r25
     a32:	ca 95       	dec	r28
     a34:	e2 f7       	brpl	.-8      	; 0xa2e <DIO_write+0xa0>
     a36:	80 95       	com	r24
     a38:	82 23       	and	r24, r18
     a3a:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a3c:	80 e0       	ldi	r24, 0x00	; 0
     a3e:	3d c0       	rjmp	.+122    	; 0xaba <DIO_write+0x12c>
				else {
					clear_bit(PORTB, pinNumber);
					}
				break;
			case PORT_C:
				if (state == HIGH) {
     a40:	11 30       	cpi	r17, 0x01	; 1
     a42:	61 f4       	brne	.+24     	; 0xa5c <DIO_write+0xce>
					set_bit(PORTC, pinNumber);
     a44:	25 b3       	in	r18, 0x15	; 21
     a46:	81 e0       	ldi	r24, 0x01	; 1
     a48:	90 e0       	ldi	r25, 0x00	; 0
     a4a:	02 c0       	rjmp	.+4      	; 0xa50 <DIO_write+0xc2>
     a4c:	88 0f       	add	r24, r24
     a4e:	99 1f       	adc	r25, r25
     a50:	ca 95       	dec	r28
     a52:	e2 f7       	brpl	.-8      	; 0xa4c <DIO_write+0xbe>
     a54:	82 2b       	or	r24, r18
     a56:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a58:	80 e0       	ldi	r24, 0x00	; 0
     a5a:	2f c0       	rjmp	.+94     	; 0xaba <DIO_write+0x12c>
			case PORT_C:
				if (state == HIGH) {
					set_bit(PORTC, pinNumber);
					}
				else {
					clear_bit(PORTC, pinNumber);
     a5c:	25 b3       	in	r18, 0x15	; 21
     a5e:	81 e0       	ldi	r24, 0x01	; 1
     a60:	90 e0       	ldi	r25, 0x00	; 0
     a62:	02 c0       	rjmp	.+4      	; 0xa68 <DIO_write+0xda>
     a64:	88 0f       	add	r24, r24
     a66:	99 1f       	adc	r25, r25
     a68:	ca 95       	dec	r28
     a6a:	e2 f7       	brpl	.-8      	; 0xa64 <DIO_write+0xd6>
     a6c:	80 95       	com	r24
     a6e:	82 23       	and	r24, r18
     a70:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a72:	80 e0       	ldi	r24, 0x00	; 0
     a74:	22 c0       	rjmp	.+68     	; 0xaba <DIO_write+0x12c>
				else {
					clear_bit(PORTC, pinNumber);
					}
				break;
			case PORT_D:
				if (state == HIGH) {
     a76:	11 30       	cpi	r17, 0x01	; 1
     a78:	61 f4       	brne	.+24     	; 0xa92 <DIO_write+0x104>
					set_bit(PORTD, pinNumber);
     a7a:	22 b3       	in	r18, 0x12	; 18
     a7c:	81 e0       	ldi	r24, 0x01	; 1
     a7e:	90 e0       	ldi	r25, 0x00	; 0
     a80:	02 c0       	rjmp	.+4      	; 0xa86 <DIO_write+0xf8>
     a82:	88 0f       	add	r24, r24
     a84:	99 1f       	adc	r25, r25
     a86:	ca 95       	dec	r28
     a88:	e2 f7       	brpl	.-8      	; 0xa82 <DIO_write+0xf4>
     a8a:	82 2b       	or	r24, r18
     a8c:	82 bb       	out	0x12, r24	; 18
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a8e:	80 e0       	ldi	r24, 0x00	; 0
     a90:	14 c0       	rjmp	.+40     	; 0xaba <DIO_write+0x12c>
			case PORT_D:
				if (state == HIGH) {
					set_bit(PORTD, pinNumber);
					}
				else {
					clear_bit(PORTD, pinNumber);
     a92:	22 b3       	in	r18, 0x12	; 18
     a94:	81 e0       	ldi	r24, 0x01	; 1
     a96:	90 e0       	ldi	r25, 0x00	; 0
     a98:	02 c0       	rjmp	.+4      	; 0xa9e <DIO_write+0x110>
     a9a:	88 0f       	add	r24, r24
     a9c:	99 1f       	adc	r25, r25
     a9e:	ca 95       	dec	r28
     aa0:	e2 f7       	brpl	.-8      	; 0xa9a <DIO_write+0x10c>
     aa2:	80 95       	com	r24
     aa4:	82 23       	and	r24, r18
     aa6:	82 bb       	out	0x12, r24	; 18
					}
				break;
		}
	return DIO_OK;
     aa8:	80 e0       	ldi	r24, 0x00	; 0
     aaa:	07 c0       	rjmp	.+14     	; 0xaba <DIO_write+0x12c>

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     aac:	81 e0       	ldi	r24, 0x01	; 1
     aae:	05 c0       	rjmp	.+10     	; 0xaba <DIO_write+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     ab0:	82 e0       	ldi	r24, 0x02	; 2
     ab2:	03 c0       	rjmp	.+6      	; 0xaba <DIO_write+0x12c>
		}
	// Validate the pin state
	if (!isValidState(state)) {
		return WRONG_STATE;
     ab4:	84 e0       	ldi	r24, 0x04	; 4
     ab6:	01 c0       	rjmp	.+2      	; 0xaba <DIO_write+0x12c>
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     ab8:	80 e0       	ldi	r24, 0x00	; 0
	}
     aba:	df 91       	pop	r29
     abc:	cf 91       	pop	r28
     abe:	1f 91       	pop	r17
     ac0:	08 95       	ret

00000ac2 <DIO_Read>:

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
     ac2:	0f 93       	push	r16
     ac4:	1f 93       	push	r17
     ac6:	cf 93       	push	r28
     ac8:	df 93       	push	r29
     aca:	d8 2f       	mov	r29, r24
     acc:	c6 2f       	mov	r28, r22
     ace:	8a 01       	movw	r16, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     ad0:	0e 94 14 04 	call	0x828	; 0x828 <isValidPinNumber>
     ad4:	88 23       	and	r24, r24
     ad6:	09 f4       	brne	.+2      	; 0xada <DIO_Read+0x18>
     ad8:	40 c0       	rjmp	.+128    	; 0xb5a <DIO_Read+0x98>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     ada:	8c 2f       	mov	r24, r28
     adc:	0e 94 1a 04 	call	0x834	; 0x834 <isValidPortNumber>
     ae0:	88 23       	and	r24, r24
     ae2:	e9 f1       	breq	.+122    	; 0xb5e <DIO_Read+0x9c>
		return WRONG_PORT;
		}
	switch (portNumber) {
     ae4:	c2 34       	cpi	r28, 0x42	; 66
     ae6:	a9 f0       	breq	.+42     	; 0xb12 <DIO_Read+0x50>
     ae8:	18 f4       	brcc	.+6      	; 0xaf0 <DIO_Read+0x2e>
     aea:	c1 34       	cpi	r28, 0x41	; 65
     aec:	31 f0       	breq	.+12     	; 0xafa <DIO_Read+0x38>
     aee:	39 c0       	rjmp	.+114    	; 0xb62 <DIO_Read+0xa0>
     af0:	c3 34       	cpi	r28, 0x43	; 67
     af2:	d9 f0       	breq	.+54     	; 0xb2a <DIO_Read+0x68>
     af4:	c4 34       	cpi	r28, 0x44	; 68
     af6:	29 f1       	breq	.+74     	; 0xb42 <DIO_Read+0x80>
     af8:	34 c0       	rjmp	.+104    	; 0xb62 <DIO_Read+0xa0>
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
     afa:	89 b3       	in	r24, 0x19	; 25
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	02 c0       	rjmp	.+4      	; 0xb04 <DIO_Read+0x42>
     b00:	95 95       	asr	r25
     b02:	87 95       	ror	r24
     b04:	da 95       	dec	r29
     b06:	e2 f7       	brpl	.-8      	; 0xb00 <DIO_Read+0x3e>
     b08:	81 70       	andi	r24, 0x01	; 1
     b0a:	f8 01       	movw	r30, r16
     b0c:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b0e:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
     b10:	29 c0       	rjmp	.+82     	; 0xb64 <DIO_Read+0xa2>
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
     b12:	86 b3       	in	r24, 0x16	; 22
     b14:	90 e0       	ldi	r25, 0x00	; 0
     b16:	02 c0       	rjmp	.+4      	; 0xb1c <DIO_Read+0x5a>
     b18:	95 95       	asr	r25
     b1a:	87 95       	ror	r24
     b1c:	da 95       	dec	r29
     b1e:	e2 f7       	brpl	.-8      	; 0xb18 <DIO_Read+0x56>
     b20:	81 70       	andi	r24, 0x01	; 1
     b22:	f8 01       	movw	r30, r16
     b24:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b26:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
     b28:	1d c0       	rjmp	.+58     	; 0xb64 <DIO_Read+0xa2>
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
     b2a:	83 b3       	in	r24, 0x13	; 19
     b2c:	90 e0       	ldi	r25, 0x00	; 0
     b2e:	02 c0       	rjmp	.+4      	; 0xb34 <DIO_Read+0x72>
     b30:	95 95       	asr	r25
     b32:	87 95       	ror	r24
     b34:	da 95       	dec	r29
     b36:	e2 f7       	brpl	.-8      	; 0xb30 <DIO_Read+0x6e>
     b38:	81 70       	andi	r24, 0x01	; 1
     b3a:	f8 01       	movw	r30, r16
     b3c:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b3e:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
     b40:	11 c0       	rjmp	.+34     	; 0xb64 <DIO_Read+0xa2>
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
     b42:	80 b3       	in	r24, 0x10	; 16
     b44:	90 e0       	ldi	r25, 0x00	; 0
     b46:	02 c0       	rjmp	.+4      	; 0xb4c <DIO_Read+0x8a>
     b48:	95 95       	asr	r25
     b4a:	87 95       	ror	r24
     b4c:	da 95       	dec	r29
     b4e:	e2 f7       	brpl	.-8      	; 0xb48 <DIO_Read+0x86>
     b50:	81 70       	andi	r24, 0x01	; 1
     b52:	f8 01       	movw	r30, r16
     b54:	80 83       	st	Z, r24
				break;
		}
	return DIO_OK;
     b56:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
     b58:	05 c0       	rjmp	.+10     	; 0xb64 <DIO_Read+0xa2>

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     b5a:	81 e0       	ldi	r24, 0x01	; 1
     b5c:	03 c0       	rjmp	.+6      	; 0xb64 <DIO_Read+0xa2>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     b5e:	82 e0       	ldi	r24, 0x02	; 2
     b60:	01 c0       	rjmp	.+2      	; 0xb64 <DIO_Read+0xa2>
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b62:	80 e0       	ldi	r24, 0x00	; 0
	}
     b64:	df 91       	pop	r29
     b66:	cf 91       	pop	r28
     b68:	1f 91       	pop	r17
     b6a:	0f 91       	pop	r16
     b6c:	08 95       	ret

00000b6e <DIO_toggle>:

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
     b6e:	cf 93       	push	r28
     b70:	df 93       	push	r29
     b72:	d8 2f       	mov	r29, r24
     b74:	c6 2f       	mov	r28, r22
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     b76:	0e 94 14 04 	call	0x828	; 0x828 <isValidPinNumber>
     b7a:	88 23       	and	r24, r24
     b7c:	09 f4       	brne	.+2      	; 0xb80 <DIO_toggle+0x12>
     b7e:	40 c0       	rjmp	.+128    	; 0xc00 <DIO_toggle+0x92>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     b80:	8c 2f       	mov	r24, r28
     b82:	0e 94 1a 04 	call	0x834	; 0x834 <isValidPortNumber>
     b86:	88 23       	and	r24, r24
     b88:	e9 f1       	breq	.+122    	; 0xc04 <DIO_toggle+0x96>
		return WRONG_PORT;
		}
	switch (portNumber) {
     b8a:	c2 34       	cpi	r28, 0x42	; 66
     b8c:	a9 f0       	breq	.+42     	; 0xbb8 <DIO_toggle+0x4a>
     b8e:	18 f4       	brcc	.+6      	; 0xb96 <DIO_toggle+0x28>
     b90:	c1 34       	cpi	r28, 0x41	; 65
     b92:	31 f0       	breq	.+12     	; 0xba0 <DIO_toggle+0x32>
     b94:	39 c0       	rjmp	.+114    	; 0xc08 <DIO_toggle+0x9a>
     b96:	c3 34       	cpi	r28, 0x43	; 67
     b98:	d9 f0       	breq	.+54     	; 0xbd0 <DIO_toggle+0x62>
     b9a:	c4 34       	cpi	r28, 0x44	; 68
     b9c:	29 f1       	breq	.+74     	; 0xbe8 <DIO_toggle+0x7a>
     b9e:	34 c0       	rjmp	.+104    	; 0xc08 <DIO_toggle+0x9a>
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
     ba0:	2b b3       	in	r18, 0x1b	; 27
     ba2:	81 e0       	ldi	r24, 0x01	; 1
     ba4:	90 e0       	ldi	r25, 0x00	; 0
     ba6:	02 c0       	rjmp	.+4      	; 0xbac <DIO_toggle+0x3e>
     ba8:	88 0f       	add	r24, r24
     baa:	99 1f       	adc	r25, r25
     bac:	da 95       	dec	r29
     bae:	e2 f7       	brpl	.-8      	; 0xba8 <DIO_toggle+0x3a>
     bb0:	82 27       	eor	r24, r18
     bb2:	8b bb       	out	0x1b, r24	; 27
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     bb4:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
     bb6:	29 c0       	rjmp	.+82     	; 0xc0a <DIO_toggle+0x9c>
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
     bb8:	28 b3       	in	r18, 0x18	; 24
     bba:	81 e0       	ldi	r24, 0x01	; 1
     bbc:	90 e0       	ldi	r25, 0x00	; 0
     bbe:	02 c0       	rjmp	.+4      	; 0xbc4 <DIO_toggle+0x56>
     bc0:	88 0f       	add	r24, r24
     bc2:	99 1f       	adc	r25, r25
     bc4:	da 95       	dec	r29
     bc6:	e2 f7       	brpl	.-8      	; 0xbc0 <DIO_toggle+0x52>
     bc8:	82 27       	eor	r24, r18
     bca:	88 bb       	out	0x18, r24	; 24
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     bcc:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
     bce:	1d c0       	rjmp	.+58     	; 0xc0a <DIO_toggle+0x9c>
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
     bd0:	25 b3       	in	r18, 0x15	; 21
     bd2:	81 e0       	ldi	r24, 0x01	; 1
     bd4:	90 e0       	ldi	r25, 0x00	; 0
     bd6:	02 c0       	rjmp	.+4      	; 0xbdc <DIO_toggle+0x6e>
     bd8:	88 0f       	add	r24, r24
     bda:	99 1f       	adc	r25, r25
     bdc:	da 95       	dec	r29
     bde:	e2 f7       	brpl	.-8      	; 0xbd8 <DIO_toggle+0x6a>
     be0:	82 27       	eor	r24, r18
     be2:	85 bb       	out	0x15, r24	; 21
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     be4:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
     be6:	11 c0       	rjmp	.+34     	; 0xc0a <DIO_toggle+0x9c>
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
     be8:	22 b3       	in	r18, 0x12	; 18
     bea:	81 e0       	ldi	r24, 0x01	; 1
     bec:	90 e0       	ldi	r25, 0x00	; 0
     bee:	02 c0       	rjmp	.+4      	; 0xbf4 <DIO_toggle+0x86>
     bf0:	88 0f       	add	r24, r24
     bf2:	99 1f       	adc	r25, r25
     bf4:	da 95       	dec	r29
     bf6:	e2 f7       	brpl	.-8      	; 0xbf0 <DIO_toggle+0x82>
     bf8:	82 27       	eor	r24, r18
     bfa:	82 bb       	out	0x12, r24	; 18
				break;
		}
	return DIO_OK;
     bfc:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
     bfe:	05 c0       	rjmp	.+10     	; 0xc0a <DIO_toggle+0x9c>

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     c00:	81 e0       	ldi	r24, 0x01	; 1
     c02:	03 c0       	rjmp	.+6      	; 0xc0a <DIO_toggle+0x9c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     c04:	82 e0       	ldi	r24, 0x02	; 2
     c06:	01 c0       	rjmp	.+2      	; 0xc0a <DIO_toggle+0x9c>
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     c08:	80 e0       	ldi	r24, 0x00	; 0
     c0a:	df 91       	pop	r29
     c0c:	cf 91       	pop	r28
     c0e:	08 95       	ret

00000c10 <getCurrentStatus>:

EN_I2CMasterStatusCode_t I2C_repeatedStart() {   // Same as start, just a different name
  TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  while (read_bit(TWCR, TWINT) == 0);
  return getCurrentStatus();
  }
     c10:	81 b1       	in	r24, 0x01	; 1
     c12:	e8 2f       	mov	r30, r24
     c14:	e8 7f       	andi	r30, 0xF8	; 248
     c16:	8e 2f       	mov	r24, r30
     c18:	90 e0       	ldi	r25, 0x00	; 0
     c1a:	fc 01       	movw	r30, r24
     c1c:	38 97       	sbiw	r30, 0x08	; 8
     c1e:	e1 35       	cpi	r30, 0x51	; 81
     c20:	f1 05       	cpc	r31, r1
     c22:	c0 f4       	brcc	.+48     	; 0xc54 <getCurrentStatus+0x44>
     c24:	e6 5d       	subi	r30, 0xD6	; 214
     c26:	ff 4f       	sbci	r31, 0xFF	; 255
     c28:	0c 94 73 13 	jmp	0x26e6	; 0x26e6 <__tablejump2__>
     c2c:	80 e0       	ldi	r24, 0x00	; 0
     c2e:	08 95       	ret
     c30:	82 e0       	ldi	r24, 0x02	; 2
     c32:	08 95       	ret
     c34:	83 e0       	ldi	r24, 0x03	; 3
     c36:	08 95       	ret
     c38:	84 e0       	ldi	r24, 0x04	; 4
     c3a:	08 95       	ret
     c3c:	85 e0       	ldi	r24, 0x05	; 5
     c3e:	08 95       	ret
     c40:	86 e0       	ldi	r24, 0x06	; 6
     c42:	08 95       	ret
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	08 95       	ret
     c48:	88 e0       	ldi	r24, 0x08	; 8
     c4a:	08 95       	ret
     c4c:	89 e0       	ldi	r24, 0x09	; 9
     c4e:	08 95       	ret
     c50:	8a e0       	ldi	r24, 0x0A	; 10
     c52:	08 95       	ret
     c54:	8b e0       	ldi	r24, 0x0B	; 11
     c56:	08 95       	ret
     c58:	81 e0       	ldi	r24, 0x01	; 1
     c5a:	08 95       	ret

00000c5c <I2C_init>:
     c5c:	11 b8       	out	0x01, r1	; 1
     c5e:	8f ef       	ldi	r24, 0xFF	; 255
     c60:	80 b9       	out	0x00, r24	; 0
     c62:	08 95       	ret

00000c64 <I2C_start>:
     c64:	84 ea       	ldi	r24, 0xA4	; 164
     c66:	86 bf       	out	0x36, r24	; 54
     c68:	06 b6       	in	r0, 0x36	; 54
     c6a:	07 fe       	sbrs	r0, 7
     c6c:	fd cf       	rjmp	.-6      	; 0xc68 <I2C_start+0x4>
     c6e:	0e 94 08 06 	call	0xc10	; 0xc10 <getCurrentStatus>
     c72:	08 95       	ret

00000c74 <I2C_write>:

EN_I2CMasterStatusCode_t I2C_write(u8 data) {
  TWDR = data;
     c74:	83 b9       	out	0x03, r24	; 3
  TWCR = (1 << TWEN) | (1 << TWINT);
     c76:	84 e8       	ldi	r24, 0x84	; 132
     c78:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWINT) == 0);
     c7a:	06 b6       	in	r0, 0x36	; 54
     c7c:	07 fe       	sbrs	r0, 7
     c7e:	fd cf       	rjmp	.-6      	; 0xc7a <I2C_write+0x6>
  return getCurrentStatus();
     c80:	0e 94 08 06 	call	0xc10	; 0xc10 <getCurrentStatus>
  }
     c84:	08 95       	ret

00000c86 <I2C_read_Ack>:

EN_I2CMasterStatusCode_t I2C_read_Ack(u8* data) {
  TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWINT);
     c86:	24 ec       	ldi	r18, 0xC4	; 196
     c88:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     c8a:	06 b6       	in	r0, 0x36	; 54
     c8c:	07 fe       	sbrs	r0, 7
     c8e:	fd cf       	rjmp	.-6      	; 0xc8a <I2C_read_Ack+0x4>
  *data = TWDR;
     c90:	23 b1       	in	r18, 0x03	; 3
     c92:	fc 01       	movw	r30, r24
     c94:	20 83       	st	Z, r18
  return getCurrentStatus();
     c96:	0e 94 08 06 	call	0xc10	; 0xc10 <getCurrentStatus>
  }
     c9a:	08 95       	ret

00000c9c <I2C_read_Nack>:

EN_I2CMasterStatusCode_t I2C_read_Nack(u8* data) {
  TWCR = (1 << TWEN) | (1 << TWINT);
     c9c:	24 e8       	ldi	r18, 0x84	; 132
     c9e:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     ca0:	06 b6       	in	r0, 0x36	; 54
     ca2:	07 fe       	sbrs	r0, 7
     ca4:	fd cf       	rjmp	.-6      	; 0xca0 <I2C_read_Nack+0x4>
  *data = TWDR;
     ca6:	23 b1       	in	r18, 0x03	; 3
     ca8:	fc 01       	movw	r30, r24
     caa:	20 83       	st	Z, r18
  return getCurrentStatus();
     cac:	0e 94 08 06 	call	0xc10	; 0xc10 <getCurrentStatus>
  }
     cb0:	08 95       	ret

00000cb2 <I2C_stop>:

void I2C_stop(void) {
  TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
     cb2:	84 e9       	ldi	r24, 0x94	; 148
     cb4:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWSTO));	// Wait until stop condition finishes
     cb6:	06 b6       	in	r0, 0x36	; 54
     cb8:	04 fc       	sbrc	r0, 4
     cba:	fd cf       	rjmp	.-6      	; 0xcb6 <I2C_stop+0x4>
  }
     cbc:	08 95       	ret

00000cbe <PWM_OCP_disconnect>:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  PWM_OCP_connect(pwmPin);
  return TIMER_OK;
  }
     cbe:	84 30       	cpi	r24, 0x04	; 4
     cc0:	40 f5       	brcc	.+80     	; 0xd12 <PWM_OCP_disconnect+0x54>
     cc2:	81 30       	cpi	r24, 0x01	; 1
     cc4:	71 f0       	breq	.+28     	; 0xce2 <PWM_OCP_disconnect+0x24>
     cc6:	28 f0       	brcs	.+10     	; 0xcd2 <PWM_OCP_disconnect+0x14>
     cc8:	82 30       	cpi	r24, 0x02	; 2
     cca:	99 f0       	breq	.+38     	; 0xcf2 <PWM_OCP_disconnect+0x34>
     ccc:	83 30       	cpi	r24, 0x03	; 3
     cce:	c9 f0       	breq	.+50     	; 0xd02 <PWM_OCP_disconnect+0x44>
     cd0:	22 c0       	rjmp	.+68     	; 0xd16 <PWM_OCP_disconnect+0x58>
     cd2:	83 b7       	in	r24, 0x33	; 51
     cd4:	8f 7e       	andi	r24, 0xEF	; 239
     cd6:	83 bf       	out	0x33, r24	; 51
     cd8:	83 b7       	in	r24, 0x33	; 51
     cda:	8f 7d       	andi	r24, 0xDF	; 223
     cdc:	83 bf       	out	0x33, r24	; 51
     cde:	80 e0       	ldi	r24, 0x00	; 0
     ce0:	08 95       	ret
     ce2:	8f b5       	in	r24, 0x2f	; 47
     ce4:	8f 7b       	andi	r24, 0xBF	; 191
     ce6:	8f bd       	out	0x2f, r24	; 47
     ce8:	8f b5       	in	r24, 0x2f	; 47
     cea:	8f 77       	andi	r24, 0x7F	; 127
     cec:	8f bd       	out	0x2f, r24	; 47
     cee:	80 e0       	ldi	r24, 0x00	; 0
     cf0:	08 95       	ret
     cf2:	8f b5       	in	r24, 0x2f	; 47
     cf4:	8f 7e       	andi	r24, 0xEF	; 239
     cf6:	8f bd       	out	0x2f, r24	; 47
     cf8:	8f b5       	in	r24, 0x2f	; 47
     cfa:	8f 7d       	andi	r24, 0xDF	; 223
     cfc:	8f bd       	out	0x2f, r24	; 47
     cfe:	80 e0       	ldi	r24, 0x00	; 0
     d00:	08 95       	ret
     d02:	85 b5       	in	r24, 0x25	; 37
     d04:	8f 7e       	andi	r24, 0xEF	; 239
     d06:	85 bd       	out	0x25, r24	; 37
     d08:	85 b5       	in	r24, 0x25	; 37
     d0a:	8f 7d       	andi	r24, 0xDF	; 223
     d0c:	85 bd       	out	0x25, r24	; 37
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	08 95       	ret
     d12:	87 e0       	ldi	r24, 0x07	; 7
     d14:	08 95       	ret
     d16:	80 e0       	ldi	r24, 0x00	; 0
     d18:	08 95       	ret

00000d1a <PWM_OCP_connect>:
     d1a:	84 30       	cpi	r24, 0x04	; 4
     d1c:	40 f5       	brcc	.+80     	; 0xd6e <PWM_OCP_connect+0x54>
     d1e:	81 30       	cpi	r24, 0x01	; 1
     d20:	71 f0       	breq	.+28     	; 0xd3e <PWM_OCP_connect+0x24>
     d22:	28 f0       	brcs	.+10     	; 0xd2e <PWM_OCP_connect+0x14>
     d24:	82 30       	cpi	r24, 0x02	; 2
     d26:	99 f0       	breq	.+38     	; 0xd4e <PWM_OCP_connect+0x34>
     d28:	83 30       	cpi	r24, 0x03	; 3
     d2a:	c9 f0       	breq	.+50     	; 0xd5e <PWM_OCP_connect+0x44>
     d2c:	22 c0       	rjmp	.+68     	; 0xd72 <PWM_OCP_connect+0x58>
     d2e:	83 b7       	in	r24, 0x33	; 51
     d30:	8f 7e       	andi	r24, 0xEF	; 239
     d32:	83 bf       	out	0x33, r24	; 51
     d34:	83 b7       	in	r24, 0x33	; 51
     d36:	80 62       	ori	r24, 0x20	; 32
     d38:	83 bf       	out	0x33, r24	; 51
     d3a:	80 e0       	ldi	r24, 0x00	; 0
     d3c:	08 95       	ret
     d3e:	8f b5       	in	r24, 0x2f	; 47
     d40:	8f 7b       	andi	r24, 0xBF	; 191
     d42:	8f bd       	out	0x2f, r24	; 47
     d44:	8f b5       	in	r24, 0x2f	; 47
     d46:	80 68       	ori	r24, 0x80	; 128
     d48:	8f bd       	out	0x2f, r24	; 47
     d4a:	80 e0       	ldi	r24, 0x00	; 0
     d4c:	08 95       	ret
     d4e:	8f b5       	in	r24, 0x2f	; 47
     d50:	8f 7e       	andi	r24, 0xEF	; 239
     d52:	8f bd       	out	0x2f, r24	; 47
     d54:	8f b5       	in	r24, 0x2f	; 47
     d56:	80 62       	ori	r24, 0x20	; 32
     d58:	8f bd       	out	0x2f, r24	; 47
     d5a:	80 e0       	ldi	r24, 0x00	; 0
     d5c:	08 95       	ret
     d5e:	85 b5       	in	r24, 0x25	; 37
     d60:	8f 7e       	andi	r24, 0xEF	; 239
     d62:	85 bd       	out	0x25, r24	; 37
     d64:	85 b5       	in	r24, 0x25	; 37
     d66:	80 62       	ori	r24, 0x20	; 32
     d68:	85 bd       	out	0x25, r24	; 37
     d6a:	80 e0       	ldi	r24, 0x00	; 0
     d6c:	08 95       	ret
     d6e:	87 e0       	ldi	r24, 0x07	; 7
     d70:	08 95       	ret
     d72:	80 e0       	ldi	r24, 0x00	; 0
     d74:	08 95       	ret

00000d76 <PWM_set_DC>:
    }
  return TIMER_OK;
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
     d76:	28 2f       	mov	r18, r24
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
     d78:	84 30       	cpi	r24, 0x04	; 4
     d7a:	c0 f5       	brcc	.+112    	; 0xdec <PWM_set_DC+0x76>
     d7c:	cb 01       	movw	r24, r22
     d7e:	ba 01       	movw	r22, r20
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
     d80:	21 30       	cpi	r18, 0x01	; 1
     d82:	89 f0       	breq	.+34     	; 0xda6 <PWM_set_DC+0x30>
     d84:	28 f0       	brcs	.+10     	; 0xd90 <PWM_set_DC+0x1a>
     d86:	22 30       	cpi	r18, 0x02	; 2
     d88:	d1 f0       	breq	.+52     	; 0xdbe <PWM_set_DC+0x48>
     d8a:	23 30       	cpi	r18, 0x03	; 3
     d8c:	21 f1       	breq	.+72     	; 0xdd6 <PWM_set_DC+0x60>
     d8e:	30 c0       	rjmp	.+96     	; 0xdf0 <PWM_set_DC+0x7a>
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
     d90:	20 e0       	ldi	r18, 0x00	; 0
     d92:	30 e0       	ldi	r19, 0x00	; 0
     d94:	4f e7       	ldi	r20, 0x7F	; 127
     d96:	53 e4       	ldi	r21, 0x43	; 67
     d98:	0e 94 06 13 	call	0x260c	; 0x260c <__mulsf3>
     d9c:	0e 94 49 12 	call	0x2492	; 0x2492 <__fixunssfsi>
     da0:	6c bf       	out	0x3c, r22	; 60
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     da2:	80 e0       	ldi	r24, 0x00	; 0
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
        break;
     da4:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     da6:	20 e0       	ldi	r18, 0x00	; 0
     da8:	30 e4       	ldi	r19, 0x40	; 64
     daa:	4c e9       	ldi	r20, 0x9C	; 156
     dac:	56 e4       	ldi	r21, 0x46	; 70
     dae:	0e 94 06 13 	call	0x260c	; 0x260c <__mulsf3>
     db2:	0e 94 49 12 	call	0x2492	; 0x2492 <__fixunssfsi>
     db6:	7b bd       	out	0x2b, r23	; 43
     db8:	6a bd       	out	0x2a, r22	; 42
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     dba:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1A = (u16)(dutyCycle * 65535);
#endif
        break;
     dbc:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     dbe:	20 e0       	ldi	r18, 0x00	; 0
     dc0:	30 e4       	ldi	r19, 0x40	; 64
     dc2:	4c e9       	ldi	r20, 0x9C	; 156
     dc4:	56 e4       	ldi	r21, 0x46	; 70
     dc6:	0e 94 06 13 	call	0x260c	; 0x260c <__mulsf3>
     dca:	0e 94 49 12 	call	0x2492	; 0x2492 <__fixunssfsi>
     dce:	79 bd       	out	0x29, r23	; 41
     dd0:	68 bd       	out	0x28, r22	; 40
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     dd2:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
     dd4:	08 95       	ret
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
     dd6:	20 e0       	ldi	r18, 0x00	; 0
     dd8:	30 e0       	ldi	r19, 0x00	; 0
     dda:	4f e7       	ldi	r20, 0x7F	; 127
     ddc:	53 e4       	ldi	r21, 0x43	; 67
     dde:	0e 94 06 13 	call	0x260c	; 0x260c <__mulsf3>
     de2:	0e 94 49 12 	call	0x2492	; 0x2492 <__fixunssfsi>
     de6:	63 bd       	out	0x23, r22	; 35
        break;
    }
  return TIMER_OK;
     de8:	80 e0       	ldi	r24, 0x00	; 0
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
     dea:	08 95       	ret
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
     dec:	87 e0       	ldi	r24, 0x07	; 7
     dee:	08 95       	ret
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     df0:	80 e0       	ldi	r24, 0x00	; 0
  }
     df2:	08 95       	ret

00000df4 <UART_sendChar>:
  }

// Receive a Char using UART
void UART_receiveChar(s8* x) {
  while (!read_bit(UCSRA, RXC)); // Wait for the data to be received.
  *x = UDR;
     df4:	5d 9b       	sbis	0x0b, 5	; 11
     df6:	fe cf       	rjmp	.-4      	; 0xdf4 <UART_sendChar>
     df8:	8c b9       	out	0x0c, r24	; 12
     dfa:	5e 9b       	sbis	0x0b, 6	; 11
     dfc:	fe cf       	rjmp	.-4      	; 0xdfa <UART_sendChar+0x6>
     dfe:	08 95       	ret

00000e00 <UART_sendString>:
  }

void UART_sendString(s8* str) {
     e00:	cf 92       	push	r12
     e02:	df 92       	push	r13
     e04:	ef 92       	push	r14
     e06:	ff 92       	push	r15
     e08:	cf 93       	push	r28
     e0a:	df 93       	push	r29
     e0c:	ec 01       	movw	r28, r24
  u32 i = 0;
     e0e:	c1 2c       	mov	r12, r1
     e10:	d1 2c       	mov	r13, r1
     e12:	76 01       	movw	r14, r12
  while (str[i] != 0) {
     e14:	07 c0       	rjmp	.+14     	; 0xe24 <UART_sendString+0x24>
    UART_sendChar(str[i]);
     e16:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <UART_sendChar>
    i++;
     e1a:	8f ef       	ldi	r24, 0xFF	; 255
     e1c:	c8 1a       	sub	r12, r24
     e1e:	d8 0a       	sbc	r13, r24
     e20:	e8 0a       	sbc	r14, r24
     e22:	f8 0a       	sbc	r15, r24
  *x = UDR;
  }

void UART_sendString(s8* str) {
  u32 i = 0;
  while (str[i] != 0) {
     e24:	fe 01       	movw	r30, r28
     e26:	ec 0d       	add	r30, r12
     e28:	fd 1d       	adc	r31, r13
     e2a:	80 81       	ld	r24, Z
     e2c:	81 11       	cpse	r24, r1
     e2e:	f3 cf       	rjmp	.-26     	; 0xe16 <UART_sendString+0x16>
    UART_sendChar(str[i]);
    i++;
    }
  UART_sendChar(0); // Send null to terminate the string
     e30:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <UART_sendChar>
  }
     e34:	df 91       	pop	r29
     e36:	cf 91       	pop	r28
     e38:	ff 90       	pop	r15
     e3a:	ef 90       	pop	r14
     e3c:	df 90       	pop	r13
     e3e:	cf 90       	pop	r12
     e40:	08 95       	ret

00000e42 <Door_open>:
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
  }

// Open the door by moving the servo to the open angle
void Door_open(void) {
  Servo_move_to_angle(DOOR_OPEN_ANGLE);
     e42:	84 eb       	ldi	r24, 0xB4	; 180
     e44:	0e 94 f7 03 	call	0x7ee	; 0x7ee <Servo_move_to_angle>
     e48:	08 95       	ret

00000e4a <Door_close>:
  }

// Close the door by moving the servo to the close angle
void Door_close(void) {
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
     e4a:	80 e0       	ldi	r24, 0x00	; 0
     e4c:	0e 94 f7 03 	call	0x7ee	; 0x7ee <Servo_move_to_angle>
     e50:	08 95       	ret

00000e52 <Lamp_on>:
  Timer_start(TIMER_2, LAMP_6_DIMMABLE_PRESCALAR);
  }

// Turn on a lamp
void Lamp_on(u8 lampNumber) {
  switch (lampNumber) {
     e52:	83 30       	cpi	r24, 0x03	; 3
     e54:	b1 f0       	breq	.+44     	; 0xe82 <Lamp_on+0x30>
     e56:	28 f4       	brcc	.+10     	; 0xe62 <Lamp_on+0x10>
     e58:	81 30       	cpi	r24, 0x01	; 1
     e5a:	49 f0       	breq	.+18     	; 0xe6e <Lamp_on+0x1c>
     e5c:	82 30       	cpi	r24, 0x02	; 2
     e5e:	61 f0       	breq	.+24     	; 0xe78 <Lamp_on+0x26>
     e60:	08 95       	ret
     e62:	85 30       	cpi	r24, 0x05	; 5
     e64:	c1 f0       	breq	.+48     	; 0xe96 <Lamp_on+0x44>
     e66:	90 f0       	brcs	.+36     	; 0xe8c <Lamp_on+0x3a>
     e68:	86 30       	cpi	r24, 0x06	; 6
     e6a:	d1 f0       	breq	.+52     	; 0xea0 <Lamp_on+0x4e>
     e6c:	08 95       	ret
      case LAMP_1:
        LED_on(LAMP_1_PORT, LAMP_1_PIN);
     e6e:	62 e0       	ldi	r22, 0x02	; 2
     e70:	83 e4       	ldi	r24, 0x43	; 67
     e72:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LED_on>
        break;
     e76:	08 95       	ret
      case LAMP_2:
        LED_on(LAMP_2_PORT, LAMP_2_PIN);
     e78:	63 e0       	ldi	r22, 0x03	; 3
     e7a:	83 e4       	ldi	r24, 0x43	; 67
     e7c:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LED_on>
        break;
     e80:	08 95       	ret
      case LAMP_3:
        LED_on(LAMP_3_PORT, LAMP_3_PIN);
     e82:	64 e0       	ldi	r22, 0x04	; 4
     e84:	83 e4       	ldi	r24, 0x43	; 67
     e86:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LED_on>
        break;
     e8a:	08 95       	ret
      case LAMP_4:
        LED_on(LAMP_4_PORT, LAMP_4_PIN);
     e8c:	65 e0       	ldi	r22, 0x05	; 5
     e8e:	83 e4       	ldi	r24, 0x43	; 67
     e90:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LED_on>
        break;
     e94:	08 95       	ret
      case LAMP_5:
        LED_on(LAMP_5_PORT, LAMP_5_PIN);
     e96:	66 e0       	ldi	r22, 0x06	; 6
     e98:	83 e4       	ldi	r24, 0x43	; 67
     e9a:	0e 94 dd 03 	call	0x7ba	; 0x7ba <LED_on>
        break;
     e9e:	08 95       	ret
      case LAMP_6:
        PWM_OCP_connect(LAMP_6_DIMMABLE_PWM_PIN);
     ea0:	83 e0       	ldi	r24, 0x03	; 3
     ea2:	0e 94 8d 06 	call	0xd1a	; 0xd1a <PWM_OCP_connect>
     ea6:	08 95       	ret

00000ea8 <Lamp_off>:
    }
  }

// Turn off a lamp
void Lamp_off(u8 lampNumber) {
  switch (lampNumber) {
     ea8:	83 30       	cpi	r24, 0x03	; 3
     eaa:	b1 f0       	breq	.+44     	; 0xed8 <Lamp_off+0x30>
     eac:	28 f4       	brcc	.+10     	; 0xeb8 <Lamp_off+0x10>
     eae:	81 30       	cpi	r24, 0x01	; 1
     eb0:	49 f0       	breq	.+18     	; 0xec4 <Lamp_off+0x1c>
     eb2:	82 30       	cpi	r24, 0x02	; 2
     eb4:	61 f0       	breq	.+24     	; 0xece <Lamp_off+0x26>
     eb6:	08 95       	ret
     eb8:	85 30       	cpi	r24, 0x05	; 5
     eba:	c1 f0       	breq	.+48     	; 0xeec <Lamp_off+0x44>
     ebc:	90 f0       	brcs	.+36     	; 0xee2 <Lamp_off+0x3a>
     ebe:	86 30       	cpi	r24, 0x06	; 6
     ec0:	d1 f0       	breq	.+52     	; 0xef6 <Lamp_off+0x4e>
     ec2:	08 95       	ret
      case LAMP_1:
        LED_off(LAMP_1_PORT, LAMP_1_PIN);
     ec4:	62 e0       	ldi	r22, 0x02	; 2
     ec6:	83 e4       	ldi	r24, 0x43	; 67
     ec8:	0e 94 e6 03 	call	0x7cc	; 0x7cc <LED_off>
        break;
     ecc:	08 95       	ret
      case LAMP_2:
        LED_off(LAMP_2_PORT, LAMP_2_PIN);
     ece:	63 e0       	ldi	r22, 0x03	; 3
     ed0:	83 e4       	ldi	r24, 0x43	; 67
     ed2:	0e 94 e6 03 	call	0x7cc	; 0x7cc <LED_off>
        break;
     ed6:	08 95       	ret
      case LAMP_3:
        LED_off(LAMP_3_PORT, LAMP_3_PIN);
     ed8:	64 e0       	ldi	r22, 0x04	; 4
     eda:	83 e4       	ldi	r24, 0x43	; 67
     edc:	0e 94 e6 03 	call	0x7cc	; 0x7cc <LED_off>
        break;
     ee0:	08 95       	ret
      case LAMP_4:
        LED_off(LAMP_4_PORT, LAMP_4_PIN);
     ee2:	65 e0       	ldi	r22, 0x05	; 5
     ee4:	83 e4       	ldi	r24, 0x43	; 67
     ee6:	0e 94 e6 03 	call	0x7cc	; 0x7cc <LED_off>
        break;
     eea:	08 95       	ret
      case LAMP_5:
        LED_off(LAMP_5_PORT, LAMP_5_PIN);
     eec:	66 e0       	ldi	r22, 0x06	; 6
     eee:	83 e4       	ldi	r24, 0x43	; 67
     ef0:	0e 94 e6 03 	call	0x7cc	; 0x7cc <LED_off>
        break;
     ef4:	08 95       	ret
      case LAMP_6:
        PWM_OCP_disconnect(LAMP_6_DIMMABLE_PWM_PIN);
     ef6:	83 e0       	ldi	r24, 0x03	; 3
     ef8:	0e 94 5f 06 	call	0xcbe	; 0xcbe <PWM_OCP_disconnect>
     efc:	08 95       	ret

00000efe <Lamp_toggle>:
    }
  }

// Toggle a lamp
void Lamp_toggle(u8 lampNumber) {
  switch (lampNumber) {
     efe:	83 30       	cpi	r24, 0x03	; 3
     f00:	b1 f0       	breq	.+44     	; 0xf2e <Lamp_toggle+0x30>
     f02:	28 f4       	brcc	.+10     	; 0xf0e <Lamp_toggle+0x10>
     f04:	81 30       	cpi	r24, 0x01	; 1
     f06:	49 f0       	breq	.+18     	; 0xf1a <Lamp_toggle+0x1c>
     f08:	82 30       	cpi	r24, 0x02	; 2
     f0a:	61 f0       	breq	.+24     	; 0xf24 <Lamp_toggle+0x26>
     f0c:	08 95       	ret
     f0e:	85 30       	cpi	r24, 0x05	; 5
     f10:	c1 f0       	breq	.+48     	; 0xf42 <Lamp_toggle+0x44>
     f12:	90 f0       	brcs	.+36     	; 0xf38 <Lamp_toggle+0x3a>
     f14:	86 30       	cpi	r24, 0x06	; 6
     f16:	d1 f0       	breq	.+52     	; 0xf4c <Lamp_toggle+0x4e>
     f18:	08 95       	ret
      case LAMP_1:
        LED_toggle(LAMP_1_PORT, LAMP_1_PIN);
     f1a:	62 e0       	ldi	r22, 0x02	; 2
     f1c:	83 e4       	ldi	r24, 0x43	; 67
     f1e:	0e 94 ef 03 	call	0x7de	; 0x7de <LED_toggle>
        break;
     f22:	08 95       	ret
      case LAMP_2:
        LED_toggle(LAMP_2_PORT, LAMP_2_PIN);
     f24:	63 e0       	ldi	r22, 0x03	; 3
     f26:	83 e4       	ldi	r24, 0x43	; 67
     f28:	0e 94 ef 03 	call	0x7de	; 0x7de <LED_toggle>
        break;
     f2c:	08 95       	ret
      case LAMP_3:
        LED_toggle(LAMP_3_PORT, LAMP_3_PIN);
     f2e:	64 e0       	ldi	r22, 0x04	; 4
     f30:	83 e4       	ldi	r24, 0x43	; 67
     f32:	0e 94 ef 03 	call	0x7de	; 0x7de <LED_toggle>
        break;
     f36:	08 95       	ret
      case LAMP_4:
        LED_toggle(LAMP_4_PORT, LAMP_4_PIN);
     f38:	65 e0       	ldi	r22, 0x05	; 5
     f3a:	83 e4       	ldi	r24, 0x43	; 67
     f3c:	0e 94 ef 03 	call	0x7de	; 0x7de <LED_toggle>
        break;
     f40:	08 95       	ret
      case LAMP_5:
        LED_toggle(LAMP_5_PORT, LAMP_5_PIN);
     f42:	66 e0       	ldi	r22, 0x06	; 6
     f44:	83 e4       	ldi	r24, 0x43	; 67
     f46:	0e 94 ef 03 	call	0x7de	; 0x7de <LED_toggle>
        break;
     f4a:	08 95       	ret
      case LAMP_6:
        if (read_bit(TCCR2, COM21)) { // OC pin is connected and lamp6 is on
     f4c:	05 b4       	in	r0, 0x25	; 37
     f4e:	05 fe       	sbrs	r0, 5
     f50:	04 c0       	rjmp	.+8      	; 0xf5a <Lamp_toggle+0x5c>
          Lamp_off(6);
     f52:	86 e0       	ldi	r24, 0x06	; 6
     f54:	0e 94 54 07 	call	0xea8	; 0xea8 <Lamp_off>
     f58:	08 95       	ret
          }
        else {
          Lamp_on(6);
     f5a:	86 e0       	ldi	r24, 0x06	; 6
     f5c:	0e 94 29 07 	call	0xe52	; 0xe52 <Lamp_on>
     f60:	08 95       	ret

00000f62 <Lamp_dimmable_set_brightness>:
        break;
    }
  }

// Adjust the brightness of the dimmable lamp
void Lamp_dimmable_set_brightness(double brightness) {
     f62:	ab 01       	movw	r20, r22
     f64:	bc 01       	movw	r22, r24
  PWM_set_DC(LAMP_6_DIMMABLE_PWM_PIN, brightness);
     f66:	83 e0       	ldi	r24, 0x03	; 3
     f68:	0e 94 bb 06 	call	0xd76	; 0xd76 <PWM_set_DC>
     f6c:	08 95       	ret

00000f6e <Local_access_init>:

ST_User_t local_user;

// Initialize the local control system
void Local_access_init(void) {
  LCD_init();
     f6e:	0e 94 66 03 	call	0x6cc	; 0x6cc <LCD_init>
  Keypad_init();
     f72:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <Keypad_init>
  User_DB_init();
     f76:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <User_DB_init>
     f7a:	08 95       	ret

00000f7c <Get_running_devices>:
  }

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
     f7c:	cf 93       	push	r28
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
     f7e:	c0 e0       	ldi	r28, 0x00	; 0
     f80:	0a c0       	rjmp	.+20     	; 0xf96 <Get_running_devices+0x1a>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
     f82:	4c 2f       	mov	r20, r28
     f84:	50 e0       	ldi	r21, 0x00	; 0
     f86:	47 5d       	subi	r20, 0xD7	; 215
     f88:	58 4f       	sbci	r21, 0xF8	; 248
     f8a:	63 e4       	ldi	r22, 0x43	; 67
     f8c:	82 e0       	ldi	r24, 0x02	; 2
     f8e:	8c 0f       	add	r24, r28
     f90:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_Read>

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
     f94:	cf 5f       	subi	r28, 0xFF	; 255
     f96:	c5 30       	cpi	r28, 0x05	; 5
     f98:	a0 f3       	brcs	.-24     	; 0xf82 <Get_running_devices+0x6>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
    }
  // Check the dimmable lamp
  running_devices[5] = read_bit(TCCR2, COM21); // To see if the OC pins are connected
     f9a:	85 b5       	in	r24, 0x25	; 37
     f9c:	85 fb       	bst	r24, 5
     f9e:	88 27       	eor	r24, r24
     fa0:	80 f9       	bld	r24, 0
     fa2:	80 93 2e 07 	sts	0x072E, r24	; 0x80072e <running_devices+0x5>
  // Check the AC
  DIO_Read(7, PORT_D, &running_devices[6]);
     fa6:	4f e2       	ldi	r20, 0x2F	; 47
     fa8:	57 e0       	ldi	r21, 0x07	; 7
     faa:	64 e4       	ldi	r22, 0x44	; 68
     fac:	87 e0       	ldi	r24, 0x07	; 7
     fae:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_Read>
  }
     fb2:	cf 91       	pop	r28
     fb4:	08 95       	ret

00000fb6 <Show_bottom_options_menu>:

// Shows the bottom line options on the LCD
void Show_bottom_options_menu(u8 menu) {
  switch (menu) {
     fb6:	90 e0       	ldi	r25, 0x00	; 0
     fb8:	fc 01       	movw	r30, r24
     fba:	31 97       	sbiw	r30, 0x01	; 1
     fbc:	e9 30       	cpi	r30, 0x09	; 9
     fbe:	f1 05       	cpc	r31, r1
     fc0:	08 f0       	brcs	.+2      	; 0xfc4 <Show_bottom_options_menu+0xe>
     fc2:	42 c0       	rjmp	.+132    	; 0x1048 <Show_bottom_options_menu+0x92>
     fc4:	e5 58       	subi	r30, 0x85	; 133
     fc6:	ff 4f       	sbci	r31, 0xFF	; 255
     fc8:	0c 94 73 13 	jmp	0x26e6	; 0x26e6 <__tablejump2__>
      case 1:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_1);
     fcc:	41 e7       	ldi	r20, 0x71	; 113
     fce:	50 e0       	ldi	r21, 0x00	; 0
     fd0:	61 e0       	ldi	r22, 0x01	; 1
     fd2:	80 e0       	ldi	r24, 0x00	; 0
     fd4:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
     fd8:	08 95       	ret
      case 2:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_2);
     fda:	42 e8       	ldi	r20, 0x82	; 130
     fdc:	50 e0       	ldi	r21, 0x00	; 0
     fde:	61 e0       	ldi	r22, 0x01	; 1
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
     fe6:	08 95       	ret
      case 3:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_3);
     fe8:	43 e9       	ldi	r20, 0x93	; 147
     fea:	50 e0       	ldi	r21, 0x00	; 0
     fec:	61 e0       	ldi	r22, 0x01	; 1
     fee:	80 e0       	ldi	r24, 0x00	; 0
     ff0:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
     ff4:	08 95       	ret
      case 4:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_4);
     ff6:	44 ea       	ldi	r20, 0xA4	; 164
     ff8:	50 e0       	ldi	r21, 0x00	; 0
     ffa:	61 e0       	ldi	r22, 0x01	; 1
     ffc:	80 e0       	ldi	r24, 0x00	; 0
     ffe:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    1002:	08 95       	ret
      case 5:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_5);
    1004:	45 eb       	ldi	r20, 0xB5	; 181
    1006:	50 e0       	ldi	r21, 0x00	; 0
    1008:	61 e0       	ldi	r22, 0x01	; 1
    100a:	80 e0       	ldi	r24, 0x00	; 0
    100c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    1010:	08 95       	ret
      case 6:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_6);
    1012:	46 ec       	ldi	r20, 0xC6	; 198
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	61 e0       	ldi	r22, 0x01	; 1
    1018:	80 e0       	ldi	r24, 0x00	; 0
    101a:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    101e:	08 95       	ret
      case 7:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_7);
    1020:	47 ed       	ldi	r20, 0xD7	; 215
    1022:	50 e0       	ldi	r21, 0x00	; 0
    1024:	61 e0       	ldi	r22, 0x01	; 1
    1026:	80 e0       	ldi	r24, 0x00	; 0
    1028:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    102c:	08 95       	ret
      case 8:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_8);
    102e:	48 ee       	ldi	r20, 0xE8	; 232
    1030:	50 e0       	ldi	r21, 0x00	; 0
    1032:	61 e0       	ldi	r22, 0x01	; 1
    1034:	80 e0       	ldi	r24, 0x00	; 0
    1036:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    103a:	08 95       	ret
      case 9:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_9);
    103c:	49 ef       	ldi	r20, 0xF9	; 249
    103e:	50 e0       	ldi	r21, 0x00	; 0
    1040:	61 e0       	ldi	r22, 0x01	; 1
    1042:	80 e0       	ldi	r24, 0x00	; 0
    1044:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
    1048:	08 95       	ret

0000104a <Show_side_options_menu>:
    }
  }

// Shows the side options list on the LCD
void Show_side_options_menu(void) {
  LCD_write_string_xy(12, 0, BACKSPACE_OPTION);
    104a:	4a e0       	ldi	r20, 0x0A	; 10
    104c:	51 e0       	ldi	r21, 0x01	; 1
    104e:	60 e0       	ldi	r22, 0x00	; 0
    1050:	8c e0       	ldi	r24, 0x0C	; 12
    1052:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
  LCD_write_string_xy(12, 1, ENTER_OPTION);
    1056:	4f e0       	ldi	r20, 0x0F	; 15
    1058:	51 e0       	ldi	r21, 0x01	; 1
    105a:	61 e0       	ldi	r22, 0x01	; 1
    105c:	8c e0       	ldi	r24, 0x0C	; 12
    105e:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
    1062:	08 95       	ret

00001064 <Get_devices_status>:
  }

// Updates the device status array, which has lamp 6 brightness level 
void Get_devices_status(void) {
    1064:	cf 93       	push	r28
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    1066:	c0 e0       	ldi	r28, 0x00	; 0
    1068:	0a c0       	rjmp	.+20     	; 0x107e <Get_devices_status+0x1a>
    DIO_Read(lamp + 2, PORT_C, &devices_status[lamp]);
    106a:	4c 2f       	mov	r20, r28
    106c:	50 e0       	ldi	r21, 0x00	; 0
    106e:	4d 5c       	subi	r20, 0xCD	; 205
    1070:	58 4f       	sbci	r21, 0xF8	; 248
    1072:	63 e4       	ldi	r22, 0x43	; 67
    1074:	82 e0       	ldi	r24, 0x02	; 2
    1076:	8c 0f       	add	r24, r28
    1078:	0e 94 61 05 	call	0xac2	; 0xac2 <DIO_Read>

// Updates the device status array, which has lamp 6 brightness level 
void Get_devices_status(void) {
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    107c:	cf 5f       	subi	r28, 0xFF	; 255
    107e:	c5 30       	cpi	r28, 0x05	; 5
    1080:	a0 f3       	brcs	.-24     	; 0x106a <Get_devices_status+0x6>
    DIO_Read(lamp + 2, PORT_C, &devices_status[lamp]);
    }
  devices_status[5] = (u8)(OCR1A / 200);
    1082:	2a b5       	in	r18, 0x2a	; 42
    1084:	3b b5       	in	r19, 0x2b	; 43
    1086:	36 95       	lsr	r19
    1088:	27 95       	ror	r18
    108a:	36 95       	lsr	r19
    108c:	27 95       	ror	r18
    108e:	36 95       	lsr	r19
    1090:	27 95       	ror	r18
    1092:	ab e7       	ldi	r26, 0x7B	; 123
    1094:	b4 e1       	ldi	r27, 0x14	; 20
    1096:	0e 94 79 13 	call	0x26f2	; 0x26f2 <__umulhisi3>
    109a:	96 95       	lsr	r25
    109c:	87 95       	ror	r24
    109e:	80 93 38 07 	sts	0x0738, r24	; 0x800738 <devices_status+0x5>
  }
    10a2:	cf 91       	pop	r28
    10a4:	08 95       	ret

000010a6 <Show_running_devices>:

// Shows the currently running devices with the appropriate control menu appended (Screen controls and login- no device controls)
void Show_running_devices(u8 screen) {
    10a6:	cf 93       	push	r28
    10a8:	c8 2f       	mov	r28, r24
  // Do nothing if the correct screen is shown.
  // if (screen == running_devices_screen) return;
  LCD_clear_screen();
    10aa:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
  // Write device name
  switch (screen) {
    10ae:	c7 30       	cpi	r28, 0x07	; 7
    10b0:	39 f4       	brne	.+14     	; 0x10c0 <Show_running_devices+0x1a>
      case 7:
        LCD_write_string_xy(0, 0, "AC: ");
    10b2:	44 e1       	ldi	r20, 0x14	; 20
    10b4:	51 e0       	ldi	r21, 0x01	; 1
    10b6:	60 e0       	ldi	r22, 0x00	; 0
    10b8:	80 e0       	ldi	r24, 0x00	; 0
    10ba:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        break;
    10be:	0e c0       	rjmp	.+28     	; 0x10dc <Show_running_devices+0x36>
      default:
        LCD_write_string_xy(0, 0, "Lamp");
    10c0:	49 e1       	ldi	r20, 0x19	; 25
    10c2:	51 e0       	ldi	r21, 0x01	; 1
    10c4:	60 e0       	ldi	r22, 0x00	; 0
    10c6:	80 e0       	ldi	r24, 0x00	; 0
    10c8:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
        LCD_sendData(screen + 48);
    10cc:	80 e3       	ldi	r24, 0x30	; 48
    10ce:	8c 0f       	add	r24, r28
    10d0:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
        LCD_write_string(": ");
    10d4:	8c e2       	ldi	r24, 0x2C	; 44
    10d6:	96 e0       	ldi	r25, 0x06	; 6
    10d8:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
        break;
    }
  // Write the device state
  if (running_devices[screen - 1])
    10dc:	ec 2f       	mov	r30, r28
    10de:	f0 e0       	ldi	r31, 0x00	; 0
    10e0:	e8 5d       	subi	r30, 0xD8	; 216
    10e2:	f8 4f       	sbci	r31, 0xF8	; 248
    10e4:	80 81       	ld	r24, Z
    10e6:	88 23       	and	r24, r24
    10e8:	29 f0       	breq	.+10     	; 0x10f4 <Show_running_devices+0x4e>
    LCD_write_string("On");
    10ea:	8e e1       	ldi	r24, 0x1E	; 30
    10ec:	91 e0       	ldi	r25, 0x01	; 1
    10ee:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
    10f2:	04 c0       	rjmp	.+8      	; 0x10fc <Show_running_devices+0x56>
  else
    LCD_write_string("Off");
    10f4:	81 e2       	ldi	r24, 0x21	; 33
    10f6:	91 e0       	ldi	r25, 0x01	; 1
    10f8:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
  // Show the options menu
  switch (screen) {
    10fc:	c1 30       	cpi	r28, 0x01	; 1
    10fe:	19 f0       	breq	.+6      	; 0x1106 <Show_running_devices+0x60>
    1100:	c7 30       	cpi	r28, 0x07	; 7
    1102:	29 f0       	breq	.+10     	; 0x110e <Show_running_devices+0x68>
    1104:	08 c0       	rjmp	.+16     	; 0x1116 <Show_running_devices+0x70>
      case 1:
        Show_bottom_options_menu(3);
    1106:	83 e0       	ldi	r24, 0x03	; 3
    1108:	0e 94 db 07 	call	0xfb6	; 0xfb6 <Show_bottom_options_menu>
        break;
    110c:	07 c0       	rjmp	.+14     	; 0x111c <Show_running_devices+0x76>
      case 7:
        Show_bottom_options_menu(2);
    110e:	82 e0       	ldi	r24, 0x02	; 2
    1110:	0e 94 db 07 	call	0xfb6	; 0xfb6 <Show_bottom_options_menu>
        break;
    1114:	03 c0       	rjmp	.+6      	; 0x111c <Show_running_devices+0x76>
      default:
        Show_bottom_options_menu(1);
    1116:	81 e0       	ldi	r24, 0x01	; 1
    1118:	0e 94 db 07 	call	0xfb6	; 0xfb6 <Show_bottom_options_menu>
        break;
    }
  }
    111c:	cf 91       	pop	r28
    111e:	08 95       	ret

00001120 <Show_devices_controls>:

// Shows the currently running devices with the appropriate control menu appended (Devices' controls)
void Show_devices_controls(u8 screen) {
    1120:	1f 93       	push	r17
    1122:	cf 93       	push	r28
    1124:	df 93       	push	r29
    1126:	00 d0       	rcall	.+0      	; 0x1128 <Show_devices_controls+0x8>
    1128:	00 d0       	rcall	.+0      	; 0x112a <Show_devices_controls+0xa>
    112a:	cd b7       	in	r28, 0x3d	; 61
    112c:	de b7       	in	r29, 0x3e	; 62
    112e:	18 2f       	mov	r17, r24
  // Do nothing if the correct screen is shown.
  // if (screen == control_devices_screen) return;
  LCD_clear_screen();
    1130:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
  LCD_write_string_xy(0, 0, "Lamp");
    1134:	49 e1       	ldi	r20, 0x19	; 25
    1136:	51 e0       	ldi	r21, 0x01	; 1
    1138:	60 e0       	ldi	r22, 0x00	; 0
    113a:	80 e0       	ldi	r24, 0x00	; 0
    113c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
  LCD_sendData(screen + 48);
    1140:	80 e3       	ldi	r24, 0x30	; 48
    1142:	81 0f       	add	r24, r17
    1144:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
  LCD_write_string(":  ");
    1148:	85 e2       	ldi	r24, 0x25	; 37
    114a:	91 e0       	ldi	r25, 0x01	; 1
    114c:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>

  if (screen < 6) {
    1150:	16 30       	cpi	r17, 0x06	; 6
    1152:	88 f4       	brcc	.+34     	; 0x1176 <Show_devices_controls+0x56>
    // Write the device state
    if (devices_status[screen - 1])
    1154:	e1 2f       	mov	r30, r17
    1156:	f0 e0       	ldi	r31, 0x00	; 0
    1158:	ee 5c       	subi	r30, 0xCE	; 206
    115a:	f8 4f       	sbci	r31, 0xF8	; 248
    115c:	80 81       	ld	r24, Z
    115e:	88 23       	and	r24, r24
    1160:	29 f0       	breq	.+10     	; 0x116c <Show_devices_controls+0x4c>
      LCD_write_string("On");
    1162:	8e e1       	ldi	r24, 0x1E	; 30
    1164:	91 e0       	ldi	r25, 0x01	; 1
    1166:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
    116a:	19 c0       	rjmp	.+50     	; 0x119e <Show_devices_controls+0x7e>
    else
      LCD_write_string("Off");
    116c:	81 e2       	ldi	r24, 0x21	; 33
    116e:	91 e0       	ldi	r25, 0x01	; 1
    1170:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
    1174:	14 c0       	rjmp	.+40     	; 0x119e <Show_devices_controls+0x7e>
    }
  else {
    s8 brightness[4];
    sprintf(brightness, "%d%%", devices_status[5]);
    1176:	80 91 38 07 	lds	r24, 0x0738	; 0x800738 <devices_status+0x5>
    117a:	1f 92       	push	r1
    117c:	8f 93       	push	r24
    117e:	89 e2       	ldi	r24, 0x29	; 41
    1180:	91 e0       	ldi	r25, 0x01	; 1
    1182:	9f 93       	push	r25
    1184:	8f 93       	push	r24
    1186:	ce 01       	movw	r24, r28
    1188:	01 96       	adiw	r24, 0x01	; 1
    118a:	9f 93       	push	r25
    118c:	8f 93       	push	r24
    118e:	0e 94 98 13 	call	0x2730	; 0x2730 <sprintf>
    1192:	0f 90       	pop	r0
    1194:	0f 90       	pop	r0
    1196:	0f 90       	pop	r0
    1198:	0f 90       	pop	r0
    119a:	0f 90       	pop	r0
    119c:	0f 90       	pop	r0
    }
  // Show the options menu
  switch (screen) {
    119e:	11 30       	cpi	r17, 0x01	; 1
    11a0:	19 f0       	breq	.+6      	; 0x11a8 <Show_devices_controls+0x88>
    11a2:	16 30       	cpi	r17, 0x06	; 6
    11a4:	69 f0       	breq	.+26     	; 0x11c0 <Show_devices_controls+0xa0>
    11a6:	10 c0       	rjmp	.+32     	; 0x11c8 <Show_devices_controls+0xa8>
      case 1:
        if (devices_status[0])
    11a8:	80 91 33 07 	lds	r24, 0x0733	; 0x800733 <devices_status>
    11ac:	88 23       	and	r24, r24
    11ae:	21 f0       	breq	.+8      	; 0x11b8 <Show_devices_controls+0x98>
          Show_bottom_options_menu(8);
    11b0:	88 e0       	ldi	r24, 0x08	; 8
    11b2:	0e 94 db 07 	call	0xfb6	; 0xfb6 <Show_bottom_options_menu>
    11b6:	16 c0       	rjmp	.+44     	; 0x11e4 <Show_devices_controls+0xc4>
        else
          Show_bottom_options_menu(7);
    11b8:	87 e0       	ldi	r24, 0x07	; 7
    11ba:	0e 94 db 07 	call	0xfb6	; 0xfb6 <Show_bottom_options_menu>
    11be:	12 c0       	rjmp	.+36     	; 0x11e4 <Show_devices_controls+0xc4>
        break;
      case 6:
        Show_bottom_options_menu(9);
    11c0:	89 e0       	ldi	r24, 0x09	; 9
    11c2:	0e 94 db 07 	call	0xfb6	; 0xfb6 <Show_bottom_options_menu>
        break;
    11c6:	0e c0       	rjmp	.+28     	; 0x11e4 <Show_devices_controls+0xc4>
      default:
        if (devices_status[screen - 1])
    11c8:	e1 2f       	mov	r30, r17
    11ca:	f0 e0       	ldi	r31, 0x00	; 0
    11cc:	ee 5c       	subi	r30, 0xCE	; 206
    11ce:	f8 4f       	sbci	r31, 0xF8	; 248
    11d0:	80 81       	ld	r24, Z
    11d2:	88 23       	and	r24, r24
    11d4:	21 f0       	breq	.+8      	; 0x11de <Show_devices_controls+0xbe>
          Show_bottom_options_menu(6);
    11d6:	86 e0       	ldi	r24, 0x06	; 6
    11d8:	0e 94 db 07 	call	0xfb6	; 0xfb6 <Show_bottom_options_menu>
    11dc:	03 c0       	rjmp	.+6      	; 0x11e4 <Show_devices_controls+0xc4>
        else
          Show_bottom_options_menu(5);
    11de:	85 e0       	ldi	r24, 0x05	; 5
    11e0:	0e 94 db 07 	call	0xfb6	; 0xfb6 <Show_bottom_options_menu>
        break;
    }
  }
    11e4:	0f 90       	pop	r0
    11e6:	0f 90       	pop	r0
    11e8:	0f 90       	pop	r0
    11ea:	0f 90       	pop	r0
    11ec:	df 91       	pop	r29
    11ee:	cf 91       	pop	r28
    11f0:	1f 91       	pop	r17
    11f2:	08 95       	ret

000011f4 <invalid_local_login_attempt>:

// Handles setting the alarm and halting the system when the user enters invalid credentials during login
void invalid_local_login_attempt(void) {
  invalid_trails++;
    11f4:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <__data_end>
    11f8:	8f 5f       	subi	r24, 0xFF	; 255
    11fa:	80 93 12 07 	sts	0x0712, r24	; 0x800712 <__data_end>
  if (invalid_trails < 3) {
    11fe:	83 30       	cpi	r24, 0x03	; 3
    1200:	b8 f4       	brcc	.+46     	; 0x1230 <invalid_local_login_attempt+0x3c>
    LCD_clear_screen();
    1202:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
    LCD_move_cursor_xy(0, 0);
    1206:	60 e0       	ldi	r22, 0x00	; 0
    1208:	80 e0       	ldi	r24, 0x00	; 0
    120a:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
    LCD_sendData((3 - invalid_trails) + 48);
    120e:	90 91 12 07 	lds	r25, 0x0712	; 0x800712 <__data_end>
    1212:	83 e3       	ldi	r24, 0x33	; 51
    1214:	89 1b       	sub	r24, r25
    1216:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
    LCD_write_string(" attempts");
    121a:	8e e2       	ldi	r24, 0x2E	; 46
    121c:	91 e0       	ldi	r25, 0x01	; 1
    121e:	0e 94 a6 03 	call	0x74c	; 0x74c <LCD_write_string>
    LCD_write_string_xy(0, 1, "remaining !");
    1222:	48 e3       	ldi	r20, 0x38	; 56
    1224:	51 e0       	ldi	r21, 0x01	; 1
    1226:	61 e0       	ldi	r22, 0x01	; 1
    1228:	80 e0       	ldi	r24, 0x00	; 0
    122a:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
    return;
    122e:	08 95       	ret
    }
  Alarm_set();
    1230:	0e 94 53 10 	call	0x20a6	; 0x20a6 <Alarm_set>
  run_system = false;
    1234:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
    1238:	08 95       	ret

0000123a <Local_control_input_handler>:
  }

// Used in the super loop for getting the user input and handling it.
void Local_control_input_handler(void) {
    123a:	1f 93       	push	r17
    123c:	cf 93       	push	r28
    123e:	df 93       	push	r29
    1240:	1f 92       	push	r1
    1242:	cd b7       	in	r28, 0x3d	; 61
    1244:	de b7       	in	r29, 0x3e	; 62
  u8 pressed_key;
  EN_KeypadStatusCode_t keypad_stat = Keypad_getPressedKey(&pressed_key);
    1246:	ce 01       	movw	r24, r28
    1248:	01 96       	adiw	r24, 0x01	; 1
    124a:	0e 94 8e 02 	call	0x51c	; 0x51c <Keypad_getPressedKey>
    124e:	18 2f       	mov	r17, r24
  switch (local_control_running_task) {
    1250:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <local_control_running_task>
    1254:	81 30       	cpi	r24, 0x01	; 1
    1256:	a9 f1       	breq	.+106    	; 0x12c2 <Local_control_input_handler+0x88>
    1258:	20 f0       	brcs	.+8      	; 0x1262 <Local_control_input_handler+0x28>
    125a:	82 30       	cpi	r24, 0x02	; 2
    125c:	09 f4       	brne	.+2      	; 0x1260 <Local_control_input_handler+0x26>
    125e:	2e c1       	rjmp	.+604    	; 0x14bc <Local_control_input_handler+0x282>
    1260:	ce c1       	rjmp	.+924    	; 0x15fe <Local_control_input_handler+0x3c4>
    // Show running devices
      case 0:
        Get_running_devices();
    1262:	0e 94 be 07 	call	0xf7c	; 0xf7c <Get_running_devices>
        if (running_devices_screen == 0) {  // First run
    1266:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <running_devices_screen>
    126a:	81 11       	cpse	r24, r1
    126c:	08 c0       	rjmp	.+16     	; 0x127e <Local_control_input_handler+0x44>
          Show_running_devices(1);
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	0e 94 53 08 	call	0x10a6	; 0x10a6 <Show_running_devices>
          running_devices_screen++;
    1274:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <running_devices_screen>
    1278:	8f 5f       	subi	r24, 0xFF	; 255
    127a:	80 93 67 07 	sts	0x0767, r24	; 0x800767 <running_devices_screen>
          }
        if (keypad_stat == NO_KEY_PRESSED) return;
    127e:	12 30       	cpi	r17, 0x02	; 2
    1280:	09 f4       	brne	.+2      	; 0x1284 <Local_control_input_handler+0x4a>
    1282:	bd c1       	rjmp	.+890    	; 0x15fe <Local_control_input_handler+0x3c4>
        switch (pressed_key) {
    1284:	89 81       	ldd	r24, Y+1	; 0x01
    1286:	82 33       	cpi	r24, 0x32	; 50
    1288:	61 f0       	breq	.+24     	; 0x12a2 <Local_control_input_handler+0x68>
    128a:	83 33       	cpi	r24, 0x33	; 51
    128c:	71 f0       	breq	.+28     	; 0x12aa <Local_control_input_handler+0x70>
    128e:	81 33       	cpi	r24, 0x31	; 49
    1290:	99 f4       	brne	.+38     	; 0x12b8 <Local_control_input_handler+0x7e>
            case '1':
              if (running_devices_screen > 1) running_devices_screen--;
    1292:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <running_devices_screen>
    1296:	82 30       	cpi	r24, 0x02	; 2
    1298:	78 f0       	brcs	.+30     	; 0x12b8 <Local_control_input_handler+0x7e>
    129a:	81 50       	subi	r24, 0x01	; 1
    129c:	80 93 67 07 	sts	0x0767, r24	; 0x800767 <running_devices_screen>
    12a0:	0b c0       	rjmp	.+22     	; 0x12b8 <Local_control_input_handler+0x7e>
              break;
            case '2':
              local_control_running_task = 1;
    12a2:	81 e0       	ldi	r24, 0x01	; 1
    12a4:	80 93 31 07 	sts	0x0731, r24	; 0x800731 <local_control_running_task>
              break;
    12a8:	07 c0       	rjmp	.+14     	; 0x12b8 <Local_control_input_handler+0x7e>
            case '3':
              if (running_devices_screen < 7) running_devices_screen++;
    12aa:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <running_devices_screen>
    12ae:	87 30       	cpi	r24, 0x07	; 7
    12b0:	18 f4       	brcc	.+6      	; 0x12b8 <Local_control_input_handler+0x7e>
    12b2:	8f 5f       	subi	r24, 0xFF	; 255
    12b4:	80 93 67 07 	sts	0x0767, r24	; 0x800767 <running_devices_screen>
              break;
          }
        Show_running_devices(running_devices_screen);
    12b8:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <running_devices_screen>
    12bc:	0e 94 53 08 	call	0x10a6	; 0x10a6 <Show_running_devices>
        break;
    12c0:	9e c1       	rjmp	.+828    	; 0x15fe <Local_control_input_handler+0x3c4>
        // Logging in
      case 1:
        if (keypad_stat == NO_KEY_PRESSED) return;
    12c2:	12 30       	cpi	r17, 0x02	; 2
    12c4:	09 f4       	brne	.+2      	; 0x12c8 <Local_control_input_handler+0x8e>
    12c6:	9b c1       	rjmp	.+822    	; 0x15fe <Local_control_input_handler+0x3c4>
        switch (login_stage) {
    12c8:	80 91 66 07 	lds	r24, 0x0766	; 0x800766 <login_stage>
    12cc:	88 23       	and	r24, r24
    12ce:	21 f0       	breq	.+8      	; 0x12d8 <Local_control_input_handler+0x9e>
    12d0:	81 30       	cpi	r24, 0x01	; 1
    12d2:	09 f4       	brne	.+2      	; 0x12d6 <Local_control_input_handler+0x9c>
    12d4:	69 c0       	rjmp	.+210    	; 0x13a8 <Local_control_input_handler+0x16e>
    12d6:	93 c1       	rjmp	.+806    	; 0x15fe <Local_control_input_handler+0x3c4>
          // Entering the user code
            case 0:
              if (!login_stage_started) {
    12d8:	80 91 65 07 	lds	r24, 0x0765	; 0x800765 <login_stage_started>
    12dc:	81 11       	cpse	r24, r1
    12de:	13 c0       	rjmp	.+38     	; 0x1306 <Local_control_input_handler+0xcc>
                LCD_clear_screen();
    12e0:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
                Show_side_options_menu();
    12e4:	0e 94 25 08 	call	0x104a	; 0x104a <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "User Code:");
    12e8:	44 e4       	ldi	r20, 0x44	; 68
    12ea:	51 e0       	ldi	r21, 0x01	; 1
    12ec:	60 e0       	ldi	r22, 0x00	; 0
    12ee:	80 e0       	ldi	r24, 0x00	; 0
    12f0:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    12f4:	61 e0       	ldi	r22, 0x01	; 1
    12f6:	80 e0       	ldi	r24, 0x00	; 0
    12f8:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
                login_stage_started = true;
    12fc:	81 e0       	ldi	r24, 0x01	; 1
    12fe:	80 93 65 07 	sts	0x0765, r24	; 0x800765 <login_stage_started>
                input_buffer_pointer = 0;
    1302:	10 92 32 07 	sts	0x0732, r1	; 0x800732 <input_buffer_pointer>
                }
              if (pressed_key == '-') { // Delete last input number
    1306:	89 81       	ldd	r24, Y+1	; 0x01
    1308:	8d 32       	cpi	r24, 0x2D	; 45
    130a:	a1 f4       	brne	.+40     	; 0x1334 <Local_control_input_handler+0xfa>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    130c:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <input_buffer_pointer>
    1310:	88 23       	and	r24, r24
    1312:	19 f0       	breq	.+6      	; 0x131a <Local_control_input_handler+0xe0>
    1314:	81 50       	subi	r24, 0x01	; 1
    1316:	80 93 32 07 	sts	0x0732, r24	; 0x800732 <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    131a:	47 e2       	ldi	r20, 0x27	; 39
    131c:	51 e0       	ldi	r21, 0x01	; 1
    131e:	61 e0       	ldi	r22, 0x01	; 1
    1320:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <input_buffer_pointer>
    1324:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    1328:	61 e0       	ldi	r22, 0x01	; 1
    132a:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <input_buffer_pointer>
    132e:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
    1332:	65 c1       	rjmp	.+714    	; 0x15fe <Local_control_input_handler+0x3c4>
                }
              else if (pressed_key == '=') {
    1334:	8d 33       	cpi	r24, 0x3D	; 61
    1336:	29 f5       	brne	.+74     	; 0x1382 <Local_control_input_handler+0x148>
                input_buffer[input_buffer_pointer] = 0;
    1338:	e0 91 32 07 	lds	r30, 0x0732	; 0x800732 <input_buffer_pointer>
    133c:	f0 e0       	ldi	r31, 0x00	; 0
    133e:	e7 5a       	subi	r30, 0xA7	; 167
    1340:	f8 4f       	sbci	r31, 0xF8	; 248
    1342:	10 82       	st	Z, r1
                // Validate user code
                EN_UserStatusCode_t codeExists = getUserByCode(input_buffer, &local_user);
    1344:	69 e3       	ldi	r22, 0x39	; 57
    1346:	77 e0       	ldi	r23, 0x07	; 7
    1348:	89 e5       	ldi	r24, 0x59	; 89
    134a:	97 e0       	ldi	r25, 0x07	; 7
    134c:	0e 94 ba 0f 	call	0x1f74	; 0x1f74 <getUserByCode>
                if (codeExists == USER_FOUND) {
    1350:	82 30       	cpi	r24, 0x02	; 2
    1352:	31 f4       	brne	.+12     	; 0x1360 <Local_control_input_handler+0x126>
                  login_stage_started = false;
    1354:	10 92 65 07 	sts	0x0765, r1	; 0x800765 <login_stage_started>
                  login_stage = 1;
    1358:	81 e0       	ldi	r24, 0x01	; 1
    135a:	80 93 66 07 	sts	0x0766, r24	; 0x800766 <login_stage>
    135e:	4f c1       	rjmp	.+670    	; 0x15fe <Local_control_input_handler+0x3c4>
                  }
                else {
                  LCD_clear_screen();
    1360:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    1364:	4f e4       	ldi	r20, 0x4F	; 79
    1366:	51 e0       	ldi	r21, 0x01	; 1
    1368:	60 e0       	ldi	r22, 0x00	; 0
    136a:	85 e0       	ldi	r24, 0x05	; 5
    136c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  LCD_write_string_xy(2, 1, "User Code !");
    1370:	45 e5       	ldi	r20, 0x55	; 85
    1372:	51 e0       	ldi	r21, 0x01	; 1
    1374:	61 e0       	ldi	r22, 0x01	; 1
    1376:	82 e0       	ldi	r24, 0x02	; 2
    1378:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  invalid_local_login_attempt();
    137c:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <invalid_local_login_attempt>
    1380:	3e c1       	rjmp	.+636    	; 0x15fe <Local_control_input_handler+0x3c4>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    1382:	90 ed       	ldi	r25, 0xD0	; 208
    1384:	98 0f       	add	r25, r24
    1386:	9a 30       	cpi	r25, 0x0A	; 10
    1388:	08 f0       	brcs	.+2      	; 0x138c <Local_control_input_handler+0x152>
    138a:	39 c1       	rjmp	.+626    	; 0x15fe <Local_control_input_handler+0x3c4>
                if (input_buffer_pointer < 6) {
    138c:	90 91 32 07 	lds	r25, 0x0732	; 0x800732 <input_buffer_pointer>
    1390:	96 30       	cpi	r25, 0x06	; 6
    1392:	08 f0       	brcs	.+2      	; 0x1396 <Local_control_input_handler+0x15c>
    1394:	34 c1       	rjmp	.+616    	; 0x15fe <Local_control_input_handler+0x3c4>
                  input_buffer[input_buffer_pointer] = pressed_key;
    1396:	e9 2f       	mov	r30, r25
    1398:	f0 e0       	ldi	r31, 0x00	; 0
    139a:	e7 5a       	subi	r30, 0xA7	; 167
    139c:	f8 4f       	sbci	r31, 0xF8	; 248
    139e:	80 83       	st	Z, r24
                  input_buffer_pointer++;
    13a0:	9f 5f       	subi	r25, 0xFF	; 255
    13a2:	90 93 32 07 	sts	0x0732, r25	; 0x800732 <input_buffer_pointer>
    13a6:	2b c1       	rjmp	.+598    	; 0x15fe <Local_control_input_handler+0x3c4>
                  }
                }
              break;
              //  Entering the password
            case 1:
              if (!login_stage_started) {
    13a8:	80 91 65 07 	lds	r24, 0x0765	; 0x800765 <login_stage_started>
    13ac:	81 11       	cpse	r24, r1
    13ae:	13 c0       	rjmp	.+38     	; 0x13d6 <Local_control_input_handler+0x19c>
                LCD_clear_screen();
    13b0:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
                Show_side_options_menu();
    13b4:	0e 94 25 08 	call	0x104a	; 0x104a <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "Password:");
    13b8:	41 e6       	ldi	r20, 0x61	; 97
    13ba:	51 e0       	ldi	r21, 0x01	; 1
    13bc:	60 e0       	ldi	r22, 0x00	; 0
    13be:	80 e0       	ldi	r24, 0x00	; 0
    13c0:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    13c4:	61 e0       	ldi	r22, 0x01	; 1
    13c6:	80 e0       	ldi	r24, 0x00	; 0
    13c8:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
                login_stage_started = true;
    13cc:	81 e0       	ldi	r24, 0x01	; 1
    13ce:	80 93 65 07 	sts	0x0765, r24	; 0x800765 <login_stage_started>
                input_buffer_pointer = 0;
    13d2:	10 92 32 07 	sts	0x0732, r1	; 0x800732 <input_buffer_pointer>
                }
              if (pressed_key == '-') { // Delete last input number
    13d6:	89 81       	ldd	r24, Y+1	; 0x01
    13d8:	8d 32       	cpi	r24, 0x2D	; 45
    13da:	a1 f4       	brne	.+40     	; 0x1404 <Local_control_input_handler+0x1ca>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    13dc:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <input_buffer_pointer>
    13e0:	88 23       	and	r24, r24
    13e2:	19 f0       	breq	.+6      	; 0x13ea <Local_control_input_handler+0x1b0>
    13e4:	81 50       	subi	r24, 0x01	; 1
    13e6:	80 93 32 07 	sts	0x0732, r24	; 0x800732 <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    13ea:	47 e2       	ldi	r20, 0x27	; 39
    13ec:	51 e0       	ldi	r21, 0x01	; 1
    13ee:	61 e0       	ldi	r22, 0x01	; 1
    13f0:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <input_buffer_pointer>
    13f4:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    13f8:	61 e0       	ldi	r22, 0x01	; 1
    13fa:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <input_buffer_pointer>
    13fe:	0e 94 c5 03 	call	0x78a	; 0x78a <LCD_move_cursor_xy>
    1402:	fd c0       	rjmp	.+506    	; 0x15fe <Local_control_input_handler+0x3c4>
                }
              else if (pressed_key == '=') {
    1404:	8d 33       	cpi	r24, 0x3D	; 61
    1406:	09 f0       	breq	.+2      	; 0x140a <Local_control_input_handler+0x1d0>
    1408:	46 c0       	rjmp	.+140    	; 0x1496 <Local_control_input_handler+0x25c>
                input_buffer[input_buffer_pointer] = 0;
    140a:	e0 91 32 07 	lds	r30, 0x0732	; 0x800732 <input_buffer_pointer>
    140e:	f0 e0       	ldi	r31, 0x00	; 0
    1410:	e7 5a       	subi	r30, 0xA7	; 167
    1412:	f8 4f       	sbci	r31, 0xF8	; 248
    1414:	10 82       	st	Z, r1
                // Validate user password
                if (strcmp(input_buffer, local_user.password) == 0) { // Password is correct
    1416:	6e e4       	ldi	r22, 0x4E	; 78
    1418:	77 e0       	ldi	r23, 0x07	; 7
    141a:	89 e5       	ldi	r24, 0x59	; 89
    141c:	97 e0       	ldi	r25, 0x07	; 7
    141e:	0e 94 88 13 	call	0x2710	; 0x2710 <strcmp>
    1422:	89 2b       	or	r24, r25
    1424:	39 f5       	brne	.+78     	; 0x1474 <Local_control_input_handler+0x23a>
                  login_stage_started = false;
    1426:	10 92 65 07 	sts	0x0765, r1	; 0x800765 <login_stage_started>
                  login_stage = 0;
    142a:	10 92 66 07 	sts	0x0766, r1	; 0x800766 <login_stage>
                  local_control_running_task = 2;
    142e:	82 e0       	ldi	r24, 0x02	; 2
    1430:	80 93 31 07 	sts	0x0731, r24	; 0x800731 <local_control_running_task>
                  LCD_clear_screen();
    1434:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
                  LCD_write_string_xy(4, 0, "Welcome");
    1438:	4b e6       	ldi	r20, 0x6B	; 107
    143a:	51 e0       	ldi	r21, 0x01	; 1
    143c:	60 e0       	ldi	r22, 0x00	; 0
    143e:	84 e0       	ldi	r24, 0x04	; 4
    1440:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  LCD_write_string_xy((16 - strlen(local_user.name)) / 2 - 1, 1, local_user.name);
    1444:	ea e3       	ldi	r30, 0x3A	; 58
    1446:	f7 e0       	ldi	r31, 0x07	; 7
    1448:	01 90       	ld	r0, Z+
    144a:	00 20       	and	r0, r0
    144c:	e9 f7       	brne	.-6      	; 0x1448 <Local_control_input_handler+0x20e>
    144e:	9f 01       	movw	r18, r30
    1450:	2b 53       	subi	r18, 0x3B	; 59
    1452:	37 40       	sbci	r19, 0x07	; 7
    1454:	80 e1       	ldi	r24, 0x10	; 16
    1456:	90 e0       	ldi	r25, 0x00	; 0
    1458:	82 1b       	sub	r24, r18
    145a:	93 0b       	sbc	r25, r19
    145c:	96 95       	lsr	r25
    145e:	87 95       	ror	r24
    1460:	4a e3       	ldi	r20, 0x3A	; 58
    1462:	57 e0       	ldi	r21, 0x07	; 7
    1464:	61 e0       	ldi	r22, 0x01	; 1
    1466:	81 50       	subi	r24, 0x01	; 1
    1468:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  LCD_sendData('!');
    146c:	81 e2       	ldi	r24, 0x21	; 33
    146e:	0e 94 30 03 	call	0x660	; 0x660 <LCD_sendData>
    1472:	c5 c0       	rjmp	.+394    	; 0x15fe <Local_control_input_handler+0x3c4>
                  }
                else {
                  LCD_clear_screen();
    1474:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    1478:	4f e4       	ldi	r20, 0x4F	; 79
    147a:	51 e0       	ldi	r21, 0x01	; 1
    147c:	60 e0       	ldi	r22, 0x00	; 0
    147e:	85 e0       	ldi	r24, 0x05	; 5
    1480:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  LCD_write_string_xy(3, 1, "Password !");
    1484:	43 e7       	ldi	r20, 0x73	; 115
    1486:	51 e0       	ldi	r21, 0x01	; 1
    1488:	61 e0       	ldi	r22, 0x01	; 1
    148a:	83 e0       	ldi	r24, 0x03	; 3
    148c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
                  invalid_local_login_attempt();
    1490:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <invalid_local_login_attempt>
    1494:	b4 c0       	rjmp	.+360    	; 0x15fe <Local_control_input_handler+0x3c4>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    1496:	90 ed       	ldi	r25, 0xD0	; 208
    1498:	98 0f       	add	r25, r24
    149a:	9a 30       	cpi	r25, 0x0A	; 10
    149c:	08 f0       	brcs	.+2      	; 0x14a0 <Local_control_input_handler+0x266>
    149e:	af c0       	rjmp	.+350    	; 0x15fe <Local_control_input_handler+0x3c4>
                if (input_buffer_pointer < 10) {
    14a0:	90 91 32 07 	lds	r25, 0x0732	; 0x800732 <input_buffer_pointer>
    14a4:	9a 30       	cpi	r25, 0x0A	; 10
    14a6:	08 f0       	brcs	.+2      	; 0x14aa <Local_control_input_handler+0x270>
    14a8:	aa c0       	rjmp	.+340    	; 0x15fe <Local_control_input_handler+0x3c4>
                  input_buffer[input_buffer_pointer] = pressed_key;
    14aa:	e9 2f       	mov	r30, r25
    14ac:	f0 e0       	ldi	r31, 0x00	; 0
    14ae:	e7 5a       	subi	r30, 0xA7	; 167
    14b0:	f8 4f       	sbci	r31, 0xF8	; 248
    14b2:	80 83       	st	Z, r24
                  input_buffer_pointer++;
    14b4:	9f 5f       	subi	r25, 0xFF	; 255
    14b6:	90 93 32 07 	sts	0x0732, r25	; 0x800732 <input_buffer_pointer>
    14ba:	a1 c0       	rjmp	.+322    	; 0x15fe <Local_control_input_handler+0x3c4>
              break;
          }
        break;
        // Devices control
      case 2:
        if (remote_user_loggedin && !control_permission_granted) {
    14bc:	80 91 13 07 	lds	r24, 0x0713	; 0x800713 <remote_user_loggedin>
    14c0:	88 23       	and	r24, r24
    14c2:	99 f0       	breq	.+38     	; 0x14ea <Local_control_input_handler+0x2b0>
    14c4:	80 91 68 07 	lds	r24, 0x0768	; 0x800768 <control_permission_granted>
    14c8:	81 11       	cpse	r24, r1
    14ca:	0f c0       	rjmp	.+30     	; 0x14ea <Local_control_input_handler+0x2b0>
          LCD_clear_screen();
    14cc:	0e 94 62 03 	call	0x6c4	; 0x6c4 <LCD_clear_screen>
          LCD_write_string_xy(0, 0, "Admin Permission");
    14d0:	4e e7       	ldi	r20, 0x7E	; 126
    14d2:	51 e0       	ldi	r21, 0x01	; 1
    14d4:	60 e0       	ldi	r22, 0x00	; 0
    14d6:	80 e0       	ldi	r24, 0x00	; 0
    14d8:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
          LCD_write_string_xy(3, 1, "Required !");
    14dc:	4f e8       	ldi	r20, 0x8F	; 143
    14de:	51 e0       	ldi	r21, 0x01	; 1
    14e0:	61 e0       	ldi	r22, 0x01	; 1
    14e2:	83 e0       	ldi	r24, 0x03	; 3
    14e4:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <LCD_write_string_xy>
    14e8:	8a c0       	rjmp	.+276    	; 0x15fe <Local_control_input_handler+0x3c4>
          //~ Controls can be added to allow the user to go back and view the running devices if needed.
          }
        else {
          Get_devices_status();
    14ea:	0e 94 32 08 	call	0x1064	; 0x1064 <Get_devices_status>
          if (control_devices_screen == 0) {  // First run
    14ee:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <control_devices_screen>
    14f2:	81 11       	cpse	r24, r1
    14f4:	08 c0       	rjmp	.+16     	; 0x1506 <Local_control_input_handler+0x2cc>
            Show_running_devices(1);
    14f6:	81 e0       	ldi	r24, 0x01	; 1
    14f8:	0e 94 53 08 	call	0x10a6	; 0x10a6 <Show_running_devices>
            control_devices_screen++;
    14fc:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <control_devices_screen>
    1500:	8f 5f       	subi	r24, 0xFF	; 255
    1502:	80 93 64 07 	sts	0x0764, r24	; 0x800764 <control_devices_screen>
            }
          if (keypad_stat == NO_KEY_PRESSED) return;
    1506:	12 30       	cpi	r17, 0x02	; 2
    1508:	09 f4       	brne	.+2      	; 0x150c <Local_control_input_handler+0x2d2>
    150a:	79 c0       	rjmp	.+242    	; 0x15fe <Local_control_input_handler+0x3c4>
          switch (pressed_key) {
    150c:	89 81       	ldd	r24, Y+1	; 0x01
    150e:	82 33       	cpi	r24, 0x32	; 50
    1510:	79 f0       	breq	.+30     	; 0x1530 <Local_control_input_handler+0x2f6>
    1512:	83 33       	cpi	r24, 0x33	; 51
    1514:	09 f4       	brne	.+2      	; 0x1518 <Local_control_input_handler+0x2de>
    1516:	48 c0       	rjmp	.+144    	; 0x15a8 <Local_control_input_handler+0x36e>
    1518:	81 33       	cpi	r24, 0x31	; 49
    151a:	09 f0       	breq	.+2      	; 0x151e <Local_control_input_handler+0x2e4>
    151c:	6c c0       	rjmp	.+216    	; 0x15f6 <Local_control_input_handler+0x3bc>
              case '1':
                if (control_devices_screen > 1) control_devices_screen--;
    151e:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <control_devices_screen>
    1522:	82 30       	cpi	r24, 0x02	; 2
    1524:	08 f4       	brcc	.+2      	; 0x1528 <Local_control_input_handler+0x2ee>
    1526:	67 c0       	rjmp	.+206    	; 0x15f6 <Local_control_input_handler+0x3bc>
    1528:	81 50       	subi	r24, 0x01	; 1
    152a:	80 93 64 07 	sts	0x0764, r24	; 0x800764 <control_devices_screen>
    152e:	63 c0       	rjmp	.+198    	; 0x15f6 <Local_control_input_handler+0x3bc>
                break;
              case '2':
                switch (control_devices_screen) {
    1530:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <control_devices_screen>
    1534:	86 30       	cpi	r24, 0x06	; 6
    1536:	31 f5       	brne	.+76     	; 0x1584 <Local_control_input_handler+0x34a>
                    case 6:
                      // Increment the brightness
                      // Floor the brightness
                      devices_status[5] = devices_status[5] - (devices_status[5] % LAMP_6_BRIGHTNESS_PERCENTAGE_STEP);
    1538:	e3 e3       	ldi	r30, 0x33	; 51
    153a:	f7 e0       	ldi	r31, 0x07	; 7
    153c:	85 81       	ldd	r24, Z+5	; 0x05
    153e:	9d ec       	ldi	r25, 0xCD	; 205
    1540:	89 9f       	mul	r24, r25
    1542:	81 2d       	mov	r24, r1
    1544:	11 24       	eor	r1, r1
    1546:	86 95       	lsr	r24
    1548:	86 95       	lsr	r24
    154a:	86 95       	lsr	r24
    154c:	88 0f       	add	r24, r24
    154e:	98 2f       	mov	r25, r24
    1550:	99 0f       	add	r25, r25
    1552:	99 0f       	add	r25, r25
    1554:	89 0f       	add	r24, r25
                      devices_status[5] += LAMP_6_BRIGHTNESS_PERCENTAGE_STEP;
    1556:	86 5f       	subi	r24, 0xF6	; 246
    1558:	85 83       	std	Z+5, r24	; 0x05
                      if (devices_status[5] > 100) devices_status[5] = 100;
    155a:	85 36       	cpi	r24, 0x65	; 101
    155c:	18 f0       	brcs	.+6      	; 0x1564 <Local_control_input_handler+0x32a>
    155e:	84 e6       	ldi	r24, 0x64	; 100
    1560:	80 93 38 07 	sts	0x0738, r24	; 0x800738 <devices_status+0x5>
                      Lamp_dimmable_set_brightness((double)devices_status[5] / 100.0);
    1564:	60 91 38 07 	lds	r22, 0x0738	; 0x800738 <devices_status+0x5>
    1568:	70 e0       	ldi	r23, 0x00	; 0
    156a:	80 e0       	ldi	r24, 0x00	; 0
    156c:	90 e0       	ldi	r25, 0x00	; 0
    156e:	0e 94 78 12 	call	0x24f0	; 0x24f0 <__floatunsisf>
    1572:	20 e0       	ldi	r18, 0x00	; 0
    1574:	30 e0       	ldi	r19, 0x00	; 0
    1576:	48 ec       	ldi	r20, 0xC8	; 200
    1578:	52 e4       	ldi	r21, 0x42	; 66
    157a:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__divsf3>
    157e:	0e 94 b1 07 	call	0xf62	; 0xf62 <Lamp_dimmable_set_brightness>
                      break;
    1582:	39 c0       	rjmp	.+114    	; 0x15f6 <Local_control_input_handler+0x3bc>
                    default:
                      Lamp_toggle(control_devices_screen);
    1584:	0e 94 7f 07 	call	0xefe	; 0xefe <Lamp_toggle>
                      devices_status[control_devices_screen - 1] = !devices_status[control_devices_screen - 1];
    1588:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <control_devices_screen>
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	01 97       	sbiw	r24, 0x01	; 1
    1590:	fc 01       	movw	r30, r24
    1592:	ed 5c       	subi	r30, 0xCD	; 205
    1594:	f8 4f       	sbci	r31, 0xF8	; 248
    1596:	30 81       	ld	r19, Z
    1598:	21 e0       	ldi	r18, 0x01	; 1
    159a:	31 11       	cpse	r19, r1
    159c:	20 e0       	ldi	r18, 0x00	; 0
    159e:	fc 01       	movw	r30, r24
    15a0:	ed 5c       	subi	r30, 0xCD	; 205
    15a2:	f8 4f       	sbci	r31, 0xF8	; 248
    15a4:	20 83       	st	Z, r18
                      break;
    15a6:	27 c0       	rjmp	.+78     	; 0x15f6 <Local_control_input_handler+0x3bc>
                  }
                break;
              case '3':
                switch (control_devices_screen) {
    15a8:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <control_devices_screen>
    15ac:	86 30       	cpi	r24, 0x06	; 6
    15ae:	f1 f4       	brne	.+60     	; 0x15ec <Local_control_input_handler+0x3b2>
                    case 6:
                      // Decrement the brightness
                      // Ceil the brightness
                      devices_status[5] = devices_status[5] - (devices_status[5] % LAMP_6_BRIGHTNESS_PERCENTAGE_STEP) + LAMP_6_BRIGHTNESS_PERCENTAGE_STEP;
    15b0:	e3 e3       	ldi	r30, 0x33	; 51
    15b2:	f7 e0       	ldi	r31, 0x07	; 7
    15b4:	85 81       	ldd	r24, Z+5	; 0x05
    15b6:	9d ec       	ldi	r25, 0xCD	; 205
    15b8:	89 9f       	mul	r24, r25
    15ba:	81 2d       	mov	r24, r1
    15bc:	11 24       	eor	r1, r1
    15be:	86 95       	lsr	r24
    15c0:	86 95       	lsr	r24
    15c2:	86 95       	lsr	r24
    15c4:	88 0f       	add	r24, r24
    15c6:	68 2f       	mov	r22, r24
    15c8:	66 0f       	add	r22, r22
    15ca:	66 0f       	add	r22, r22
    15cc:	68 0f       	add	r22, r24
                      devices_status[5] -= LAMP_6_BRIGHTNESS_PERCENTAGE_STEP;
    15ce:	65 83       	std	Z+5, r22	; 0x05
                      if (devices_status[5] < 0) devices_status[5] = 0;
                      Lamp_dimmable_set_brightness((double)devices_status[5] / 100.0);
    15d0:	70 e0       	ldi	r23, 0x00	; 0
    15d2:	80 e0       	ldi	r24, 0x00	; 0
    15d4:	90 e0       	ldi	r25, 0x00	; 0
    15d6:	0e 94 78 12 	call	0x24f0	; 0x24f0 <__floatunsisf>
    15da:	20 e0       	ldi	r18, 0x00	; 0
    15dc:	30 e0       	ldi	r19, 0x00	; 0
    15de:	48 ec       	ldi	r20, 0xC8	; 200
    15e0:	52 e4       	ldi	r21, 0x42	; 66
    15e2:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__divsf3>
    15e6:	0e 94 b1 07 	call	0xf62	; 0xf62 <Lamp_dimmable_set_brightness>
                      break;
    15ea:	05 c0       	rjmp	.+10     	; 0x15f6 <Local_control_input_handler+0x3bc>
                    default:
                      if (control_devices_screen < 6) control_devices_screen++;
    15ec:	86 30       	cpi	r24, 0x06	; 6
    15ee:	18 f4       	brcc	.+6      	; 0x15f6 <Local_control_input_handler+0x3bc>
    15f0:	8f 5f       	subi	r24, 0xFF	; 255
    15f2:	80 93 64 07 	sts	0x0764, r24	; 0x800764 <control_devices_screen>
                      break;
                  }
                break;
            }
          Show_devices_controls(control_devices_screen);
    15f6:	80 91 64 07 	lds	r24, 0x0764	; 0x800764 <control_devices_screen>
    15fa:	0e 94 90 08 	call	0x1120	; 0x1120 <Show_devices_controls>
          }
        break;
        break;
    }
  }
    15fe:	0f 90       	pop	r0
    1600:	df 91       	pop	r29
    1602:	cf 91       	pop	r28
    1604:	1f 91       	pop	r17
    1606:	08 95       	ret

00001608 <println_msg>:
  BT_init(baudRate);
  }

void println_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    1608:	0e 94 dd 01 	call	0x3ba	; 0x3ba <BT_sendString>
  // Send CRLF - carriage return + new line
  BT_sendString("\r\n");
    160c:	8a e9       	ldi	r24, 0x9A	; 154
    160e:	91 e0       	ldi	r25, 0x01	; 1
    1610:	0e 94 dd 01 	call	0x3ba	; 0x3ba <BT_sendString>
    1614:	08 95       	ret

00001616 <print_msg>:
  }

void print_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    1616:	0e 94 dd 01 	call	0x3ba	; 0x3ba <BT_sendString>
    161a:	08 95       	ret

0000161c <request_user_input>:
  }

void request_user_input(s8 options[4], u8 msgLength) {
    161c:	cf 93       	push	r28
    161e:	c6 2f       	mov	r28, r22
  strcpy(user_dialog_tree, options);
    1620:	bc 01       	movw	r22, r24
    1622:	85 e2       	ldi	r24, 0x25	; 37
    1624:	97 e0       	ldi	r25, 0x07	; 7
    1626:	0e 94 91 13 	call	0x2722	; 0x2722 <strcpy>
  msg_length = msgLength;
    162a:	c0 93 24 07 	sts	0x0724, r28	; 0x800724 <msg_length>
  }
    162e:	cf 91       	pop	r28
    1630:	08 95       	ret

00001632 <print_remote_control_menu>:
      }
    }
  }

void print_remote_control_menu(void) {
  println_msg("Select one of the following devices to control:\t");
    1632:	8d e9       	ldi	r24, 0x9D	; 157
    1634:	91 e0       	ldi	r25, 0x01	; 1
    1636:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
  println_msg("[1] Lamp 1");
    163a:	8e ec       	ldi	r24, 0xCE	; 206
    163c:	91 e0       	ldi	r25, 0x01	; 1
    163e:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
  println_msg("[2] Lamp 2");
    1642:	89 ed       	ldi	r24, 0xD9	; 217
    1644:	91 e0       	ldi	r25, 0x01	; 1
    1646:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
  println_msg("[3] Lamp 3");
    164a:	84 ee       	ldi	r24, 0xE4	; 228
    164c:	91 e0       	ldi	r25, 0x01	; 1
    164e:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
  println_msg("[4] Lamp 4");
    1652:	8f ee       	ldi	r24, 0xEF	; 239
    1654:	91 e0       	ldi	r25, 0x01	; 1
    1656:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
  println_msg("[5] Lamp 5");
    165a:	8a ef       	ldi	r24, 0xFA	; 250
    165c:	91 e0       	ldi	r25, 0x01	; 1
    165e:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
  println_msg("[6] Lamp 6");
    1662:	85 e0       	ldi	r24, 0x05	; 5
    1664:	92 e0       	ldi	r25, 0x02	; 2
    1666:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
  if (remote_user.isAdmin) {
    166a:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <remote_user>
    166e:	88 23       	and	r24, r24
    1670:	21 f0       	breq	.+8      	; 0x167a <print_remote_control_menu+0x48>
    println_msg("[7] The Door");
    1672:	80 e1       	ldi	r24, 0x10	; 16
    1674:	92 e0       	ldi	r25, 0x02	; 2
    1676:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    167a:	08 95       	ret

0000167c <control_device>:
  }

// TODO: Send the status of each device to the user instead of just asking him to switch the device on or off.

void control_device(void) {
  u8 option = msg_buffer[0];
    167c:	60 91 15 07 	lds	r22, 0x0715	; 0x800715 <msg_buffer>
  if (invalid_user_input || option < '0' || option > '9') {
    1680:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <invalid_user_input>
    1684:	81 11       	cpse	r24, r1
    1686:	04 c0       	rjmp	.+8      	; 0x1690 <control_device+0x14>
    1688:	60 33       	cpi	r22, 0x30	; 48
    168a:	10 f0       	brcs	.+4      	; 0x1690 <control_device+0x14>
    168c:	6a 33       	cpi	r22, 0x3A	; 58
    168e:	60 f0       	brcs	.+24     	; 0x16a8 <control_device+0x2c>
    println_msg("\r\nInvalid input!!\t");
    1690:	8d e1       	ldi	r24, 0x1D	; 29
    1692:	92 e0       	ldi	r25, 0x02	; 2
    1694:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    print_remote_control_menu();
    1698:	0e 94 19 0b 	call	0x1632	; 0x1632 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    169c:	62 e0       	ldi	r22, 0x02	; 2
    169e:	87 e9       	ldi	r24, 0x97	; 151
    16a0:	9b e0       	ldi	r25, 0x0B	; 11
    16a2:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    16a6:	08 95       	ret
    }
  else {
    if (device_number < 6) {
    16a8:	80 91 ab 07 	lds	r24, 0x07AB	; 0x8007ab <device_number>
    16ac:	86 30       	cpi	r24, 0x06	; 6
    16ae:	80 f4       	brcc	.+32     	; 0x16d0 <control_device+0x54>
      if (option == '1') {
    16b0:	61 33       	cpi	r22, 0x31	; 49
    16b2:	39 f4       	brne	.+14     	; 0x16c2 <control_device+0x46>
        Lamp_on(device_number);
    16b4:	0e 94 29 07 	call	0xe52	; 0xe52 <Lamp_on>
        println_msg("The device has been turned on!");
    16b8:	80 e3       	ldi	r24, 0x30	; 48
    16ba:	92 e0       	ldi	r25, 0x02	; 2
    16bc:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    16c0:	2e c0       	rjmp	.+92     	; 0x171e <control_device+0xa2>
        }
      else {
        Lamp_off(device_number);
    16c2:	0e 94 54 07 	call	0xea8	; 0xea8 <Lamp_off>
        println_msg("The device has been turned off!");
    16c6:	8f e4       	ldi	r24, 0x4F	; 79
    16c8:	92 e0       	ldi	r25, 0x02	; 2
    16ca:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    16ce:	27 c0       	rjmp	.+78     	; 0x171e <control_device+0xa2>
        }
      }
    else if (device_number == 6) { // Dimmable led
    16d0:	86 30       	cpi	r24, 0x06	; 6
    16d2:	b1 f4       	brne	.+44     	; 0x1700 <control_device+0x84>
      Lamp_dimmable_set_brightness(((double)(option - 48) / 9.0));
    16d4:	70 e0       	ldi	r23, 0x00	; 0
    16d6:	60 53       	subi	r22, 0x30	; 48
    16d8:	71 09       	sbc	r23, r1
    16da:	07 2e       	mov	r0, r23
    16dc:	00 0c       	add	r0, r0
    16de:	88 0b       	sbc	r24, r24
    16e0:	99 0b       	sbc	r25, r25
    16e2:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <__floatsisf>
    16e6:	20 e0       	ldi	r18, 0x00	; 0
    16e8:	30 e0       	ldi	r19, 0x00	; 0
    16ea:	40 e1       	ldi	r20, 0x10	; 16
    16ec:	51 e4       	ldi	r21, 0x41	; 65
    16ee:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__divsf3>
    16f2:	0e 94 b1 07 	call	0xf62	; 0xf62 <Lamp_dimmable_set_brightness>
      println_msg("The brightness has been adjusted!");
    16f6:	8f e6       	ldi	r24, 0x6F	; 111
    16f8:	92 e0       	ldi	r25, 0x02	; 2
    16fa:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    16fe:	0f c0       	rjmp	.+30     	; 0x171e <control_device+0xa2>
      }
    else {
      if (option == '1') {
    1700:	61 33       	cpi	r22, 0x31	; 49
    1702:	39 f4       	brne	.+14     	; 0x1712 <control_device+0x96>
        Door_open();
    1704:	0e 94 21 07 	call	0xe42	; 0xe42 <Door_open>
        println_msg("The Door is open now.");
    1708:	81 e9       	ldi	r24, 0x91	; 145
    170a:	92 e0       	ldi	r25, 0x02	; 2
    170c:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    1710:	06 c0       	rjmp	.+12     	; 0x171e <control_device+0xa2>
        }
      else {
        Door_close();
    1712:	0e 94 25 07 	call	0xe4a	; 0xe4a <Door_close>
        println_msg("The Door is closed now.");
    1716:	87 ea       	ldi	r24, 0xA7	; 167
    1718:	92 e0       	ldi	r25, 0x02	; 2
    171a:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
        }
      }
    print_remote_control_menu();
    171e:	0e 94 19 0b 	call	0x1632	; 0x1632 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    1722:	62 e0       	ldi	r22, 0x02	; 2
    1724:	87 e9       	ldi	r24, 0x97	; 151
    1726:	9b e0       	ldi	r25, 0x0B	; 11
    1728:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    172c:	08 95       	ret

0000172e <remote_control>:
    }
  }

void remote_control(void) {
    172e:	cf 93       	push	r28
  u8 option = msg_buffer[0];
    1730:	c0 91 15 07 	lds	r28, 0x0715	; 0x800715 <msg_buffer>
  if (remote_user.isAdmin) {
    1734:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <remote_user>
    1738:	88 23       	and	r24, r24
    173a:	49 f1       	breq	.+82     	; 0x178e <remote_control+0x60>
    if (invalid_user_input || option < '1' || option > '7') {
    173c:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <invalid_user_input>
    1740:	81 11       	cpse	r24, r1
    1742:	04 c0       	rjmp	.+8      	; 0x174c <remote_control+0x1e>
    1744:	c1 33       	cpi	r28, 0x31	; 49
    1746:	10 f0       	brcs	.+4      	; 0x174c <remote_control+0x1e>
    1748:	c8 33       	cpi	r28, 0x38	; 56
    174a:	60 f0       	brcs	.+24     	; 0x1764 <remote_control+0x36>
      println_msg("Invalid option!\t");
    174c:	8f eb       	ldi	r24, 0xBF	; 191
    174e:	92 e0       	ldi	r25, 0x02	; 2
    1750:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      print_remote_control_menu();
    1754:	0e 94 19 0b 	call	0x1632	; 0x1632 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    1758:	62 e0       	ldi	r22, 0x02	; 2
    175a:	87 e9       	ldi	r24, 0x97	; 151
    175c:	9b e0       	ldi	r25, 0x0B	; 11
    175e:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1762:	3d c0       	rjmp	.+122    	; 0x17de <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    1764:	80 ed       	ldi	r24, 0xD0	; 208
    1766:	92 e0       	ldi	r25, 0x02	; 2
    1768:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    176c:	86 e2       	ldi	r24, 0x26	; 38
    176e:	93 e0       	ldi	r25, 0x03	; 3
    1770:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    1774:	8f e5       	ldi	r24, 0x5F	; 95
    1776:	93 e0       	ldi	r25, 0x03	; 3
    1778:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      request_user_input(control_device, 2);
    177c:	62 e0       	ldi	r22, 0x02	; 2
    177e:	8e e3       	ldi	r24, 0x3E	; 62
    1780:	9b e0       	ldi	r25, 0x0B	; 11
    1782:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
      device_number = option - 48;
    1786:	c0 53       	subi	r28, 0x30	; 48
    1788:	c0 93 ab 07 	sts	0x07AB, r28	; 0x8007ab <device_number>
    178c:	28 c0       	rjmp	.+80     	; 0x17de <remote_control+0xb0>
      }
    }
  else {
    if (invalid_user_input || option < '1' || option > '6') {
    178e:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <invalid_user_input>
    1792:	81 11       	cpse	r24, r1
    1794:	04 c0       	rjmp	.+8      	; 0x179e <remote_control+0x70>
    1796:	c1 33       	cpi	r28, 0x31	; 49
    1798:	10 f0       	brcs	.+4      	; 0x179e <remote_control+0x70>
    179a:	c7 33       	cpi	r28, 0x37	; 55
    179c:	60 f0       	brcs	.+24     	; 0x17b6 <remote_control+0x88>
      println_msg("Invalid option!\t");
    179e:	8f eb       	ldi	r24, 0xBF	; 191
    17a0:	92 e0       	ldi	r25, 0x02	; 2
    17a2:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      print_remote_control_menu();
    17a6:	0e 94 19 0b 	call	0x1632	; 0x1632 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    17aa:	62 e0       	ldi	r22, 0x02	; 2
    17ac:	87 e9       	ldi	r24, 0x97	; 151
    17ae:	9b e0       	ldi	r25, 0x0B	; 11
    17b0:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    17b4:	14 c0       	rjmp	.+40     	; 0x17de <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    17b6:	80 ed       	ldi	r24, 0xD0	; 208
    17b8:	92 e0       	ldi	r25, 0x02	; 2
    17ba:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    17be:	86 e2       	ldi	r24, 0x26	; 38
    17c0:	93 e0       	ldi	r25, 0x03	; 3
    17c2:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    17c6:	8f e5       	ldi	r24, 0x5F	; 95
    17c8:	93 e0       	ldi	r25, 0x03	; 3
    17ca:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      request_user_input(control_device, 2);
    17ce:	62 e0       	ldi	r22, 0x02	; 2
    17d0:	8e e3       	ldi	r24, 0x3E	; 62
    17d2:	9b e0       	ldi	r25, 0x0B	; 11
    17d4:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
      device_number = option - 48;
    17d8:	c0 53       	subi	r28, 0x30	; 48
    17da:	c0 93 ab 07 	sts	0x07AB, r28	; 0x8007ab <device_number>
      }
    }
  }
    17de:	cf 91       	pop	r28
    17e0:	08 95       	ret

000017e2 <print_initial_options_menu>:

void print_initial_options_menu(void) {
  if (remote_user.isAdmin) {
    17e2:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <remote_user>
    17e6:	88 23       	and	r24, r24
    17e8:	a9 f0       	breq	.+42     	; 0x1814 <print_initial_options_menu+0x32>
    println_msg("Select one of the following options(by entering its number):\t");
    17ea:	87 e9       	ldi	r24, 0x97	; 151
    17ec:	93 e0       	ldi	r25, 0x03	; 3
    17ee:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    println_msg("[1] Add user\t");
    17f2:	85 ed       	ldi	r24, 0xD5	; 213
    17f4:	93 e0       	ldi	r25, 0x03	; 3
    17f6:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    println_msg("[2] Delete user\t");
    17fa:	83 ee       	ldi	r24, 0xE3	; 227
    17fc:	93 e0       	ldi	r25, 0x03	; 3
    17fe:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    println_msg("[3] Control a device\t");
    1802:	84 ef       	ldi	r24, 0xF4	; 244
    1804:	93 e0       	ldi	r25, 0x03	; 3
    1806:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    println_msg("[4] Log out\t");
    180a:	8a e0       	ldi	r24, 0x0A	; 10
    180c:	94 e0       	ldi	r25, 0x04	; 4
    180e:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    1812:	08 95       	ret
    }
  else {
    println_msg("Select one of the following options(by entering its number):\t");
    1814:	87 e9       	ldi	r24, 0x97	; 151
    1816:	93 e0       	ldi	r25, 0x03	; 3
    1818:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    println_msg("[1] Control a device\t");
    181c:	87 e1       	ldi	r24, 0x17	; 23
    181e:	94 e0       	ldi	r25, 0x04	; 4
    1820:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    println_msg("[2] Log out\t");
    1824:	8d e2       	ldi	r24, 0x2D	; 45
    1826:	94 e0       	ldi	r25, 0x04	; 4
    1828:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    182c:	08 95       	ret

0000182e <delete_user_prompt>:
  strcpy(user_dialog_tree, options);
  msg_length = msgLength;
  }

void delete_user_prompt(void) {
  if (invalid_user_input) {
    182e:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <invalid_user_input>
    1832:	88 23       	and	r24, r24
    1834:	61 f0       	breq	.+24     	; 0x184e <delete_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    1836:	8a e3       	ldi	r24, 0x3A	; 58
    1838:	94 e0       	ldi	r25, 0x04	; 4
    183a:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    183e:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1842:	62 e0       	ldi	r22, 0x02	; 2
    1844:	8b e4       	ldi	r24, 0x4B	; 75
    1846:	9c e0       	ldi	r25, 0x0C	; 12
    1848:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    184c:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    184e:	69 e8       	ldi	r22, 0x89	; 137
    1850:	77 e0       	ldi	r23, 0x07	; 7
    1852:	85 e1       	ldi	r24, 0x15	; 21
    1854:	97 e0       	ldi	r25, 0x07	; 7
    1856:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    185a:	83 30       	cpi	r24, 0x03	; 3
    185c:	61 f4       	brne	.+24     	; 0x1876 <delete_user_prompt+0x48>
      println_msg("\rError! User not found. Returning to the main menu...");
    185e:	80 e5       	ldi	r24, 0x50	; 80
    1860:	94 e0       	ldi	r25, 0x04	; 4
    1862:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      print_initial_options_menu();
    1866:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    186a:	62 e0       	ldi	r22, 0x02	; 2
    186c:	8b e4       	ldi	r24, 0x4B	; 75
    186e:	9c e0       	ldi	r25, 0x0C	; 12
    1870:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1874:	08 95       	ret
      }
    else {
      // Delete the user
      delete_user(&temp_user);
    1876:	89 e8       	ldi	r24, 0x89	; 137
    1878:	97 e0       	ldi	r25, 0x07	; 7
    187a:	0e 94 f7 10 	call	0x21ee	; 0x21ee <delete_user>
      println_msg("The user has been deleted successfully!\t");
    187e:	86 e8       	ldi	r24, 0x86	; 134
    1880:	94 e0       	ldi	r25, 0x04	; 4
    1882:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1886:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    188a:	62 e0       	ldi	r22, 0x02	; 2
    188c:	8b e4       	ldi	r24, 0x4B	; 75
    188e:	9c e0       	ldi	r25, 0x0C	; 12
    1890:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1894:	08 95       	ret

00001896 <initial_options_menu>:
    println_msg("[2] Log out\t");
    }
  }

void initial_options_menu() {
  if (remote_user.isAdmin) {
    1896:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <remote_user>
    189a:	88 23       	and	r24, r24
    189c:	09 f4       	brne	.+2      	; 0x18a0 <initial_options_menu+0xa>
    189e:	4b c0       	rjmp	.+150    	; 0x1936 <initial_options_menu+0xa0>
    u8 option = msg_buffer[0];
    18a0:	80 91 15 07 	lds	r24, 0x0715	; 0x800715 <msg_buffer>
    if (invalid_user_input || option < '1' || option > '4') {
    18a4:	90 91 30 07 	lds	r25, 0x0730	; 0x800730 <invalid_user_input>
    18a8:	91 11       	cpse	r25, r1
    18aa:	04 c0       	rjmp	.+8      	; 0x18b4 <initial_options_menu+0x1e>
    18ac:	81 33       	cpi	r24, 0x31	; 49
    18ae:	10 f0       	brcs	.+4      	; 0x18b4 <initial_options_menu+0x1e>
    18b0:	85 33       	cpi	r24, 0x35	; 53
    18b2:	60 f0       	brcs	.+24     	; 0x18cc <initial_options_menu+0x36>
      println_msg("Invalid option!\t");
    18b4:	8f eb       	ldi	r24, 0xBF	; 191
    18b6:	92 e0       	ldi	r25, 0x02	; 2
    18b8:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      print_initial_options_menu();
    18bc:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    18c0:	62 e0       	ldi	r22, 0x02	; 2
    18c2:	8b e4       	ldi	r24, 0x4B	; 75
    18c4:	9c e0       	ldi	r25, 0x0C	; 12
    18c6:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    18ca:	08 95       	ret
      }
    else {
      switch (option) {
    18cc:	82 33       	cpi	r24, 0x32	; 50
    18ce:	99 f0       	breq	.+38     	; 0x18f6 <initial_options_menu+0x60>
    18d0:	18 f4       	brcc	.+6      	; 0x18d8 <initial_options_menu+0x42>
    18d2:	81 33       	cpi	r24, 0x31	; 49
    18d4:	31 f0       	breq	.+12     	; 0x18e2 <initial_options_menu+0x4c>
    18d6:	08 95       	ret
    18d8:	83 33       	cpi	r24, 0x33	; 51
    18da:	b9 f0       	breq	.+46     	; 0x190a <initial_options_menu+0x74>
    18dc:	84 33       	cpi	r24, 0x34	; 52
    18de:	e9 f0       	breq	.+58     	; 0x191a <initial_options_menu+0x84>
    18e0:	08 95       	ret
          case '1':
            print_msg("Enter the user name: ");
    18e2:	8f ea       	ldi	r24, 0xAF	; 175
    18e4:	94 e0       	ldi	r25, 0x04	; 4
    18e6:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
            request_user_input(add_user_prompt, 13);
    18ea:	6d e0       	ldi	r22, 0x0D	; 13
    18ec:	8d e4       	ldi	r24, 0x4D	; 77
    18ee:	9d e0       	ldi	r25, 0x0D	; 13
    18f0:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
            break;
    18f4:	08 95       	ret
          case '2':
            print_msg("Enter the user name: ");
    18f6:	8f ea       	ldi	r24, 0xAF	; 175
    18f8:	94 e0       	ldi	r25, 0x04	; 4
    18fa:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
            request_user_input(delete_user_prompt, 13);
    18fe:	6d e0       	ldi	r22, 0x0D	; 13
    1900:	87 e1       	ldi	r24, 0x17	; 23
    1902:	9c e0       	ldi	r25, 0x0C	; 12
    1904:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
            break;
    1908:	08 95       	ret
          case '3':
            print_remote_control_menu();
    190a:	0e 94 19 0b 	call	0x1632	; 0x1632 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    190e:	62 e0       	ldi	r22, 0x02	; 2
    1910:	87 e9       	ldi	r24, 0x97	; 151
    1912:	9b e0       	ldi	r25, 0x0B	; 11
    1914:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
            break;
    1918:	08 95       	ret
          case '4':
            remote_user_loggedin = true;
    191a:	81 e0       	ldi	r24, 0x01	; 1
    191c:	80 93 13 07 	sts	0x0713, r24	; 0x800713 <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    1920:	85 ec       	ldi	r24, 0xC5	; 197
    1922:	94 e0       	ldi	r25, 0x04	; 4
    1924:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
            println_msg("You have successfully logged out...");
    1928:	8d e0       	ldi	r24, 0x0D	; 13
    192a:	95 e0       	ldi	r25, 0x05	; 5
    192c:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
            msg_length = 0;
    1930:	10 92 24 07 	sts	0x0724, r1	; 0x800724 <msg_length>
            break;
    1934:	08 95       	ret
        }
      }
    }
  else {
    u8 option = msg_buffer[0];
    1936:	80 91 15 07 	lds	r24, 0x0715	; 0x800715 <msg_buffer>
    if (invalid_user_input || option < '1' || option > '2') {
    193a:	90 91 30 07 	lds	r25, 0x0730	; 0x800730 <invalid_user_input>
    193e:	91 11       	cpse	r25, r1
    1940:	04 c0       	rjmp	.+8      	; 0x194a <initial_options_menu+0xb4>
    1942:	81 33       	cpi	r24, 0x31	; 49
    1944:	10 f0       	brcs	.+4      	; 0x194a <initial_options_menu+0xb4>
    1946:	83 33       	cpi	r24, 0x33	; 51
    1948:	60 f0       	brcs	.+24     	; 0x1962 <initial_options_menu+0xcc>
      println_msg("Invalid option!\t");
    194a:	8f eb       	ldi	r24, 0xBF	; 191
    194c:	92 e0       	ldi	r25, 0x02	; 2
    194e:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      print_initial_options_menu();
    1952:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1956:	62 e0       	ldi	r22, 0x02	; 2
    1958:	8b e4       	ldi	r24, 0x4B	; 75
    195a:	9c e0       	ldi	r25, 0x0C	; 12
    195c:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1960:	08 95       	ret
      }
    else {
      switch (option) {
    1962:	81 33       	cpi	r24, 0x31	; 49
    1964:	19 f0       	breq	.+6      	; 0x196c <initial_options_menu+0xd6>
    1966:	82 33       	cpi	r24, 0x32	; 50
    1968:	49 f0       	breq	.+18     	; 0x197c <initial_options_menu+0xe6>
    196a:	08 95       	ret
          case '1':
            print_remote_control_menu();
    196c:	0e 94 19 0b 	call	0x1632	; 0x1632 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    1970:	62 e0       	ldi	r22, 0x02	; 2
    1972:	87 e9       	ldi	r24, 0x97	; 151
    1974:	9b e0       	ldi	r25, 0x0B	; 11
    1976:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
            break;
    197a:	08 95       	ret
          case '2':
            remote_user_loggedin = true;
    197c:	81 e0       	ldi	r24, 0x01	; 1
    197e:	80 93 13 07 	sts	0x0713, r24	; 0x800713 <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    1982:	85 ec       	ldi	r24, 0xC5	; 197
    1984:	94 e0       	ldi	r25, 0x04	; 4
    1986:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
            println_msg("You have successfully logged out...");
    198a:	8d e0       	ldi	r24, 0x0D	; 13
    198c:	95 e0       	ldi	r25, 0x05	; 5
    198e:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
            msg_length = 0;
    1992:	10 92 24 07 	sts	0x0724, r1	; 0x800724 <msg_length>
    1996:	08 95       	ret

00001998 <add_user_isAdmin_prompt>:
      }
    }
  }

void add_user_isAdmin_prompt(void) {
  if (invalid_user_input) {
    1998:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <invalid_user_input>
    199c:	88 23       	and	r24, r24
    199e:	61 f0       	breq	.+24     	; 0x19b8 <add_user_isAdmin_prompt+0x20>
    println_msg("\r\nInvalid input!!\t");
    19a0:	8d e1       	ldi	r24, 0x1D	; 29
    19a2:	92 e0       	ldi	r25, 0x02	; 2
    19a4:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    //! The system should ask the user wether he wants to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    19a8:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    19ac:	62 e0       	ldi	r22, 0x02	; 2
    19ae:	8b e4       	ldi	r24, 0x4B	; 75
    19b0:	9c e0       	ldi	r25, 0x0C	; 12
    19b2:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    19b6:	08 95       	ret
    }
  else {
    new_user.isAdmin = (msg_buffer[0] == 'y' || msg_buffer[0] == 'Y');
    19b8:	80 91 15 07 	lds	r24, 0x0715	; 0x800715 <msg_buffer>
    19bc:	89 37       	cpi	r24, 0x79	; 121
    19be:	21 f0       	breq	.+8      	; 0x19c8 <add_user_isAdmin_prompt+0x30>
    19c0:	89 35       	cpi	r24, 0x59	; 89
    19c2:	21 f4       	brne	.+8      	; 0x19cc <add_user_isAdmin_prompt+0x34>
    19c4:	81 e0       	ldi	r24, 0x01	; 1
    19c6:	03 c0       	rjmp	.+6      	; 0x19ce <add_user_isAdmin_prompt+0x36>
    19c8:	81 e0       	ldi	r24, 0x01	; 1
    19ca:	01 c0       	rjmp	.+2      	; 0x19ce <add_user_isAdmin_prompt+0x36>
    19cc:	80 e0       	ldi	r24, 0x00	; 0
    19ce:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <new_user>
    add_user(&new_user);
    19d2:	8c ea       	ldi	r24, 0xAC	; 172
    19d4:	97 e0       	ldi	r25, 0x07	; 7
    19d6:	0e 94 bc 10 	call	0x2178	; 0x2178 <add_user>
    println_msg("User has been added successfully!");
    19da:	81 e3       	ldi	r24, 0x31	; 49
    19dc:	95 e0       	ldi	r25, 0x05	; 5
    19de:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    //! Return to the main menu
    print_initial_options_menu();
    19e2:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    19e6:	62 e0       	ldi	r22, 0x02	; 2
    19e8:	8b e4       	ldi	r24, 0x4B	; 75
    19ea:	9c e0       	ldi	r25, 0x0C	; 12
    19ec:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    19f0:	08 95       	ret

000019f2 <add_user_password_prompt>:
    }
  }

void add_user_password_prompt(void) {
  if (invalid_user_input) {
    19f2:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <invalid_user_input>
    19f6:	88 23       	and	r24, r24
    19f8:	61 f0       	breq	.+24     	; 0x1a12 <add_user_password_prompt+0x20>
    println_msg("\r\nPassword too long!!\t");
    19fa:	83 e5       	ldi	r24, 0x53	; 83
    19fc:	95 e0       	ldi	r25, 0x05	; 5
    19fe:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1a02:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1a06:	62 e0       	ldi	r22, 0x02	; 2
    1a08:	8b e4       	ldi	r24, 0x4B	; 75
    1a0a:	9c e0       	ldi	r25, 0x0C	; 12
    1a0c:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1a10:	08 95       	ret
    }
  else {
    strcpy(new_user.password, msg_buffer);
    1a12:	65 e1       	ldi	r22, 0x15	; 21
    1a14:	77 e0       	ldi	r23, 0x07	; 7
    1a16:	81 ec       	ldi	r24, 0xC1	; 193
    1a18:	97 e0       	ldi	r25, 0x07	; 7
    1a1a:	0e 94 91 13 	call	0x2722	; 0x2722 <strcpy>
    print_msg("Do you want to make the new user an admin? (y/n) ");
    1a1e:	8a e6       	ldi	r24, 0x6A	; 106
    1a20:	95 e0       	ldi	r25, 0x05	; 5
    1a22:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
    request_user_input(add_user_isAdmin_prompt, 2);
    1a26:	62 e0       	ldi	r22, 0x02	; 2
    1a28:	8c ec       	ldi	r24, 0xCC	; 204
    1a2a:	9c e0       	ldi	r25, 0x0C	; 12
    1a2c:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1a30:	08 95       	ret

00001a32 <add_user_code_prompt>:
    }
  }

void add_user_code_prompt(void) {
  if (invalid_user_input) {
    1a32:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <invalid_user_input>
    1a36:	88 23       	and	r24, r24
    1a38:	61 f0       	breq	.+24     	; 0x1a52 <add_user_code_prompt+0x20>
    println_msg("\r\nInvalid user code!\t");
    1a3a:	8c e9       	ldi	r24, 0x9C	; 156
    1a3c:	95 e0       	ldi	r25, 0x05	; 5
    1a3e:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1a42:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1a46:	62 e0       	ldi	r22, 0x02	; 2
    1a48:	8b e4       	ldi	r24, 0x4B	; 75
    1a4a:	9c e0       	ldi	r25, 0x0C	; 12
    1a4c:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1a50:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByCode(msg_buffer, &temp_user);
    1a52:	69 e8       	ldi	r22, 0x89	; 137
    1a54:	77 e0       	ldi	r23, 0x07	; 7
    1a56:	85 e1       	ldi	r24, 0x15	; 21
    1a58:	97 e0       	ldi	r25, 0x07	; 7
    1a5a:	0e 94 ba 0f 	call	0x1f74	; 0x1f74 <getUserByCode>
    if (userExists == USER_NOT_FOUND) {
    1a5e:	83 30       	cpi	r24, 0x03	; 3
    1a60:	81 f4       	brne	.+32     	; 0x1a82 <add_user_code_prompt+0x50>
      strcpy(new_user.code, msg_buffer);
    1a62:	65 e1       	ldi	r22, 0x15	; 21
    1a64:	77 e0       	ldi	r23, 0x07	; 7
    1a66:	8a eb       	ldi	r24, 0xBA	; 186
    1a68:	97 e0       	ldi	r25, 0x07	; 7
    1a6a:	0e 94 91 13 	call	0x2722	; 0x2722 <strcpy>
      print_msg("Enter the new user's password: ");
    1a6e:	82 eb       	ldi	r24, 0xB2	; 178
    1a70:	95 e0       	ldi	r25, 0x05	; 5
    1a72:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
      request_user_input(add_user_password_prompt, 11);
    1a76:	6b e0       	ldi	r22, 0x0B	; 11
    1a78:	89 ef       	ldi	r24, 0xF9	; 249
    1a7a:	9c e0       	ldi	r25, 0x0C	; 12
    1a7c:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1a80:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      println_msg("\rThe user code already exists!\t");
    1a82:	82 ed       	ldi	r24, 0xD2	; 210
    1a84:	95 e0       	ldi	r25, 0x05	; 5
    1a86:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1a8a:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1a8e:	62 e0       	ldi	r22, 0x02	; 2
    1a90:	8b e4       	ldi	r24, 0x4B	; 75
    1a92:	9c e0       	ldi	r25, 0x0C	; 12
    1a94:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1a98:	08 95       	ret

00001a9a <add_user_prompt>:
      }
    }
  }

void add_user_prompt(void) {
  if (invalid_user_input) {
    1a9a:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <invalid_user_input>
    1a9e:	88 23       	and	r24, r24
    1aa0:	61 f0       	breq	.+24     	; 0x1aba <add_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    1aa2:	8a e3       	ldi	r24, 0x3A	; 58
    1aa4:	94 e0       	ldi	r25, 0x04	; 4
    1aa6:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1aaa:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1aae:	62 e0       	ldi	r22, 0x02	; 2
    1ab0:	8b e4       	ldi	r24, 0x4B	; 75
    1ab2:	9c e0       	ldi	r25, 0x0C	; 12
    1ab4:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1ab8:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    1aba:	69 e8       	ldi	r22, 0x89	; 137
    1abc:	77 e0       	ldi	r23, 0x07	; 7
    1abe:	85 e1       	ldi	r24, 0x15	; 21
    1ac0:	97 e0       	ldi	r25, 0x07	; 7
    1ac2:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    1ac6:	83 30       	cpi	r24, 0x03	; 3
    1ac8:	81 f4       	brne	.+32     	; 0x1aea <add_user_prompt+0x50>
      strcpy(new_user.name, msg_buffer);
    1aca:	65 e1       	ldi	r22, 0x15	; 21
    1acc:	77 e0       	ldi	r23, 0x07	; 7
    1ace:	8d ea       	ldi	r24, 0xAD	; 173
    1ad0:	97 e0       	ldi	r25, 0x07	; 7
    1ad2:	0e 94 91 13 	call	0x2722	; 0x2722 <strcpy>
      print_msg("Enter the new user's code(must be a unique six digit code): ");
    1ad6:	82 ef       	ldi	r24, 0xF2	; 242
    1ad8:	95 e0       	ldi	r25, 0x05	; 5
    1ada:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
      request_user_input(add_user_code_prompt, 7);
    1ade:	67 e0       	ldi	r22, 0x07	; 7
    1ae0:	89 e1       	ldi	r24, 0x19	; 25
    1ae2:	9d e0       	ldi	r25, 0x0D	; 13
    1ae4:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1ae8:	08 95       	ret
      }
    else {
      // Prompt the user to enter the user code
      println_msg("\rThe user already exists!\t");
    1aea:	8f e2       	ldi	r24, 0x2F	; 47
    1aec:	96 e0       	ldi	r25, 0x06	; 6
    1aee:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1af2:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1af6:	62 e0       	ldi	r22, 0x02	; 2
    1af8:	8b e4       	ldi	r24, 0x4B	; 75
    1afa:	9c e0       	ldi	r25, 0x0C	; 12
    1afc:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1b00:	08 95       	ret

00001b02 <invalid_remote_login_attempt>:
      }
    }
  }

void invalid_remote_login_attempt(void) {
    1b02:	0f 93       	push	r16
    1b04:	1f 93       	push	r17
    1b06:	cf 93       	push	r28
    1b08:	df 93       	push	r29
    1b0a:	cd b7       	in	r28, 0x3d	; 61
    1b0c:	de b7       	in	r29, 0x3e	; 62
    1b0e:	e2 97       	sbiw	r28, 0x32	; 50
    1b10:	0f b6       	in	r0, 0x3f	; 63
    1b12:	f8 94       	cli
    1b14:	de bf       	out	0x3e, r29	; 62
    1b16:	0f be       	out	0x3f, r0	; 63
    1b18:	cd bf       	out	0x3d, r28	; 61
  invalid_trails++;
    1b1a:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <__data_end>
    1b1e:	8f 5f       	subi	r24, 0xFF	; 255
    1b20:	80 93 12 07 	sts	0x0712, r24	; 0x800712 <__data_end>
  if (invalid_trails < 3) {
    1b24:	83 30       	cpi	r24, 0x03	; 3
    1b26:	e8 f4       	brcc	.+58     	; 0x1b62 <invalid_remote_login_attempt+0x60>
    s8 msg[50];
    sprintf(msg, "\r\nInvalid login attempt! \r\n%d attempts remaining.", 3 - invalid_trails);
    1b28:	23 e0       	ldi	r18, 0x03	; 3
    1b2a:	30 e0       	ldi	r19, 0x00	; 0
    1b2c:	a9 01       	movw	r20, r18
    1b2e:	48 1b       	sub	r20, r24
    1b30:	51 09       	sbc	r21, r1
    1b32:	ca 01       	movw	r24, r20
    1b34:	9f 93       	push	r25
    1b36:	4f 93       	push	r20
    1b38:	8a e4       	ldi	r24, 0x4A	; 74
    1b3a:	96 e0       	ldi	r25, 0x06	; 6
    1b3c:	9f 93       	push	r25
    1b3e:	8f 93       	push	r24
    1b40:	8e 01       	movw	r16, r28
    1b42:	0f 5f       	subi	r16, 0xFF	; 255
    1b44:	1f 4f       	sbci	r17, 0xFF	; 255
    1b46:	1f 93       	push	r17
    1b48:	0f 93       	push	r16
    1b4a:	0e 94 98 13 	call	0x2730	; 0x2730 <sprintf>
    println_msg(msg);
    1b4e:	c8 01       	movw	r24, r16
    1b50:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
    1b54:	0f 90       	pop	r0
    1b56:	0f 90       	pop	r0
    1b58:	0f 90       	pop	r0
    1b5a:	0f 90       	pop	r0
    1b5c:	0f 90       	pop	r0
    1b5e:	0f 90       	pop	r0
    1b60:	04 c0       	rjmp	.+8      	; 0x1b6a <invalid_remote_login_attempt+0x68>
    return;
    }
  Alarm_set();
    1b62:	0e 94 53 10 	call	0x20a6	; 0x20a6 <Alarm_set>
  run_system = false;
    1b66:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
  }
    1b6a:	e2 96       	adiw	r28, 0x32	; 50
    1b6c:	0f b6       	in	r0, 0x3f	; 63
    1b6e:	f8 94       	cli
    1b70:	de bf       	out	0x3e, r29	; 62
    1b72:	0f be       	out	0x3f, r0	; 63
    1b74:	cd bf       	out	0x3d, r28	; 61
    1b76:	df 91       	pop	r29
    1b78:	cf 91       	pop	r28
    1b7a:	1f 91       	pop	r17
    1b7c:	0f 91       	pop	r16
    1b7e:	08 95       	ret

00001b80 <userPassword_prompt_handler>:

void userPassword_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    1b80:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <invalid_user_input>
    1b84:	88 23       	and	r24, r24
    1b86:	61 f0       	breq	.+24     	; 0x1ba0 <userPassword_prompt_handler+0x20>
    invalid_remote_login_attempt();
    1b88:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <invalid_remote_login_attempt>
    print_msg("Enter your password:\t");
    1b8c:	8c e7       	ldi	r24, 0x7C	; 124
    1b8e:	96 e0       	ldi	r25, 0x06	; 6
    1b90:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
    request_user_input(userPassword_prompt_handler, 11);
    1b94:	6b e0       	ldi	r22, 0x0B	; 11
    1b96:	80 ec       	ldi	r24, 0xC0	; 192
    1b98:	9d e0       	ldi	r25, 0x0D	; 13
    1b9a:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1b9e:	08 95       	ret
    }
  else {
    if (strcmp(remote_user.password, msg_buffer)) { // Wrong password
    1ba0:	65 e1       	ldi	r22, 0x15	; 21
    1ba2:	77 e0       	ldi	r23, 0x07	; 7
    1ba4:	8e e7       	ldi	r24, 0x7E	; 126
    1ba6:	97 e0       	ldi	r25, 0x07	; 7
    1ba8:	0e 94 88 13 	call	0x2710	; 0x2710 <strcmp>
    1bac:	89 2b       	or	r24, r25
    1bae:	81 f0       	breq	.+32     	; 0x1bd0 <userPassword_prompt_handler+0x50>
      print_msg("Wrong password!");
    1bb0:	82 e9       	ldi	r24, 0x92	; 146
    1bb2:	96 e0       	ldi	r25, 0x06	; 6
    1bb4:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
      invalid_remote_login_attempt();
    1bb8:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <invalid_remote_login_attempt>
      print_msg("Enter your password:\t");
    1bbc:	8c e7       	ldi	r24, 0x7C	; 124
    1bbe:	96 e0       	ldi	r25, 0x06	; 6
    1bc0:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    1bc4:	6b e0       	ldi	r22, 0x0B	; 11
    1bc6:	80 ec       	ldi	r24, 0xC0	; 192
    1bc8:	9d e0       	ldi	r25, 0x0D	; 13
    1bca:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1bce:	08 95       	ret
      }
    else {
      remote_user_loggedin = true;
    1bd0:	81 e0       	ldi	r24, 0x01	; 1
    1bd2:	80 93 13 07 	sts	0x0713, r24	; 0x800713 <remote_user_loggedin>
      print_msg("Welcome ");
    1bd6:	82 ea       	ldi	r24, 0xA2	; 162
    1bd8:	96 e0       	ldi	r25, 0x06	; 6
    1bda:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
      print_msg(remote_user.name);
    1bde:	8a e6       	ldi	r24, 0x6A	; 106
    1be0:	97 e0       	ldi	r25, 0x07	; 7
    1be2:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
      println_msg("!");
    1be6:	88 e9       	ldi	r24, 0x98	; 152
    1be8:	91 e0       	ldi	r25, 0x01	; 1
    1bea:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
      // Show the options menu
      print_initial_options_menu();
    1bee:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1bf2:	62 e0       	ldi	r22, 0x02	; 2
    1bf4:	8b e4       	ldi	r24, 0x4B	; 75
    1bf6:	9c e0       	ldi	r25, 0x0C	; 12
    1bf8:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1bfc:	08 95       	ret

00001bfe <userName_prompt_handler>:
    }
  }

void userName_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    1bfe:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <invalid_user_input>
    1c02:	88 23       	and	r24, r24
    1c04:	61 f0       	breq	.+24     	; 0x1c1e <userName_prompt_handler+0x20>
    invalid_remote_login_attempt();
    1c06:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <invalid_remote_login_attempt>
    print_msg("Enter your user name:\t");
    1c0a:	8b ea       	ldi	r24, 0xAB	; 171
    1c0c:	96 e0       	ldi	r25, 0x06	; 6
    1c0e:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
    request_user_input(userName_prompt_handler, 13);
    1c12:	6d e0       	ldi	r22, 0x0D	; 13
    1c14:	8f ef       	ldi	r24, 0xFF	; 255
    1c16:	9d e0       	ldi	r25, 0x0D	; 13
    1c18:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1c1c:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &remote_user);
    1c1e:	69 e6       	ldi	r22, 0x69	; 105
    1c20:	77 e0       	ldi	r23, 0x07	; 7
    1c22:	85 e1       	ldi	r24, 0x15	; 21
    1c24:	97 e0       	ldi	r25, 0x07	; 7
    1c26:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    1c2a:	83 30       	cpi	r24, 0x03	; 3
    1c2c:	81 f4       	brne	.+32     	; 0x1c4e <userName_prompt_handler+0x50>
      print_msg("User doesn't exist!");
    1c2e:	82 ec       	ldi	r24, 0xC2	; 194
    1c30:	96 e0       	ldi	r25, 0x06	; 6
    1c32:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
      invalid_remote_login_attempt();
    1c36:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <invalid_remote_login_attempt>
      print_msg("Enter your user name:\t");
    1c3a:	8b ea       	ldi	r24, 0xAB	; 171
    1c3c:	96 e0       	ldi	r25, 0x06	; 6
    1c3e:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
      request_user_input(userName_prompt_handler, 13);
    1c42:	6d e0       	ldi	r22, 0x0D	; 13
    1c44:	8f ef       	ldi	r24, 0xFF	; 255
    1c46:	9d e0       	ldi	r25, 0x0D	; 13
    1c48:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1c4c:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      print_msg("Enter your password:\t");
    1c4e:	8c e7       	ldi	r24, 0x7C	; 124
    1c50:	96 e0       	ldi	r25, 0x06	; 6
    1c52:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    1c56:	6b e0       	ldi	r22, 0x0B	; 11
    1c58:	80 ec       	ldi	r24, 0xC0	; 192
    1c5a:	9d e0       	ldi	r25, 0x0D	; 13
    1c5c:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1c60:	08 95       	ret

00001c62 <remote_login_prompt>:
      }
    }
  }

void remote_login_prompt(void) {
  println_msg("Welcome to the Smart Home System!");
    1c62:	86 ed       	ldi	r24, 0xD6	; 214
    1c64:	96 e0       	ldi	r25, 0x06	; 6
    1c66:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
  println_msg("To proceed, please login.");
    1c6a:	88 ef       	ldi	r24, 0xF8	; 248
    1c6c:	96 e0       	ldi	r25, 0x06	; 6
    1c6e:	0e 94 04 0b 	call	0x1608	; 0x1608 <println_msg>
  print_msg("Enter your user name:\t");
    1c72:	8b ea       	ldi	r24, 0xAB	; 171
    1c74:	96 e0       	ldi	r25, 0x06	; 6
    1c76:	0e 94 0b 0b 	call	0x1616	; 0x1616 <print_msg>
  request_user_input(userName_prompt_handler, 13);
    1c7a:	6d e0       	ldi	r22, 0x0D	; 13
    1c7c:	8f ef       	ldi	r24, 0xFF	; 255
    1c7e:	9d e0       	ldi	r25, 0x0D	; 13
    1c80:	0e 94 0e 0b 	call	0x161c	; 0x161c <request_user_input>
    1c84:	08 95       	ret

00001c86 <__vector_13>:
  }

// Handles the user input asynchronously.
ISR(USART_RXC_vect) {
    1c86:	1f 92       	push	r1
    1c88:	0f 92       	push	r0
    1c8a:	0f b6       	in	r0, 0x3f	; 63
    1c8c:	0f 92       	push	r0
    1c8e:	11 24       	eor	r1, r1
    1c90:	2f 93       	push	r18
    1c92:	3f 93       	push	r19
    1c94:	4f 93       	push	r20
    1c96:	5f 93       	push	r21
    1c98:	6f 93       	push	r22
    1c9a:	7f 93       	push	r23
    1c9c:	8f 93       	push	r24
    1c9e:	9f 93       	push	r25
    1ca0:	af 93       	push	r26
    1ca2:	bf 93       	push	r27
    1ca4:	ef 93       	push	r30
    1ca6:	ff 93       	push	r31
#if UART_COMMUNICATION_INTERFACE ==  PROTEUS_VIRTUAL_TERMINAL
  // Read the UDR to clear the RXC bit
  udr_temp = UDR;
    1ca8:	8c b1       	in	r24, 0x0c	; 12
    1caa:	80 93 aa 07 	sts	0x07AA, r24	; 0x8007aa <udr_temp>

  // If no input requested, ignore the input. No input requested is indicated by msg length of zero
  if (msg_length == 0) return;
    1cae:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <msg_length>
    1cb2:	99 23       	and	r25, r25
    1cb4:	09 f4       	brne	.+2      	; 0x1cb8 <__vector_13+0x32>
    1cb6:	4d c0       	rjmp	.+154    	; 0x1d52 <__vector_13+0xcc>

  // Handling backspaces
  if (udr_temp == '\b') {
    1cb8:	88 30       	cpi	r24, 0x08	; 8
    1cba:	59 f4       	brne	.+22     	; 0x1cd2 <__vector_13+0x4c>
    if (msg_buffer_pointer > 0) {
    1cbc:	90 91 14 07 	lds	r25, 0x0714	; 0x800714 <msg_buffer_pointer>
    1cc0:	99 23       	and	r25, r25
    1cc2:	09 f4       	brne	.+2      	; 0x1cc6 <__vector_13+0x40>
    1cc4:	46 c0       	rjmp	.+140    	; 0x1d52 <__vector_13+0xcc>
      msg_buffer_pointer--;
    1cc6:	91 50       	subi	r25, 0x01	; 1
    1cc8:	90 93 14 07 	sts	0x0714, r25	; 0x800714 <msg_buffer_pointer>
      BT_sendChar(udr_temp);
    1ccc:	0e 94 da 01 	call	0x3b4	; 0x3b4 <BT_sendChar>
    1cd0:	40 c0       	rjmp	.+128    	; 0x1d52 <__vector_13+0xcc>
      }
    return;
    }

  msg_buffer[msg_buffer_pointer] = udr_temp;
    1cd2:	90 91 14 07 	lds	r25, 0x0714	; 0x800714 <msg_buffer_pointer>
    1cd6:	e9 2f       	mov	r30, r25
    1cd8:	f0 e0       	ldi	r31, 0x00	; 0
    1cda:	eb 5e       	subi	r30, 0xEB	; 235
    1cdc:	f8 4f       	sbci	r31, 0xF8	; 248
    1cde:	80 83       	st	Z, r24
  msg_buffer_pointer++;
    1ce0:	9f 5f       	subi	r25, 0xFF	; 255
    1ce2:	90 93 14 07 	sts	0x0714, r25	; 0x800714 <msg_buffer_pointer>

  // Msg is empty
  // Ignore null msgs
  if (msg_buffer_pointer == 1) {
    1ce6:	91 30       	cpi	r25, 0x01	; 1
    1ce8:	39 f4       	brne	.+14     	; 0x1cf8 <__vector_13+0x72>
    if (msg_buffer[0] == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1cea:	90 91 15 07 	lds	r25, 0x0715	; 0x800715 <msg_buffer>
    1cee:	9d 30       	cpi	r25, 0x0D	; 13
    1cf0:	19 f4       	brne	.+6      	; 0x1cf8 <__vector_13+0x72>
      msg_buffer_pointer = 0;
    1cf2:	10 92 14 07 	sts	0x0714, r1	; 0x800714 <msg_buffer_pointer>
      return;
    1cf6:	2d c0       	rjmp	.+90     	; 0x1d52 <__vector_13+0xcc>
      }
    }

  // Echo the sent char on the terminal
  //! Proteus virtual terminal doesn't send a line feed char (ASCII code: 10). Instead it sends a carriage return (ASCII code: 13).
  if (udr_temp != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER)
    1cf8:	8d 30       	cpi	r24, 0x0D	; 13
    1cfa:	11 f0       	breq	.+4      	; 0x1d00 <__vector_13+0x7a>
    BT_sendChar(udr_temp);
    1cfc:	0e 94 da 01 	call	0x3b4	; 0x3b4 <BT_sendChar>

  // Msg is longer than required
  if (msg_buffer_pointer == msg_length) {
    1d00:	e0 91 14 07 	lds	r30, 0x0714	; 0x800714 <msg_buffer_pointer>
    1d04:	80 91 24 07 	lds	r24, 0x0724	; 0x800724 <msg_length>
    1d08:	e8 13       	cpse	r30, r24
    1d0a:	10 c0       	rjmp	.+32     	; 0x1d2c <__vector_13+0xa6>
    if (msg_buffer[msg_buffer_pointer - 1] != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1d0c:	f0 e0       	ldi	r31, 0x00	; 0
    1d0e:	ec 5e       	subi	r30, 0xEC	; 236
    1d10:	f8 4f       	sbci	r31, 0xF8	; 248
    1d12:	80 81       	ld	r24, Z
    1d14:	8d 30       	cpi	r24, 0x0D	; 13
    1d16:	51 f0       	breq	.+20     	; 0x1d2c <__vector_13+0xa6>
      invalid_user_input = true;
    1d18:	81 e0       	ldi	r24, 0x01	; 1
    1d1a:	80 93 30 07 	sts	0x0730, r24	; 0x800730 <invalid_user_input>
      dump_invalid_data = true;
    1d1e:	80 93 a9 07 	sts	0x07A9, r24	; 0x8007a9 <dump_invalid_data>
      msg_buffer_pointer = 0;
    1d22:	10 92 14 07 	sts	0x0714, r1	; 0x800714 <msg_buffer_pointer>
      BT_sendChar('\r');
    1d26:	8d e0       	ldi	r24, 0x0D	; 13
    1d28:	0e 94 da 01 	call	0x3b4	; 0x3b4 <BT_sendChar>
      Remote_control_interface(user_dialog_tree);
      }
    }

  // Msg has ended and is within the required length
  if (udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1d2c:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <udr_temp>
    1d30:	8d 30       	cpi	r24, 0x0D	; 13
    1d32:	79 f4       	brne	.+30     	; 0x1d52 <__vector_13+0xcc>
    if (msg_buffer_pointer <= msg_length) {
    1d34:	e0 91 14 07 	lds	r30, 0x0714	; 0x800714 <msg_buffer_pointer>
    1d38:	80 91 24 07 	lds	r24, 0x0724	; 0x800724 <msg_length>
    1d3c:	8e 17       	cp	r24, r30
    1d3e:	48 f0       	brcs	.+18     	; 0x1d52 <__vector_13+0xcc>
      // Replace the carriage return with null to terminate the string correctly
      msg_buffer[msg_buffer_pointer - 1] = '\0';
    1d40:	f0 e0       	ldi	r31, 0x00	; 0
    1d42:	ec 5e       	subi	r30, 0xEC	; 236
    1d44:	f8 4f       	sbci	r31, 0xF8	; 248
    1d46:	10 82       	st	Z, r1
      BT_sendChar('\r');
    1d48:	8d e0       	ldi	r24, 0x0D	; 13
    1d4a:	0e 94 da 01 	call	0x3b4	; 0x3b4 <BT_sendChar>
      Remote_control_interface(user_dialog_tree);
      msg_buffer_pointer = 0;
    1d4e:	10 92 14 07 	sts	0x0714, r1	; 0x800714 <msg_buffer_pointer>
      Remote_control_interface(user_dialog_tree);
      msg_buffer_pointer = 0;
      }
    }
#endif
  }
    1d52:	ff 91       	pop	r31
    1d54:	ef 91       	pop	r30
    1d56:	bf 91       	pop	r27
    1d58:	af 91       	pop	r26
    1d5a:	9f 91       	pop	r25
    1d5c:	8f 91       	pop	r24
    1d5e:	7f 91       	pop	r23
    1d60:	6f 91       	pop	r22
    1d62:	5f 91       	pop	r21
    1d64:	4f 91       	pop	r20
    1d66:	3f 91       	pop	r19
    1d68:	2f 91       	pop	r18
    1d6a:	0f 90       	pop	r0
    1d6c:	0f be       	out	0x3f, r0	; 63
    1d6e:	0f 90       	pop	r0
    1d70:	1f 90       	pop	r1
    1d72:	18 95       	reti

00001d74 <__vector_1>:

ISR(INT0_vect) {
    1d74:	1f 92       	push	r1
    1d76:	0f 92       	push	r0
    1d78:	0f b6       	in	r0, 0x3f	; 63
    1d7a:	0f 92       	push	r0
    1d7c:	11 24       	eor	r1, r1
    1d7e:	2f 93       	push	r18
    1d80:	3f 93       	push	r19
    1d82:	4f 93       	push	r20
    1d84:	5f 93       	push	r21
    1d86:	6f 93       	push	r22
    1d88:	7f 93       	push	r23
    1d8a:	8f 93       	push	r24
    1d8c:	9f 93       	push	r25
    1d8e:	af 93       	push	r26
    1d90:	bf 93       	push	r27
    1d92:	ef 93       	push	r30
    1d94:	ff 93       	push	r31
  // Initialize communication with the user
  // Request user login credentials
  remote_login_prompt();
    1d96:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <remote_login_prompt>
  }
    1d9a:	ff 91       	pop	r31
    1d9c:	ef 91       	pop	r30
    1d9e:	bf 91       	pop	r27
    1da0:	af 91       	pop	r26
    1da2:	9f 91       	pop	r25
    1da4:	8f 91       	pop	r24
    1da6:	7f 91       	pop	r23
    1da8:	6f 91       	pop	r22
    1daa:	5f 91       	pop	r21
    1dac:	4f 91       	pop	r20
    1dae:	3f 91       	pop	r19
    1db0:	2f 91       	pop	r18
    1db2:	0f 90       	pop	r0
    1db4:	0f be       	out	0x3f, r0	; 63
    1db6:	0f 90       	pop	r0
    1db8:	1f 90       	pop	r1
    1dba:	18 95       	reti

00001dbc <__vector_16>:
#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_BY_ACTIVATING_TIMER0_OVF_INT
// To reset the TOV0 flag. Alternatively, it can be reset in the ADC complete interrupt.
ISR(TIMER0_OVF_vect) {}
#endif

ISR(ADC_vect) {
    1dbc:	1f 92       	push	r1
    1dbe:	0f 92       	push	r0
    1dc0:	0f b6       	in	r0, 0x3f	; 63
    1dc2:	0f 92       	push	r0
    1dc4:	11 24       	eor	r1, r1
    1dc6:	2f 93       	push	r18
    1dc8:	3f 93       	push	r19
    1dca:	4f 93       	push	r20
    1dcc:	5f 93       	push	r21
    1dce:	6f 93       	push	r22
    1dd0:	7f 93       	push	r23
    1dd2:	8f 93       	push	r24
    1dd4:	9f 93       	push	r25
    1dd6:	af 93       	push	r26
    1dd8:	bf 93       	push	r27
    1dda:	cf 93       	push	r28
    1ddc:	df 93       	push	r29
    1dde:	ef 93       	push	r30
    1de0:	ff 93       	push	r31
  u16 temperature;
  temperature = ADCL + (ADCH << 8);
    1de2:	84 b1       	in	r24, 0x04	; 4
    1de4:	c5 b1       	in	r28, 0x05	; 5
    1de6:	d0 e0       	ldi	r29, 0x00	; 0
    1de8:	dc 2f       	mov	r29, r28
    1dea:	cc 27       	eor	r28, r28
    1dec:	c8 0f       	add	r28, r24
    1dee:	d1 1d       	adc	r29, r1
  // Since the ADC is set to use the internal VREF of 2.56 V, the resolution of the ADC is 2.5 mV. This resolution allows to measure the temperature
  // out of the LM35 with a resolution of 0.25 degree celsius, since each 10mV  increment on the LM35 output is 1 degree C.
  // If the temperature is higher than the maximum specified temperature, turn on the AC.
  if (temperature > AMBIENT_HIGH_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, HIGH);
    1df0:	c1 37       	cpi	r28, 0x71	; 113
    1df2:	d1 05       	cpc	r29, r1
    1df4:	28 f0       	brcs	.+10     	; 0x1e00 <__vector_16+0x44>
    1df6:	41 e0       	ldi	r20, 0x01	; 1
    1df8:	63 e4       	ldi	r22, 0x43	; 67
    1dfa:	87 e0       	ldi	r24, 0x07	; 7
    1dfc:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>
  // If the temperature became below the minimum specified temperature turn off the AC.
  if (temperature < AMBIENT_LOW_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, LOW);
    1e00:	c4 35       	cpi	r28, 0x54	; 84
    1e02:	d1 05       	cpc	r29, r1
    1e04:	28 f4       	brcc	.+10     	; 0x1e10 <__vector_16+0x54>
    1e06:	40 e0       	ldi	r20, 0x00	; 0
    1e08:	63 e4       	ldi	r22, 0x43	; 67
    1e0a:	87 e0       	ldi	r24, 0x07	; 7
    1e0c:	0e 94 c7 04 	call	0x98e	; 0x98e <DIO_write>

#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_VIA_ADC_COMPLETE_INTERRUPT
  // Since the ADC is configured in auto trigger mode with timer 0 overflow as the trigger, 
  // The overflow interrupt flag bit must be cleared by software if timer 0 overflow interrupt isn't used. 
  // Otherwise the triggering won't work and the ADC will halt.
  set_bit(TIFR, TOV0);
    1e10:	88 b7       	in	r24, 0x38	; 56
    1e12:	81 60       	ori	r24, 0x01	; 1
    1e14:	88 bf       	out	0x38, r24	; 56
#endif
    1e16:	ff 91       	pop	r31
    1e18:	ef 91       	pop	r30
    1e1a:	df 91       	pop	r29
    1e1c:	cf 91       	pop	r28
    1e1e:	bf 91       	pop	r27
    1e20:	af 91       	pop	r26
    1e22:	9f 91       	pop	r25
    1e24:	8f 91       	pop	r24
    1e26:	7f 91       	pop	r23
    1e28:	6f 91       	pop	r22
    1e2a:	5f 91       	pop	r21
    1e2c:	4f 91       	pop	r20
    1e2e:	3f 91       	pop	r19
    1e30:	2f 91       	pop	r18
    1e32:	0f 90       	pop	r0
    1e34:	0f be       	out	0x3f, r0	; 63
    1e36:	0f 90       	pop	r0
    1e38:	1f 90       	pop	r1
    1e3a:	18 95       	reti

00001e3c <User_DB_init>:
    return getUserByName(user_code_or_name, user);
    }
  else {
    return getUserByCode(user_code_or_name, user);
    }
  }
    1e3c:	0e 94 ac 00 	call	0x158	; 0x158 <EEPROM_init>
    1e40:	08 95       	ret

00001e42 <getUserByName>:
    1e42:	9f 92       	push	r9
    1e44:	af 92       	push	r10
    1e46:	bf 92       	push	r11
    1e48:	cf 92       	push	r12
    1e4a:	df 92       	push	r13
    1e4c:	ef 92       	push	r14
    1e4e:	ff 92       	push	r15
    1e50:	0f 93       	push	r16
    1e52:	1f 93       	push	r17
    1e54:	cf 93       	push	r28
    1e56:	df 93       	push	r29
    1e58:	cd b7       	in	r28, 0x3d	; 61
    1e5a:	de b7       	in	r29, 0x3e	; 62
    1e5c:	6d 97       	sbiw	r28, 0x1d	; 29
    1e5e:	0f b6       	in	r0, 0x3f	; 63
    1e60:	f8 94       	cli
    1e62:	de bf       	out	0x3e, r29	; 62
    1e64:	0f be       	out	0x3f, r0	; 63
    1e66:	cd bf       	out	0x3d, r28	; 61
    1e68:	7c 01       	movw	r14, r24
    1e6a:	6b 01       	movw	r12, r22
    1e6c:	91 2c       	mov	r9, r1
    1e6e:	6b c0       	rjmp	.+214    	; 0x1f46 <getUserByName+0x104>
    1e70:	ae 01       	movw	r20, r28
    1e72:	4f 5f       	subi	r20, 0xFF	; 255
    1e74:	5f 4f       	sbci	r21, 0xFF	; 255
    1e76:	60 e0       	ldi	r22, 0x00	; 0
    1e78:	89 2d       	mov	r24, r9
    1e7a:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    1e7e:	ae 01       	movw	r20, r28
    1e80:	4e 5f       	subi	r20, 0xFE	; 254
    1e82:	5f 4f       	sbci	r21, 0xFF	; 255
    1e84:	61 e0       	ldi	r22, 0x01	; 1
    1e86:	89 2d       	mov	r24, r9
    1e88:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    1e8c:	b1 2c       	mov	r11, r1
    1e8e:	56 c0       	rjmp	.+172    	; 0x1f3c <getUserByName+0xfa>
    1e90:	89 81       	ldd	r24, Y+1	; 0x01
    1e92:	90 e0       	ldi	r25, 0x00	; 0
    1e94:	0b 2c       	mov	r0, r11
    1e96:	02 c0       	rjmp	.+4      	; 0x1e9c <getUserByName+0x5a>
    1e98:	95 95       	asr	r25
    1e9a:	87 95       	ror	r24
    1e9c:	0a 94       	dec	r0
    1e9e:	e2 f7       	brpl	.-8      	; 0x1e98 <getUserByName+0x56>
    1ea0:	80 ff       	sbrs	r24, 0
    1ea2:	4b c0       	rjmp	.+150    	; 0x1f3a <getUserByName+0xf8>
    1ea4:	6f e1       	ldi	r22, 0x1F	; 31
    1ea6:	b6 9e       	mul	r11, r22
    1ea8:	a0 2c       	mov	r10, r0
    1eaa:	11 24       	eor	r1, r1
    1eac:	68 e0       	ldi	r22, 0x08	; 8
    1eae:	6a 0d       	add	r22, r10
    1eb0:	9e 01       	movw	r18, r28
    1eb2:	2d 5f       	subi	r18, 0xFD	; 253
    1eb4:	3f 4f       	sbci	r19, 0xFF	; 255
    1eb6:	4d e0       	ldi	r20, 0x0D	; 13
    1eb8:	50 e0       	ldi	r21, 0x00	; 0
    1eba:	89 2d       	mov	r24, r9
    1ebc:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    1ec0:	be 01       	movw	r22, r28
    1ec2:	6d 5f       	subi	r22, 0xFD	; 253
    1ec4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ec6:	c7 01       	movw	r24, r14
    1ec8:	0e 94 88 13 	call	0x2710	; 0x2710 <strcmp>
    1ecc:	89 2b       	or	r24, r25
    1ece:	a9 f5       	brne	.+106    	; 0x1f3a <getUserByName+0xf8>
    1ed0:	65 e1       	ldi	r22, 0x15	; 21
    1ed2:	6a 0d       	add	r22, r10
    1ed4:	9e 01       	movw	r18, r28
    1ed6:	20 5f       	subi	r18, 0xF0	; 240
    1ed8:	3f 4f       	sbci	r19, 0xFF	; 255
    1eda:	47 e0       	ldi	r20, 0x07	; 7
    1edc:	50 e0       	ldi	r21, 0x00	; 0
    1ede:	89 2d       	mov	r24, r9
    1ee0:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    1ee4:	6c e1       	ldi	r22, 0x1C	; 28
    1ee6:	6a 0d       	add	r22, r10
    1ee8:	9e 01       	movw	r18, r28
    1eea:	29 5e       	subi	r18, 0xE9	; 233
    1eec:	3f 4f       	sbci	r19, 0xFF	; 255
    1eee:	47 e0       	ldi	r20, 0x07	; 7
    1ef0:	50 e0       	ldi	r21, 0x00	; 0
    1ef2:	89 2d       	mov	r24, r9
    1ef4:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    1ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    1efa:	90 e0       	ldi	r25, 0x00	; 0
    1efc:	02 c0       	rjmp	.+4      	; 0x1f02 <getUserByName+0xc0>
    1efe:	95 95       	asr	r25
    1f00:	87 95       	ror	r24
    1f02:	ba 94       	dec	r11
    1f04:	e2 f7       	brpl	.-8      	; 0x1efe <getUserByName+0xbc>
    1f06:	98 2f       	mov	r25, r24
    1f08:	91 70       	andi	r25, 0x01	; 1
    1f0a:	f6 01       	movw	r30, r12
    1f0c:	91 93       	st	Z+, r25
    1f0e:	be 01       	movw	r22, r28
    1f10:	6d 5f       	subi	r22, 0xFD	; 253
    1f12:	7f 4f       	sbci	r23, 0xFF	; 255
    1f14:	cf 01       	movw	r24, r30
    1f16:	0e 94 91 13 	call	0x2722	; 0x2722 <strcpy>
    1f1a:	be 01       	movw	r22, r28
    1f1c:	60 5f       	subi	r22, 0xF0	; 240
    1f1e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f20:	c6 01       	movw	r24, r12
    1f22:	0e 96       	adiw	r24, 0x0e	; 14
    1f24:	0e 94 91 13 	call	0x2722	; 0x2722 <strcpy>
    1f28:	be 01       	movw	r22, r28
    1f2a:	69 5e       	subi	r22, 0xE9	; 233
    1f2c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f2e:	c6 01       	movw	r24, r12
    1f30:	45 96       	adiw	r24, 0x15	; 21
    1f32:	0e 94 91 13 	call	0x2722	; 0x2722 <strcpy>
    1f36:	82 e0       	ldi	r24, 0x02	; 2
    1f38:	0b c0       	rjmp	.+22     	; 0x1f50 <getUserByName+0x10e>
    1f3a:	b3 94       	inc	r11
    1f3c:	87 e0       	ldi	r24, 0x07	; 7
    1f3e:	8b 15       	cp	r24, r11
    1f40:	08 f0       	brcs	.+2      	; 0x1f44 <getUserByName+0x102>
    1f42:	a6 cf       	rjmp	.-180    	; 0x1e90 <getUserByName+0x4e>
    1f44:	93 94       	inc	r9
    1f46:	87 e0       	ldi	r24, 0x07	; 7
    1f48:	89 15       	cp	r24, r9
    1f4a:	08 f0       	brcs	.+2      	; 0x1f4e <getUserByName+0x10c>
    1f4c:	91 cf       	rjmp	.-222    	; 0x1e70 <getUserByName+0x2e>
    1f4e:	83 e0       	ldi	r24, 0x03	; 3
    1f50:	6d 96       	adiw	r28, 0x1d	; 29
    1f52:	0f b6       	in	r0, 0x3f	; 63
    1f54:	f8 94       	cli
    1f56:	de bf       	out	0x3e, r29	; 62
    1f58:	0f be       	out	0x3f, r0	; 63
    1f5a:	cd bf       	out	0x3d, r28	; 61
    1f5c:	df 91       	pop	r29
    1f5e:	cf 91       	pop	r28
    1f60:	1f 91       	pop	r17
    1f62:	0f 91       	pop	r16
    1f64:	ff 90       	pop	r15
    1f66:	ef 90       	pop	r14
    1f68:	df 90       	pop	r13
    1f6a:	cf 90       	pop	r12
    1f6c:	bf 90       	pop	r11
    1f6e:	af 90       	pop	r10
    1f70:	9f 90       	pop	r9
    1f72:	08 95       	ret

00001f74 <getUserByCode>:
    1f74:	9f 92       	push	r9
    1f76:	af 92       	push	r10
    1f78:	bf 92       	push	r11
    1f7a:	cf 92       	push	r12
    1f7c:	df 92       	push	r13
    1f7e:	ef 92       	push	r14
    1f80:	ff 92       	push	r15
    1f82:	0f 93       	push	r16
    1f84:	1f 93       	push	r17
    1f86:	cf 93       	push	r28
    1f88:	df 93       	push	r29
    1f8a:	cd b7       	in	r28, 0x3d	; 61
    1f8c:	de b7       	in	r29, 0x3e	; 62
    1f8e:	6d 97       	sbiw	r28, 0x1d	; 29
    1f90:	0f b6       	in	r0, 0x3f	; 63
    1f92:	f8 94       	cli
    1f94:	de bf       	out	0x3e, r29	; 62
    1f96:	0f be       	out	0x3f, r0	; 63
    1f98:	cd bf       	out	0x3d, r28	; 61
    1f9a:	7c 01       	movw	r14, r24
    1f9c:	6b 01       	movw	r12, r22
    1f9e:	91 2c       	mov	r9, r1
    1fa0:	6b c0       	rjmp	.+214    	; 0x2078 <getUserByCode+0x104>
    1fa2:	ae 01       	movw	r20, r28
    1fa4:	4f 5f       	subi	r20, 0xFF	; 255
    1fa6:	5f 4f       	sbci	r21, 0xFF	; 255
    1fa8:	60 e0       	ldi	r22, 0x00	; 0
    1faa:	89 2d       	mov	r24, r9
    1fac:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    1fb0:	ae 01       	movw	r20, r28
    1fb2:	4e 5f       	subi	r20, 0xFE	; 254
    1fb4:	5f 4f       	sbci	r21, 0xFF	; 255
    1fb6:	61 e0       	ldi	r22, 0x01	; 1
    1fb8:	89 2d       	mov	r24, r9
    1fba:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    1fbe:	b1 2c       	mov	r11, r1
    1fc0:	56 c0       	rjmp	.+172    	; 0x206e <getUserByCode+0xfa>
    1fc2:	89 81       	ldd	r24, Y+1	; 0x01
    1fc4:	90 e0       	ldi	r25, 0x00	; 0
    1fc6:	0b 2c       	mov	r0, r11
    1fc8:	02 c0       	rjmp	.+4      	; 0x1fce <getUserByCode+0x5a>
    1fca:	95 95       	asr	r25
    1fcc:	87 95       	ror	r24
    1fce:	0a 94       	dec	r0
    1fd0:	e2 f7       	brpl	.-8      	; 0x1fca <getUserByCode+0x56>
    1fd2:	80 ff       	sbrs	r24, 0
    1fd4:	4b c0       	rjmp	.+150    	; 0x206c <getUserByCode+0xf8>
    1fd6:	6f e1       	ldi	r22, 0x1F	; 31
    1fd8:	b6 9e       	mul	r11, r22
    1fda:	a0 2c       	mov	r10, r0
    1fdc:	11 24       	eor	r1, r1
    1fde:	65 e1       	ldi	r22, 0x15	; 21
    1fe0:	6a 0d       	add	r22, r10
    1fe2:	9e 01       	movw	r18, r28
    1fe4:	20 5f       	subi	r18, 0xF0	; 240
    1fe6:	3f 4f       	sbci	r19, 0xFF	; 255
    1fe8:	47 e0       	ldi	r20, 0x07	; 7
    1fea:	50 e0       	ldi	r21, 0x00	; 0
    1fec:	89 2d       	mov	r24, r9
    1fee:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    1ff2:	be 01       	movw	r22, r28
    1ff4:	60 5f       	subi	r22, 0xF0	; 240
    1ff6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ff8:	c7 01       	movw	r24, r14
    1ffa:	0e 94 88 13 	call	0x2710	; 0x2710 <strcmp>
    1ffe:	89 2b       	or	r24, r25
    2000:	a9 f5       	brne	.+106    	; 0x206c <getUserByCode+0xf8>
    2002:	68 e0       	ldi	r22, 0x08	; 8
    2004:	6a 0d       	add	r22, r10
    2006:	9e 01       	movw	r18, r28
    2008:	2d 5f       	subi	r18, 0xFD	; 253
    200a:	3f 4f       	sbci	r19, 0xFF	; 255
    200c:	4d e0       	ldi	r20, 0x0D	; 13
    200e:	50 e0       	ldi	r21, 0x00	; 0
    2010:	89 2d       	mov	r24, r9
    2012:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    2016:	6c e1       	ldi	r22, 0x1C	; 28
    2018:	6a 0d       	add	r22, r10
    201a:	9e 01       	movw	r18, r28
    201c:	29 5e       	subi	r18, 0xE9	; 233
    201e:	3f 4f       	sbci	r19, 0xFF	; 255
    2020:	47 e0       	ldi	r20, 0x07	; 7
    2022:	50 e0       	ldi	r21, 0x00	; 0
    2024:	89 2d       	mov	r24, r9
    2026:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
    202a:	8a 81       	ldd	r24, Y+2	; 0x02
    202c:	90 e0       	ldi	r25, 0x00	; 0
    202e:	02 c0       	rjmp	.+4      	; 0x2034 <getUserByCode+0xc0>
    2030:	95 95       	asr	r25
    2032:	87 95       	ror	r24
    2034:	ba 94       	dec	r11
    2036:	e2 f7       	brpl	.-8      	; 0x2030 <getUserByCode+0xbc>
    2038:	98 2f       	mov	r25, r24
    203a:	91 70       	andi	r25, 0x01	; 1
    203c:	f6 01       	movw	r30, r12
    203e:	91 93       	st	Z+, r25
    2040:	be 01       	movw	r22, r28
    2042:	6d 5f       	subi	r22, 0xFD	; 253
    2044:	7f 4f       	sbci	r23, 0xFF	; 255
    2046:	cf 01       	movw	r24, r30
    2048:	0e 94 91 13 	call	0x2722	; 0x2722 <strcpy>
    204c:	be 01       	movw	r22, r28
    204e:	60 5f       	subi	r22, 0xF0	; 240
    2050:	7f 4f       	sbci	r23, 0xFF	; 255
    2052:	c6 01       	movw	r24, r12
    2054:	0e 96       	adiw	r24, 0x0e	; 14
    2056:	0e 94 91 13 	call	0x2722	; 0x2722 <strcpy>
    205a:	be 01       	movw	r22, r28
    205c:	69 5e       	subi	r22, 0xE9	; 233
    205e:	7f 4f       	sbci	r23, 0xFF	; 255
    2060:	c6 01       	movw	r24, r12
    2062:	45 96       	adiw	r24, 0x15	; 21
    2064:	0e 94 91 13 	call	0x2722	; 0x2722 <strcpy>
    2068:	82 e0       	ldi	r24, 0x02	; 2
    206a:	0b c0       	rjmp	.+22     	; 0x2082 <getUserByCode+0x10e>
    206c:	b3 94       	inc	r11
    206e:	87 e0       	ldi	r24, 0x07	; 7
    2070:	8b 15       	cp	r24, r11
    2072:	08 f0       	brcs	.+2      	; 0x2076 <getUserByCode+0x102>
    2074:	a6 cf       	rjmp	.-180    	; 0x1fc2 <getUserByCode+0x4e>
    2076:	93 94       	inc	r9
    2078:	87 e0       	ldi	r24, 0x07	; 7
    207a:	89 15       	cp	r24, r9
    207c:	08 f0       	brcs	.+2      	; 0x2080 <getUserByCode+0x10c>
    207e:	91 cf       	rjmp	.-222    	; 0x1fa2 <getUserByCode+0x2e>
    2080:	83 e0       	ldi	r24, 0x03	; 3
    2082:	6d 96       	adiw	r28, 0x1d	; 29
    2084:	0f b6       	in	r0, 0x3f	; 63
    2086:	f8 94       	cli
    2088:	de bf       	out	0x3e, r29	; 62
    208a:	0f be       	out	0x3f, r0	; 63
    208c:	cd bf       	out	0x3d, r28	; 61
    208e:	df 91       	pop	r29
    2090:	cf 91       	pop	r28
    2092:	1f 91       	pop	r17
    2094:	0f 91       	pop	r16
    2096:	ff 90       	pop	r15
    2098:	ef 90       	pop	r14
    209a:	df 90       	pop	r13
    209c:	cf 90       	pop	r12
    209e:	bf 90       	pop	r11
    20a0:	af 90       	pop	r10
    20a2:	9f 90       	pop	r9
    20a4:	08 95       	ret

000020a6 <Alarm_set>:

void Alarm_set(void) {
  Buzzer_on(BUZZER_PORT, BUZZER_PIN);
    20a6:	66 e0       	ldi	r22, 0x06	; 6
    20a8:	84 e4       	ldi	r24, 0x44	; 68
    20aa:	0e 94 a3 00 	call	0x146	; 0x146 <Buzzer_on>
    20ae:	08 95       	ret

000020b0 <write_user>:
  }

void write_user(u8 userBlockIndex, ST_User_t* user) {
    20b0:	ef 92       	push	r14
    20b2:	ff 92       	push	r15
    20b4:	0f 93       	push	r16
    20b6:	1f 93       	push	r17
    20b8:	cf 93       	push	r28
    20ba:	df 93       	push	r29
    20bc:	00 d0       	rcall	.+0      	; 0x20be <write_user+0xe>
    20be:	cd b7       	in	r28, 0x3d	; 61
    20c0:	de b7       	in	r29, 0x3e	; 62
    20c2:	7b 01       	movw	r14, r22
  // Get the user block location (page - index)
  u8 page = userBlockIndex / 8;
    20c4:	08 2f       	mov	r16, r24
    20c6:	06 95       	lsr	r16
    20c8:	06 95       	lsr	r16
    20ca:	06 95       	lsr	r16
  u8 blockNumber = userBlockIndex % 8;
    20cc:	18 2f       	mov	r17, r24
    20ce:	17 70       	andi	r17, 0x07	; 7
  // Read and update the block status (reserve the block). And update the user authority level flag if the user is admin
  u8 usersBlockStatus, usersAuthorityLevel;
  EEPROM_read_byte(page, 0, &usersBlockStatus);
    20d0:	ae 01       	movw	r20, r28
    20d2:	4f 5f       	subi	r20, 0xFF	; 255
    20d4:	5f 4f       	sbci	r21, 0xFF	; 255
    20d6:	60 e0       	ldi	r22, 0x00	; 0
    20d8:	80 2f       	mov	r24, r16
    20da:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
  EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    20de:	ae 01       	movw	r20, r28
    20e0:	4e 5f       	subi	r20, 0xFE	; 254
    20e2:	5f 4f       	sbci	r21, 0xFF	; 255
    20e4:	61 e0       	ldi	r22, 0x01	; 1
    20e6:	80 2f       	mov	r24, r16
    20e8:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
  set_bit(usersBlockStatus, blockNumber);
    20ec:	81 e0       	ldi	r24, 0x01	; 1
    20ee:	90 e0       	ldi	r25, 0x00	; 0
    20f0:	01 2e       	mov	r0, r17
    20f2:	02 c0       	rjmp	.+4      	; 0x20f8 <write_user+0x48>
    20f4:	88 0f       	add	r24, r24
    20f6:	99 1f       	adc	r25, r25
    20f8:	0a 94       	dec	r0
    20fa:	e2 f7       	brpl	.-8      	; 0x20f4 <write_user+0x44>
    20fc:	49 81       	ldd	r20, Y+1	; 0x01
    20fe:	48 2b       	or	r20, r24
    2100:	49 83       	std	Y+1, r20	; 0x01
  if (user->isAdmin) set_bit(usersAuthorityLevel, blockNumber);
    2102:	f7 01       	movw	r30, r14
    2104:	20 81       	ld	r18, Z
    2106:	22 23       	and	r18, r18
    2108:	19 f0       	breq	.+6      	; 0x2110 <write_user+0x60>
    210a:	9a 81       	ldd	r25, Y+2	; 0x02
    210c:	89 2b       	or	r24, r25
    210e:	8a 83       	std	Y+2, r24	; 0x02
  EEPROM_write_byte(page, 0, usersBlockStatus);
    2110:	60 e0       	ldi	r22, 0x00	; 0
    2112:	80 2f       	mov	r24, r16
    2114:	0e 94 06 01 	call	0x20c	; 0x20c <EEPROM_write_byte>
  EEPROM_write_byte(page, 1, usersAuthorityLevel);
    2118:	4a 81       	ldd	r20, Y+2	; 0x02
    211a:	61 e0       	ldi	r22, 0x01	; 1
    211c:	80 2f       	mov	r24, r16
    211e:	0e 94 06 01 	call	0x20c	; 0x20c <EEPROM_write_byte>
  // Write the user data
  EEPROM_write_block(page, 8 + 31 * blockNumber, 13, user->name);
    2122:	97 01       	movw	r18, r14
    2124:	2f 5f       	subi	r18, 0xFF	; 255
    2126:	3f 4f       	sbci	r19, 0xFF	; 255
    2128:	6f e1       	ldi	r22, 0x1F	; 31
    212a:	16 9f       	mul	r17, r22
    212c:	10 2d       	mov	r17, r0
    212e:	11 24       	eor	r1, r1
    2130:	68 e0       	ldi	r22, 0x08	; 8
    2132:	61 0f       	add	r22, r17
    2134:	4d e0       	ldi	r20, 0x0D	; 13
    2136:	50 e0       	ldi	r21, 0x00	; 0
    2138:	80 2f       	mov	r24, r16
    213a:	0e 94 25 01 	call	0x24a	; 0x24a <EEPROM_write_block>
  EEPROM_write_block(page, 21 + 31 * blockNumber, 7, user->code);
    213e:	97 01       	movw	r18, r14
    2140:	22 5f       	subi	r18, 0xF2	; 242
    2142:	3f 4f       	sbci	r19, 0xFF	; 255
    2144:	65 e1       	ldi	r22, 0x15	; 21
    2146:	61 0f       	add	r22, r17
    2148:	47 e0       	ldi	r20, 0x07	; 7
    214a:	50 e0       	ldi	r21, 0x00	; 0
    214c:	80 2f       	mov	r24, r16
    214e:	0e 94 25 01 	call	0x24a	; 0x24a <EEPROM_write_block>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
    2152:	97 01       	movw	r18, r14
    2154:	2b 5e       	subi	r18, 0xEB	; 235
    2156:	3f 4f       	sbci	r19, 0xFF	; 255
    2158:	6c e1       	ldi	r22, 0x1C	; 28
    215a:	61 0f       	add	r22, r17
    215c:	4b e0       	ldi	r20, 0x0B	; 11
    215e:	50 e0       	ldi	r21, 0x00	; 0
    2160:	80 2f       	mov	r24, r16
    2162:	0e 94 25 01 	call	0x24a	; 0x24a <EEPROM_write_block>
  }
    2166:	0f 90       	pop	r0
    2168:	0f 90       	pop	r0
    216a:	df 91       	pop	r29
    216c:	cf 91       	pop	r28
    216e:	1f 91       	pop	r17
    2170:	0f 91       	pop	r16
    2172:	ff 90       	pop	r15
    2174:	ef 90       	pop	r14
    2176:	08 95       	ret

00002178 <add_user>:

EN_UserStatusCode_t add_user(ST_User_t* user) {
    2178:	ef 92       	push	r14
    217a:	ff 92       	push	r15
    217c:	1f 93       	push	r17
    217e:	cf 93       	push	r28
    2180:	df 93       	push	r29
    2182:	1f 92       	push	r1
    2184:	cd b7       	in	r28, 0x3d	; 61
    2186:	de b7       	in	r29, 0x3e	; 62
    2188:	7c 01       	movw	r14, r24
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    218a:	10 e0       	ldi	r17, 0x00	; 0
    218c:	1a c0       	rjmp	.+52     	; 0x21c2 <add_user+0x4a>
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    218e:	ae 01       	movw	r20, r28
    2190:	4f 5f       	subi	r20, 0xFF	; 255
    2192:	5f 4f       	sbci	r21, 0xFF	; 255
    2194:	60 e0       	ldi	r22, 0x00	; 0
    2196:	81 2f       	mov	r24, r17
    2198:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    if (usersBlockStatus != 0xFF) {
    219c:	99 81       	ldd	r25, Y+1	; 0x01
    219e:	9f 3f       	cpi	r25, 0xFF	; 255
    21a0:	79 f0       	breq	.+30     	; 0x21c0 <add_user+0x48>
    21a2:	02 c0       	rjmp	.+4      	; 0x21a8 <add_user+0x30>
      // Find the block number in the page
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
    21a4:	8f 5f       	subi	r24, 0xFF	; 255
    21a6:	01 c0       	rjmp	.+2      	; 0x21aa <add_user+0x32>
    21a8:	80 e0       	ldi	r24, 0x00	; 0
    21aa:	29 2f       	mov	r18, r25
    21ac:	30 e0       	ldi	r19, 0x00	; 0
    21ae:	08 2e       	mov	r0, r24
    21b0:	02 c0       	rjmp	.+4      	; 0x21b6 <add_user+0x3e>
    21b2:	35 95       	asr	r19
    21b4:	27 95       	ror	r18
    21b6:	0a 94       	dec	r0
    21b8:	e2 f7       	brpl	.-8      	; 0x21b2 <add_user+0x3a>
    21ba:	20 fd       	sbrc	r18, 0
    21bc:	f3 cf       	rjmp	.-26     	; 0x21a4 <add_user+0x2c>
    21be:	04 c0       	rjmp	.+8      	; 0x21c8 <add_user+0x50>
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    21c0:	1f 5f       	subi	r17, 0xFF	; 255
    21c2:	18 30       	cpi	r17, 0x08	; 8
    21c4:	20 f3       	brcs	.-56     	; 0x218e <add_user+0x16>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
    21c6:	80 e0       	ldi	r24, 0x00	; 0
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    21c8:	18 30       	cpi	r17, 0x08	; 8
    21ca:	49 f0       	breq	.+18     	; 0x21de <add_user+0x66>
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
    21cc:	11 0f       	add	r17, r17
    21ce:	11 0f       	add	r17, r17
    21d0:	11 0f       	add	r17, r17
  write_user(availableUserBlockIndex, user);
    21d2:	b7 01       	movw	r22, r14
    21d4:	81 0f       	add	r24, r17
    21d6:	0e 94 58 10 	call	0x20b0	; 0x20b0 <write_user>
  return USER_ADDED_SUCCESSFULLY;
    21da:	89 e0       	ldi	r24, 0x09	; 9
    21dc:	01 c0       	rjmp	.+2      	; 0x21e0 <add_user+0x68>
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    21de:	8b e0       	ldi	r24, 0x0B	; 11
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
  write_user(availableUserBlockIndex, user);
  return USER_ADDED_SUCCESSFULLY;
  }
    21e0:	0f 90       	pop	r0
    21e2:	df 91       	pop	r29
    21e4:	cf 91       	pop	r28
    21e6:	1f 91       	pop	r17
    21e8:	ff 90       	pop	r15
    21ea:	ef 90       	pop	r14
    21ec:	08 95       	ret

000021ee <delete_user>:

EN_UserStatusCode_t delete_user(ST_User_t* user) {
    21ee:	cf 92       	push	r12
    21f0:	df 92       	push	r13
    21f2:	ef 92       	push	r14
    21f4:	ff 92       	push	r15
    21f6:	0f 93       	push	r16
    21f8:	1f 93       	push	r17
    21fa:	cf 93       	push	r28
    21fc:	df 93       	push	r29
    21fe:	cd b7       	in	r28, 0x3d	; 61
    2200:	de b7       	in	r29, 0x3e	; 62
    2202:	29 97       	sbiw	r28, 0x09	; 9
    2204:	0f b6       	in	r0, 0x3f	; 63
    2206:	f8 94       	cli
    2208:	de bf       	out	0x3e, r29	; 62
    220a:	0f be       	out	0x3f, r0	; 63
    220c:	cd bf       	out	0x3d, r28	; 61
    220e:	6c 01       	movw	r12, r24
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    2210:	00 e0       	ldi	r16, 0x00	; 0
    2212:	4d c0       	rjmp	.+154    	; 0x22ae <delete_user+0xc0>
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    2214:	ae 01       	movw	r20, r28
    2216:	4f 5f       	subi	r20, 0xFF	; 255
    2218:	5f 4f       	sbci	r21, 0xFF	; 255
    221a:	60 e0       	ldi	r22, 0x00	; 0
    221c:	80 2f       	mov	r24, r16
    221e:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    2222:	ae 01       	movw	r20, r28
    2224:	4e 5f       	subi	r20, 0xFE	; 254
    2226:	5f 4f       	sbci	r21, 0xFF	; 255
    2228:	61 e0       	ldi	r22, 0x01	; 1
    222a:	80 2f       	mov	r24, r16
    222c:	0e 94 af 00 	call	0x15e	; 0x15e <EEPROM_read_byte>
    for (userIndex = 0; userIndex < 8;userIndex++) {
    2230:	10 e0       	ldi	r17, 0x00	; 0
    2232:	3a c0       	rjmp	.+116    	; 0x22a8 <delete_user+0xba>
      if (read_bit(usersBlockStatus, userIndex)) {  // If the user isn't deleted
    2234:	89 81       	ldd	r24, Y+1	; 0x01
    2236:	90 e0       	ldi	r25, 0x00	; 0
    2238:	01 2e       	mov	r0, r17
    223a:	02 c0       	rjmp	.+4      	; 0x2240 <delete_user+0x52>
    223c:	95 95       	asr	r25
    223e:	87 95       	ror	r24
    2240:	0a 94       	dec	r0
    2242:	e2 f7       	brpl	.-8      	; 0x223c <delete_user+0x4e>
    2244:	80 ff       	sbrs	r24, 0
    2246:	2f c0       	rjmp	.+94     	; 0x22a6 <delete_user+0xb8>
        EEPROM_read_block(page, 21 + 31 * userIndex, 7, tempUserCode);
    2248:	6f e1       	ldi	r22, 0x1F	; 31
    224a:	16 9f       	mul	r17, r22
    224c:	60 2d       	mov	r22, r0
    224e:	11 24       	eor	r1, r1
    2250:	6b 5e       	subi	r22, 0xEB	; 235
    2252:	9e 01       	movw	r18, r28
    2254:	2d 5f       	subi	r18, 0xFD	; 253
    2256:	3f 4f       	sbci	r19, 0xFF	; 255
    2258:	47 e0       	ldi	r20, 0x07	; 7
    225a:	50 e0       	ldi	r21, 0x00	; 0
    225c:	80 2f       	mov	r24, r16
    225e:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <EEPROM_read_block>
        if (strcmp(user->code, tempUserCode) == 0) { // User has been found
    2262:	be 01       	movw	r22, r28
    2264:	6d 5f       	subi	r22, 0xFD	; 253
    2266:	7f 4f       	sbci	r23, 0xFF	; 255
    2268:	c6 01       	movw	r24, r12
    226a:	0e 96       	adiw	r24, 0x0e	; 14
    226c:	0e 94 88 13 	call	0x2710	; 0x2710 <strcmp>
    2270:	89 2b       	or	r24, r25
    2272:	c9 f4       	brne	.+50     	; 0x22a6 <delete_user+0xb8>
          // Mark it as deleted
          clear_bit(usersBlockStatus, userIndex);
    2274:	81 e0       	ldi	r24, 0x01	; 1
    2276:	90 e0       	ldi	r25, 0x00	; 0
    2278:	02 c0       	rjmp	.+4      	; 0x227e <delete_user+0x90>
    227a:	88 0f       	add	r24, r24
    227c:	99 1f       	adc	r25, r25
    227e:	1a 95       	dec	r17
    2280:	e2 f7       	brpl	.-8      	; 0x227a <delete_user+0x8c>
    2282:	80 95       	com	r24
    2284:	49 81       	ldd	r20, Y+1	; 0x01
    2286:	48 23       	and	r20, r24
    2288:	49 83       	std	Y+1, r20	; 0x01
          clear_bit(usersAuthorityLevel, userIndex);
    228a:	9a 81       	ldd	r25, Y+2	; 0x02
    228c:	89 23       	and	r24, r25
    228e:	8a 83       	std	Y+2, r24	; 0x02
          EEPROM_write_byte(page, 0, usersBlockStatus);
    2290:	60 e0       	ldi	r22, 0x00	; 0
    2292:	80 2f       	mov	r24, r16
    2294:	0e 94 06 01 	call	0x20c	; 0x20c <EEPROM_write_byte>
          EEPROM_write_byte(page, 1, usersAuthorityLevel);
    2298:	4a 81       	ldd	r20, Y+2	; 0x02
    229a:	61 e0       	ldi	r22, 0x01	; 1
    229c:	80 2f       	mov	r24, r16
    229e:	0e 94 06 01 	call	0x20c	; 0x20c <EEPROM_write_byte>
          return USER_DELETED_SUCCESSFULLY;
    22a2:	8a e0       	ldi	r24, 0x0A	; 10
    22a4:	08 c0       	rjmp	.+16     	; 0x22b6 <delete_user+0xc8>
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    for (userIndex = 0; userIndex < 8;userIndex++) {
    22a6:	1f 5f       	subi	r17, 0xFF	; 255
    22a8:	18 30       	cpi	r17, 0x08	; 8
    22aa:	20 f2       	brcs	.-120    	; 0x2234 <delete_user+0x46>
EN_UserStatusCode_t delete_user(ST_User_t* user) {
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    22ac:	0f 5f       	subi	r16, 0xFF	; 255
    22ae:	08 30       	cpi	r16, 0x08	; 8
    22b0:	08 f4       	brcc	.+2      	; 0x22b4 <delete_user+0xc6>
    22b2:	b0 cf       	rjmp	.-160    	; 0x2214 <delete_user+0x26>
          return USER_DELETED_SUCCESSFULLY;
          }
        }
      }
    }
  return USER_NOT_FOUND;
    22b4:	83 e0       	ldi	r24, 0x03	; 3
  }
    22b6:	29 96       	adiw	r28, 0x09	; 9
    22b8:	0f b6       	in	r0, 0x3f	; 63
    22ba:	f8 94       	cli
    22bc:	de bf       	out	0x3e, r29	; 62
    22be:	0f be       	out	0x3f, r0	; 63
    22c0:	cd bf       	out	0x3d, r28	; 61
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	1f 91       	pop	r17
    22c8:	0f 91       	pop	r16
    22ca:	ff 90       	pop	r15
    22cc:	ef 90       	pop	r14
    22ce:	df 90       	pop	r13
    22d0:	cf 90       	pop	r12
    22d2:	08 95       	ret

000022d4 <__subsf3>:
    22d4:	50 58       	subi	r21, 0x80	; 128

000022d6 <__addsf3>:
    22d6:	bb 27       	eor	r27, r27
    22d8:	aa 27       	eor	r26, r26
    22da:	0e 94 82 11 	call	0x2304	; 0x2304 <__addsf3x>
    22de:	0c 94 cc 12 	jmp	0x2598	; 0x2598 <__fp_round>
    22e2:	0e 94 be 12 	call	0x257c	; 0x257c <__fp_pscA>
    22e6:	38 f0       	brcs	.+14     	; 0x22f6 <__addsf3+0x20>
    22e8:	0e 94 c5 12 	call	0x258a	; 0x258a <__fp_pscB>
    22ec:	20 f0       	brcs	.+8      	; 0x22f6 <__addsf3+0x20>
    22ee:	39 f4       	brne	.+14     	; 0x22fe <__addsf3+0x28>
    22f0:	9f 3f       	cpi	r25, 0xFF	; 255
    22f2:	19 f4       	brne	.+6      	; 0x22fa <__addsf3+0x24>
    22f4:	26 f4       	brtc	.+8      	; 0x22fe <__addsf3+0x28>
    22f6:	0c 94 bb 12 	jmp	0x2576	; 0x2576 <__fp_nan>
    22fa:	0e f4       	brtc	.+2      	; 0x22fe <__addsf3+0x28>
    22fc:	e0 95       	com	r30
    22fe:	e7 fb       	bst	r30, 7
    2300:	0c 94 b5 12 	jmp	0x256a	; 0x256a <__fp_inf>

00002304 <__addsf3x>:
    2304:	e9 2f       	mov	r30, r25
    2306:	0e 94 dd 12 	call	0x25ba	; 0x25ba <__fp_split3>
    230a:	58 f3       	brcs	.-42     	; 0x22e2 <__addsf3+0xc>
    230c:	ba 17       	cp	r27, r26
    230e:	62 07       	cpc	r22, r18
    2310:	73 07       	cpc	r23, r19
    2312:	84 07       	cpc	r24, r20
    2314:	95 07       	cpc	r25, r21
    2316:	20 f0       	brcs	.+8      	; 0x2320 <__addsf3x+0x1c>
    2318:	79 f4       	brne	.+30     	; 0x2338 <__addsf3x+0x34>
    231a:	a6 f5       	brtc	.+104    	; 0x2384 <__addsf3x+0x80>
    231c:	0c 94 ff 12 	jmp	0x25fe	; 0x25fe <__fp_zero>
    2320:	0e f4       	brtc	.+2      	; 0x2324 <__addsf3x+0x20>
    2322:	e0 95       	com	r30
    2324:	0b 2e       	mov	r0, r27
    2326:	ba 2f       	mov	r27, r26
    2328:	a0 2d       	mov	r26, r0
    232a:	0b 01       	movw	r0, r22
    232c:	b9 01       	movw	r22, r18
    232e:	90 01       	movw	r18, r0
    2330:	0c 01       	movw	r0, r24
    2332:	ca 01       	movw	r24, r20
    2334:	a0 01       	movw	r20, r0
    2336:	11 24       	eor	r1, r1
    2338:	ff 27       	eor	r31, r31
    233a:	59 1b       	sub	r21, r25
    233c:	99 f0       	breq	.+38     	; 0x2364 <__addsf3x+0x60>
    233e:	59 3f       	cpi	r21, 0xF9	; 249
    2340:	50 f4       	brcc	.+20     	; 0x2356 <__addsf3x+0x52>
    2342:	50 3e       	cpi	r21, 0xE0	; 224
    2344:	68 f1       	brcs	.+90     	; 0x23a0 <__addsf3x+0x9c>
    2346:	1a 16       	cp	r1, r26
    2348:	f0 40       	sbci	r31, 0x00	; 0
    234a:	a2 2f       	mov	r26, r18
    234c:	23 2f       	mov	r18, r19
    234e:	34 2f       	mov	r19, r20
    2350:	44 27       	eor	r20, r20
    2352:	58 5f       	subi	r21, 0xF8	; 248
    2354:	f3 cf       	rjmp	.-26     	; 0x233c <__addsf3x+0x38>
    2356:	46 95       	lsr	r20
    2358:	37 95       	ror	r19
    235a:	27 95       	ror	r18
    235c:	a7 95       	ror	r26
    235e:	f0 40       	sbci	r31, 0x00	; 0
    2360:	53 95       	inc	r21
    2362:	c9 f7       	brne	.-14     	; 0x2356 <__addsf3x+0x52>
    2364:	7e f4       	brtc	.+30     	; 0x2384 <__addsf3x+0x80>
    2366:	1f 16       	cp	r1, r31
    2368:	ba 0b       	sbc	r27, r26
    236a:	62 0b       	sbc	r22, r18
    236c:	73 0b       	sbc	r23, r19
    236e:	84 0b       	sbc	r24, r20
    2370:	ba f0       	brmi	.+46     	; 0x23a0 <__addsf3x+0x9c>
    2372:	91 50       	subi	r25, 0x01	; 1
    2374:	a1 f0       	breq	.+40     	; 0x239e <__addsf3x+0x9a>
    2376:	ff 0f       	add	r31, r31
    2378:	bb 1f       	adc	r27, r27
    237a:	66 1f       	adc	r22, r22
    237c:	77 1f       	adc	r23, r23
    237e:	88 1f       	adc	r24, r24
    2380:	c2 f7       	brpl	.-16     	; 0x2372 <__addsf3x+0x6e>
    2382:	0e c0       	rjmp	.+28     	; 0x23a0 <__addsf3x+0x9c>
    2384:	ba 0f       	add	r27, r26
    2386:	62 1f       	adc	r22, r18
    2388:	73 1f       	adc	r23, r19
    238a:	84 1f       	adc	r24, r20
    238c:	48 f4       	brcc	.+18     	; 0x23a0 <__addsf3x+0x9c>
    238e:	87 95       	ror	r24
    2390:	77 95       	ror	r23
    2392:	67 95       	ror	r22
    2394:	b7 95       	ror	r27
    2396:	f7 95       	ror	r31
    2398:	9e 3f       	cpi	r25, 0xFE	; 254
    239a:	08 f0       	brcs	.+2      	; 0x239e <__addsf3x+0x9a>
    239c:	b0 cf       	rjmp	.-160    	; 0x22fe <__addsf3+0x28>
    239e:	93 95       	inc	r25
    23a0:	88 0f       	add	r24, r24
    23a2:	08 f0       	brcs	.+2      	; 0x23a6 <__addsf3x+0xa2>
    23a4:	99 27       	eor	r25, r25
    23a6:	ee 0f       	add	r30, r30
    23a8:	97 95       	ror	r25
    23aa:	87 95       	ror	r24
    23ac:	08 95       	ret

000023ae <__divsf3>:
    23ae:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <__divsf3x>
    23b2:	0c 94 cc 12 	jmp	0x2598	; 0x2598 <__fp_round>
    23b6:	0e 94 c5 12 	call	0x258a	; 0x258a <__fp_pscB>
    23ba:	58 f0       	brcs	.+22     	; 0x23d2 <__divsf3+0x24>
    23bc:	0e 94 be 12 	call	0x257c	; 0x257c <__fp_pscA>
    23c0:	40 f0       	brcs	.+16     	; 0x23d2 <__divsf3+0x24>
    23c2:	29 f4       	brne	.+10     	; 0x23ce <__divsf3+0x20>
    23c4:	5f 3f       	cpi	r21, 0xFF	; 255
    23c6:	29 f0       	breq	.+10     	; 0x23d2 <__divsf3+0x24>
    23c8:	0c 94 b5 12 	jmp	0x256a	; 0x256a <__fp_inf>
    23cc:	51 11       	cpse	r21, r1
    23ce:	0c 94 00 13 	jmp	0x2600	; 0x2600 <__fp_szero>
    23d2:	0c 94 bb 12 	jmp	0x2576	; 0x2576 <__fp_nan>

000023d6 <__divsf3x>:
    23d6:	0e 94 dd 12 	call	0x25ba	; 0x25ba <__fp_split3>
    23da:	68 f3       	brcs	.-38     	; 0x23b6 <__divsf3+0x8>

000023dc <__divsf3_pse>:
    23dc:	99 23       	and	r25, r25
    23de:	b1 f3       	breq	.-20     	; 0x23cc <__divsf3+0x1e>
    23e0:	55 23       	and	r21, r21
    23e2:	91 f3       	breq	.-28     	; 0x23c8 <__divsf3+0x1a>
    23e4:	95 1b       	sub	r25, r21
    23e6:	55 0b       	sbc	r21, r21
    23e8:	bb 27       	eor	r27, r27
    23ea:	aa 27       	eor	r26, r26
    23ec:	62 17       	cp	r22, r18
    23ee:	73 07       	cpc	r23, r19
    23f0:	84 07       	cpc	r24, r20
    23f2:	38 f0       	brcs	.+14     	; 0x2402 <__divsf3_pse+0x26>
    23f4:	9f 5f       	subi	r25, 0xFF	; 255
    23f6:	5f 4f       	sbci	r21, 0xFF	; 255
    23f8:	22 0f       	add	r18, r18
    23fa:	33 1f       	adc	r19, r19
    23fc:	44 1f       	adc	r20, r20
    23fe:	aa 1f       	adc	r26, r26
    2400:	a9 f3       	breq	.-22     	; 0x23ec <__divsf3_pse+0x10>
    2402:	35 d0       	rcall	.+106    	; 0x246e <__divsf3_pse+0x92>
    2404:	0e 2e       	mov	r0, r30
    2406:	3a f0       	brmi	.+14     	; 0x2416 <__divsf3_pse+0x3a>
    2408:	e0 e8       	ldi	r30, 0x80	; 128
    240a:	32 d0       	rcall	.+100    	; 0x2470 <__divsf3_pse+0x94>
    240c:	91 50       	subi	r25, 0x01	; 1
    240e:	50 40       	sbci	r21, 0x00	; 0
    2410:	e6 95       	lsr	r30
    2412:	00 1c       	adc	r0, r0
    2414:	ca f7       	brpl	.-14     	; 0x2408 <__divsf3_pse+0x2c>
    2416:	2b d0       	rcall	.+86     	; 0x246e <__divsf3_pse+0x92>
    2418:	fe 2f       	mov	r31, r30
    241a:	29 d0       	rcall	.+82     	; 0x246e <__divsf3_pse+0x92>
    241c:	66 0f       	add	r22, r22
    241e:	77 1f       	adc	r23, r23
    2420:	88 1f       	adc	r24, r24
    2422:	bb 1f       	adc	r27, r27
    2424:	26 17       	cp	r18, r22
    2426:	37 07       	cpc	r19, r23
    2428:	48 07       	cpc	r20, r24
    242a:	ab 07       	cpc	r26, r27
    242c:	b0 e8       	ldi	r27, 0x80	; 128
    242e:	09 f0       	breq	.+2      	; 0x2432 <__divsf3_pse+0x56>
    2430:	bb 0b       	sbc	r27, r27
    2432:	80 2d       	mov	r24, r0
    2434:	bf 01       	movw	r22, r30
    2436:	ff 27       	eor	r31, r31
    2438:	93 58       	subi	r25, 0x83	; 131
    243a:	5f 4f       	sbci	r21, 0xFF	; 255
    243c:	3a f0       	brmi	.+14     	; 0x244c <__divsf3_pse+0x70>
    243e:	9e 3f       	cpi	r25, 0xFE	; 254
    2440:	51 05       	cpc	r21, r1
    2442:	78 f0       	brcs	.+30     	; 0x2462 <__divsf3_pse+0x86>
    2444:	0c 94 b5 12 	jmp	0x256a	; 0x256a <__fp_inf>
    2448:	0c 94 00 13 	jmp	0x2600	; 0x2600 <__fp_szero>
    244c:	5f 3f       	cpi	r21, 0xFF	; 255
    244e:	e4 f3       	brlt	.-8      	; 0x2448 <__divsf3_pse+0x6c>
    2450:	98 3e       	cpi	r25, 0xE8	; 232
    2452:	d4 f3       	brlt	.-12     	; 0x2448 <__divsf3_pse+0x6c>
    2454:	86 95       	lsr	r24
    2456:	77 95       	ror	r23
    2458:	67 95       	ror	r22
    245a:	b7 95       	ror	r27
    245c:	f7 95       	ror	r31
    245e:	9f 5f       	subi	r25, 0xFF	; 255
    2460:	c9 f7       	brne	.-14     	; 0x2454 <__divsf3_pse+0x78>
    2462:	88 0f       	add	r24, r24
    2464:	91 1d       	adc	r25, r1
    2466:	96 95       	lsr	r25
    2468:	87 95       	ror	r24
    246a:	97 f9       	bld	r25, 7
    246c:	08 95       	ret
    246e:	e1 e0       	ldi	r30, 0x01	; 1
    2470:	66 0f       	add	r22, r22
    2472:	77 1f       	adc	r23, r23
    2474:	88 1f       	adc	r24, r24
    2476:	bb 1f       	adc	r27, r27
    2478:	62 17       	cp	r22, r18
    247a:	73 07       	cpc	r23, r19
    247c:	84 07       	cpc	r24, r20
    247e:	ba 07       	cpc	r27, r26
    2480:	20 f0       	brcs	.+8      	; 0x248a <__divsf3_pse+0xae>
    2482:	62 1b       	sub	r22, r18
    2484:	73 0b       	sbc	r23, r19
    2486:	84 0b       	sbc	r24, r20
    2488:	ba 0b       	sbc	r27, r26
    248a:	ee 1f       	adc	r30, r30
    248c:	88 f7       	brcc	.-30     	; 0x2470 <__divsf3_pse+0x94>
    248e:	e0 95       	com	r30
    2490:	08 95       	ret

00002492 <__fixunssfsi>:
    2492:	0e 94 e5 12 	call	0x25ca	; 0x25ca <__fp_splitA>
    2496:	88 f0       	brcs	.+34     	; 0x24ba <__fixunssfsi+0x28>
    2498:	9f 57       	subi	r25, 0x7F	; 127
    249a:	98 f0       	brcs	.+38     	; 0x24c2 <__fixunssfsi+0x30>
    249c:	b9 2f       	mov	r27, r25
    249e:	99 27       	eor	r25, r25
    24a0:	b7 51       	subi	r27, 0x17	; 23
    24a2:	b0 f0       	brcs	.+44     	; 0x24d0 <__fixunssfsi+0x3e>
    24a4:	e1 f0       	breq	.+56     	; 0x24de <__fixunssfsi+0x4c>
    24a6:	66 0f       	add	r22, r22
    24a8:	77 1f       	adc	r23, r23
    24aa:	88 1f       	adc	r24, r24
    24ac:	99 1f       	adc	r25, r25
    24ae:	1a f0       	brmi	.+6      	; 0x24b6 <__fixunssfsi+0x24>
    24b0:	ba 95       	dec	r27
    24b2:	c9 f7       	brne	.-14     	; 0x24a6 <__fixunssfsi+0x14>
    24b4:	14 c0       	rjmp	.+40     	; 0x24de <__fixunssfsi+0x4c>
    24b6:	b1 30       	cpi	r27, 0x01	; 1
    24b8:	91 f0       	breq	.+36     	; 0x24de <__fixunssfsi+0x4c>
    24ba:	0e 94 ff 12 	call	0x25fe	; 0x25fe <__fp_zero>
    24be:	b1 e0       	ldi	r27, 0x01	; 1
    24c0:	08 95       	ret
    24c2:	0c 94 ff 12 	jmp	0x25fe	; 0x25fe <__fp_zero>
    24c6:	67 2f       	mov	r22, r23
    24c8:	78 2f       	mov	r23, r24
    24ca:	88 27       	eor	r24, r24
    24cc:	b8 5f       	subi	r27, 0xF8	; 248
    24ce:	39 f0       	breq	.+14     	; 0x24de <__fixunssfsi+0x4c>
    24d0:	b9 3f       	cpi	r27, 0xF9	; 249
    24d2:	cc f3       	brlt	.-14     	; 0x24c6 <__fixunssfsi+0x34>
    24d4:	86 95       	lsr	r24
    24d6:	77 95       	ror	r23
    24d8:	67 95       	ror	r22
    24da:	b3 95       	inc	r27
    24dc:	d9 f7       	brne	.-10     	; 0x24d4 <__fixunssfsi+0x42>
    24de:	3e f4       	brtc	.+14     	; 0x24ee <__fixunssfsi+0x5c>
    24e0:	90 95       	com	r25
    24e2:	80 95       	com	r24
    24e4:	70 95       	com	r23
    24e6:	61 95       	neg	r22
    24e8:	7f 4f       	sbci	r23, 0xFF	; 255
    24ea:	8f 4f       	sbci	r24, 0xFF	; 255
    24ec:	9f 4f       	sbci	r25, 0xFF	; 255
    24ee:	08 95       	ret

000024f0 <__floatunsisf>:
    24f0:	e8 94       	clt
    24f2:	09 c0       	rjmp	.+18     	; 0x2506 <__floatsisf+0x12>

000024f4 <__floatsisf>:
    24f4:	97 fb       	bst	r25, 7
    24f6:	3e f4       	brtc	.+14     	; 0x2506 <__floatsisf+0x12>
    24f8:	90 95       	com	r25
    24fa:	80 95       	com	r24
    24fc:	70 95       	com	r23
    24fe:	61 95       	neg	r22
    2500:	7f 4f       	sbci	r23, 0xFF	; 255
    2502:	8f 4f       	sbci	r24, 0xFF	; 255
    2504:	9f 4f       	sbci	r25, 0xFF	; 255
    2506:	99 23       	and	r25, r25
    2508:	a9 f0       	breq	.+42     	; 0x2534 <__floatsisf+0x40>
    250a:	f9 2f       	mov	r31, r25
    250c:	96 e9       	ldi	r25, 0x96	; 150
    250e:	bb 27       	eor	r27, r27
    2510:	93 95       	inc	r25
    2512:	f6 95       	lsr	r31
    2514:	87 95       	ror	r24
    2516:	77 95       	ror	r23
    2518:	67 95       	ror	r22
    251a:	b7 95       	ror	r27
    251c:	f1 11       	cpse	r31, r1
    251e:	f8 cf       	rjmp	.-16     	; 0x2510 <__floatsisf+0x1c>
    2520:	fa f4       	brpl	.+62     	; 0x2560 <__floatsisf+0x6c>
    2522:	bb 0f       	add	r27, r27
    2524:	11 f4       	brne	.+4      	; 0x252a <__floatsisf+0x36>
    2526:	60 ff       	sbrs	r22, 0
    2528:	1b c0       	rjmp	.+54     	; 0x2560 <__floatsisf+0x6c>
    252a:	6f 5f       	subi	r22, 0xFF	; 255
    252c:	7f 4f       	sbci	r23, 0xFF	; 255
    252e:	8f 4f       	sbci	r24, 0xFF	; 255
    2530:	9f 4f       	sbci	r25, 0xFF	; 255
    2532:	16 c0       	rjmp	.+44     	; 0x2560 <__floatsisf+0x6c>
    2534:	88 23       	and	r24, r24
    2536:	11 f0       	breq	.+4      	; 0x253c <__floatsisf+0x48>
    2538:	96 e9       	ldi	r25, 0x96	; 150
    253a:	11 c0       	rjmp	.+34     	; 0x255e <__floatsisf+0x6a>
    253c:	77 23       	and	r23, r23
    253e:	21 f0       	breq	.+8      	; 0x2548 <__floatsisf+0x54>
    2540:	9e e8       	ldi	r25, 0x8E	; 142
    2542:	87 2f       	mov	r24, r23
    2544:	76 2f       	mov	r23, r22
    2546:	05 c0       	rjmp	.+10     	; 0x2552 <__floatsisf+0x5e>
    2548:	66 23       	and	r22, r22
    254a:	71 f0       	breq	.+28     	; 0x2568 <__floatsisf+0x74>
    254c:	96 e8       	ldi	r25, 0x86	; 134
    254e:	86 2f       	mov	r24, r22
    2550:	70 e0       	ldi	r23, 0x00	; 0
    2552:	60 e0       	ldi	r22, 0x00	; 0
    2554:	2a f0       	brmi	.+10     	; 0x2560 <__floatsisf+0x6c>
    2556:	9a 95       	dec	r25
    2558:	66 0f       	add	r22, r22
    255a:	77 1f       	adc	r23, r23
    255c:	88 1f       	adc	r24, r24
    255e:	da f7       	brpl	.-10     	; 0x2556 <__floatsisf+0x62>
    2560:	88 0f       	add	r24, r24
    2562:	96 95       	lsr	r25
    2564:	87 95       	ror	r24
    2566:	97 f9       	bld	r25, 7
    2568:	08 95       	ret

0000256a <__fp_inf>:
    256a:	97 f9       	bld	r25, 7
    256c:	9f 67       	ori	r25, 0x7F	; 127
    256e:	80 e8       	ldi	r24, 0x80	; 128
    2570:	70 e0       	ldi	r23, 0x00	; 0
    2572:	60 e0       	ldi	r22, 0x00	; 0
    2574:	08 95       	ret

00002576 <__fp_nan>:
    2576:	9f ef       	ldi	r25, 0xFF	; 255
    2578:	80 ec       	ldi	r24, 0xC0	; 192
    257a:	08 95       	ret

0000257c <__fp_pscA>:
    257c:	00 24       	eor	r0, r0
    257e:	0a 94       	dec	r0
    2580:	16 16       	cp	r1, r22
    2582:	17 06       	cpc	r1, r23
    2584:	18 06       	cpc	r1, r24
    2586:	09 06       	cpc	r0, r25
    2588:	08 95       	ret

0000258a <__fp_pscB>:
    258a:	00 24       	eor	r0, r0
    258c:	0a 94       	dec	r0
    258e:	12 16       	cp	r1, r18
    2590:	13 06       	cpc	r1, r19
    2592:	14 06       	cpc	r1, r20
    2594:	05 06       	cpc	r0, r21
    2596:	08 95       	ret

00002598 <__fp_round>:
    2598:	09 2e       	mov	r0, r25
    259a:	03 94       	inc	r0
    259c:	00 0c       	add	r0, r0
    259e:	11 f4       	brne	.+4      	; 0x25a4 <__fp_round+0xc>
    25a0:	88 23       	and	r24, r24
    25a2:	52 f0       	brmi	.+20     	; 0x25b8 <__fp_round+0x20>
    25a4:	bb 0f       	add	r27, r27
    25a6:	40 f4       	brcc	.+16     	; 0x25b8 <__fp_round+0x20>
    25a8:	bf 2b       	or	r27, r31
    25aa:	11 f4       	brne	.+4      	; 0x25b0 <__fp_round+0x18>
    25ac:	60 ff       	sbrs	r22, 0
    25ae:	04 c0       	rjmp	.+8      	; 0x25b8 <__fp_round+0x20>
    25b0:	6f 5f       	subi	r22, 0xFF	; 255
    25b2:	7f 4f       	sbci	r23, 0xFF	; 255
    25b4:	8f 4f       	sbci	r24, 0xFF	; 255
    25b6:	9f 4f       	sbci	r25, 0xFF	; 255
    25b8:	08 95       	ret

000025ba <__fp_split3>:
    25ba:	57 fd       	sbrc	r21, 7
    25bc:	90 58       	subi	r25, 0x80	; 128
    25be:	44 0f       	add	r20, r20
    25c0:	55 1f       	adc	r21, r21
    25c2:	59 f0       	breq	.+22     	; 0x25da <__fp_splitA+0x10>
    25c4:	5f 3f       	cpi	r21, 0xFF	; 255
    25c6:	71 f0       	breq	.+28     	; 0x25e4 <__fp_splitA+0x1a>
    25c8:	47 95       	ror	r20

000025ca <__fp_splitA>:
    25ca:	88 0f       	add	r24, r24
    25cc:	97 fb       	bst	r25, 7
    25ce:	99 1f       	adc	r25, r25
    25d0:	61 f0       	breq	.+24     	; 0x25ea <__fp_splitA+0x20>
    25d2:	9f 3f       	cpi	r25, 0xFF	; 255
    25d4:	79 f0       	breq	.+30     	; 0x25f4 <__fp_splitA+0x2a>
    25d6:	87 95       	ror	r24
    25d8:	08 95       	ret
    25da:	12 16       	cp	r1, r18
    25dc:	13 06       	cpc	r1, r19
    25de:	14 06       	cpc	r1, r20
    25e0:	55 1f       	adc	r21, r21
    25e2:	f2 cf       	rjmp	.-28     	; 0x25c8 <__fp_split3+0xe>
    25e4:	46 95       	lsr	r20
    25e6:	f1 df       	rcall	.-30     	; 0x25ca <__fp_splitA>
    25e8:	08 c0       	rjmp	.+16     	; 0x25fa <__fp_splitA+0x30>
    25ea:	16 16       	cp	r1, r22
    25ec:	17 06       	cpc	r1, r23
    25ee:	18 06       	cpc	r1, r24
    25f0:	99 1f       	adc	r25, r25
    25f2:	f1 cf       	rjmp	.-30     	; 0x25d6 <__fp_splitA+0xc>
    25f4:	86 95       	lsr	r24
    25f6:	71 05       	cpc	r23, r1
    25f8:	61 05       	cpc	r22, r1
    25fa:	08 94       	sec
    25fc:	08 95       	ret

000025fe <__fp_zero>:
    25fe:	e8 94       	clt

00002600 <__fp_szero>:
    2600:	bb 27       	eor	r27, r27
    2602:	66 27       	eor	r22, r22
    2604:	77 27       	eor	r23, r23
    2606:	cb 01       	movw	r24, r22
    2608:	97 f9       	bld	r25, 7
    260a:	08 95       	ret

0000260c <__mulsf3>:
    260c:	0e 94 19 13 	call	0x2632	; 0x2632 <__mulsf3x>
    2610:	0c 94 cc 12 	jmp	0x2598	; 0x2598 <__fp_round>
    2614:	0e 94 be 12 	call	0x257c	; 0x257c <__fp_pscA>
    2618:	38 f0       	brcs	.+14     	; 0x2628 <__mulsf3+0x1c>
    261a:	0e 94 c5 12 	call	0x258a	; 0x258a <__fp_pscB>
    261e:	20 f0       	brcs	.+8      	; 0x2628 <__mulsf3+0x1c>
    2620:	95 23       	and	r25, r21
    2622:	11 f0       	breq	.+4      	; 0x2628 <__mulsf3+0x1c>
    2624:	0c 94 b5 12 	jmp	0x256a	; 0x256a <__fp_inf>
    2628:	0c 94 bb 12 	jmp	0x2576	; 0x2576 <__fp_nan>
    262c:	11 24       	eor	r1, r1
    262e:	0c 94 00 13 	jmp	0x2600	; 0x2600 <__fp_szero>

00002632 <__mulsf3x>:
    2632:	0e 94 dd 12 	call	0x25ba	; 0x25ba <__fp_split3>
    2636:	70 f3       	brcs	.-36     	; 0x2614 <__mulsf3+0x8>

00002638 <__mulsf3_pse>:
    2638:	95 9f       	mul	r25, r21
    263a:	c1 f3       	breq	.-16     	; 0x262c <__mulsf3+0x20>
    263c:	95 0f       	add	r25, r21
    263e:	50 e0       	ldi	r21, 0x00	; 0
    2640:	55 1f       	adc	r21, r21
    2642:	62 9f       	mul	r22, r18
    2644:	f0 01       	movw	r30, r0
    2646:	72 9f       	mul	r23, r18
    2648:	bb 27       	eor	r27, r27
    264a:	f0 0d       	add	r31, r0
    264c:	b1 1d       	adc	r27, r1
    264e:	63 9f       	mul	r22, r19
    2650:	aa 27       	eor	r26, r26
    2652:	f0 0d       	add	r31, r0
    2654:	b1 1d       	adc	r27, r1
    2656:	aa 1f       	adc	r26, r26
    2658:	64 9f       	mul	r22, r20
    265a:	66 27       	eor	r22, r22
    265c:	b0 0d       	add	r27, r0
    265e:	a1 1d       	adc	r26, r1
    2660:	66 1f       	adc	r22, r22
    2662:	82 9f       	mul	r24, r18
    2664:	22 27       	eor	r18, r18
    2666:	b0 0d       	add	r27, r0
    2668:	a1 1d       	adc	r26, r1
    266a:	62 1f       	adc	r22, r18
    266c:	73 9f       	mul	r23, r19
    266e:	b0 0d       	add	r27, r0
    2670:	a1 1d       	adc	r26, r1
    2672:	62 1f       	adc	r22, r18
    2674:	83 9f       	mul	r24, r19
    2676:	a0 0d       	add	r26, r0
    2678:	61 1d       	adc	r22, r1
    267a:	22 1f       	adc	r18, r18
    267c:	74 9f       	mul	r23, r20
    267e:	33 27       	eor	r19, r19
    2680:	a0 0d       	add	r26, r0
    2682:	61 1d       	adc	r22, r1
    2684:	23 1f       	adc	r18, r19
    2686:	84 9f       	mul	r24, r20
    2688:	60 0d       	add	r22, r0
    268a:	21 1d       	adc	r18, r1
    268c:	82 2f       	mov	r24, r18
    268e:	76 2f       	mov	r23, r22
    2690:	6a 2f       	mov	r22, r26
    2692:	11 24       	eor	r1, r1
    2694:	9f 57       	subi	r25, 0x7F	; 127
    2696:	50 40       	sbci	r21, 0x00	; 0
    2698:	9a f0       	brmi	.+38     	; 0x26c0 <__mulsf3_pse+0x88>
    269a:	f1 f0       	breq	.+60     	; 0x26d8 <__mulsf3_pse+0xa0>
    269c:	88 23       	and	r24, r24
    269e:	4a f0       	brmi	.+18     	; 0x26b2 <__mulsf3_pse+0x7a>
    26a0:	ee 0f       	add	r30, r30
    26a2:	ff 1f       	adc	r31, r31
    26a4:	bb 1f       	adc	r27, r27
    26a6:	66 1f       	adc	r22, r22
    26a8:	77 1f       	adc	r23, r23
    26aa:	88 1f       	adc	r24, r24
    26ac:	91 50       	subi	r25, 0x01	; 1
    26ae:	50 40       	sbci	r21, 0x00	; 0
    26b0:	a9 f7       	brne	.-22     	; 0x269c <__mulsf3_pse+0x64>
    26b2:	9e 3f       	cpi	r25, 0xFE	; 254
    26b4:	51 05       	cpc	r21, r1
    26b6:	80 f0       	brcs	.+32     	; 0x26d8 <__mulsf3_pse+0xa0>
    26b8:	0c 94 b5 12 	jmp	0x256a	; 0x256a <__fp_inf>
    26bc:	0c 94 00 13 	jmp	0x2600	; 0x2600 <__fp_szero>
    26c0:	5f 3f       	cpi	r21, 0xFF	; 255
    26c2:	e4 f3       	brlt	.-8      	; 0x26bc <__mulsf3_pse+0x84>
    26c4:	98 3e       	cpi	r25, 0xE8	; 232
    26c6:	d4 f3       	brlt	.-12     	; 0x26bc <__mulsf3_pse+0x84>
    26c8:	86 95       	lsr	r24
    26ca:	77 95       	ror	r23
    26cc:	67 95       	ror	r22
    26ce:	b7 95       	ror	r27
    26d0:	f7 95       	ror	r31
    26d2:	e7 95       	ror	r30
    26d4:	9f 5f       	subi	r25, 0xFF	; 255
    26d6:	c1 f7       	brne	.-16     	; 0x26c8 <__mulsf3_pse+0x90>
    26d8:	fe 2b       	or	r31, r30
    26da:	88 0f       	add	r24, r24
    26dc:	91 1d       	adc	r25, r1
    26de:	96 95       	lsr	r25
    26e0:	87 95       	ror	r24
    26e2:	97 f9       	bld	r25, 7
    26e4:	08 95       	ret

000026e6 <__tablejump2__>:
    26e6:	ee 0f       	add	r30, r30
    26e8:	ff 1f       	adc	r31, r31
    26ea:	05 90       	lpm	r0, Z+
    26ec:	f4 91       	lpm	r31, Z
    26ee:	e0 2d       	mov	r30, r0
    26f0:	09 94       	ijmp

000026f2 <__umulhisi3>:
    26f2:	a2 9f       	mul	r26, r18
    26f4:	b0 01       	movw	r22, r0
    26f6:	b3 9f       	mul	r27, r19
    26f8:	c0 01       	movw	r24, r0
    26fa:	a3 9f       	mul	r26, r19
    26fc:	70 0d       	add	r23, r0
    26fe:	81 1d       	adc	r24, r1
    2700:	11 24       	eor	r1, r1
    2702:	91 1d       	adc	r25, r1
    2704:	b2 9f       	mul	r27, r18
    2706:	70 0d       	add	r23, r0
    2708:	81 1d       	adc	r24, r1
    270a:	11 24       	eor	r1, r1
    270c:	91 1d       	adc	r25, r1
    270e:	08 95       	ret

00002710 <strcmp>:
    2710:	fb 01       	movw	r30, r22
    2712:	dc 01       	movw	r26, r24
    2714:	8d 91       	ld	r24, X+
    2716:	01 90       	ld	r0, Z+
    2718:	80 19       	sub	r24, r0
    271a:	01 10       	cpse	r0, r1
    271c:	d9 f3       	breq	.-10     	; 0x2714 <strcmp+0x4>
    271e:	99 0b       	sbc	r25, r25
    2720:	08 95       	ret

00002722 <strcpy>:
    2722:	fb 01       	movw	r30, r22
    2724:	dc 01       	movw	r26, r24
    2726:	01 90       	ld	r0, Z+
    2728:	0d 92       	st	X+, r0
    272a:	00 20       	and	r0, r0
    272c:	e1 f7       	brne	.-8      	; 0x2726 <strcpy+0x4>
    272e:	08 95       	ret

00002730 <sprintf>:
    2730:	ae e0       	ldi	r26, 0x0E	; 14
    2732:	b0 e0       	ldi	r27, 0x00	; 0
    2734:	ee e9       	ldi	r30, 0x9E	; 158
    2736:	f3 e1       	ldi	r31, 0x13	; 19
    2738:	0c 94 59 16 	jmp	0x2cb2	; 0x2cb2 <__prologue_saves__+0x1c>
    273c:	0d 89       	ldd	r16, Y+21	; 0x15
    273e:	1e 89       	ldd	r17, Y+22	; 0x16
    2740:	86 e0       	ldi	r24, 0x06	; 6
    2742:	8c 83       	std	Y+4, r24	; 0x04
    2744:	1a 83       	std	Y+2, r17	; 0x02
    2746:	09 83       	std	Y+1, r16	; 0x01
    2748:	8f ef       	ldi	r24, 0xFF	; 255
    274a:	9f e7       	ldi	r25, 0x7F	; 127
    274c:	9e 83       	std	Y+6, r25	; 0x06
    274e:	8d 83       	std	Y+5, r24	; 0x05
    2750:	ae 01       	movw	r20, r28
    2752:	47 5e       	subi	r20, 0xE7	; 231
    2754:	5f 4f       	sbci	r21, 0xFF	; 255
    2756:	6f 89       	ldd	r22, Y+23	; 0x17
    2758:	78 8d       	ldd	r23, Y+24	; 0x18
    275a:	ce 01       	movw	r24, r28
    275c:	01 96       	adiw	r24, 0x01	; 1
    275e:	0e 94 ba 13 	call	0x2774	; 0x2774 <vfprintf>
    2762:	ef 81       	ldd	r30, Y+7	; 0x07
    2764:	f8 85       	ldd	r31, Y+8	; 0x08
    2766:	e0 0f       	add	r30, r16
    2768:	f1 1f       	adc	r31, r17
    276a:	10 82       	st	Z, r1
    276c:	2e 96       	adiw	r28, 0x0e	; 14
    276e:	e4 e0       	ldi	r30, 0x04	; 4
    2770:	0c 94 75 16 	jmp	0x2cea	; 0x2cea <__epilogue_restores__+0x1c>

00002774 <vfprintf>:
    2774:	ab e0       	ldi	r26, 0x0B	; 11
    2776:	b0 e0       	ldi	r27, 0x00	; 0
    2778:	e0 ec       	ldi	r30, 0xC0	; 192
    277a:	f3 e1       	ldi	r31, 0x13	; 19
    277c:	0c 94 4b 16 	jmp	0x2c96	; 0x2c96 <__prologue_saves__>
    2780:	6c 01       	movw	r12, r24
    2782:	7b 01       	movw	r14, r22
    2784:	8a 01       	movw	r16, r20
    2786:	fc 01       	movw	r30, r24
    2788:	17 82       	std	Z+7, r1	; 0x07
    278a:	16 82       	std	Z+6, r1	; 0x06
    278c:	83 81       	ldd	r24, Z+3	; 0x03
    278e:	81 ff       	sbrs	r24, 1
    2790:	cc c1       	rjmp	.+920    	; 0x2b2a <vfprintf+0x3b6>
    2792:	ce 01       	movw	r24, r28
    2794:	01 96       	adiw	r24, 0x01	; 1
    2796:	3c 01       	movw	r6, r24
    2798:	f6 01       	movw	r30, r12
    279a:	93 81       	ldd	r25, Z+3	; 0x03
    279c:	f7 01       	movw	r30, r14
    279e:	93 fd       	sbrc	r25, 3
    27a0:	85 91       	lpm	r24, Z+
    27a2:	93 ff       	sbrs	r25, 3
    27a4:	81 91       	ld	r24, Z+
    27a6:	7f 01       	movw	r14, r30
    27a8:	88 23       	and	r24, r24
    27aa:	09 f4       	brne	.+2      	; 0x27ae <vfprintf+0x3a>
    27ac:	ba c1       	rjmp	.+884    	; 0x2b22 <vfprintf+0x3ae>
    27ae:	85 32       	cpi	r24, 0x25	; 37
    27b0:	39 f4       	brne	.+14     	; 0x27c0 <vfprintf+0x4c>
    27b2:	93 fd       	sbrc	r25, 3
    27b4:	85 91       	lpm	r24, Z+
    27b6:	93 ff       	sbrs	r25, 3
    27b8:	81 91       	ld	r24, Z+
    27ba:	7f 01       	movw	r14, r30
    27bc:	85 32       	cpi	r24, 0x25	; 37
    27be:	29 f4       	brne	.+10     	; 0x27ca <vfprintf+0x56>
    27c0:	b6 01       	movw	r22, r12
    27c2:	90 e0       	ldi	r25, 0x00	; 0
    27c4:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <fputc>
    27c8:	e7 cf       	rjmp	.-50     	; 0x2798 <vfprintf+0x24>
    27ca:	91 2c       	mov	r9, r1
    27cc:	21 2c       	mov	r2, r1
    27ce:	31 2c       	mov	r3, r1
    27d0:	ff e1       	ldi	r31, 0x1F	; 31
    27d2:	f3 15       	cp	r31, r3
    27d4:	d8 f0       	brcs	.+54     	; 0x280c <vfprintf+0x98>
    27d6:	8b 32       	cpi	r24, 0x2B	; 43
    27d8:	79 f0       	breq	.+30     	; 0x27f8 <vfprintf+0x84>
    27da:	38 f4       	brcc	.+14     	; 0x27ea <vfprintf+0x76>
    27dc:	80 32       	cpi	r24, 0x20	; 32
    27de:	79 f0       	breq	.+30     	; 0x27fe <vfprintf+0x8a>
    27e0:	83 32       	cpi	r24, 0x23	; 35
    27e2:	a1 f4       	brne	.+40     	; 0x280c <vfprintf+0x98>
    27e4:	23 2d       	mov	r18, r3
    27e6:	20 61       	ori	r18, 0x10	; 16
    27e8:	1d c0       	rjmp	.+58     	; 0x2824 <vfprintf+0xb0>
    27ea:	8d 32       	cpi	r24, 0x2D	; 45
    27ec:	61 f0       	breq	.+24     	; 0x2806 <vfprintf+0x92>
    27ee:	80 33       	cpi	r24, 0x30	; 48
    27f0:	69 f4       	brne	.+26     	; 0x280c <vfprintf+0x98>
    27f2:	23 2d       	mov	r18, r3
    27f4:	21 60       	ori	r18, 0x01	; 1
    27f6:	16 c0       	rjmp	.+44     	; 0x2824 <vfprintf+0xb0>
    27f8:	83 2d       	mov	r24, r3
    27fa:	82 60       	ori	r24, 0x02	; 2
    27fc:	38 2e       	mov	r3, r24
    27fe:	e3 2d       	mov	r30, r3
    2800:	e4 60       	ori	r30, 0x04	; 4
    2802:	3e 2e       	mov	r3, r30
    2804:	2a c0       	rjmp	.+84     	; 0x285a <vfprintf+0xe6>
    2806:	f3 2d       	mov	r31, r3
    2808:	f8 60       	ori	r31, 0x08	; 8
    280a:	1d c0       	rjmp	.+58     	; 0x2846 <vfprintf+0xd2>
    280c:	37 fc       	sbrc	r3, 7
    280e:	2d c0       	rjmp	.+90     	; 0x286a <vfprintf+0xf6>
    2810:	20 ed       	ldi	r18, 0xD0	; 208
    2812:	28 0f       	add	r18, r24
    2814:	2a 30       	cpi	r18, 0x0A	; 10
    2816:	40 f0       	brcs	.+16     	; 0x2828 <vfprintf+0xb4>
    2818:	8e 32       	cpi	r24, 0x2E	; 46
    281a:	b9 f4       	brne	.+46     	; 0x284a <vfprintf+0xd6>
    281c:	36 fc       	sbrc	r3, 6
    281e:	81 c1       	rjmp	.+770    	; 0x2b22 <vfprintf+0x3ae>
    2820:	23 2d       	mov	r18, r3
    2822:	20 64       	ori	r18, 0x40	; 64
    2824:	32 2e       	mov	r3, r18
    2826:	19 c0       	rjmp	.+50     	; 0x285a <vfprintf+0xe6>
    2828:	36 fe       	sbrs	r3, 6
    282a:	06 c0       	rjmp	.+12     	; 0x2838 <vfprintf+0xc4>
    282c:	8a e0       	ldi	r24, 0x0A	; 10
    282e:	98 9e       	mul	r9, r24
    2830:	20 0d       	add	r18, r0
    2832:	11 24       	eor	r1, r1
    2834:	92 2e       	mov	r9, r18
    2836:	11 c0       	rjmp	.+34     	; 0x285a <vfprintf+0xe6>
    2838:	ea e0       	ldi	r30, 0x0A	; 10
    283a:	2e 9e       	mul	r2, r30
    283c:	20 0d       	add	r18, r0
    283e:	11 24       	eor	r1, r1
    2840:	22 2e       	mov	r2, r18
    2842:	f3 2d       	mov	r31, r3
    2844:	f0 62       	ori	r31, 0x20	; 32
    2846:	3f 2e       	mov	r3, r31
    2848:	08 c0       	rjmp	.+16     	; 0x285a <vfprintf+0xe6>
    284a:	8c 36       	cpi	r24, 0x6C	; 108
    284c:	21 f4       	brne	.+8      	; 0x2856 <vfprintf+0xe2>
    284e:	83 2d       	mov	r24, r3
    2850:	80 68       	ori	r24, 0x80	; 128
    2852:	38 2e       	mov	r3, r24
    2854:	02 c0       	rjmp	.+4      	; 0x285a <vfprintf+0xe6>
    2856:	88 36       	cpi	r24, 0x68	; 104
    2858:	41 f4       	brne	.+16     	; 0x286a <vfprintf+0xf6>
    285a:	f7 01       	movw	r30, r14
    285c:	93 fd       	sbrc	r25, 3
    285e:	85 91       	lpm	r24, Z+
    2860:	93 ff       	sbrs	r25, 3
    2862:	81 91       	ld	r24, Z+
    2864:	7f 01       	movw	r14, r30
    2866:	81 11       	cpse	r24, r1
    2868:	b3 cf       	rjmp	.-154    	; 0x27d0 <vfprintf+0x5c>
    286a:	98 2f       	mov	r25, r24
    286c:	9f 7d       	andi	r25, 0xDF	; 223
    286e:	95 54       	subi	r25, 0x45	; 69
    2870:	93 30       	cpi	r25, 0x03	; 3
    2872:	28 f4       	brcc	.+10     	; 0x287e <vfprintf+0x10a>
    2874:	0c 5f       	subi	r16, 0xFC	; 252
    2876:	1f 4f       	sbci	r17, 0xFF	; 255
    2878:	9f e3       	ldi	r25, 0x3F	; 63
    287a:	99 83       	std	Y+1, r25	; 0x01
    287c:	0d c0       	rjmp	.+26     	; 0x2898 <vfprintf+0x124>
    287e:	83 36       	cpi	r24, 0x63	; 99
    2880:	31 f0       	breq	.+12     	; 0x288e <vfprintf+0x11a>
    2882:	83 37       	cpi	r24, 0x73	; 115
    2884:	71 f0       	breq	.+28     	; 0x28a2 <vfprintf+0x12e>
    2886:	83 35       	cpi	r24, 0x53	; 83
    2888:	09 f0       	breq	.+2      	; 0x288c <vfprintf+0x118>
    288a:	59 c0       	rjmp	.+178    	; 0x293e <vfprintf+0x1ca>
    288c:	21 c0       	rjmp	.+66     	; 0x28d0 <vfprintf+0x15c>
    288e:	f8 01       	movw	r30, r16
    2890:	80 81       	ld	r24, Z
    2892:	89 83       	std	Y+1, r24	; 0x01
    2894:	0e 5f       	subi	r16, 0xFE	; 254
    2896:	1f 4f       	sbci	r17, 0xFF	; 255
    2898:	88 24       	eor	r8, r8
    289a:	83 94       	inc	r8
    289c:	91 2c       	mov	r9, r1
    289e:	53 01       	movw	r10, r6
    28a0:	13 c0       	rjmp	.+38     	; 0x28c8 <vfprintf+0x154>
    28a2:	28 01       	movw	r4, r16
    28a4:	f2 e0       	ldi	r31, 0x02	; 2
    28a6:	4f 0e       	add	r4, r31
    28a8:	51 1c       	adc	r5, r1
    28aa:	f8 01       	movw	r30, r16
    28ac:	a0 80       	ld	r10, Z
    28ae:	b1 80       	ldd	r11, Z+1	; 0x01
    28b0:	36 fe       	sbrs	r3, 6
    28b2:	03 c0       	rjmp	.+6      	; 0x28ba <vfprintf+0x146>
    28b4:	69 2d       	mov	r22, r9
    28b6:	70 e0       	ldi	r23, 0x00	; 0
    28b8:	02 c0       	rjmp	.+4      	; 0x28be <vfprintf+0x14a>
    28ba:	6f ef       	ldi	r22, 0xFF	; 255
    28bc:	7f ef       	ldi	r23, 0xFF	; 255
    28be:	c5 01       	movw	r24, r10
    28c0:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <strnlen>
    28c4:	4c 01       	movw	r8, r24
    28c6:	82 01       	movw	r16, r4
    28c8:	f3 2d       	mov	r31, r3
    28ca:	ff 77       	andi	r31, 0x7F	; 127
    28cc:	3f 2e       	mov	r3, r31
    28ce:	16 c0       	rjmp	.+44     	; 0x28fc <vfprintf+0x188>
    28d0:	28 01       	movw	r4, r16
    28d2:	22 e0       	ldi	r18, 0x02	; 2
    28d4:	42 0e       	add	r4, r18
    28d6:	51 1c       	adc	r5, r1
    28d8:	f8 01       	movw	r30, r16
    28da:	a0 80       	ld	r10, Z
    28dc:	b1 80       	ldd	r11, Z+1	; 0x01
    28de:	36 fe       	sbrs	r3, 6
    28e0:	03 c0       	rjmp	.+6      	; 0x28e8 <vfprintf+0x174>
    28e2:	69 2d       	mov	r22, r9
    28e4:	70 e0       	ldi	r23, 0x00	; 0
    28e6:	02 c0       	rjmp	.+4      	; 0x28ec <vfprintf+0x178>
    28e8:	6f ef       	ldi	r22, 0xFF	; 255
    28ea:	7f ef       	ldi	r23, 0xFF	; 255
    28ec:	c5 01       	movw	r24, r10
    28ee:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <strnlen_P>
    28f2:	4c 01       	movw	r8, r24
    28f4:	f3 2d       	mov	r31, r3
    28f6:	f0 68       	ori	r31, 0x80	; 128
    28f8:	3f 2e       	mov	r3, r31
    28fa:	82 01       	movw	r16, r4
    28fc:	33 fc       	sbrc	r3, 3
    28fe:	1b c0       	rjmp	.+54     	; 0x2936 <vfprintf+0x1c2>
    2900:	82 2d       	mov	r24, r2
    2902:	90 e0       	ldi	r25, 0x00	; 0
    2904:	88 16       	cp	r8, r24
    2906:	99 06       	cpc	r9, r25
    2908:	b0 f4       	brcc	.+44     	; 0x2936 <vfprintf+0x1c2>
    290a:	b6 01       	movw	r22, r12
    290c:	80 e2       	ldi	r24, 0x20	; 32
    290e:	90 e0       	ldi	r25, 0x00	; 0
    2910:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <fputc>
    2914:	2a 94       	dec	r2
    2916:	f4 cf       	rjmp	.-24     	; 0x2900 <vfprintf+0x18c>
    2918:	f5 01       	movw	r30, r10
    291a:	37 fc       	sbrc	r3, 7
    291c:	85 91       	lpm	r24, Z+
    291e:	37 fe       	sbrs	r3, 7
    2920:	81 91       	ld	r24, Z+
    2922:	5f 01       	movw	r10, r30
    2924:	b6 01       	movw	r22, r12
    2926:	90 e0       	ldi	r25, 0x00	; 0
    2928:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <fputc>
    292c:	21 10       	cpse	r2, r1
    292e:	2a 94       	dec	r2
    2930:	21 e0       	ldi	r18, 0x01	; 1
    2932:	82 1a       	sub	r8, r18
    2934:	91 08       	sbc	r9, r1
    2936:	81 14       	cp	r8, r1
    2938:	91 04       	cpc	r9, r1
    293a:	71 f7       	brne	.-36     	; 0x2918 <vfprintf+0x1a4>
    293c:	e8 c0       	rjmp	.+464    	; 0x2b0e <vfprintf+0x39a>
    293e:	84 36       	cpi	r24, 0x64	; 100
    2940:	11 f0       	breq	.+4      	; 0x2946 <vfprintf+0x1d2>
    2942:	89 36       	cpi	r24, 0x69	; 105
    2944:	41 f5       	brne	.+80     	; 0x2996 <vfprintf+0x222>
    2946:	f8 01       	movw	r30, r16
    2948:	37 fe       	sbrs	r3, 7
    294a:	07 c0       	rjmp	.+14     	; 0x295a <vfprintf+0x1e6>
    294c:	60 81       	ld	r22, Z
    294e:	71 81       	ldd	r23, Z+1	; 0x01
    2950:	82 81       	ldd	r24, Z+2	; 0x02
    2952:	93 81       	ldd	r25, Z+3	; 0x03
    2954:	0c 5f       	subi	r16, 0xFC	; 252
    2956:	1f 4f       	sbci	r17, 0xFF	; 255
    2958:	08 c0       	rjmp	.+16     	; 0x296a <vfprintf+0x1f6>
    295a:	60 81       	ld	r22, Z
    295c:	71 81       	ldd	r23, Z+1	; 0x01
    295e:	07 2e       	mov	r0, r23
    2960:	00 0c       	add	r0, r0
    2962:	88 0b       	sbc	r24, r24
    2964:	99 0b       	sbc	r25, r25
    2966:	0e 5f       	subi	r16, 0xFE	; 254
    2968:	1f 4f       	sbci	r17, 0xFF	; 255
    296a:	f3 2d       	mov	r31, r3
    296c:	ff 76       	andi	r31, 0x6F	; 111
    296e:	3f 2e       	mov	r3, r31
    2970:	97 ff       	sbrs	r25, 7
    2972:	09 c0       	rjmp	.+18     	; 0x2986 <vfprintf+0x212>
    2974:	90 95       	com	r25
    2976:	80 95       	com	r24
    2978:	70 95       	com	r23
    297a:	61 95       	neg	r22
    297c:	7f 4f       	sbci	r23, 0xFF	; 255
    297e:	8f 4f       	sbci	r24, 0xFF	; 255
    2980:	9f 4f       	sbci	r25, 0xFF	; 255
    2982:	f0 68       	ori	r31, 0x80	; 128
    2984:	3f 2e       	mov	r3, r31
    2986:	2a e0       	ldi	r18, 0x0A	; 10
    2988:	30 e0       	ldi	r19, 0x00	; 0
    298a:	a3 01       	movw	r20, r6
    298c:	0e 94 ed 15 	call	0x2bda	; 0x2bda <__ultoa_invert>
    2990:	88 2e       	mov	r8, r24
    2992:	86 18       	sub	r8, r6
    2994:	45 c0       	rjmp	.+138    	; 0x2a20 <vfprintf+0x2ac>
    2996:	85 37       	cpi	r24, 0x75	; 117
    2998:	31 f4       	brne	.+12     	; 0x29a6 <vfprintf+0x232>
    299a:	23 2d       	mov	r18, r3
    299c:	2f 7e       	andi	r18, 0xEF	; 239
    299e:	b2 2e       	mov	r11, r18
    29a0:	2a e0       	ldi	r18, 0x0A	; 10
    29a2:	30 e0       	ldi	r19, 0x00	; 0
    29a4:	25 c0       	rjmp	.+74     	; 0x29f0 <vfprintf+0x27c>
    29a6:	93 2d       	mov	r25, r3
    29a8:	99 7f       	andi	r25, 0xF9	; 249
    29aa:	b9 2e       	mov	r11, r25
    29ac:	8f 36       	cpi	r24, 0x6F	; 111
    29ae:	c1 f0       	breq	.+48     	; 0x29e0 <vfprintf+0x26c>
    29b0:	18 f4       	brcc	.+6      	; 0x29b8 <vfprintf+0x244>
    29b2:	88 35       	cpi	r24, 0x58	; 88
    29b4:	79 f0       	breq	.+30     	; 0x29d4 <vfprintf+0x260>
    29b6:	b5 c0       	rjmp	.+362    	; 0x2b22 <vfprintf+0x3ae>
    29b8:	80 37       	cpi	r24, 0x70	; 112
    29ba:	19 f0       	breq	.+6      	; 0x29c2 <vfprintf+0x24e>
    29bc:	88 37       	cpi	r24, 0x78	; 120
    29be:	21 f0       	breq	.+8      	; 0x29c8 <vfprintf+0x254>
    29c0:	b0 c0       	rjmp	.+352    	; 0x2b22 <vfprintf+0x3ae>
    29c2:	e9 2f       	mov	r30, r25
    29c4:	e0 61       	ori	r30, 0x10	; 16
    29c6:	be 2e       	mov	r11, r30
    29c8:	b4 fe       	sbrs	r11, 4
    29ca:	0d c0       	rjmp	.+26     	; 0x29e6 <vfprintf+0x272>
    29cc:	fb 2d       	mov	r31, r11
    29ce:	f4 60       	ori	r31, 0x04	; 4
    29d0:	bf 2e       	mov	r11, r31
    29d2:	09 c0       	rjmp	.+18     	; 0x29e6 <vfprintf+0x272>
    29d4:	34 fe       	sbrs	r3, 4
    29d6:	0a c0       	rjmp	.+20     	; 0x29ec <vfprintf+0x278>
    29d8:	29 2f       	mov	r18, r25
    29da:	26 60       	ori	r18, 0x06	; 6
    29dc:	b2 2e       	mov	r11, r18
    29de:	06 c0       	rjmp	.+12     	; 0x29ec <vfprintf+0x278>
    29e0:	28 e0       	ldi	r18, 0x08	; 8
    29e2:	30 e0       	ldi	r19, 0x00	; 0
    29e4:	05 c0       	rjmp	.+10     	; 0x29f0 <vfprintf+0x27c>
    29e6:	20 e1       	ldi	r18, 0x10	; 16
    29e8:	30 e0       	ldi	r19, 0x00	; 0
    29ea:	02 c0       	rjmp	.+4      	; 0x29f0 <vfprintf+0x27c>
    29ec:	20 e1       	ldi	r18, 0x10	; 16
    29ee:	32 e0       	ldi	r19, 0x02	; 2
    29f0:	f8 01       	movw	r30, r16
    29f2:	b7 fe       	sbrs	r11, 7
    29f4:	07 c0       	rjmp	.+14     	; 0x2a04 <vfprintf+0x290>
    29f6:	60 81       	ld	r22, Z
    29f8:	71 81       	ldd	r23, Z+1	; 0x01
    29fa:	82 81       	ldd	r24, Z+2	; 0x02
    29fc:	93 81       	ldd	r25, Z+3	; 0x03
    29fe:	0c 5f       	subi	r16, 0xFC	; 252
    2a00:	1f 4f       	sbci	r17, 0xFF	; 255
    2a02:	06 c0       	rjmp	.+12     	; 0x2a10 <vfprintf+0x29c>
    2a04:	60 81       	ld	r22, Z
    2a06:	71 81       	ldd	r23, Z+1	; 0x01
    2a08:	80 e0       	ldi	r24, 0x00	; 0
    2a0a:	90 e0       	ldi	r25, 0x00	; 0
    2a0c:	0e 5f       	subi	r16, 0xFE	; 254
    2a0e:	1f 4f       	sbci	r17, 0xFF	; 255
    2a10:	a3 01       	movw	r20, r6
    2a12:	0e 94 ed 15 	call	0x2bda	; 0x2bda <__ultoa_invert>
    2a16:	88 2e       	mov	r8, r24
    2a18:	86 18       	sub	r8, r6
    2a1a:	fb 2d       	mov	r31, r11
    2a1c:	ff 77       	andi	r31, 0x7F	; 127
    2a1e:	3f 2e       	mov	r3, r31
    2a20:	36 fe       	sbrs	r3, 6
    2a22:	0d c0       	rjmp	.+26     	; 0x2a3e <vfprintf+0x2ca>
    2a24:	23 2d       	mov	r18, r3
    2a26:	2e 7f       	andi	r18, 0xFE	; 254
    2a28:	a2 2e       	mov	r10, r18
    2a2a:	89 14       	cp	r8, r9
    2a2c:	58 f4       	brcc	.+22     	; 0x2a44 <vfprintf+0x2d0>
    2a2e:	34 fe       	sbrs	r3, 4
    2a30:	0b c0       	rjmp	.+22     	; 0x2a48 <vfprintf+0x2d4>
    2a32:	32 fc       	sbrc	r3, 2
    2a34:	09 c0       	rjmp	.+18     	; 0x2a48 <vfprintf+0x2d4>
    2a36:	83 2d       	mov	r24, r3
    2a38:	8e 7e       	andi	r24, 0xEE	; 238
    2a3a:	a8 2e       	mov	r10, r24
    2a3c:	05 c0       	rjmp	.+10     	; 0x2a48 <vfprintf+0x2d4>
    2a3e:	b8 2c       	mov	r11, r8
    2a40:	a3 2c       	mov	r10, r3
    2a42:	03 c0       	rjmp	.+6      	; 0x2a4a <vfprintf+0x2d6>
    2a44:	b8 2c       	mov	r11, r8
    2a46:	01 c0       	rjmp	.+2      	; 0x2a4a <vfprintf+0x2d6>
    2a48:	b9 2c       	mov	r11, r9
    2a4a:	a4 fe       	sbrs	r10, 4
    2a4c:	0f c0       	rjmp	.+30     	; 0x2a6c <vfprintf+0x2f8>
    2a4e:	fe 01       	movw	r30, r28
    2a50:	e8 0d       	add	r30, r8
    2a52:	f1 1d       	adc	r31, r1
    2a54:	80 81       	ld	r24, Z
    2a56:	80 33       	cpi	r24, 0x30	; 48
    2a58:	21 f4       	brne	.+8      	; 0x2a62 <vfprintf+0x2ee>
    2a5a:	9a 2d       	mov	r25, r10
    2a5c:	99 7e       	andi	r25, 0xE9	; 233
    2a5e:	a9 2e       	mov	r10, r25
    2a60:	09 c0       	rjmp	.+18     	; 0x2a74 <vfprintf+0x300>
    2a62:	a2 fe       	sbrs	r10, 2
    2a64:	06 c0       	rjmp	.+12     	; 0x2a72 <vfprintf+0x2fe>
    2a66:	b3 94       	inc	r11
    2a68:	b3 94       	inc	r11
    2a6a:	04 c0       	rjmp	.+8      	; 0x2a74 <vfprintf+0x300>
    2a6c:	8a 2d       	mov	r24, r10
    2a6e:	86 78       	andi	r24, 0x86	; 134
    2a70:	09 f0       	breq	.+2      	; 0x2a74 <vfprintf+0x300>
    2a72:	b3 94       	inc	r11
    2a74:	a3 fc       	sbrc	r10, 3
    2a76:	11 c0       	rjmp	.+34     	; 0x2a9a <vfprintf+0x326>
    2a78:	a0 fe       	sbrs	r10, 0
    2a7a:	06 c0       	rjmp	.+12     	; 0x2a88 <vfprintf+0x314>
    2a7c:	b2 14       	cp	r11, r2
    2a7e:	88 f4       	brcc	.+34     	; 0x2aa2 <vfprintf+0x32e>
    2a80:	28 0c       	add	r2, r8
    2a82:	92 2c       	mov	r9, r2
    2a84:	9b 18       	sub	r9, r11
    2a86:	0e c0       	rjmp	.+28     	; 0x2aa4 <vfprintf+0x330>
    2a88:	b2 14       	cp	r11, r2
    2a8a:	60 f4       	brcc	.+24     	; 0x2aa4 <vfprintf+0x330>
    2a8c:	b6 01       	movw	r22, r12
    2a8e:	80 e2       	ldi	r24, 0x20	; 32
    2a90:	90 e0       	ldi	r25, 0x00	; 0
    2a92:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <fputc>
    2a96:	b3 94       	inc	r11
    2a98:	f7 cf       	rjmp	.-18     	; 0x2a88 <vfprintf+0x314>
    2a9a:	b2 14       	cp	r11, r2
    2a9c:	18 f4       	brcc	.+6      	; 0x2aa4 <vfprintf+0x330>
    2a9e:	2b 18       	sub	r2, r11
    2aa0:	02 c0       	rjmp	.+4      	; 0x2aa6 <vfprintf+0x332>
    2aa2:	98 2c       	mov	r9, r8
    2aa4:	21 2c       	mov	r2, r1
    2aa6:	a4 fe       	sbrs	r10, 4
    2aa8:	10 c0       	rjmp	.+32     	; 0x2aca <vfprintf+0x356>
    2aaa:	b6 01       	movw	r22, r12
    2aac:	80 e3       	ldi	r24, 0x30	; 48
    2aae:	90 e0       	ldi	r25, 0x00	; 0
    2ab0:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <fputc>
    2ab4:	a2 fe       	sbrs	r10, 2
    2ab6:	17 c0       	rjmp	.+46     	; 0x2ae6 <vfprintf+0x372>
    2ab8:	a1 fc       	sbrc	r10, 1
    2aba:	03 c0       	rjmp	.+6      	; 0x2ac2 <vfprintf+0x34e>
    2abc:	88 e7       	ldi	r24, 0x78	; 120
    2abe:	90 e0       	ldi	r25, 0x00	; 0
    2ac0:	02 c0       	rjmp	.+4      	; 0x2ac6 <vfprintf+0x352>
    2ac2:	88 e5       	ldi	r24, 0x58	; 88
    2ac4:	90 e0       	ldi	r25, 0x00	; 0
    2ac6:	b6 01       	movw	r22, r12
    2ac8:	0c c0       	rjmp	.+24     	; 0x2ae2 <vfprintf+0x36e>
    2aca:	8a 2d       	mov	r24, r10
    2acc:	86 78       	andi	r24, 0x86	; 134
    2ace:	59 f0       	breq	.+22     	; 0x2ae6 <vfprintf+0x372>
    2ad0:	a1 fe       	sbrs	r10, 1
    2ad2:	02 c0       	rjmp	.+4      	; 0x2ad8 <vfprintf+0x364>
    2ad4:	8b e2       	ldi	r24, 0x2B	; 43
    2ad6:	01 c0       	rjmp	.+2      	; 0x2ada <vfprintf+0x366>
    2ad8:	80 e2       	ldi	r24, 0x20	; 32
    2ada:	a7 fc       	sbrc	r10, 7
    2adc:	8d e2       	ldi	r24, 0x2D	; 45
    2ade:	b6 01       	movw	r22, r12
    2ae0:	90 e0       	ldi	r25, 0x00	; 0
    2ae2:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <fputc>
    2ae6:	89 14       	cp	r8, r9
    2ae8:	38 f4       	brcc	.+14     	; 0x2af8 <vfprintf+0x384>
    2aea:	b6 01       	movw	r22, r12
    2aec:	80 e3       	ldi	r24, 0x30	; 48
    2aee:	90 e0       	ldi	r25, 0x00	; 0
    2af0:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <fputc>
    2af4:	9a 94       	dec	r9
    2af6:	f7 cf       	rjmp	.-18     	; 0x2ae6 <vfprintf+0x372>
    2af8:	8a 94       	dec	r8
    2afa:	f3 01       	movw	r30, r6
    2afc:	e8 0d       	add	r30, r8
    2afe:	f1 1d       	adc	r31, r1
    2b00:	80 81       	ld	r24, Z
    2b02:	b6 01       	movw	r22, r12
    2b04:	90 e0       	ldi	r25, 0x00	; 0
    2b06:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <fputc>
    2b0a:	81 10       	cpse	r8, r1
    2b0c:	f5 cf       	rjmp	.-22     	; 0x2af8 <vfprintf+0x384>
    2b0e:	22 20       	and	r2, r2
    2b10:	09 f4       	brne	.+2      	; 0x2b14 <vfprintf+0x3a0>
    2b12:	42 ce       	rjmp	.-892    	; 0x2798 <vfprintf+0x24>
    2b14:	b6 01       	movw	r22, r12
    2b16:	80 e2       	ldi	r24, 0x20	; 32
    2b18:	90 e0       	ldi	r25, 0x00	; 0
    2b1a:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <fputc>
    2b1e:	2a 94       	dec	r2
    2b20:	f6 cf       	rjmp	.-20     	; 0x2b0e <vfprintf+0x39a>
    2b22:	f6 01       	movw	r30, r12
    2b24:	86 81       	ldd	r24, Z+6	; 0x06
    2b26:	97 81       	ldd	r25, Z+7	; 0x07
    2b28:	02 c0       	rjmp	.+4      	; 0x2b2e <vfprintf+0x3ba>
    2b2a:	8f ef       	ldi	r24, 0xFF	; 255
    2b2c:	9f ef       	ldi	r25, 0xFF	; 255
    2b2e:	2b 96       	adiw	r28, 0x0b	; 11
    2b30:	e2 e1       	ldi	r30, 0x12	; 18
    2b32:	0c 94 67 16 	jmp	0x2cce	; 0x2cce <__epilogue_restores__>

00002b36 <strnlen_P>:
    2b36:	fc 01       	movw	r30, r24
    2b38:	05 90       	lpm	r0, Z+
    2b3a:	61 50       	subi	r22, 0x01	; 1
    2b3c:	70 40       	sbci	r23, 0x00	; 0
    2b3e:	01 10       	cpse	r0, r1
    2b40:	d8 f7       	brcc	.-10     	; 0x2b38 <strnlen_P+0x2>
    2b42:	80 95       	com	r24
    2b44:	90 95       	com	r25
    2b46:	8e 0f       	add	r24, r30
    2b48:	9f 1f       	adc	r25, r31
    2b4a:	08 95       	ret

00002b4c <strnlen>:
    2b4c:	fc 01       	movw	r30, r24
    2b4e:	61 50       	subi	r22, 0x01	; 1
    2b50:	70 40       	sbci	r23, 0x00	; 0
    2b52:	01 90       	ld	r0, Z+
    2b54:	01 10       	cpse	r0, r1
    2b56:	d8 f7       	brcc	.-10     	; 0x2b4e <strnlen+0x2>
    2b58:	80 95       	com	r24
    2b5a:	90 95       	com	r25
    2b5c:	8e 0f       	add	r24, r30
    2b5e:	9f 1f       	adc	r25, r31
    2b60:	08 95       	ret

00002b62 <fputc>:
    2b62:	0f 93       	push	r16
    2b64:	1f 93       	push	r17
    2b66:	cf 93       	push	r28
    2b68:	df 93       	push	r29
    2b6a:	fb 01       	movw	r30, r22
    2b6c:	23 81       	ldd	r18, Z+3	; 0x03
    2b6e:	21 fd       	sbrc	r18, 1
    2b70:	03 c0       	rjmp	.+6      	; 0x2b78 <fputc+0x16>
    2b72:	8f ef       	ldi	r24, 0xFF	; 255
    2b74:	9f ef       	ldi	r25, 0xFF	; 255
    2b76:	2c c0       	rjmp	.+88     	; 0x2bd0 <fputc+0x6e>
    2b78:	22 ff       	sbrs	r18, 2
    2b7a:	16 c0       	rjmp	.+44     	; 0x2ba8 <fputc+0x46>
    2b7c:	46 81       	ldd	r20, Z+6	; 0x06
    2b7e:	57 81       	ldd	r21, Z+7	; 0x07
    2b80:	24 81       	ldd	r18, Z+4	; 0x04
    2b82:	35 81       	ldd	r19, Z+5	; 0x05
    2b84:	42 17       	cp	r20, r18
    2b86:	53 07       	cpc	r21, r19
    2b88:	44 f4       	brge	.+16     	; 0x2b9a <fputc+0x38>
    2b8a:	a0 81       	ld	r26, Z
    2b8c:	b1 81       	ldd	r27, Z+1	; 0x01
    2b8e:	9d 01       	movw	r18, r26
    2b90:	2f 5f       	subi	r18, 0xFF	; 255
    2b92:	3f 4f       	sbci	r19, 0xFF	; 255
    2b94:	31 83       	std	Z+1, r19	; 0x01
    2b96:	20 83       	st	Z, r18
    2b98:	8c 93       	st	X, r24
    2b9a:	26 81       	ldd	r18, Z+6	; 0x06
    2b9c:	37 81       	ldd	r19, Z+7	; 0x07
    2b9e:	2f 5f       	subi	r18, 0xFF	; 255
    2ba0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ba2:	37 83       	std	Z+7, r19	; 0x07
    2ba4:	26 83       	std	Z+6, r18	; 0x06
    2ba6:	14 c0       	rjmp	.+40     	; 0x2bd0 <fputc+0x6e>
    2ba8:	8b 01       	movw	r16, r22
    2baa:	ec 01       	movw	r28, r24
    2bac:	fb 01       	movw	r30, r22
    2bae:	00 84       	ldd	r0, Z+8	; 0x08
    2bb0:	f1 85       	ldd	r31, Z+9	; 0x09
    2bb2:	e0 2d       	mov	r30, r0
    2bb4:	09 95       	icall
    2bb6:	89 2b       	or	r24, r25
    2bb8:	e1 f6       	brne	.-72     	; 0x2b72 <fputc+0x10>
    2bba:	d8 01       	movw	r26, r16
    2bbc:	16 96       	adiw	r26, 0x06	; 6
    2bbe:	8d 91       	ld	r24, X+
    2bc0:	9c 91       	ld	r25, X
    2bc2:	17 97       	sbiw	r26, 0x07	; 7
    2bc4:	01 96       	adiw	r24, 0x01	; 1
    2bc6:	17 96       	adiw	r26, 0x07	; 7
    2bc8:	9c 93       	st	X, r25
    2bca:	8e 93       	st	-X, r24
    2bcc:	16 97       	sbiw	r26, 0x06	; 6
    2bce:	ce 01       	movw	r24, r28
    2bd0:	df 91       	pop	r29
    2bd2:	cf 91       	pop	r28
    2bd4:	1f 91       	pop	r17
    2bd6:	0f 91       	pop	r16
    2bd8:	08 95       	ret

00002bda <__ultoa_invert>:
    2bda:	fa 01       	movw	r30, r20
    2bdc:	aa 27       	eor	r26, r26
    2bde:	28 30       	cpi	r18, 0x08	; 8
    2be0:	51 f1       	breq	.+84     	; 0x2c36 <__ultoa_invert+0x5c>
    2be2:	20 31       	cpi	r18, 0x10	; 16
    2be4:	81 f1       	breq	.+96     	; 0x2c46 <__ultoa_invert+0x6c>
    2be6:	e8 94       	clt
    2be8:	6f 93       	push	r22
    2bea:	6e 7f       	andi	r22, 0xFE	; 254
    2bec:	6e 5f       	subi	r22, 0xFE	; 254
    2bee:	7f 4f       	sbci	r23, 0xFF	; 255
    2bf0:	8f 4f       	sbci	r24, 0xFF	; 255
    2bf2:	9f 4f       	sbci	r25, 0xFF	; 255
    2bf4:	af 4f       	sbci	r26, 0xFF	; 255
    2bf6:	b1 e0       	ldi	r27, 0x01	; 1
    2bf8:	3e d0       	rcall	.+124    	; 0x2c76 <__ultoa_invert+0x9c>
    2bfa:	b4 e0       	ldi	r27, 0x04	; 4
    2bfc:	3c d0       	rcall	.+120    	; 0x2c76 <__ultoa_invert+0x9c>
    2bfe:	67 0f       	add	r22, r23
    2c00:	78 1f       	adc	r23, r24
    2c02:	89 1f       	adc	r24, r25
    2c04:	9a 1f       	adc	r25, r26
    2c06:	a1 1d       	adc	r26, r1
    2c08:	68 0f       	add	r22, r24
    2c0a:	79 1f       	adc	r23, r25
    2c0c:	8a 1f       	adc	r24, r26
    2c0e:	91 1d       	adc	r25, r1
    2c10:	a1 1d       	adc	r26, r1
    2c12:	6a 0f       	add	r22, r26
    2c14:	71 1d       	adc	r23, r1
    2c16:	81 1d       	adc	r24, r1
    2c18:	91 1d       	adc	r25, r1
    2c1a:	a1 1d       	adc	r26, r1
    2c1c:	20 d0       	rcall	.+64     	; 0x2c5e <__ultoa_invert+0x84>
    2c1e:	09 f4       	brne	.+2      	; 0x2c22 <__ultoa_invert+0x48>
    2c20:	68 94       	set
    2c22:	3f 91       	pop	r19
    2c24:	2a e0       	ldi	r18, 0x0A	; 10
    2c26:	26 9f       	mul	r18, r22
    2c28:	11 24       	eor	r1, r1
    2c2a:	30 19       	sub	r19, r0
    2c2c:	30 5d       	subi	r19, 0xD0	; 208
    2c2e:	31 93       	st	Z+, r19
    2c30:	de f6       	brtc	.-74     	; 0x2be8 <__ultoa_invert+0xe>
    2c32:	cf 01       	movw	r24, r30
    2c34:	08 95       	ret
    2c36:	46 2f       	mov	r20, r22
    2c38:	47 70       	andi	r20, 0x07	; 7
    2c3a:	40 5d       	subi	r20, 0xD0	; 208
    2c3c:	41 93       	st	Z+, r20
    2c3e:	b3 e0       	ldi	r27, 0x03	; 3
    2c40:	0f d0       	rcall	.+30     	; 0x2c60 <__ultoa_invert+0x86>
    2c42:	c9 f7       	brne	.-14     	; 0x2c36 <__ultoa_invert+0x5c>
    2c44:	f6 cf       	rjmp	.-20     	; 0x2c32 <__ultoa_invert+0x58>
    2c46:	46 2f       	mov	r20, r22
    2c48:	4f 70       	andi	r20, 0x0F	; 15
    2c4a:	40 5d       	subi	r20, 0xD0	; 208
    2c4c:	4a 33       	cpi	r20, 0x3A	; 58
    2c4e:	18 f0       	brcs	.+6      	; 0x2c56 <__ultoa_invert+0x7c>
    2c50:	49 5d       	subi	r20, 0xD9	; 217
    2c52:	31 fd       	sbrc	r19, 1
    2c54:	40 52       	subi	r20, 0x20	; 32
    2c56:	41 93       	st	Z+, r20
    2c58:	02 d0       	rcall	.+4      	; 0x2c5e <__ultoa_invert+0x84>
    2c5a:	a9 f7       	brne	.-22     	; 0x2c46 <__ultoa_invert+0x6c>
    2c5c:	ea cf       	rjmp	.-44     	; 0x2c32 <__ultoa_invert+0x58>
    2c5e:	b4 e0       	ldi	r27, 0x04	; 4
    2c60:	a6 95       	lsr	r26
    2c62:	97 95       	ror	r25
    2c64:	87 95       	ror	r24
    2c66:	77 95       	ror	r23
    2c68:	67 95       	ror	r22
    2c6a:	ba 95       	dec	r27
    2c6c:	c9 f7       	brne	.-14     	; 0x2c60 <__ultoa_invert+0x86>
    2c6e:	00 97       	sbiw	r24, 0x00	; 0
    2c70:	61 05       	cpc	r22, r1
    2c72:	71 05       	cpc	r23, r1
    2c74:	08 95       	ret
    2c76:	9b 01       	movw	r18, r22
    2c78:	ac 01       	movw	r20, r24
    2c7a:	0a 2e       	mov	r0, r26
    2c7c:	06 94       	lsr	r0
    2c7e:	57 95       	ror	r21
    2c80:	47 95       	ror	r20
    2c82:	37 95       	ror	r19
    2c84:	27 95       	ror	r18
    2c86:	ba 95       	dec	r27
    2c88:	c9 f7       	brne	.-14     	; 0x2c7c <__ultoa_invert+0xa2>
    2c8a:	62 0f       	add	r22, r18
    2c8c:	73 1f       	adc	r23, r19
    2c8e:	84 1f       	adc	r24, r20
    2c90:	95 1f       	adc	r25, r21
    2c92:	a0 1d       	adc	r26, r0
    2c94:	08 95       	ret

00002c96 <__prologue_saves__>:
    2c96:	2f 92       	push	r2
    2c98:	3f 92       	push	r3
    2c9a:	4f 92       	push	r4
    2c9c:	5f 92       	push	r5
    2c9e:	6f 92       	push	r6
    2ca0:	7f 92       	push	r7
    2ca2:	8f 92       	push	r8
    2ca4:	9f 92       	push	r9
    2ca6:	af 92       	push	r10
    2ca8:	bf 92       	push	r11
    2caa:	cf 92       	push	r12
    2cac:	df 92       	push	r13
    2cae:	ef 92       	push	r14
    2cb0:	ff 92       	push	r15
    2cb2:	0f 93       	push	r16
    2cb4:	1f 93       	push	r17
    2cb6:	cf 93       	push	r28
    2cb8:	df 93       	push	r29
    2cba:	cd b7       	in	r28, 0x3d	; 61
    2cbc:	de b7       	in	r29, 0x3e	; 62
    2cbe:	ca 1b       	sub	r28, r26
    2cc0:	db 0b       	sbc	r29, r27
    2cc2:	0f b6       	in	r0, 0x3f	; 63
    2cc4:	f8 94       	cli
    2cc6:	de bf       	out	0x3e, r29	; 62
    2cc8:	0f be       	out	0x3f, r0	; 63
    2cca:	cd bf       	out	0x3d, r28	; 61
    2ccc:	09 94       	ijmp

00002cce <__epilogue_restores__>:
    2cce:	2a 88       	ldd	r2, Y+18	; 0x12
    2cd0:	39 88       	ldd	r3, Y+17	; 0x11
    2cd2:	48 88       	ldd	r4, Y+16	; 0x10
    2cd4:	5f 84       	ldd	r5, Y+15	; 0x0f
    2cd6:	6e 84       	ldd	r6, Y+14	; 0x0e
    2cd8:	7d 84       	ldd	r7, Y+13	; 0x0d
    2cda:	8c 84       	ldd	r8, Y+12	; 0x0c
    2cdc:	9b 84       	ldd	r9, Y+11	; 0x0b
    2cde:	aa 84       	ldd	r10, Y+10	; 0x0a
    2ce0:	b9 84       	ldd	r11, Y+9	; 0x09
    2ce2:	c8 84       	ldd	r12, Y+8	; 0x08
    2ce4:	df 80       	ldd	r13, Y+7	; 0x07
    2ce6:	ee 80       	ldd	r14, Y+6	; 0x06
    2ce8:	fd 80       	ldd	r15, Y+5	; 0x05
    2cea:	0c 81       	ldd	r16, Y+4	; 0x04
    2cec:	1b 81       	ldd	r17, Y+3	; 0x03
    2cee:	aa 81       	ldd	r26, Y+2	; 0x02
    2cf0:	b9 81       	ldd	r27, Y+1	; 0x01
    2cf2:	ce 0f       	add	r28, r30
    2cf4:	d1 1d       	adc	r29, r1
    2cf6:	0f b6       	in	r0, 0x3f	; 63
    2cf8:	f8 94       	cli
    2cfa:	de bf       	out	0x3e, r29	; 62
    2cfc:	0f be       	out	0x3f, r0	; 63
    2cfe:	cd bf       	out	0x3d, r28	; 61
    2d00:	ed 01       	movw	r28, r26
    2d02:	08 95       	ret

00002d04 <_exit>:
    2d04:	f8 94       	cli

00002d06 <__stop_program>:
    2d06:	ff cf       	rjmp	.-2      	; 0x2d06 <__stop_program>
