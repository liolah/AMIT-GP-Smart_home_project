
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002a5a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000057a  00800060  00002a5a  00002aee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000007c  008005da  008005da  00003068  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003068  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000030c4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005e0  00000000  00000000  00003100  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005c5c  00000000  00000000  000036e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001905  00000000  00000000  0000933c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003bb2  00000000  00000000  0000ac41  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d94  00000000  00000000  0000e7f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001352  00000000  00000000  0000f588  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003355  00000000  00000000  000108da  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000480  00000000  00000000  00013c2f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 82 00 	jmp	0x104	; 0x104 <__ctors_end>
       4:	0c 94 5f 0d 	jmp	0x1abe	; 0x1abe <__vector_1>
       8:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
       c:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      10:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      14:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      18:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      1c:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      20:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      24:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      28:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      2c:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      30:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      34:	0c 94 e4 0c 	jmp	0x19c8	; 0x19c8 <__vector_13>
      38:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      3c:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      40:	0c 94 99 0d 	jmp	0x1b32	; 0x1b32 <__vector_16>
      44:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      48:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      4c:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      50:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      54:	73 03       	mulsu	r23, r19
      56:	77 03       	mulsu	r23, r23
      58:	7b 03       	fmul	r23, r19
      5a:	7f 03       	fmul	r23, r23
      5c:	83 03       	fmuls	r16, r19
      5e:	87 03       	fmuls	r16, r23
      60:	8b 03       	fmulsu	r16, r19
      62:	ee 04       	cpc	r14, r14
      64:	02 05       	cpc	r16, r2
      66:	02 05       	cpc	r16, r2
      68:	02 05       	cpc	r16, r2
      6a:	02 05       	cpc	r16, r2
      6c:	02 05       	cpc	r16, r2
      6e:	02 05       	cpc	r16, r2
      70:	02 05       	cpc	r16, r2
      72:	04 05       	cpc	r16, r4
      74:	02 05       	cpc	r16, r2
      76:	02 05       	cpc	r16, r2
      78:	02 05       	cpc	r16, r2
      7a:	02 05       	cpc	r16, r2
      7c:	02 05       	cpc	r16, r2
      7e:	02 05       	cpc	r16, r2
      80:	02 05       	cpc	r16, r2
      82:	f0 04       	cpc	r15, r0
      84:	02 05       	cpc	r16, r2
      86:	02 05       	cpc	r16, r2
      88:	02 05       	cpc	r16, r2
      8a:	02 05       	cpc	r16, r2
      8c:	02 05       	cpc	r16, r2
      8e:	02 05       	cpc	r16, r2
      90:	02 05       	cpc	r16, r2
      92:	f2 04       	cpc	r15, r2
      94:	02 05       	cpc	r16, r2
      96:	02 05       	cpc	r16, r2
      98:	02 05       	cpc	r16, r2
      9a:	02 05       	cpc	r16, r2
      9c:	02 05       	cpc	r16, r2
      9e:	02 05       	cpc	r16, r2
      a0:	02 05       	cpc	r16, r2
      a2:	f4 04       	cpc	r15, r4
      a4:	02 05       	cpc	r16, r2
      a6:	02 05       	cpc	r16, r2
      a8:	02 05       	cpc	r16, r2
      aa:	02 05       	cpc	r16, r2
      ac:	02 05       	cpc	r16, r2
      ae:	02 05       	cpc	r16, r2
      b0:	02 05       	cpc	r16, r2
      b2:	f6 04       	cpc	r15, r6
      b4:	02 05       	cpc	r16, r2
      b6:	02 05       	cpc	r16, r2
      b8:	02 05       	cpc	r16, r2
      ba:	02 05       	cpc	r16, r2
      bc:	02 05       	cpc	r16, r2
      be:	02 05       	cpc	r16, r2
      c0:	02 05       	cpc	r16, r2
      c2:	f8 04       	cpc	r15, r8
      c4:	02 05       	cpc	r16, r2
      c6:	02 05       	cpc	r16, r2
      c8:	02 05       	cpc	r16, r2
      ca:	02 05       	cpc	r16, r2
      cc:	02 05       	cpc	r16, r2
      ce:	02 05       	cpc	r16, r2
      d0:	02 05       	cpc	r16, r2
      d2:	fa 04       	cpc	r15, r10
      d4:	02 05       	cpc	r16, r2
      d6:	02 05       	cpc	r16, r2
      d8:	02 05       	cpc	r16, r2
      da:	02 05       	cpc	r16, r2
      dc:	02 05       	cpc	r16, r2
      de:	02 05       	cpc	r16, r2
      e0:	02 05       	cpc	r16, r2
      e2:	fc 04       	cpc	r15, r12
      e4:	02 05       	cpc	r16, r2
      e6:	02 05       	cpc	r16, r2
      e8:	02 05       	cpc	r16, r2
      ea:	02 05       	cpc	r16, r2
      ec:	02 05       	cpc	r16, r2
      ee:	02 05       	cpc	r16, r2
      f0:	02 05       	cpc	r16, r2
      f2:	fe 04       	cpc	r15, r14
      f4:	02 05       	cpc	r16, r2
      f6:	02 05       	cpc	r16, r2
      f8:	02 05       	cpc	r16, r2
      fa:	02 05       	cpc	r16, r2
      fc:	02 05       	cpc	r16, r2
      fe:	02 05       	cpc	r16, r2
     100:	02 05       	cpc	r16, r2
     102:	00 05       	cpc	r16, r0

00000104 <__ctors_end>:
     104:	11 24       	eor	r1, r1
     106:	1f be       	out	0x3f, r1	; 63
     108:	cf e5       	ldi	r28, 0x5F	; 95
     10a:	d8 e0       	ldi	r29, 0x08	; 8
     10c:	de bf       	out	0x3e, r29	; 62
     10e:	cd bf       	out	0x3d, r28	; 61

00000110 <__do_copy_data>:
     110:	15 e0       	ldi	r17, 0x05	; 5
     112:	a0 e6       	ldi	r26, 0x60	; 96
     114:	b0 e0       	ldi	r27, 0x00	; 0
     116:	ea e5       	ldi	r30, 0x5A	; 90
     118:	fa e2       	ldi	r31, 0x2A	; 42
     11a:	02 c0       	rjmp	.+4      	; 0x120 <__do_copy_data+0x10>
     11c:	05 90       	lpm	r0, Z+
     11e:	0d 92       	st	X+, r0
     120:	aa 3d       	cpi	r26, 0xDA	; 218
     122:	b1 07       	cpc	r27, r17
     124:	d9 f7       	brne	.-10     	; 0x11c <__do_copy_data+0xc>

00000126 <__do_clear_bss>:
     126:	26 e0       	ldi	r18, 0x06	; 6
     128:	aa ed       	ldi	r26, 0xDA	; 218
     12a:	b5 e0       	ldi	r27, 0x05	; 5
     12c:	01 c0       	rjmp	.+2      	; 0x130 <.do_clear_bss_start>

0000012e <.do_clear_bss_loop>:
     12e:	1d 92       	st	X+, r1

00000130 <.do_clear_bss_start>:
     130:	a6 35       	cpi	r26, 0x56	; 86
     132:	b2 07       	cpc	r27, r18
     134:	e1 f7       	brne	.-8      	; 0x12e <.do_clear_bss_loop>
     136:	0e 94 45 03 	call	0x68a	; 0x68a <main>
     13a:	0c 94 2b 15 	jmp	0x2a56	; 0x2a56 <_exit>

0000013e <__bad_interrupt>:
     13e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000142 <App_init>:

#include "app.h"

 // Does all the initializations required in the app
void App_init(void) {
  EEPROM_init();
     142:	0e 94 c9 00 	call	0x192	; 0x192 <EEPROM_init>
  AC_auto_control_service_start();
     146:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <AC_auto_control_service_start>
  Remote_init(9600);
     14a:	60 e8       	ldi	r22, 0x80	; 128
     14c:	75 e2       	ldi	r23, 0x25	; 37
     14e:	80 e0       	ldi	r24, 0x00	; 0
     150:	90 e0       	ldi	r25, 0x00	; 0
     152:	0e 94 a0 09 	call	0x1340	; 0x1340 <Remote_init>
  Lamps_init();
     156:	0e 94 17 09 	call	0x122e	; 0x122e <Lamps_init>
  Door_init();
     15a:	0e 94 09 09 	call	0x1212	; 0x1212 <Door_init>
  Local_access_init();
     15e:	0e 94 9b 09 	call	0x1336	; 0x1336 <Local_access_init>
  // format_users_db();
  sei();
     162:	78 94       	sei

  INT0_init(RISING_EDGE_INTERRUPT_REQUEST);
     164:	83 e0       	ldi	r24, 0x03	; 3
     166:	0e 94 37 05 	call	0xa6e	; 0xa6e <INT0_init>
  UART_RXC_INT_init();
     16a:	0e 94 59 05 	call	0xab2	; 0xab2 <UART_RXC_INT_init>
  run_system = true;
     16e:	81 e0       	ldi	r24, 0x01	; 1
     170:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     174:	08 95       	ret

00000176 <App_start>:
  }

// Contains all functionalities and top level logic of the app
void App_start(void) {
  while (run_system) {
     176:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     17a:	81 11       	cpse	r24, r1
     17c:	fc cf       	rjmp	.-8      	; 0x176 <App_start>
     17e:	ff cf       	rjmp	.-2      	; 0x17e <App_start+0x8>

00000180 <Buzzer_on>:
  // Return error code to indicate that the buzzer initialization failed
  return BUZZER_ERROR_INIT;
  }

// Turn on the buzzer
EN_BuzzerError_t Buzzer_on(u8 buzzerPort, u8 buzzerPin) {
     180:	98 2f       	mov	r25, r24
     182:	86 2f       	mov	r24, r22
  if (DIO_write(buzzerPin, buzzerPort, HIGH) == DIO_OK) {
     184:	41 e0       	ldi	r20, 0x01	; 1
     186:	69 2f       	mov	r22, r25
     188:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
     18c:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that attempting to turn on the buzzer has failed
  return BUZZER_ERROR_ON;
     18e:	82 e0       	ldi	r24, 0x02	; 2
  }
     190:	08 95       	ret

00000192 <EEPROM_init>:
 */

#include "eeprom.h"

void EEPROM_init() {
  I2C_init();
     192:	0e 94 06 05 	call	0xa0c	; 0xa0c <I2C_init>
     196:	08 95       	ret

00000198 <EEPROM_read_byte>:
  }

void EEPROM_read_byte(u8 page, u8 address, s8* data) {
     198:	0f 93       	push	r16
     19a:	1f 93       	push	r17
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	c8 2f       	mov	r28, r24
     1a2:	d6 2f       	mov	r29, r22
     1a4:	8a 01       	movw	r16, r20
  I2C_start();
     1a6:	0e 94 0a 05 	call	0xa14	; 0xa14 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     1aa:	cc 0f       	add	r28, r28
     1ac:	80 ea       	ldi	r24, 0xA0	; 160
     1ae:	8c 0f       	add	r24, r28
     1b0:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  I2C_write(address);
     1b4:	8d 2f       	mov	r24, r29
     1b6:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  I2C_start();
     1ba:	0e 94 0a 05 	call	0xa14	; 0xa14 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     1be:	81 ea       	ldi	r24, 0xA1	; 161
     1c0:	8c 0f       	add	r24, r28
     1c2:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  // read_Ack will halt the reading here, because it will send the next byte, which will not be received and wait for ack, which will not be sent. 
  // Nack must be sent after the arrival of the last requested byte. It's used basically to indicate that no further data transmission is required and then the stop condition is sent
  I2C_read_Nack(data);
     1c6:	c8 01       	movw	r24, r16
     1c8:	0e 94 26 05 	call	0xa4c	; 0xa4c <I2C_read_Nack>
  I2C_stop();
     1cc:	0e 94 31 05 	call	0xa62	; 0xa62 <I2C_stop>
  }
     1d0:	df 91       	pop	r29
     1d2:	cf 91       	pop	r28
     1d4:	1f 91       	pop	r17
     1d6:	0f 91       	pop	r16
     1d8:	08 95       	ret

000001da <EEPROM_read_block>:

void EEPROM_read_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     1da:	ef 92       	push	r14
     1dc:	ff 92       	push	r15
     1de:	0f 93       	push	r16
     1e0:	1f 93       	push	r17
     1e2:	cf 93       	push	r28
     1e4:	df 93       	push	r29
     1e6:	c8 2f       	mov	r28, r24
     1e8:	d6 2f       	mov	r29, r22
     1ea:	7a 01       	movw	r14, r20
     1ec:	89 01       	movw	r16, r18
  u16 i;
  for (i = 0;i < bytes_number;i++) {
    EEPROM_read_byte(page, address + i, &data[i]);
    }
#elif READ_BLOCK_METHOD == MULTIBYTE
  I2C_start();
     1ee:	0e 94 0a 05 	call	0xa14	; 0xa14 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     1f2:	cc 0f       	add	r28, r28
     1f4:	80 ea       	ldi	r24, 0xA0	; 160
     1f6:	8c 0f       	add	r24, r28
     1f8:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  I2C_write(address);
     1fc:	8d 2f       	mov	r24, r29
     1fe:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  I2C_start();
     202:	0e 94 0a 05 	call	0xa14	; 0xa14 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     206:	81 ea       	ldi	r24, 0xA1	; 161
     208:	8c 0f       	add	r24, r28
     20a:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     20e:	c0 e0       	ldi	r28, 0x00	; 0
     210:	d0 e0       	ldi	r29, 0x00	; 0
     212:	06 c0       	rjmp	.+12     	; 0x220 <EEPROM_read_block+0x46>
    I2C_read_Ack(&data[i]);
     214:	c8 01       	movw	r24, r16
     216:	8c 0f       	add	r24, r28
     218:	9d 1f       	adc	r25, r29
     21a:	0e 94 1b 05 	call	0xa36	; 0xa36 <I2C_read_Ack>
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  I2C_start();
  I2C_write(0xA0 + (page << 1) + 1);
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     21e:	21 96       	adiw	r28, 0x01	; 1
     220:	c7 01       	movw	r24, r14
     222:	01 97       	sbiw	r24, 0x01	; 1
     224:	c8 17       	cp	r28, r24
     226:	d9 07       	cpc	r29, r25
     228:	a8 f3       	brcs	.-22     	; 0x214 <EEPROM_read_block+0x3a>
    I2C_read_Ack(&data[i]);
    }
  I2C_read_Nack(&data[i]);
     22a:	c8 01       	movw	r24, r16
     22c:	8c 0f       	add	r24, r28
     22e:	9d 1f       	adc	r25, r29
     230:	0e 94 26 05 	call	0xa4c	; 0xa4c <I2C_read_Nack>
  I2C_stop();
     234:	0e 94 31 05 	call	0xa62	; 0xa62 <I2C_stop>
#endif
  }
     238:	df 91       	pop	r29
     23a:	cf 91       	pop	r28
     23c:	1f 91       	pop	r17
     23e:	0f 91       	pop	r16
     240:	ff 90       	pop	r15
     242:	ef 90       	pop	r14
     244:	08 95       	ret

00000246 <EEPROM_write_byte>:

void EEPROM_write_byte(u8 page, u8 address, s8 data) {
     246:	1f 93       	push	r17
     248:	cf 93       	push	r28
     24a:	df 93       	push	r29
     24c:	c8 2f       	mov	r28, r24
     24e:	16 2f       	mov	r17, r22
     250:	d4 2f       	mov	r29, r20
  I2C_start();
     252:	0e 94 0a 05 	call	0xa14	; 0xa14 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     256:	8c 2f       	mov	r24, r28
     258:	88 0f       	add	r24, r24
     25a:	80 56       	subi	r24, 0x60	; 96
     25c:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  I2C_write(address);
     260:	81 2f       	mov	r24, r17
     262:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  I2C_write(data);
     266:	8d 2f       	mov	r24, r29
     268:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  I2C_stop();
     26c:	0e 94 31 05 	call	0xa62	; 0xa62 <I2C_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     270:	8f e3       	ldi	r24, 0x3F	; 63
     272:	9c e9       	ldi	r25, 0x9C	; 156
     274:	01 97       	sbiw	r24, 0x01	; 1
     276:	f1 f7       	brne	.-4      	; 0x274 <EEPROM_write_byte+0x2e>
     278:	00 c0       	rjmp	.+0      	; 0x27a <EEPROM_write_byte+0x34>
     27a:	00 00       	nop

#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
  }
     27c:	df 91       	pop	r29
     27e:	cf 91       	pop	r28
     280:	1f 91       	pop	r17
     282:	08 95       	ret

00000284 <EEPROM_write_block>:

// bytes_number must be within page size (256 bytes)
void EEPROM_write_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     284:	6f 92       	push	r6
     286:	7f 92       	push	r7
     288:	8f 92       	push	r8
     28a:	9f 92       	push	r9
     28c:	af 92       	push	r10
     28e:	bf 92       	push	r11
     290:	cf 92       	push	r12
     292:	df 92       	push	r13
     294:	ef 92       	push	r14
     296:	ff 92       	push	r15
     298:	0f 93       	push	r16
     29a:	1f 93       	push	r17
     29c:	cf 93       	push	r28
     29e:	df 93       	push	r29
     2a0:	78 2e       	mov	r7, r24
     2a2:	66 2e       	mov	r6, r22
     2a4:	6a 01       	movw	r12, r20
     2a6:	89 01       	movw	r16, r18
  //! If data is required to be written in the first 16 bytes starting from byte 10 for example, the data will be stored starting from bytes 10, 
  //! and if the data exceeds the row limit ** IT WILL ROLL OVER AND OVERWRITE THE ROW **. Therefore, in a single multibyte write cycle, we can't write more than 16 bytes at maximum if starting from the first byte in the row
  //! or the remaining bytes till the end of the row from the starting position. The remaining bytes must be written in another write cycle to avoind the roll over problem.

  u16 dataIndex, blockNumber, i;
  u16 first_block_size = 16 - (address % 16);
     2a8:	86 2f       	mov	r24, r22
     2aa:	8f 70       	andi	r24, 0x0F	; 15
     2ac:	20 e1       	ldi	r18, 0x10	; 16
     2ae:	30 e0       	ldi	r19, 0x00	; 0
     2b0:	79 01       	movw	r14, r18
     2b2:	e8 1a       	sub	r14, r24
     2b4:	f1 08       	sbc	r15, r1
  if (16 - (address % 16) > bytes_number) first_block_size = bytes_number;
     2b6:	4e 15       	cp	r20, r14
     2b8:	5f 05       	cpc	r21, r15
     2ba:	08 f4       	brcc	.+2      	; 0x2be <EEPROM_write_block+0x3a>
     2bc:	7a 01       	movw	r14, r20

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
     2be:	0e 94 0a 05 	call	0xa14	; 0xa14 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     2c2:	87 2d       	mov	r24, r7
     2c4:	88 0f       	add	r24, r24
     2c6:	0f 2e       	mov	r0, r31
     2c8:	f0 ea       	ldi	r31, 0xA0	; 160
     2ca:	7f 2e       	mov	r7, r31
     2cc:	f0 2d       	mov	r31, r0
     2ce:	78 0e       	add	r7, r24
     2d0:	87 2d       	mov	r24, r7
     2d2:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  I2C_write(address);
     2d6:	86 2d       	mov	r24, r6
     2d8:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2dc:	c0 e0       	ldi	r28, 0x00	; 0
     2de:	d0 e0       	ldi	r29, 0x00	; 0
     2e0:	07 c0       	rjmp	.+14     	; 0x2f0 <EEPROM_write_block+0x6c>
    I2C_write(data[dataIndex]);
     2e2:	f8 01       	movw	r30, r16
     2e4:	ec 0f       	add	r30, r28
     2e6:	fd 1f       	adc	r31, r29
     2e8:	80 81       	ld	r24, Z
     2ea:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2ee:	21 96       	adiw	r28, 0x01	; 1
     2f0:	ce 15       	cp	r28, r14
     2f2:	df 05       	cpc	r29, r15
     2f4:	b0 f3       	brcs	.-20     	; 0x2e2 <EEPROM_write_block+0x5e>
    I2C_write(data[dataIndex]);
    }
  I2C_stop();
     2f6:	0e 94 31 05 	call	0xa62	; 0xa62 <I2C_stop>
     2fa:	8f e3       	ldi	r24, 0x3F	; 63
     2fc:	9c e9       	ldi	r25, 0x9C	; 156
     2fe:	01 97       	sbiw	r24, 0x01	; 1
     300:	f1 f7       	brne	.-4      	; 0x2fe <EEPROM_write_block+0x7a>
     302:	00 c0       	rjmp	.+0      	; 0x304 <EEPROM_write_block+0x80>
     304:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif

  // Return if the data fits in the row (data fits in a single row or the remaining part of it after the address)
  if (first_block_size == bytes_number) return;
     306:	ec 14       	cp	r14, r12
     308:	fd 04       	cpc	r15, r13
     30a:	09 f4       	brne	.+2      	; 0x30e <EEPROM_write_block+0x8a>
     30c:	61 c0       	rjmp	.+194    	; 0x3d0 <EEPROM_write_block+0x14c>

  u16 last_block_size = (address + bytes_number) % 16;
     30e:	56 01       	movw	r10, r12
     310:	a6 0c       	add	r10, r6
     312:	b1 1c       	adc	r11, r1
     314:	9f e0       	ldi	r25, 0x0F	; 15
     316:	a9 22       	and	r10, r25
     318:	bb 24       	eor	r11, r11
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
     31a:	ce 18       	sub	r12, r14
     31c:	df 08       	sbc	r13, r15
     31e:	ca 18       	sub	r12, r10
     320:	db 08       	sbc	r13, r11
     322:	d6 94       	lsr	r13
     324:	c7 94       	ror	r12
     326:	d6 94       	lsr	r13
     328:	c7 94       	ror	r12
     32a:	d6 94       	lsr	r13
     32c:	c7 94       	ror	r12
     32e:	d6 94       	lsr	r13
     330:	c7 94       	ror	r12
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     332:	e1 2c       	mov	r14, r1
     334:	f1 2c       	mov	r15, r1
     336:	27 c0       	rjmp	.+78     	; 0x386 <EEPROM_write_block+0x102>
    I2C_start();
     338:	0e 94 0a 05 	call	0xa14	; 0xa14 <I2C_start>
    I2C_write(0xA0 + (page << 1));
     33c:	87 2d       	mov	r24, r7
     33e:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
    I2C_write(address + dataIndex);
     342:	8c 2f       	mov	r24, r28
     344:	86 0d       	add	r24, r6
     346:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
    for (i = 0;i < 16;i++) {
     34a:	81 2c       	mov	r8, r1
     34c:	91 2c       	mov	r9, r1
     34e:	0b c0       	rjmp	.+22     	; 0x366 <EEPROM_write_block+0xe2>
      I2C_write(data[dataIndex + i]);
     350:	fe 01       	movw	r30, r28
     352:	e8 0d       	add	r30, r8
     354:	f9 1d       	adc	r31, r9
     356:	e0 0f       	add	r30, r16
     358:	f1 1f       	adc	r31, r17
     35a:	80 81       	ld	r24, Z
     35c:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
    I2C_start();
    I2C_write(0xA0 + (page << 1));
    I2C_write(address + dataIndex);
    for (i = 0;i < 16;i++) {
     360:	8f ef       	ldi	r24, 0xFF	; 255
     362:	88 1a       	sub	r8, r24
     364:	98 0a       	sbc	r9, r24
     366:	90 e1       	ldi	r25, 0x10	; 16
     368:	89 16       	cp	r8, r25
     36a:	91 04       	cpc	r9, r1
     36c:	88 f3       	brcs	.-30     	; 0x350 <EEPROM_write_block+0xcc>
      I2C_write(data[dataIndex + i]);
      }
    dataIndex += 16;
     36e:	60 96       	adiw	r28, 0x10	; 16
    I2C_stop();
     370:	0e 94 31 05 	call	0xa62	; 0xa62 <I2C_stop>
     374:	8f e3       	ldi	r24, 0x3F	; 63
     376:	9c e9       	ldi	r25, 0x9C	; 156
     378:	01 97       	sbiw	r24, 0x01	; 1
     37a:	f1 f7       	brne	.-4      	; 0x378 <EEPROM_write_block+0xf4>
     37c:	00 c0       	rjmp	.+0      	; 0x37e <EEPROM_write_block+0xfa>
     37e:	00 00       	nop
  if (first_block_size == bytes_number) return;

  u16 last_block_size = (address + bytes_number) % 16;
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     380:	9f ef       	ldi	r25, 0xFF	; 255
     382:	e9 1a       	sub	r14, r25
     384:	f9 0a       	sbc	r15, r25
     386:	ec 14       	cp	r14, r12
     388:	fd 04       	cpc	r15, r13
     38a:	b0 f2       	brcs	.-84     	; 0x338 <EEPROM_write_block+0xb4>
    _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
    }

  // Write the last part of the data
  I2C_start();
     38c:	0e 94 0a 05 	call	0xa14	; 0xa14 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     390:	87 2d       	mov	r24, r7
     392:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  I2C_write(address + dataIndex);
     396:	8c 2f       	mov	r24, r28
     398:	86 0d       	add	r24, r6
     39a:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>
  for (i = 0;i < last_block_size;i++) {
     39e:	e1 2c       	mov	r14, r1
     3a0:	f1 2c       	mov	r15, r1
     3a2:	0b c0       	rjmp	.+22     	; 0x3ba <EEPROM_write_block+0x136>
    I2C_write(data[dataIndex + i]);
     3a4:	fe 01       	movw	r30, r28
     3a6:	ee 0d       	add	r30, r14
     3a8:	ff 1d       	adc	r31, r15
     3aa:	e0 0f       	add	r30, r16
     3ac:	f1 1f       	adc	r31, r17
     3ae:	80 81       	ld	r24, Z
     3b0:	0e 94 12 05 	call	0xa24	; 0xa24 <I2C_write>

  // Write the last part of the data
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address + dataIndex);
  for (i = 0;i < last_block_size;i++) {
     3b4:	8f ef       	ldi	r24, 0xFF	; 255
     3b6:	e8 1a       	sub	r14, r24
     3b8:	f8 0a       	sbc	r15, r24
     3ba:	ea 14       	cp	r14, r10
     3bc:	fb 04       	cpc	r15, r11
     3be:	90 f3       	brcs	.-28     	; 0x3a4 <EEPROM_write_block+0x120>
    I2C_write(data[dataIndex + i]);
    }
  I2C_stop();
     3c0:	0e 94 31 05 	call	0xa62	; 0xa62 <I2C_stop>
     3c4:	8f e3       	ldi	r24, 0x3F	; 63
     3c6:	9c e9       	ldi	r25, 0x9C	; 156
     3c8:	01 97       	sbiw	r24, 0x01	; 1
     3ca:	f1 f7       	brne	.-4      	; 0x3c8 <EEPROM_write_block+0x144>
     3cc:	00 c0       	rjmp	.+0      	; 0x3ce <EEPROM_write_block+0x14a>
     3ce:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
#endif
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	1f 91       	pop	r17
     3d6:	0f 91       	pop	r16
     3d8:	ff 90       	pop	r15
     3da:	ef 90       	pop	r14
     3dc:	df 90       	pop	r13
     3de:	cf 90       	pop	r12
     3e0:	bf 90       	pop	r11
     3e2:	af 90       	pop	r10
     3e4:	9f 90       	pop	r9
     3e6:	8f 90       	pop	r8
     3e8:	7f 90       	pop	r7
     3ea:	6f 90       	pop	r6
     3ec:	08 95       	ret

000003ee <BT_init>:
 *  Author: Hesham Hany
 */

#include "hc_05.h"

void BT_init(u32 baudRate) {
     3ee:	cf 92       	push	r12
     3f0:	df 92       	push	r13
     3f2:	ef 92       	push	r14
     3f4:	ff 92       	push	r15
     3f6:	6b 01       	movw	r12, r22
     3f8:	7c 01       	movw	r14, r24
  DIO_init(HC_05_STATUS_PIN, HC_05_STATUS_PORT, IN);
     3fa:	40 e0       	ldi	r20, 0x00	; 0
     3fc:	64 e4       	ldi	r22, 0x44	; 68
     3fe:	82 e0       	ldi	r24, 0x02	; 2
     400:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  UART_init(baudRate);
     404:	c7 01       	movw	r24, r14
     406:	b6 01       	movw	r22, r12
     408:	0e 94 40 08 	call	0x1080	; 0x1080 <UART_init>
  }
     40c:	ff 90       	pop	r15
     40e:	ef 90       	pop	r14
     410:	df 90       	pop	r13
     412:	cf 90       	pop	r12
     414:	08 95       	ret

00000416 <BT_sendChar>:

void BT_sendChar(s8 data) {
  UART_sendChar(data);
     416:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <UART_sendChar>
     41a:	08 95       	ret

0000041c <BT_sendString>:
  }

void BT_sendString(s8* str) {
  UART_sendString(str);
     41c:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <UART_sendString>
     420:	08 95       	ret

00000422 <Keypad_init>:

#include "keypad.h"

void Keypad_init(void) {
  // Set rows as outputs
  DIO_init(KEYPAD_R0_PIN, KEYPAD_PORT, OUT);
     422:	41 e0       	ldi	r20, 0x01	; 1
     424:	62 e4       	ldi	r22, 0x42	; 66
     426:	80 e0       	ldi	r24, 0x00	; 0
     428:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  DIO_init(KEYPAD_R1_PIN, KEYPAD_PORT, OUT);
     42c:	41 e0       	ldi	r20, 0x01	; 1
     42e:	62 e4       	ldi	r22, 0x42	; 66
     430:	81 e0       	ldi	r24, 0x01	; 1
     432:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  DIO_init(KEYPAD_R2_PIN, KEYPAD_PORT, OUT);
     436:	41 e0       	ldi	r20, 0x01	; 1
     438:	62 e4       	ldi	r22, 0x42	; 66
     43a:	82 e0       	ldi	r24, 0x02	; 2
     43c:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  DIO_init(KEYPAD_R3_PIN, KEYPAD_PORT, OUT);
     440:	41 e0       	ldi	r20, 0x01	; 1
     442:	62 e4       	ldi	r22, 0x42	; 66
     444:	83 e0       	ldi	r24, 0x03	; 3
     446:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  // Set all high
  DIO_write(KEYPAD_R0_PIN, KEYPAD_PORT, HIGH);
     44a:	41 e0       	ldi	r20, 0x01	; 1
     44c:	62 e4       	ldi	r22, 0x42	; 66
     44e:	80 e0       	ldi	r24, 0x00	; 0
     450:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
  DIO_write(KEYPAD_R1_PIN, KEYPAD_PORT, HIGH);
     454:	41 e0       	ldi	r20, 0x01	; 1
     456:	62 e4       	ldi	r22, 0x42	; 66
     458:	81 e0       	ldi	r24, 0x01	; 1
     45a:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
  DIO_write(KEYPAD_R2_PIN, KEYPAD_PORT, HIGH);
     45e:	41 e0       	ldi	r20, 0x01	; 1
     460:	62 e4       	ldi	r22, 0x42	; 66
     462:	82 e0       	ldi	r24, 0x02	; 2
     464:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
  DIO_write(KEYPAD_R3_PIN, KEYPAD_PORT, HIGH);
     468:	41 e0       	ldi	r20, 0x01	; 1
     46a:	62 e4       	ldi	r22, 0x42	; 66
     46c:	83 e0       	ldi	r24, 0x03	; 3
     46e:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
  // Set columns as inputs
  DIO_init(KEYPAD_C0_PIN, KEYPAD_PORT, IN);
     472:	40 e0       	ldi	r20, 0x00	; 0
     474:	62 e4       	ldi	r22, 0x42	; 66
     476:	84 e0       	ldi	r24, 0x04	; 4
     478:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  DIO_init(KEYPAD_C1_PIN, KEYPAD_PORT, IN);
     47c:	40 e0       	ldi	r20, 0x00	; 0
     47e:	62 e4       	ldi	r22, 0x42	; 66
     480:	85 e0       	ldi	r24, 0x05	; 5
     482:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  DIO_init(KEYPAD_C2_PIN, KEYPAD_PORT, IN);
     486:	40 e0       	ldi	r20, 0x00	; 0
     488:	62 e4       	ldi	r22, 0x42	; 66
     48a:	86 e0       	ldi	r24, 0x06	; 6
     48c:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  DIO_init(KEYPAD_C3_PIN, KEYPAD_PORT, IN);
     490:	40 e0       	ldi	r20, 0x00	; 0
     492:	62 e4       	ldi	r22, 0x42	; 66
     494:	87 e0       	ldi	r24, 0x07	; 7
     496:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  // Activate the pull up resistors
  DIO_write(KEYPAD_C0_PIN, KEYPAD_PORT, HIGH);
     49a:	41 e0       	ldi	r20, 0x01	; 1
     49c:	62 e4       	ldi	r22, 0x42	; 66
     49e:	84 e0       	ldi	r24, 0x04	; 4
     4a0:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
  DIO_write(KEYPAD_C1_PIN, KEYPAD_PORT, HIGH);
     4a4:	41 e0       	ldi	r20, 0x01	; 1
     4a6:	62 e4       	ldi	r22, 0x42	; 66
     4a8:	85 e0       	ldi	r24, 0x05	; 5
     4aa:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
  DIO_write(KEYPAD_C2_PIN, KEYPAD_PORT, HIGH);
     4ae:	41 e0       	ldi	r20, 0x01	; 1
     4b0:	62 e4       	ldi	r22, 0x42	; 66
     4b2:	86 e0       	ldi	r24, 0x06	; 6
     4b4:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
  DIO_write(KEYPAD_C3_PIN, KEYPAD_PORT, HIGH);
     4b8:	41 e0       	ldi	r20, 0x01	; 1
     4ba:	62 e4       	ldi	r22, 0x42	; 66
     4bc:	87 e0       	ldi	r24, 0x07	; 7
     4be:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
     4c2:	08 95       	ret

000004c4 <LCD_sendEnablePulse>:

  _delay_us(1); // wait for the data to be processed
#else

#endif
  }
     4c4:	41 e0       	ldi	r20, 0x01	; 1
     4c6:	61 e4       	ldi	r22, 0x41	; 65
     4c8:	86 e0       	ldi	r24, 0x06	; 6
     4ca:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
     4ce:	8a e1       	ldi	r24, 0x1A	; 26
     4d0:	8a 95       	dec	r24
     4d2:	f1 f7       	brne	.-4      	; 0x4d0 <LCD_sendEnablePulse+0xc>
     4d4:	00 c0       	rjmp	.+0      	; 0x4d6 <LCD_sendEnablePulse+0x12>
     4d6:	40 e0       	ldi	r20, 0x00	; 0
     4d8:	61 e4       	ldi	r22, 0x41	; 65
     4da:	86 e0       	ldi	r24, 0x06	; 6
     4dc:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
     4e0:	08 95       	ret

000004e2 <LCD_write_4bits>:
     4e2:	cf 93       	push	r28
     4e4:	c8 2f       	mov	r28, r24
     4e6:	48 2f       	mov	r20, r24
     4e8:	41 70       	andi	r20, 0x01	; 1
     4ea:	61 e4       	ldi	r22, 0x41	; 65
     4ec:	80 e0       	ldi	r24, 0x00	; 0
     4ee:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
     4f2:	c1 fb       	bst	r28, 1
     4f4:	44 27       	eor	r20, r20
     4f6:	40 f9       	bld	r20, 0
     4f8:	61 e4       	ldi	r22, 0x41	; 65
     4fa:	81 e0       	ldi	r24, 0x01	; 1
     4fc:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
     500:	c2 fb       	bst	r28, 2
     502:	44 27       	eor	r20, r20
     504:	40 f9       	bld	r20, 0
     506:	61 e4       	ldi	r22, 0x41	; 65
     508:	82 e0       	ldi	r24, 0x02	; 2
     50a:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
     50e:	c3 fb       	bst	r28, 3
     510:	44 27       	eor	r20, r20
     512:	40 f9       	bld	r20, 0
     514:	61 e4       	ldi	r22, 0x41	; 65
     516:	83 e0       	ldi	r24, 0x03	; 3
     518:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
     51c:	cf 91       	pop	r28
     51e:	08 95       	ret

00000520 <LCD_sendCommand>:

void LCD_sendCommand(u8 cmd) {
     520:	cf 93       	push	r28
     522:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(cmd >> 4);
     524:	82 95       	swap	r24
     526:	8f 70       	andi	r24, 0x0F	; 15
     528:	0e 94 71 02 	call	0x4e2	; 0x4e2 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, LOW); // To indicate that this a command
     52c:	40 e0       	ldi	r20, 0x00	; 0
     52e:	61 e4       	ldi	r22, 0x41	; 65
     530:	84 e0       	ldi	r24, 0x04	; 4
     532:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>

  LCD_sendEnablePulse();
     536:	0e 94 62 02 	call	0x4c4	; 0x4c4 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the command to be sent

  LCD_write_4bits(cmd);
     53a:	8c 2f       	mov	r24, r28
     53c:	0e 94 71 02 	call	0x4e2	; 0x4e2 <LCD_write_4bits>

  LCD_sendEnablePulse();
     540:	0e 94 62 02 	call	0x4c4	; 0x4c4 <LCD_sendEnablePulse>
     544:	8f ed       	ldi	r24, 0xDF	; 223
     546:	9e e2       	ldi	r25, 0x2E	; 46
     548:	01 97       	sbiw	r24, 0x01	; 1
     54a:	f1 f7       	brne	.-4      	; 0x548 <LCD_sendCommand+0x28>
     54c:	00 c0       	rjmp	.+0      	; 0x54e <LCD_sendCommand+0x2e>
     54e:	00 00       	nop

  _delay_ms(3); // wait for the command to be executed
#else

#endif
  }
     550:	cf 91       	pop	r28
     552:	08 95       	ret

00000554 <LCD_clear_screen>:

void LCD_clear_screen() {
  LCD_sendCommand(0x01);
     554:	81 e0       	ldi	r24, 0x01	; 1
     556:	0e 94 90 02 	call	0x520	; 0x520 <LCD_sendCommand>
     55a:	08 95       	ret

0000055c <LCD_init>:
     55c:	2f ef       	ldi	r18, 0xFF	; 255
     55e:	89 ef       	ldi	r24, 0xF9	; 249
     560:	90 e0       	ldi	r25, 0x00	; 0
     562:	21 50       	subi	r18, 0x01	; 1
     564:	80 40       	sbci	r24, 0x00	; 0
     566:	90 40       	sbci	r25, 0x00	; 0
     568:	e1 f7       	brne	.-8      	; 0x562 <LCD_init+0x6>
     56a:	00 c0       	rjmp	.+0      	; 0x56c <LCD_init+0x10>
     56c:	00 00       	nop

void LCD_init(void) {
  _delay_ms(20); // wait for the LCD to start up.

#if LCD_MODE == FOUR_BIT_MODE
  DIO_init(LCD_DATA_PIN4, LCD_DATA_PORT, OUT);
     56e:	41 e0       	ldi	r20, 0x01	; 1
     570:	61 e4       	ldi	r22, 0x41	; 65
     572:	80 e0       	ldi	r24, 0x00	; 0
     574:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  DIO_init(LCD_DATA_PIN5, LCD_DATA_PORT, OUT);
     578:	41 e0       	ldi	r20, 0x01	; 1
     57a:	61 e4       	ldi	r22, 0x41	; 65
     57c:	81 e0       	ldi	r24, 0x01	; 1
     57e:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  DIO_init(LCD_DATA_PIN6, LCD_DATA_PORT, OUT);
     582:	41 e0       	ldi	r20, 0x01	; 1
     584:	61 e4       	ldi	r22, 0x41	; 65
     586:	82 e0       	ldi	r24, 0x02	; 2
     588:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  DIO_init(LCD_DATA_PIN7, LCD_DATA_PORT, OUT);
     58c:	41 e0       	ldi	r20, 0x01	; 1
     58e:	61 e4       	ldi	r22, 0x41	; 65
     590:	83 e0       	ldi	r24, 0x03	; 3
     592:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>

  DIO_init(RS, LCD_CTRL_PORT, OUT);
     596:	41 e0       	ldi	r20, 0x01	; 1
     598:	61 e4       	ldi	r22, 0x41	; 65
     59a:	84 e0       	ldi	r24, 0x04	; 4
     59c:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  DIO_init(RW, LCD_CTRL_PORT, OUT);
     5a0:	41 e0       	ldi	r20, 0x01	; 1
     5a2:	61 e4       	ldi	r22, 0x41	; 65
     5a4:	85 e0       	ldi	r24, 0x05	; 5
     5a6:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  DIO_init(EN, LCD_CTRL_PORT, OUT);
     5aa:	41 e0       	ldi	r20, 0x01	; 1
     5ac:	61 e4       	ldi	r22, 0x41	; 65
     5ae:	86 e0       	ldi	r24, 0x06	; 6
     5b0:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>

  DIO_write(RW, LCD_CTRL_PORT, LOW);
     5b4:	40 e0       	ldi	r20, 0x00	; 0
     5b6:	61 e4       	ldi	r22, 0x41	; 65
     5b8:	85 e0       	ldi	r24, 0x05	; 5
     5ba:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>

  LCD_sendCommand(0x02);  // return home 
     5be:	82 e0       	ldi	r24, 0x02	; 2
     5c0:	0e 94 90 02 	call	0x520	; 0x520 <LCD_sendCommand>
  LCD_sendCommand(0x28);  // 2 line  and 4 bit mode
     5c4:	88 e2       	ldi	r24, 0x28	; 40
     5c6:	0e 94 90 02 	call	0x520	; 0x520 <LCD_sendCommand>
  LCD_sendCommand(0x0C);  // display on 
     5ca:	8c e0       	ldi	r24, 0x0C	; 12
     5cc:	0e 94 90 02 	call	0x520	; 0x520 <LCD_sendCommand>
  LCD_sendCommand(0x06);  // auto increment 
     5d0:	86 e0       	ldi	r24, 0x06	; 6
     5d2:	0e 94 90 02 	call	0x520	; 0x520 <LCD_sendCommand>
  LCD_clear_screen();
     5d6:	0e 94 aa 02 	call	0x554	; 0x554 <LCD_clear_screen>
     5da:	08 95       	ret

000005dc <LED_init>:
 */

#include "led.h"

 // Initialize the LED
EN_ledError_t LED_init(u8 ledPort, u8 ledPin) {
     5dc:	98 2f       	mov	r25, r24
     5de:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(ledPin, ledPort, OUT) == DIO_OK) {
     5e0:	41 e0       	ldi	r20, 0x01	; 1
     5e2:	69 2f       	mov	r22, r25
     5e4:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
     5e8:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that the led initialization failed
  return LED_ERROR_INIT;
     5ea:	81 e0       	ldi	r24, 0x01	; 1
  }
     5ec:	08 95       	ret

000005ee <LED_on>:

// Turn on the LED
EN_ledError_t LED_on(u8 ledPort, u8 ledPin) {
     5ee:	98 2f       	mov	r25, r24
     5f0:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, HIGH) == DIO_OK) {
     5f2:	41 e0       	ldi	r20, 0x01	; 1
     5f4:	69 2f       	mov	r22, r25
     5f6:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
     5fa:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn on the led has failed
  return LED_ERROR_ON;
     5fc:	82 e0       	ldi	r24, 0x02	; 2
  }
     5fe:	08 95       	ret

00000600 <LED_off>:

// Turn off the LED
EN_ledError_t LED_off(u8 ledPort, u8 ledPin) {
     600:	98 2f       	mov	r25, r24
     602:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, LOW) == DIO_OK) {
     604:	40 e0       	ldi	r20, 0x00	; 0
     606:	69 2f       	mov	r22, r25
     608:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
     60c:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn off the led has failed
  return LED_ERROR_OFF;
     60e:	83 e0       	ldi	r24, 0x03	; 3
  }
     610:	08 95       	ret

00000612 <LM35_init_INT>:
  ADC_init();
  ADC_select_channel(pinNumber);
  }

// Initialize LM35 with the ADC in auto trigger mode
void LM35_init_INT(u8 pinNumber, u8 trigger) {
     612:	cf 93       	push	r28
     614:	df 93       	push	r29
     616:	c8 2f       	mov	r28, r24
     618:	d6 2f       	mov	r29, r22
  DIO_init(pinNumber, PORT_A, IN);
     61a:	40 e0       	ldi	r20, 0x00	; 0
     61c:	61 e4       	ldi	r22, 0x41	; 65
     61e:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  ADC_init_auto_trigger(trigger);
     622:	8d 2f       	mov	r24, r29
     624:	0e 94 56 03 	call	0x6ac	; 0x6ac <ADC_init_auto_trigger>
  ADC_select_channel(pinNumber);
     628:	8c 2f       	mov	r24, r28
     62a:	0e 94 4c 03 	call	0x698	; 0x698 <ADC_select_channel>
     62e:	df 91       	pop	r29
     630:	cf 91       	pop	r28
     632:	08 95       	ret

00000634 <Servo_init>:

#include "servo.h"

 // Initialized the servo
void Servo_init() {
  DIO_init(SERVO_PIN, SERVO_PORT, OUT);
     634:	41 e0       	ldi	r20, 0x01	; 1
     636:	64 e4       	ldi	r22, 0x44	; 68
     638:	85 e0       	ldi	r24, 0x05	; 5
     63a:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
  PWM_init(SERVO_PWM_PIN, (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS), PWM_PHASE_CORRECT);
     63e:	22 e0       	ldi	r18, 0x02	; 2
     640:	4d ec       	ldi	r20, 0xCD	; 205
     642:	5c ec       	ldi	r21, 0xCC	; 204
     644:	6c ec       	ldi	r22, 0xCC	; 204
     646:	7c e3       	ldi	r23, 0x3C	; 60
     648:	81 e0       	ldi	r24, 0x01	; 1
     64a:	0e 94 41 07 	call	0xe82	; 0xe82 <PWM_init>
  Timer_start(TIMER_1, 8);
     64e:	68 e0       	ldi	r22, 0x08	; 8
     650:	70 e0       	ldi	r23, 0x00	; 0
     652:	81 e0       	ldi	r24, 0x01	; 1
     654:	0e 94 2d 07 	call	0xe5a	; 0xe5a <Timer_start>
     658:	08 95       	ret

0000065a <Servo_move_to_angle>:
  }

// Moves the servo to a specific angle (relative to the 0 angle position, not the previous one).
void Servo_move_to_angle(u8 angle) {
  PWM_set_DC(SERVO_PWM_PIN, ((double)angle / ((SERVO_MAX_ANGLE - SERVO_MIN_ANGLE) * (SERVO_PULSE_PERIODIC_TIME_mS / (SERVO_MAX_HIGH_PULSE_DURATION_mS - SERVO_MIN_HIGH_PULSE_DURATION_mS)))) + (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS));
     65a:	68 2f       	mov	r22, r24
     65c:	70 e0       	ldi	r23, 0x00	; 0
     65e:	80 e0       	ldi	r24, 0x00	; 0
     660:	90 e0       	ldi	r25, 0x00	; 0
     662:	0e 94 30 11 	call	0x2260	; 0x2260 <__floatunsisf>
     666:	20 e0       	ldi	r18, 0x00	; 0
     668:	30 e0       	ldi	r19, 0x00	; 0
     66a:	41 ee       	ldi	r20, 0xE1	; 225
     66c:	54 e4       	ldi	r21, 0x44	; 68
     66e:	0e 94 8f 10 	call	0x211e	; 0x211e <__divsf3>
     672:	2d ec       	ldi	r18, 0xCD	; 205
     674:	3c ec       	ldi	r19, 0xCC	; 204
     676:	4c ec       	ldi	r20, 0xCC	; 204
     678:	5c e3       	ldi	r21, 0x3C	; 60
     67a:	0e 94 23 10 	call	0x2046	; 0x2046 <__addsf3>
     67e:	ab 01       	movw	r20, r22
     680:	bc 01       	movw	r22, r24
     682:	81 e0       	ldi	r24, 0x01	; 1
     684:	0e 94 01 08 	call	0x1002	; 0x1002 <PWM_set_DC>
     688:	08 95       	ret

0000068a <main>:

#include "Application/app.h"

int main(void) {

	App_init();
     68a:	0e 94 a1 00 	call	0x142	; 0x142 <App_init>

	App_start();
     68e:	0e 94 bb 00 	call	0x176	; 0x176 <App_start>

	}
     692:	80 e0       	ldi	r24, 0x00	; 0
     694:	90 e0       	ldi	r25, 0x00	; 0
     696:	08 95       	ret

00000698 <ADC_select_channel>:
  //   adjusted and no more than 8 - bit precision is required, it is sufficient to read ADCH.Otherwise, ADCL must be read
  //   first, then ADCH.
  * result = (u16)ADCL + ((u16)ADCH << 8); //? This will work
  //! *result = ((u16)ADCH << 8) + (u16)ADCL; // This won't work
  return ADC_OK;
  }
     698:	88 30       	cpi	r24, 0x08	; 8
     69a:	30 f4       	brcc	.+12     	; 0x6a8 <ADC_select_channel+0x10>
     69c:	97 b1       	in	r25, 0x07	; 7
     69e:	90 7e       	andi	r25, 0xE0	; 224
     6a0:	89 2b       	or	r24, r25
     6a2:	87 b9       	out	0x07, r24	; 7
     6a4:	80 e0       	ldi	r24, 0x00	; 0
     6a6:	08 95       	ret
     6a8:	81 e0       	ldi	r24, 0x01	; 1
     6aa:	08 95       	ret

000006ac <ADC_init_auto_trigger>:

// Initialize the ADC in auto trigger mode
EN_ADCError_t ADC_init_auto_trigger(u8 trigger) {
     6ac:	e8 2f       	mov	r30, r24
  // since the defualt for pins is to be low (0) we don't need to change anything here(since it's 0).
  // I don't need to write anything too. Because the VREF won't be changed during the run time. The only case I will need to clear a bit is if it was set by the MCU or me.
#elif (ADC_VREF == AVCC)
  set_bit(ADMUX, REFS0);
#elif (ADC_VREF == INTERNAL_VREF)
  set_bit(ADMUX, REFS0);
     6ae:	87 b1       	in	r24, 0x07	; 7
     6b0:	80 64       	ori	r24, 0x40	; 64
     6b2:	87 b9       	out	0x07, r24	; 7
  set_bit(ADMUX, REFS1);
     6b4:	87 b1       	in	r24, 0x07	; 7
     6b6:	80 68       	ori	r24, 0x80	; 128
     6b8:	87 b9       	out	0x07, r24	; 7
#endif
  // Setting the prescalar to 128 so the operation frequency of the adc be within
  // the applicable range (50KHz-200KHz). The oscillator frequency is 16000000, Therefore the only applicable prescalar is 128.
  set_bit(ADCSRA, ADPS0);
     6ba:	86 b1       	in	r24, 0x06	; 6
     6bc:	81 60       	ori	r24, 0x01	; 1
     6be:	86 b9       	out	0x06, r24	; 6
  set_bit(ADCSRA, ADPS1);
     6c0:	86 b1       	in	r24, 0x06	; 6
     6c2:	82 60       	ori	r24, 0x02	; 2
     6c4:	86 b9       	out	0x06, r24	; 6
  set_bit(ADCSRA, ADPS2);
     6c6:	86 b1       	in	r24, 0x06	; 6
     6c8:	84 60       	ori	r24, 0x04	; 4
     6ca:	86 b9       	out	0x06, r24	; 6
  // Enable the auto trigger mode
  set_bit(ADCSRA, ADATE);
     6cc:	86 b1       	in	r24, 0x06	; 6
     6ce:	80 62       	ori	r24, 0x20	; 32
     6d0:	86 b9       	out	0x06, r24	; 6
  // Select the auto trigger source
  //! Cause of a bug: setting ADTS bits one by one. when setting them one by one, only the last bit is set and the rest are cleared. 
  //! The bits must be set in one write operation.
  //^ Generally, in this project, setting bits in a register one by one has caused multiple issues, also sometimes the order matters. other times a register must be read before another.
  //? Setting one bit is okay. But multiple bits need to be set in one write operation.
  switch (trigger) {
     6d2:	8e 2f       	mov	r24, r30
     6d4:	90 e0       	ldi	r25, 0x00	; 0
     6d6:	87 30       	cpi	r24, 0x07	; 7
     6d8:	91 05       	cpc	r25, r1
     6da:	00 f5       	brcc	.+64     	; 0x71c <ADC_init_auto_trigger+0x70>
     6dc:	fc 01       	movw	r30, r24
     6de:	e6 5d       	subi	r30, 0xD6	; 214
     6e0:	ff 4f       	sbci	r31, 0xFF	; 255
     6e2:	0c 94 2b 12 	jmp	0x2456	; 0x2456 <__tablejump2__>
      case FREE_RUNNING_MODE_TRIGGER:
        // All bits are clear by default
        // Start free running mode first conversion
        set_bit(ADCSRA, ADSC);
     6e6:	86 b1       	in	r24, 0x06	; 6
     6e8:	80 64       	ori	r24, 0x40	; 64
     6ea:	86 b9       	out	0x06, r24	; 6
        break;
     6ec:	17 c0       	rjmp	.+46     	; 0x71c <ADC_init_auto_trigger+0x70>
      case ANALOG_COMPARATOR_TRIGGER:
        set_bit(SFIOR, ADTS0);
     6ee:	80 b7       	in	r24, 0x30	; 48
     6f0:	80 62       	ori	r24, 0x20	; 32
     6f2:	80 bf       	out	0x30, r24	; 48
        break;
     6f4:	13 c0       	rjmp	.+38     	; 0x71c <ADC_init_auto_trigger+0x70>
      case INT0_TRIGGER:
        set_bit(SFIOR, ADTS1);
     6f6:	80 b7       	in	r24, 0x30	; 48
     6f8:	80 64       	ori	r24, 0x40	; 64
     6fa:	80 bf       	out	0x30, r24	; 48
        break;
     6fc:	0f c0       	rjmp	.+30     	; 0x71c <ADC_init_auto_trigger+0x70>
      case TIMER_0_COMPARE_MATCH_TRIGGER:
        SFIOR |= (1 << ADTS0) | (1 << ADTS1);
     6fe:	80 b7       	in	r24, 0x30	; 48
     700:	80 66       	ori	r24, 0x60	; 96
     702:	80 bf       	out	0x30, r24	; 48
        break;
     704:	0b c0       	rjmp	.+22     	; 0x71c <ADC_init_auto_trigger+0x70>
      case TIMER_0_OVF_TRIGGER:
        set_bit(SFIOR, ADTS2);
     706:	80 b7       	in	r24, 0x30	; 48
     708:	80 68       	ori	r24, 0x80	; 128
     70a:	80 bf       	out	0x30, r24	; 48
        break;
     70c:	07 c0       	rjmp	.+14     	; 0x71c <ADC_init_auto_trigger+0x70>
      case TIMER_1_COMPARE_MATCH_B_TRIGGER:
        SFIOR |= (1 << ADTS0) | (1 << ADTS2);
     70e:	80 b7       	in	r24, 0x30	; 48
     710:	80 6a       	ori	r24, 0xA0	; 160
     712:	80 bf       	out	0x30, r24	; 48
        break;
     714:	03 c0       	rjmp	.+6      	; 0x71c <ADC_init_auto_trigger+0x70>
      case TIMER_1_OVF_TRIGGER:
        SFIOR |= (1 << ADTS1) | (1 << ADTS2);
     716:	80 b7       	in	r24, 0x30	; 48
     718:	80 6c       	ori	r24, 0xC0	; 192
     71a:	80 bf       	out	0x30, r24	; 48
        break;
    }
  // Enable the ADC
  set_bit(ADCSRA, ADEN);
     71c:	86 b1       	in	r24, 0x06	; 6
     71e:	80 68       	ori	r24, 0x80	; 128
     720:	86 b9       	out	0x06, r24	; 6
  return ADC_OK;
     722:	80 e0       	ldi	r24, 0x00	; 0
     724:	08 95       	ret

00000726 <isValidPinNumber>:
 */

#include "dio.h"

bool isValidPinNumber(u8 pinNumber) {
	if (pinNumber < 8) {
     726:	88 30       	cpi	r24, 0x08	; 8
     728:	10 f4       	brcc	.+4      	; 0x72e <isValidPinNumber+0x8>
		return true;
     72a:	81 e0       	ldi	r24, 0x01	; 1
     72c:	08 95       	ret
		}
	return false;
     72e:	80 e0       	ldi	r24, 0x00	; 0
	}
     730:	08 95       	ret

00000732 <isValidPortNumber>:

bool isValidPortNumber(u8 portNumber) {
	if (portNumber == PORT_A || portNumber == PORT_B || portNumber == PORT_C || portNumber == PORT_D) {
     732:	81 54       	subi	r24, 0x41	; 65
     734:	84 30       	cpi	r24, 0x04	; 4
     736:	10 f4       	brcc	.+4      	; 0x73c <isValidPortNumber+0xa>
		return true;
     738:	81 e0       	ldi	r24, 0x01	; 1
     73a:	08 95       	ret
		}
	return false;
     73c:	80 e0       	ldi	r24, 0x00	; 0
	}
     73e:	08 95       	ret

00000740 <isValidDirection>:

bool isValidDirection(u8 direction) {
	if (direction == IN || direction == OUT) {
     740:	82 30       	cpi	r24, 0x02	; 2
     742:	10 f4       	brcc	.+4      	; 0x748 <isValidDirection+0x8>
		return true;
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	08 95       	ret
		}
	return false;
     748:	80 e0       	ldi	r24, 0x00	; 0
	}
     74a:	08 95       	ret

0000074c <isValidState>:

bool isValidState(u8 state) {
	if (state == HIGH || state == LOW) {
     74c:	82 30       	cpi	r24, 0x02	; 2
     74e:	10 f4       	brcc	.+4      	; 0x754 <isValidState+0x8>
		return true;
     750:	81 e0       	ldi	r24, 0x01	; 1
     752:	08 95       	ret
		}
	return false;
     754:	80 e0       	ldi	r24, 0x00	; 0
	}
     756:	08 95       	ret

00000758 <DIO_init>:

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
     758:	1f 93       	push	r17
     75a:	cf 93       	push	r28
     75c:	df 93       	push	r29
     75e:	c8 2f       	mov	r28, r24
     760:	d6 2f       	mov	r29, r22
     762:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     764:	0e 94 93 03 	call	0x726	; 0x726 <isValidPinNumber>
     768:	88 23       	and	r24, r24
     76a:	09 f4       	brne	.+2      	; 0x76e <DIO_init+0x16>
     76c:	84 c0       	rjmp	.+264    	; 0x876 <__stack+0x17>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     76e:	8d 2f       	mov	r24, r29
     770:	0e 94 99 03 	call	0x732	; 0x732 <isValidPortNumber>
     774:	88 23       	and	r24, r24
     776:	09 f4       	brne	.+2      	; 0x77a <DIO_init+0x22>
     778:	80 c0       	rjmp	.+256    	; 0x87a <__stack+0x1b>
		return WRONG_PORT;
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
     77a:	81 2f       	mov	r24, r17
     77c:	0e 94 a0 03 	call	0x740	; 0x740 <isValidDirection>
     780:	88 23       	and	r24, r24
     782:	09 f4       	brne	.+2      	; 0x786 <DIO_init+0x2e>
     784:	7c c0       	rjmp	.+248    	; 0x87e <__stack+0x1f>
		return WRONG_DIRECTION;
		}
	switch (portNumber) {
     786:	d2 34       	cpi	r29, 0x42	; 66
     788:	29 f1       	breq	.+74     	; 0x7d4 <DIO_init+0x7c>
     78a:	18 f4       	brcc	.+6      	; 0x792 <DIO_init+0x3a>
     78c:	d1 34       	cpi	r29, 0x41	; 65
     78e:	39 f0       	breq	.+14     	; 0x79e <DIO_init+0x46>
     790:	78 c0       	rjmp	.+240    	; 0x882 <__stack+0x23>
     792:	d3 34       	cpi	r29, 0x43	; 67
     794:	d1 f1       	breq	.+116    	; 0x80a <__DATA_REGION_LENGTH__+0xa>
     796:	d4 34       	cpi	r29, 0x44	; 68
     798:	09 f4       	brne	.+2      	; 0x79c <DIO_init+0x44>
     79a:	52 c0       	rjmp	.+164    	; 0x840 <__DATA_REGION_LENGTH__+0x40>
     79c:	72 c0       	rjmp	.+228    	; 0x882 <__stack+0x23>
			case PORT_A:
				if (direction == OUT) {
     79e:	11 30       	cpi	r17, 0x01	; 1
     7a0:	61 f4       	brne	.+24     	; 0x7ba <DIO_init+0x62>
					set_bit(DDRA, pinNumber);
     7a2:	2a b3       	in	r18, 0x1a	; 26
     7a4:	81 e0       	ldi	r24, 0x01	; 1
     7a6:	90 e0       	ldi	r25, 0x00	; 0
     7a8:	02 c0       	rjmp	.+4      	; 0x7ae <DIO_init+0x56>
     7aa:	88 0f       	add	r24, r24
     7ac:	99 1f       	adc	r25, r25
     7ae:	ca 95       	dec	r28
     7b0:	e2 f7       	brpl	.-8      	; 0x7aa <DIO_init+0x52>
     7b2:	82 2b       	or	r24, r18
     7b4:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     7b6:	80 e0       	ldi	r24, 0x00	; 0
     7b8:	65 c0       	rjmp	.+202    	; 0x884 <__stack+0x25>
			case PORT_A:
				if (direction == OUT) {
					set_bit(DDRA, pinNumber);
					}
				else {
					clear_bit(DDRA, pinNumber);
     7ba:	2a b3       	in	r18, 0x1a	; 26
     7bc:	81 e0       	ldi	r24, 0x01	; 1
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	02 c0       	rjmp	.+4      	; 0x7c6 <DIO_init+0x6e>
     7c2:	88 0f       	add	r24, r24
     7c4:	99 1f       	adc	r25, r25
     7c6:	ca 95       	dec	r28
     7c8:	e2 f7       	brpl	.-8      	; 0x7c2 <DIO_init+0x6a>
     7ca:	80 95       	com	r24
     7cc:	82 23       	and	r24, r18
     7ce:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     7d0:	80 e0       	ldi	r24, 0x00	; 0
     7d2:	58 c0       	rjmp	.+176    	; 0x884 <__stack+0x25>
				else {
					clear_bit(DDRA, pinNumber);
					}
				break;
			case PORT_B:
				if (direction == OUT) {
     7d4:	11 30       	cpi	r17, 0x01	; 1
     7d6:	61 f4       	brne	.+24     	; 0x7f0 <DIO_init+0x98>
					set_bit(DDRB, pinNumber);
     7d8:	27 b3       	in	r18, 0x17	; 23
     7da:	81 e0       	ldi	r24, 0x01	; 1
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	02 c0       	rjmp	.+4      	; 0x7e4 <DIO_init+0x8c>
     7e0:	88 0f       	add	r24, r24
     7e2:	99 1f       	adc	r25, r25
     7e4:	ca 95       	dec	r28
     7e6:	e2 f7       	brpl	.-8      	; 0x7e0 <DIO_init+0x88>
     7e8:	82 2b       	or	r24, r18
     7ea:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     7ec:	80 e0       	ldi	r24, 0x00	; 0
     7ee:	4a c0       	rjmp	.+148    	; 0x884 <__stack+0x25>
			case PORT_B:
				if (direction == OUT) {
					set_bit(DDRB, pinNumber);
					}
				else {
					clear_bit(DDRB, pinNumber);
     7f0:	27 b3       	in	r18, 0x17	; 23
     7f2:	81 e0       	ldi	r24, 0x01	; 1
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	02 c0       	rjmp	.+4      	; 0x7fc <DIO_init+0xa4>
     7f8:	88 0f       	add	r24, r24
     7fa:	99 1f       	adc	r25, r25
     7fc:	ca 95       	dec	r28
     7fe:	e2 f7       	brpl	.-8      	; 0x7f8 <DIO_init+0xa0>
     800:	80 95       	com	r24
     802:	82 23       	and	r24, r18
     804:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     806:	80 e0       	ldi	r24, 0x00	; 0
     808:	3d c0       	rjmp	.+122    	; 0x884 <__stack+0x25>
				else {
					clear_bit(DDRB, pinNumber);
					}
				break;
			case PORT_C:
				if (direction == OUT) {
     80a:	11 30       	cpi	r17, 0x01	; 1
     80c:	61 f4       	brne	.+24     	; 0x826 <__DATA_REGION_LENGTH__+0x26>
					set_bit(DDRC, pinNumber);
     80e:	24 b3       	in	r18, 0x14	; 20
     810:	81 e0       	ldi	r24, 0x01	; 1
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	02 c0       	rjmp	.+4      	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
     816:	88 0f       	add	r24, r24
     818:	99 1f       	adc	r25, r25
     81a:	ca 95       	dec	r28
     81c:	e2 f7       	brpl	.-8      	; 0x816 <__DATA_REGION_LENGTH__+0x16>
     81e:	82 2b       	or	r24, r18
     820:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     822:	80 e0       	ldi	r24, 0x00	; 0
     824:	2f c0       	rjmp	.+94     	; 0x884 <__stack+0x25>
			case PORT_C:
				if (direction == OUT) {
					set_bit(DDRC, pinNumber);
					}
				else {
					clear_bit(DDRC, pinNumber);
     826:	24 b3       	in	r18, 0x14	; 20
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	90 e0       	ldi	r25, 0x00	; 0
     82c:	02 c0       	rjmp	.+4      	; 0x832 <__DATA_REGION_LENGTH__+0x32>
     82e:	88 0f       	add	r24, r24
     830:	99 1f       	adc	r25, r25
     832:	ca 95       	dec	r28
     834:	e2 f7       	brpl	.-8      	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
     836:	80 95       	com	r24
     838:	82 23       	and	r24, r18
     83a:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     83c:	80 e0       	ldi	r24, 0x00	; 0
     83e:	22 c0       	rjmp	.+68     	; 0x884 <__stack+0x25>
				else {
					clear_bit(DDRC, pinNumber);
					}
				break;
			case PORT_D:
				if (direction == OUT) {
     840:	11 30       	cpi	r17, 0x01	; 1
     842:	61 f4       	brne	.+24     	; 0x85c <__DATA_REGION_LENGTH__+0x5c>
					set_bit(DDRD, pinNumber);
     844:	21 b3       	in	r18, 0x11	; 17
     846:	81 e0       	ldi	r24, 0x01	; 1
     848:	90 e0       	ldi	r25, 0x00	; 0
     84a:	02 c0       	rjmp	.+4      	; 0x850 <__DATA_REGION_LENGTH__+0x50>
     84c:	88 0f       	add	r24, r24
     84e:	99 1f       	adc	r25, r25
     850:	ca 95       	dec	r28
     852:	e2 f7       	brpl	.-8      	; 0x84c <__DATA_REGION_LENGTH__+0x4c>
     854:	82 2b       	or	r24, r18
     856:	81 bb       	out	0x11, r24	; 17
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     858:	80 e0       	ldi	r24, 0x00	; 0
     85a:	14 c0       	rjmp	.+40     	; 0x884 <__stack+0x25>
			case PORT_D:
				if (direction == OUT) {
					set_bit(DDRD, pinNumber);
					}
				else {
					clear_bit(DDRD, pinNumber);
     85c:	21 b3       	in	r18, 0x11	; 17
     85e:	81 e0       	ldi	r24, 0x01	; 1
     860:	90 e0       	ldi	r25, 0x00	; 0
     862:	02 c0       	rjmp	.+4      	; 0x868 <__stack+0x9>
     864:	88 0f       	add	r24, r24
     866:	99 1f       	adc	r25, r25
     868:	ca 95       	dec	r28
     86a:	e2 f7       	brpl	.-8      	; 0x864 <__stack+0x5>
     86c:	80 95       	com	r24
     86e:	82 23       	and	r24, r18
     870:	81 bb       	out	0x11, r24	; 17
					}
				break;
		}
	return DIO_OK;
     872:	80 e0       	ldi	r24, 0x00	; 0
     874:	07 c0       	rjmp	.+14     	; 0x884 <__stack+0x25>

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     876:	81 e0       	ldi	r24, 0x01	; 1
     878:	05 c0       	rjmp	.+10     	; 0x884 <__stack+0x25>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     87a:	82 e0       	ldi	r24, 0x02	; 2
     87c:	03 c0       	rjmp	.+6      	; 0x884 <__stack+0x25>
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
		return WRONG_DIRECTION;
     87e:	83 e0       	ldi	r24, 0x03	; 3
     880:	01 c0       	rjmp	.+2      	; 0x884 <__stack+0x25>
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     882:	80 e0       	ldi	r24, 0x00	; 0
	}
     884:	df 91       	pop	r29
     886:	cf 91       	pop	r28
     888:	1f 91       	pop	r17
     88a:	08 95       	ret

0000088c <DIO_write>:

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
     88c:	1f 93       	push	r17
     88e:	cf 93       	push	r28
     890:	df 93       	push	r29
     892:	c8 2f       	mov	r28, r24
     894:	d6 2f       	mov	r29, r22
     896:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     898:	0e 94 93 03 	call	0x726	; 0x726 <isValidPinNumber>
     89c:	88 23       	and	r24, r24
     89e:	09 f4       	brne	.+2      	; 0x8a2 <DIO_write+0x16>
     8a0:	84 c0       	rjmp	.+264    	; 0x9aa <DIO_write+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     8a2:	8d 2f       	mov	r24, r29
     8a4:	0e 94 99 03 	call	0x732	; 0x732 <isValidPortNumber>
     8a8:	88 23       	and	r24, r24
     8aa:	09 f4       	brne	.+2      	; 0x8ae <DIO_write+0x22>
     8ac:	80 c0       	rjmp	.+256    	; 0x9ae <DIO_write+0x122>
		return WRONG_PORT;
		}
	// Validate the pin state
	if (!isValidState(state)) {
     8ae:	81 2f       	mov	r24, r17
     8b0:	0e 94 a6 03 	call	0x74c	; 0x74c <isValidState>
     8b4:	88 23       	and	r24, r24
     8b6:	09 f4       	brne	.+2      	; 0x8ba <DIO_write+0x2e>
     8b8:	7c c0       	rjmp	.+248    	; 0x9b2 <DIO_write+0x126>
		return WRONG_STATE;
		}
	switch (portNumber) {
     8ba:	d2 34       	cpi	r29, 0x42	; 66
     8bc:	29 f1       	breq	.+74     	; 0x908 <DIO_write+0x7c>
     8be:	18 f4       	brcc	.+6      	; 0x8c6 <DIO_write+0x3a>
     8c0:	d1 34       	cpi	r29, 0x41	; 65
     8c2:	39 f0       	breq	.+14     	; 0x8d2 <DIO_write+0x46>
     8c4:	78 c0       	rjmp	.+240    	; 0x9b6 <DIO_write+0x12a>
     8c6:	d3 34       	cpi	r29, 0x43	; 67
     8c8:	d1 f1       	breq	.+116    	; 0x93e <DIO_write+0xb2>
     8ca:	d4 34       	cpi	r29, 0x44	; 68
     8cc:	09 f4       	brne	.+2      	; 0x8d0 <DIO_write+0x44>
     8ce:	52 c0       	rjmp	.+164    	; 0x974 <DIO_write+0xe8>
     8d0:	72 c0       	rjmp	.+228    	; 0x9b6 <DIO_write+0x12a>
			case PORT_A:
				if (state == HIGH) {
     8d2:	11 30       	cpi	r17, 0x01	; 1
     8d4:	61 f4       	brne	.+24     	; 0x8ee <DIO_write+0x62>
					set_bit(PORTA, pinNumber);
     8d6:	2b b3       	in	r18, 0x1b	; 27
     8d8:	81 e0       	ldi	r24, 0x01	; 1
     8da:	90 e0       	ldi	r25, 0x00	; 0
     8dc:	02 c0       	rjmp	.+4      	; 0x8e2 <DIO_write+0x56>
     8de:	88 0f       	add	r24, r24
     8e0:	99 1f       	adc	r25, r25
     8e2:	ca 95       	dec	r28
     8e4:	e2 f7       	brpl	.-8      	; 0x8de <DIO_write+0x52>
     8e6:	82 2b       	or	r24, r18
     8e8:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     8ea:	80 e0       	ldi	r24, 0x00	; 0
     8ec:	65 c0       	rjmp	.+202    	; 0x9b8 <DIO_write+0x12c>
			case PORT_A:
				if (state == HIGH) {
					set_bit(PORTA, pinNumber);
					}
				else {
					clear_bit(PORTA, pinNumber);
     8ee:	2b b3       	in	r18, 0x1b	; 27
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	90 e0       	ldi	r25, 0x00	; 0
     8f4:	02 c0       	rjmp	.+4      	; 0x8fa <DIO_write+0x6e>
     8f6:	88 0f       	add	r24, r24
     8f8:	99 1f       	adc	r25, r25
     8fa:	ca 95       	dec	r28
     8fc:	e2 f7       	brpl	.-8      	; 0x8f6 <DIO_write+0x6a>
     8fe:	80 95       	com	r24
     900:	82 23       	and	r24, r18
     902:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     904:	80 e0       	ldi	r24, 0x00	; 0
     906:	58 c0       	rjmp	.+176    	; 0x9b8 <DIO_write+0x12c>
				else {
					clear_bit(PORTA, pinNumber);
					}
				break;
			case PORT_B:
				if (state == HIGH) {
     908:	11 30       	cpi	r17, 0x01	; 1
     90a:	61 f4       	brne	.+24     	; 0x924 <DIO_write+0x98>
					set_bit(PORTB, pinNumber);
     90c:	28 b3       	in	r18, 0x18	; 24
     90e:	81 e0       	ldi	r24, 0x01	; 1
     910:	90 e0       	ldi	r25, 0x00	; 0
     912:	02 c0       	rjmp	.+4      	; 0x918 <DIO_write+0x8c>
     914:	88 0f       	add	r24, r24
     916:	99 1f       	adc	r25, r25
     918:	ca 95       	dec	r28
     91a:	e2 f7       	brpl	.-8      	; 0x914 <DIO_write+0x88>
     91c:	82 2b       	or	r24, r18
     91e:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     920:	80 e0       	ldi	r24, 0x00	; 0
     922:	4a c0       	rjmp	.+148    	; 0x9b8 <DIO_write+0x12c>
			case PORT_B:
				if (state == HIGH) {
					set_bit(PORTB, pinNumber);
					}
				else {
					clear_bit(PORTB, pinNumber);
     924:	28 b3       	in	r18, 0x18	; 24
     926:	81 e0       	ldi	r24, 0x01	; 1
     928:	90 e0       	ldi	r25, 0x00	; 0
     92a:	02 c0       	rjmp	.+4      	; 0x930 <DIO_write+0xa4>
     92c:	88 0f       	add	r24, r24
     92e:	99 1f       	adc	r25, r25
     930:	ca 95       	dec	r28
     932:	e2 f7       	brpl	.-8      	; 0x92c <DIO_write+0xa0>
     934:	80 95       	com	r24
     936:	82 23       	and	r24, r18
     938:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     93a:	80 e0       	ldi	r24, 0x00	; 0
     93c:	3d c0       	rjmp	.+122    	; 0x9b8 <DIO_write+0x12c>
				else {
					clear_bit(PORTB, pinNumber);
					}
				break;
			case PORT_C:
				if (state == HIGH) {
     93e:	11 30       	cpi	r17, 0x01	; 1
     940:	61 f4       	brne	.+24     	; 0x95a <DIO_write+0xce>
					set_bit(PORTC, pinNumber);
     942:	25 b3       	in	r18, 0x15	; 21
     944:	81 e0       	ldi	r24, 0x01	; 1
     946:	90 e0       	ldi	r25, 0x00	; 0
     948:	02 c0       	rjmp	.+4      	; 0x94e <DIO_write+0xc2>
     94a:	88 0f       	add	r24, r24
     94c:	99 1f       	adc	r25, r25
     94e:	ca 95       	dec	r28
     950:	e2 f7       	brpl	.-8      	; 0x94a <DIO_write+0xbe>
     952:	82 2b       	or	r24, r18
     954:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     956:	80 e0       	ldi	r24, 0x00	; 0
     958:	2f c0       	rjmp	.+94     	; 0x9b8 <DIO_write+0x12c>
			case PORT_C:
				if (state == HIGH) {
					set_bit(PORTC, pinNumber);
					}
				else {
					clear_bit(PORTC, pinNumber);
     95a:	25 b3       	in	r18, 0x15	; 21
     95c:	81 e0       	ldi	r24, 0x01	; 1
     95e:	90 e0       	ldi	r25, 0x00	; 0
     960:	02 c0       	rjmp	.+4      	; 0x966 <DIO_write+0xda>
     962:	88 0f       	add	r24, r24
     964:	99 1f       	adc	r25, r25
     966:	ca 95       	dec	r28
     968:	e2 f7       	brpl	.-8      	; 0x962 <DIO_write+0xd6>
     96a:	80 95       	com	r24
     96c:	82 23       	and	r24, r18
     96e:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     970:	80 e0       	ldi	r24, 0x00	; 0
     972:	22 c0       	rjmp	.+68     	; 0x9b8 <DIO_write+0x12c>
				else {
					clear_bit(PORTC, pinNumber);
					}
				break;
			case PORT_D:
				if (state == HIGH) {
     974:	11 30       	cpi	r17, 0x01	; 1
     976:	61 f4       	brne	.+24     	; 0x990 <DIO_write+0x104>
					set_bit(PORTD, pinNumber);
     978:	22 b3       	in	r18, 0x12	; 18
     97a:	81 e0       	ldi	r24, 0x01	; 1
     97c:	90 e0       	ldi	r25, 0x00	; 0
     97e:	02 c0       	rjmp	.+4      	; 0x984 <DIO_write+0xf8>
     980:	88 0f       	add	r24, r24
     982:	99 1f       	adc	r25, r25
     984:	ca 95       	dec	r28
     986:	e2 f7       	brpl	.-8      	; 0x980 <DIO_write+0xf4>
     988:	82 2b       	or	r24, r18
     98a:	82 bb       	out	0x12, r24	; 18
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     98c:	80 e0       	ldi	r24, 0x00	; 0
     98e:	14 c0       	rjmp	.+40     	; 0x9b8 <DIO_write+0x12c>
			case PORT_D:
				if (state == HIGH) {
					set_bit(PORTD, pinNumber);
					}
				else {
					clear_bit(PORTD, pinNumber);
     990:	22 b3       	in	r18, 0x12	; 18
     992:	81 e0       	ldi	r24, 0x01	; 1
     994:	90 e0       	ldi	r25, 0x00	; 0
     996:	02 c0       	rjmp	.+4      	; 0x99c <DIO_write+0x110>
     998:	88 0f       	add	r24, r24
     99a:	99 1f       	adc	r25, r25
     99c:	ca 95       	dec	r28
     99e:	e2 f7       	brpl	.-8      	; 0x998 <DIO_write+0x10c>
     9a0:	80 95       	com	r24
     9a2:	82 23       	and	r24, r18
     9a4:	82 bb       	out	0x12, r24	; 18
					}
				break;
		}
	return DIO_OK;
     9a6:	80 e0       	ldi	r24, 0x00	; 0
     9a8:	07 c0       	rjmp	.+14     	; 0x9b8 <DIO_write+0x12c>

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     9aa:	81 e0       	ldi	r24, 0x01	; 1
     9ac:	05 c0       	rjmp	.+10     	; 0x9b8 <DIO_write+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     9ae:	82 e0       	ldi	r24, 0x02	; 2
     9b0:	03 c0       	rjmp	.+6      	; 0x9b8 <DIO_write+0x12c>
		}
	// Validate the pin state
	if (!isValidState(state)) {
		return WRONG_STATE;
     9b2:	84 e0       	ldi	r24, 0x04	; 4
     9b4:	01 c0       	rjmp	.+2      	; 0x9b8 <DIO_write+0x12c>
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     9b6:	80 e0       	ldi	r24, 0x00	; 0
	}
     9b8:	df 91       	pop	r29
     9ba:	cf 91       	pop	r28
     9bc:	1f 91       	pop	r17
     9be:	08 95       	ret

000009c0 <getCurrentStatus>:

EN_I2CMasterStatusCode_t I2C_repeatedStart() {   // Same as start, just a different name
  TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  while (read_bit(TWCR, TWINT) == 0);
  return getCurrentStatus();
  }
     9c0:	81 b1       	in	r24, 0x01	; 1
     9c2:	e8 2f       	mov	r30, r24
     9c4:	e8 7f       	andi	r30, 0xF8	; 248
     9c6:	8e 2f       	mov	r24, r30
     9c8:	90 e0       	ldi	r25, 0x00	; 0
     9ca:	fc 01       	movw	r30, r24
     9cc:	38 97       	sbiw	r30, 0x08	; 8
     9ce:	e1 35       	cpi	r30, 0x51	; 81
     9d0:	f1 05       	cpc	r31, r1
     9d2:	c0 f4       	brcc	.+48     	; 0xa04 <getCurrentStatus+0x44>
     9d4:	ef 5c       	subi	r30, 0xCF	; 207
     9d6:	ff 4f       	sbci	r31, 0xFF	; 255
     9d8:	0c 94 2b 12 	jmp	0x2456	; 0x2456 <__tablejump2__>
     9dc:	80 e0       	ldi	r24, 0x00	; 0
     9de:	08 95       	ret
     9e0:	82 e0       	ldi	r24, 0x02	; 2
     9e2:	08 95       	ret
     9e4:	83 e0       	ldi	r24, 0x03	; 3
     9e6:	08 95       	ret
     9e8:	84 e0       	ldi	r24, 0x04	; 4
     9ea:	08 95       	ret
     9ec:	85 e0       	ldi	r24, 0x05	; 5
     9ee:	08 95       	ret
     9f0:	86 e0       	ldi	r24, 0x06	; 6
     9f2:	08 95       	ret
     9f4:	87 e0       	ldi	r24, 0x07	; 7
     9f6:	08 95       	ret
     9f8:	88 e0       	ldi	r24, 0x08	; 8
     9fa:	08 95       	ret
     9fc:	89 e0       	ldi	r24, 0x09	; 9
     9fe:	08 95       	ret
     a00:	8a e0       	ldi	r24, 0x0A	; 10
     a02:	08 95       	ret
     a04:	8b e0       	ldi	r24, 0x0B	; 11
     a06:	08 95       	ret
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	08 95       	ret

00000a0c <I2C_init>:
     a0c:	11 b8       	out	0x01, r1	; 1
     a0e:	8f ef       	ldi	r24, 0xFF	; 255
     a10:	80 b9       	out	0x00, r24	; 0
     a12:	08 95       	ret

00000a14 <I2C_start>:
     a14:	84 ea       	ldi	r24, 0xA4	; 164
     a16:	86 bf       	out	0x36, r24	; 54
     a18:	06 b6       	in	r0, 0x36	; 54
     a1a:	07 fe       	sbrs	r0, 7
     a1c:	fd cf       	rjmp	.-6      	; 0xa18 <I2C_start+0x4>
     a1e:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <getCurrentStatus>
     a22:	08 95       	ret

00000a24 <I2C_write>:

EN_I2CMasterStatusCode_t I2C_write(u8 data) {
  TWDR = data;
     a24:	83 b9       	out	0x03, r24	; 3
  TWCR = (1 << TWEN) | (1 << TWINT);
     a26:	84 e8       	ldi	r24, 0x84	; 132
     a28:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWINT) == 0);
     a2a:	06 b6       	in	r0, 0x36	; 54
     a2c:	07 fe       	sbrs	r0, 7
     a2e:	fd cf       	rjmp	.-6      	; 0xa2a <I2C_write+0x6>
  return getCurrentStatus();
     a30:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <getCurrentStatus>
  }
     a34:	08 95       	ret

00000a36 <I2C_read_Ack>:

EN_I2CMasterStatusCode_t I2C_read_Ack(u8* data) {
  TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWINT);
     a36:	24 ec       	ldi	r18, 0xC4	; 196
     a38:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     a3a:	06 b6       	in	r0, 0x36	; 54
     a3c:	07 fe       	sbrs	r0, 7
     a3e:	fd cf       	rjmp	.-6      	; 0xa3a <I2C_read_Ack+0x4>
  *data = TWDR;
     a40:	23 b1       	in	r18, 0x03	; 3
     a42:	fc 01       	movw	r30, r24
     a44:	20 83       	st	Z, r18
  return getCurrentStatus();
     a46:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <getCurrentStatus>
  }
     a4a:	08 95       	ret

00000a4c <I2C_read_Nack>:

EN_I2CMasterStatusCode_t I2C_read_Nack(u8* data) {
  TWCR = (1 << TWEN) | (1 << TWINT);
     a4c:	24 e8       	ldi	r18, 0x84	; 132
     a4e:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     a50:	06 b6       	in	r0, 0x36	; 54
     a52:	07 fe       	sbrs	r0, 7
     a54:	fd cf       	rjmp	.-6      	; 0xa50 <I2C_read_Nack+0x4>
  *data = TWDR;
     a56:	23 b1       	in	r18, 0x03	; 3
     a58:	fc 01       	movw	r30, r24
     a5a:	20 83       	st	Z, r18
  return getCurrentStatus();
     a5c:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <getCurrentStatus>
  }
     a60:	08 95       	ret

00000a62 <I2C_stop>:

void I2C_stop(void) {
  TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
     a62:	84 e9       	ldi	r24, 0x94	; 148
     a64:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWSTO));	// Wait until stop condition finishes
     a66:	06 b6       	in	r0, 0x36	; 54
     a68:	04 fc       	sbrc	r0, 4
     a6a:	fd cf       	rjmp	.-6      	; 0xa66 <I2C_stop+0x4>
  }
     a6c:	08 95       	ret

00000a6e <INT0_init>:
        break;
    }
  // Enable the external interrupt 
  set_bit(GICR, INT2);
  return INTERRUPT_INIT_OK;
  }
     a6e:	84 30       	cpi	r24, 0x04	; 4
     a70:	c8 f4       	brcc	.+50     	; 0xaa4 <INT0_init+0x36>
     a72:	82 30       	cpi	r24, 0x02	; 2
     a74:	41 f0       	breq	.+16     	; 0xa86 <INT0_init+0x18>
     a76:	83 30       	cpi	r24, 0x03	; 3
     a78:	51 f0       	breq	.+20     	; 0xa8e <INT0_init+0x20>
     a7a:	81 30       	cpi	r24, 0x01	; 1
     a7c:	71 f4       	brne	.+28     	; 0xa9a <INT0_init+0x2c>
     a7e:	85 b7       	in	r24, 0x35	; 53
     a80:	81 60       	ori	r24, 0x01	; 1
     a82:	85 bf       	out	0x35, r24	; 53
     a84:	0a c0       	rjmp	.+20     	; 0xa9a <INT0_init+0x2c>
     a86:	85 b7       	in	r24, 0x35	; 53
     a88:	82 60       	ori	r24, 0x02	; 2
     a8a:	85 bf       	out	0x35, r24	; 53
     a8c:	06 c0       	rjmp	.+12     	; 0xa9a <INT0_init+0x2c>
     a8e:	85 b7       	in	r24, 0x35	; 53
     a90:	81 60       	ori	r24, 0x01	; 1
     a92:	85 bf       	out	0x35, r24	; 53
     a94:	85 b7       	in	r24, 0x35	; 53
     a96:	82 60       	ori	r24, 0x02	; 2
     a98:	85 bf       	out	0x35, r24	; 53
     a9a:	8b b7       	in	r24, 0x3b	; 59
     a9c:	80 64       	ori	r24, 0x40	; 64
     a9e:	8b bf       	out	0x3b, r24	; 59
     aa0:	80 e0       	ldi	r24, 0x00	; 0
     aa2:	08 95       	ret
     aa4:	81 e0       	ldi	r24, 0x01	; 1
     aa6:	08 95       	ret

00000aa8 <ADC_INT_init>:

// Initialize the ADC conversion complete interrupt
EN_INT_init_Status_t ADC_INT_init(void) {
  // Enable the ADC conversion complete interrupt
  set_bit(ADCSRA, ADIE);
     aa8:	86 b1       	in	r24, 0x06	; 6
     aaa:	88 60       	ori	r24, 0x08	; 8
     aac:	86 b9       	out	0x06, r24	; 6
  return INTERRUPT_INIT_OK;
  }
     aae:	80 e0       	ldi	r24, 0x00	; 0
     ab0:	08 95       	ret

00000ab2 <UART_RXC_INT_init>:

// Initialize the UART RX complete interrupt
EN_INT_init_Status_t UART_RXC_INT_init(void) {
  // Enable the UART RX complete interrupt
  set_bit(UCSRB, RXCIE);
     ab2:	8a b1       	in	r24, 0x0a	; 10
     ab4:	80 68       	ori	r24, 0x80	; 128
     ab6:	8a b9       	out	0x0a, r24	; 10
  return INTERRUPT_INIT_OK;
     ab8:	80 e0       	ldi	r24, 0x00	; 0
     aba:	08 95       	ret

00000abc <isValidTimer>:
        clear_bit(TCCR2, COM21);
        set_prescalar(TIMER_2, PWM_PRESCALAR);
        break;
    }
  return TIMER_OK;
  }
     abc:	83 30       	cpi	r24, 0x03	; 3
     abe:	10 f4       	brcc	.+4      	; 0xac4 <isValidTimer+0x8>
     ac0:	81 e0       	ldi	r24, 0x01	; 1
     ac2:	08 95       	ret
     ac4:	80 e0       	ldi	r24, 0x00	; 0
     ac6:	08 95       	ret

00000ac8 <set_prescalar>:
     ac8:	1f 93       	push	r17
     aca:	cf 93       	push	r28
     acc:	df 93       	push	r29
     ace:	18 2f       	mov	r17, r24
     ad0:	eb 01       	movw	r28, r22
     ad2:	0e 94 5e 05 	call	0xabc	; 0xabc <isValidTimer>
     ad6:	88 23       	and	r24, r24
     ad8:	09 f4       	brne	.+2      	; 0xadc <set_prescalar+0x14>
     ada:	6a c1       	rjmp	.+724    	; 0xdb0 <set_prescalar+0x2e8>
     adc:	11 30       	cpi	r17, 0x01	; 1
     ade:	09 f4       	brne	.+2      	; 0xae2 <set_prescalar+0x1a>
     ae0:	6f c0       	rjmp	.+222    	; 0xbc0 <set_prescalar+0xf8>
     ae2:	20 f0       	brcs	.+8      	; 0xaec <set_prescalar+0x24>
     ae4:	12 30       	cpi	r17, 0x02	; 2
     ae6:	09 f4       	brne	.+2      	; 0xaea <set_prescalar+0x22>
     ae8:	d5 c0       	rjmp	.+426    	; 0xc94 <set_prescalar+0x1cc>
     aea:	64 c1       	rjmp	.+712    	; 0xdb4 <set_prescalar+0x2ec>
     aec:	c2 30       	cpi	r28, 0x02	; 2
     aee:	d1 05       	cpc	r29, r1
     af0:	78 f0       	brcs	.+30     	; 0xb10 <set_prescalar+0x48>
     af2:	c8 30       	cpi	r28, 0x08	; 8
     af4:	d1 05       	cpc	r29, r1
     af6:	61 f0       	breq	.+24     	; 0xb10 <set_prescalar+0x48>
     af8:	c0 34       	cpi	r28, 0x40	; 64
     afa:	d1 05       	cpc	r29, r1
     afc:	49 f0       	breq	.+18     	; 0xb10 <set_prescalar+0x48>
     afe:	c1 15       	cp	r28, r1
     b00:	81 e0       	ldi	r24, 0x01	; 1
     b02:	d8 07       	cpc	r29, r24
     b04:	29 f0       	breq	.+10     	; 0xb10 <set_prescalar+0x48>
     b06:	c1 15       	cp	r28, r1
     b08:	84 e0       	ldi	r24, 0x04	; 4
     b0a:	d8 07       	cpc	r29, r24
     b0c:	09 f0       	breq	.+2      	; 0xb10 <set_prescalar+0x48>
     b0e:	54 c1       	rjmp	.+680    	; 0xdb8 <set_prescalar+0x2f0>
     b10:	c8 30       	cpi	r28, 0x08	; 8
     b12:	d1 05       	cpc	r29, r1
     b14:	49 f1       	breq	.+82     	; 0xb68 <set_prescalar+0xa0>
     b16:	28 f4       	brcc	.+10     	; 0xb22 <set_prescalar+0x5a>
     b18:	20 97       	sbiw	r28, 0x00	; 0
     b1a:	81 f0       	breq	.+32     	; 0xb3c <set_prescalar+0x74>
     b1c:	21 97       	sbiw	r28, 0x01	; 1
     b1e:	c9 f0       	breq	.+50     	; 0xb52 <set_prescalar+0x8a>
     b20:	4d c1       	rjmp	.+666    	; 0xdbc <set_prescalar+0x2f4>
     b22:	c1 15       	cp	r28, r1
     b24:	81 e0       	ldi	r24, 0x01	; 1
     b26:	d8 07       	cpc	r29, r24
     b28:	a9 f1       	breq	.+106    	; 0xb94 <set_prescalar+0xcc>
     b2a:	c1 15       	cp	r28, r1
     b2c:	84 e0       	ldi	r24, 0x04	; 4
     b2e:	d8 07       	cpc	r29, r24
     b30:	e1 f1       	breq	.+120    	; 0xbaa <set_prescalar+0xe2>
     b32:	c0 34       	cpi	r28, 0x40	; 64
     b34:	d1 05       	cpc	r29, r1
     b36:	09 f0       	breq	.+2      	; 0xb3a <set_prescalar+0x72>
     b38:	41 c1       	rjmp	.+642    	; 0xdbc <set_prescalar+0x2f4>
     b3a:	21 c0       	rjmp	.+66     	; 0xb7e <set_prescalar+0xb6>
     b3c:	83 b7       	in	r24, 0x33	; 51
     b3e:	8e 7f       	andi	r24, 0xFE	; 254
     b40:	83 bf       	out	0x33, r24	; 51
     b42:	83 b7       	in	r24, 0x33	; 51
     b44:	8d 7f       	andi	r24, 0xFD	; 253
     b46:	83 bf       	out	0x33, r24	; 51
     b48:	83 b7       	in	r24, 0x33	; 51
     b4a:	8b 7f       	andi	r24, 0xFB	; 251
     b4c:	83 bf       	out	0x33, r24	; 51
     b4e:	80 e0       	ldi	r24, 0x00	; 0
     b50:	3e c1       	rjmp	.+636    	; 0xdce <set_prescalar+0x306>
     b52:	83 b7       	in	r24, 0x33	; 51
     b54:	81 60       	ori	r24, 0x01	; 1
     b56:	83 bf       	out	0x33, r24	; 51
     b58:	83 b7       	in	r24, 0x33	; 51
     b5a:	8d 7f       	andi	r24, 0xFD	; 253
     b5c:	83 bf       	out	0x33, r24	; 51
     b5e:	83 b7       	in	r24, 0x33	; 51
     b60:	8b 7f       	andi	r24, 0xFB	; 251
     b62:	83 bf       	out	0x33, r24	; 51
     b64:	80 e0       	ldi	r24, 0x00	; 0
     b66:	33 c1       	rjmp	.+614    	; 0xdce <set_prescalar+0x306>
     b68:	83 b7       	in	r24, 0x33	; 51
     b6a:	8e 7f       	andi	r24, 0xFE	; 254
     b6c:	83 bf       	out	0x33, r24	; 51
     b6e:	83 b7       	in	r24, 0x33	; 51
     b70:	82 60       	ori	r24, 0x02	; 2
     b72:	83 bf       	out	0x33, r24	; 51
     b74:	83 b7       	in	r24, 0x33	; 51
     b76:	8b 7f       	andi	r24, 0xFB	; 251
     b78:	83 bf       	out	0x33, r24	; 51
     b7a:	80 e0       	ldi	r24, 0x00	; 0
     b7c:	28 c1       	rjmp	.+592    	; 0xdce <set_prescalar+0x306>
     b7e:	83 b7       	in	r24, 0x33	; 51
     b80:	81 60       	ori	r24, 0x01	; 1
     b82:	83 bf       	out	0x33, r24	; 51
     b84:	83 b7       	in	r24, 0x33	; 51
     b86:	82 60       	ori	r24, 0x02	; 2
     b88:	83 bf       	out	0x33, r24	; 51
     b8a:	83 b7       	in	r24, 0x33	; 51
     b8c:	8b 7f       	andi	r24, 0xFB	; 251
     b8e:	83 bf       	out	0x33, r24	; 51
     b90:	80 e0       	ldi	r24, 0x00	; 0
     b92:	1d c1       	rjmp	.+570    	; 0xdce <set_prescalar+0x306>
     b94:	83 b7       	in	r24, 0x33	; 51
     b96:	8e 7f       	andi	r24, 0xFE	; 254
     b98:	83 bf       	out	0x33, r24	; 51
     b9a:	83 b7       	in	r24, 0x33	; 51
     b9c:	8d 7f       	andi	r24, 0xFD	; 253
     b9e:	83 bf       	out	0x33, r24	; 51
     ba0:	83 b7       	in	r24, 0x33	; 51
     ba2:	84 60       	ori	r24, 0x04	; 4
     ba4:	83 bf       	out	0x33, r24	; 51
     ba6:	80 e0       	ldi	r24, 0x00	; 0
     ba8:	12 c1       	rjmp	.+548    	; 0xdce <set_prescalar+0x306>
     baa:	83 b7       	in	r24, 0x33	; 51
     bac:	81 60       	ori	r24, 0x01	; 1
     bae:	83 bf       	out	0x33, r24	; 51
     bb0:	83 b7       	in	r24, 0x33	; 51
     bb2:	8d 7f       	andi	r24, 0xFD	; 253
     bb4:	83 bf       	out	0x33, r24	; 51
     bb6:	83 b7       	in	r24, 0x33	; 51
     bb8:	84 60       	ori	r24, 0x04	; 4
     bba:	83 bf       	out	0x33, r24	; 51
     bbc:	80 e0       	ldi	r24, 0x00	; 0
     bbe:	07 c1       	rjmp	.+526    	; 0xdce <set_prescalar+0x306>
     bc0:	c2 30       	cpi	r28, 0x02	; 2
     bc2:	d1 05       	cpc	r29, r1
     bc4:	78 f0       	brcs	.+30     	; 0xbe4 <set_prescalar+0x11c>
     bc6:	c8 30       	cpi	r28, 0x08	; 8
     bc8:	d1 05       	cpc	r29, r1
     bca:	61 f0       	breq	.+24     	; 0xbe4 <set_prescalar+0x11c>
     bcc:	c0 34       	cpi	r28, 0x40	; 64
     bce:	d1 05       	cpc	r29, r1
     bd0:	49 f0       	breq	.+18     	; 0xbe4 <set_prescalar+0x11c>
     bd2:	c1 15       	cp	r28, r1
     bd4:	81 e0       	ldi	r24, 0x01	; 1
     bd6:	d8 07       	cpc	r29, r24
     bd8:	29 f0       	breq	.+10     	; 0xbe4 <set_prescalar+0x11c>
     bda:	c1 15       	cp	r28, r1
     bdc:	84 e0       	ldi	r24, 0x04	; 4
     bde:	d8 07       	cpc	r29, r24
     be0:	09 f0       	breq	.+2      	; 0xbe4 <set_prescalar+0x11c>
     be2:	ee c0       	rjmp	.+476    	; 0xdc0 <set_prescalar+0x2f8>
     be4:	c8 30       	cpi	r28, 0x08	; 8
     be6:	d1 05       	cpc	r29, r1
     be8:	49 f1       	breq	.+82     	; 0xc3c <set_prescalar+0x174>
     bea:	28 f4       	brcc	.+10     	; 0xbf6 <set_prescalar+0x12e>
     bec:	20 97       	sbiw	r28, 0x00	; 0
     bee:	81 f0       	breq	.+32     	; 0xc10 <set_prescalar+0x148>
     bf0:	21 97       	sbiw	r28, 0x01	; 1
     bf2:	c9 f0       	breq	.+50     	; 0xc26 <set_prescalar+0x15e>
     bf4:	e7 c0       	rjmp	.+462    	; 0xdc4 <set_prescalar+0x2fc>
     bf6:	c1 15       	cp	r28, r1
     bf8:	81 e0       	ldi	r24, 0x01	; 1
     bfa:	d8 07       	cpc	r29, r24
     bfc:	a9 f1       	breq	.+106    	; 0xc68 <set_prescalar+0x1a0>
     bfe:	c1 15       	cp	r28, r1
     c00:	84 e0       	ldi	r24, 0x04	; 4
     c02:	d8 07       	cpc	r29, r24
     c04:	e1 f1       	breq	.+120    	; 0xc7e <set_prescalar+0x1b6>
     c06:	c0 34       	cpi	r28, 0x40	; 64
     c08:	d1 05       	cpc	r29, r1
     c0a:	09 f0       	breq	.+2      	; 0xc0e <set_prescalar+0x146>
     c0c:	db c0       	rjmp	.+438    	; 0xdc4 <set_prescalar+0x2fc>
     c0e:	21 c0       	rjmp	.+66     	; 0xc52 <set_prescalar+0x18a>
     c10:	8e b5       	in	r24, 0x2e	; 46
     c12:	8e 7f       	andi	r24, 0xFE	; 254
     c14:	8e bd       	out	0x2e, r24	; 46
     c16:	8e b5       	in	r24, 0x2e	; 46
     c18:	8d 7f       	andi	r24, 0xFD	; 253
     c1a:	8e bd       	out	0x2e, r24	; 46
     c1c:	8e b5       	in	r24, 0x2e	; 46
     c1e:	8b 7f       	andi	r24, 0xFB	; 251
     c20:	8e bd       	out	0x2e, r24	; 46
     c22:	80 e0       	ldi	r24, 0x00	; 0
     c24:	d4 c0       	rjmp	.+424    	; 0xdce <set_prescalar+0x306>
     c26:	8e b5       	in	r24, 0x2e	; 46
     c28:	81 60       	ori	r24, 0x01	; 1
     c2a:	8e bd       	out	0x2e, r24	; 46
     c2c:	8e b5       	in	r24, 0x2e	; 46
     c2e:	8d 7f       	andi	r24, 0xFD	; 253
     c30:	8e bd       	out	0x2e, r24	; 46
     c32:	8e b5       	in	r24, 0x2e	; 46
     c34:	8b 7f       	andi	r24, 0xFB	; 251
     c36:	8e bd       	out	0x2e, r24	; 46
     c38:	80 e0       	ldi	r24, 0x00	; 0
     c3a:	c9 c0       	rjmp	.+402    	; 0xdce <set_prescalar+0x306>
     c3c:	8e b5       	in	r24, 0x2e	; 46
     c3e:	8e 7f       	andi	r24, 0xFE	; 254
     c40:	8e bd       	out	0x2e, r24	; 46
     c42:	8e b5       	in	r24, 0x2e	; 46
     c44:	82 60       	ori	r24, 0x02	; 2
     c46:	8e bd       	out	0x2e, r24	; 46
     c48:	8e b5       	in	r24, 0x2e	; 46
     c4a:	8b 7f       	andi	r24, 0xFB	; 251
     c4c:	8e bd       	out	0x2e, r24	; 46
     c4e:	80 e0       	ldi	r24, 0x00	; 0
     c50:	be c0       	rjmp	.+380    	; 0xdce <set_prescalar+0x306>
     c52:	8e b5       	in	r24, 0x2e	; 46
     c54:	81 60       	ori	r24, 0x01	; 1
     c56:	8e bd       	out	0x2e, r24	; 46
     c58:	8e b5       	in	r24, 0x2e	; 46
     c5a:	82 60       	ori	r24, 0x02	; 2
     c5c:	8e bd       	out	0x2e, r24	; 46
     c5e:	8e b5       	in	r24, 0x2e	; 46
     c60:	8b 7f       	andi	r24, 0xFB	; 251
     c62:	8e bd       	out	0x2e, r24	; 46
     c64:	80 e0       	ldi	r24, 0x00	; 0
     c66:	b3 c0       	rjmp	.+358    	; 0xdce <set_prescalar+0x306>
     c68:	8e b5       	in	r24, 0x2e	; 46
     c6a:	8e 7f       	andi	r24, 0xFE	; 254
     c6c:	8e bd       	out	0x2e, r24	; 46
     c6e:	8e b5       	in	r24, 0x2e	; 46
     c70:	8d 7f       	andi	r24, 0xFD	; 253
     c72:	8e bd       	out	0x2e, r24	; 46
     c74:	8e b5       	in	r24, 0x2e	; 46
     c76:	84 60       	ori	r24, 0x04	; 4
     c78:	8e bd       	out	0x2e, r24	; 46
     c7a:	80 e0       	ldi	r24, 0x00	; 0
     c7c:	a8 c0       	rjmp	.+336    	; 0xdce <set_prescalar+0x306>
     c7e:	8e b5       	in	r24, 0x2e	; 46
     c80:	81 60       	ori	r24, 0x01	; 1
     c82:	8e bd       	out	0x2e, r24	; 46
     c84:	8e b5       	in	r24, 0x2e	; 46
     c86:	8d 7f       	andi	r24, 0xFD	; 253
     c88:	8e bd       	out	0x2e, r24	; 46
     c8a:	8e b5       	in	r24, 0x2e	; 46
     c8c:	84 60       	ori	r24, 0x04	; 4
     c8e:	8e bd       	out	0x2e, r24	; 46
     c90:	80 e0       	ldi	r24, 0x00	; 0
     c92:	9d c0       	rjmp	.+314    	; 0xdce <set_prescalar+0x306>
     c94:	c2 30       	cpi	r28, 0x02	; 2
     c96:	d1 05       	cpc	r29, r1
     c98:	a8 f0       	brcs	.+42     	; 0xcc4 <set_prescalar+0x1fc>
     c9a:	c8 30       	cpi	r28, 0x08	; 8
     c9c:	d1 05       	cpc	r29, r1
     c9e:	91 f0       	breq	.+36     	; 0xcc4 <set_prescalar+0x1fc>
     ca0:	c0 32       	cpi	r28, 0x20	; 32
     ca2:	d1 05       	cpc	r29, r1
     ca4:	79 f0       	breq	.+30     	; 0xcc4 <set_prescalar+0x1fc>
     ca6:	c0 34       	cpi	r28, 0x40	; 64
     ca8:	d1 05       	cpc	r29, r1
     caa:	61 f0       	breq	.+24     	; 0xcc4 <set_prescalar+0x1fc>
     cac:	c0 38       	cpi	r28, 0x80	; 128
     cae:	d1 05       	cpc	r29, r1
     cb0:	49 f0       	breq	.+18     	; 0xcc4 <set_prescalar+0x1fc>
     cb2:	c1 15       	cp	r28, r1
     cb4:	81 e0       	ldi	r24, 0x01	; 1
     cb6:	d8 07       	cpc	r29, r24
     cb8:	29 f0       	breq	.+10     	; 0xcc4 <set_prescalar+0x1fc>
     cba:	c1 15       	cp	r28, r1
     cbc:	84 e0       	ldi	r24, 0x04	; 4
     cbe:	d8 07       	cpc	r29, r24
     cc0:	09 f0       	breq	.+2      	; 0xcc4 <set_prescalar+0x1fc>
     cc2:	82 c0       	rjmp	.+260    	; 0xdc8 <set_prescalar+0x300>
     cc4:	c0 32       	cpi	r28, 0x20	; 32
     cc6:	d1 05       	cpc	r29, r1
     cc8:	e1 f1       	breq	.+120    	; 0xd42 <set_prescalar+0x27a>
     cca:	38 f4       	brcc	.+14     	; 0xcda <set_prescalar+0x212>
     ccc:	c1 30       	cpi	r28, 0x01	; 1
     cce:	d1 05       	cpc	r29, r1
     cd0:	11 f1       	breq	.+68     	; 0xd16 <set_prescalar+0x24e>
     cd2:	b0 f0       	brcs	.+44     	; 0xd00 <set_prescalar+0x238>
     cd4:	28 97       	sbiw	r28, 0x08	; 8
     cd6:	51 f1       	breq	.+84     	; 0xd2c <set_prescalar+0x264>
     cd8:	79 c0       	rjmp	.+242    	; 0xdcc <set_prescalar+0x304>
     cda:	c0 38       	cpi	r28, 0x80	; 128
     cdc:	d1 05       	cpc	r29, r1
     cde:	09 f4       	brne	.+2      	; 0xce2 <set_prescalar+0x21a>
     ce0:	46 c0       	rjmp	.+140    	; 0xd6e <set_prescalar+0x2a6>
     ce2:	20 f4       	brcc	.+8      	; 0xcec <set_prescalar+0x224>
     ce4:	c0 34       	cpi	r28, 0x40	; 64
     ce6:	d1 05       	cpc	r29, r1
     ce8:	b9 f1       	breq	.+110    	; 0xd58 <set_prescalar+0x290>
     cea:	70 c0       	rjmp	.+224    	; 0xdcc <set_prescalar+0x304>
     cec:	c1 15       	cp	r28, r1
     cee:	81 e0       	ldi	r24, 0x01	; 1
     cf0:	d8 07       	cpc	r29, r24
     cf2:	09 f4       	brne	.+2      	; 0xcf6 <set_prescalar+0x22e>
     cf4:	47 c0       	rjmp	.+142    	; 0xd84 <set_prescalar+0x2bc>
     cf6:	c1 15       	cp	r28, r1
     cf8:	d4 40       	sbci	r29, 0x04	; 4
     cfa:	09 f4       	brne	.+2      	; 0xcfe <set_prescalar+0x236>
     cfc:	4e c0       	rjmp	.+156    	; 0xd9a <set_prescalar+0x2d2>
     cfe:	66 c0       	rjmp	.+204    	; 0xdcc <set_prescalar+0x304>
     d00:	85 b5       	in	r24, 0x25	; 37
     d02:	8e 7f       	andi	r24, 0xFE	; 254
     d04:	85 bd       	out	0x25, r24	; 37
     d06:	85 b5       	in	r24, 0x25	; 37
     d08:	8d 7f       	andi	r24, 0xFD	; 253
     d0a:	85 bd       	out	0x25, r24	; 37
     d0c:	85 b5       	in	r24, 0x25	; 37
     d0e:	8b 7f       	andi	r24, 0xFB	; 251
     d10:	85 bd       	out	0x25, r24	; 37
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	5c c0       	rjmp	.+184    	; 0xdce <set_prescalar+0x306>
     d16:	85 b5       	in	r24, 0x25	; 37
     d18:	81 60       	ori	r24, 0x01	; 1
     d1a:	85 bd       	out	0x25, r24	; 37
     d1c:	85 b5       	in	r24, 0x25	; 37
     d1e:	8d 7f       	andi	r24, 0xFD	; 253
     d20:	85 bd       	out	0x25, r24	; 37
     d22:	85 b5       	in	r24, 0x25	; 37
     d24:	8b 7f       	andi	r24, 0xFB	; 251
     d26:	85 bd       	out	0x25, r24	; 37
     d28:	80 e0       	ldi	r24, 0x00	; 0
     d2a:	51 c0       	rjmp	.+162    	; 0xdce <set_prescalar+0x306>
     d2c:	85 b5       	in	r24, 0x25	; 37
     d2e:	8e 7f       	andi	r24, 0xFE	; 254
     d30:	85 bd       	out	0x25, r24	; 37
     d32:	85 b5       	in	r24, 0x25	; 37
     d34:	82 60       	ori	r24, 0x02	; 2
     d36:	85 bd       	out	0x25, r24	; 37
     d38:	85 b5       	in	r24, 0x25	; 37
     d3a:	8b 7f       	andi	r24, 0xFB	; 251
     d3c:	85 bd       	out	0x25, r24	; 37
     d3e:	80 e0       	ldi	r24, 0x00	; 0
     d40:	46 c0       	rjmp	.+140    	; 0xdce <set_prescalar+0x306>
     d42:	85 b5       	in	r24, 0x25	; 37
     d44:	81 60       	ori	r24, 0x01	; 1
     d46:	85 bd       	out	0x25, r24	; 37
     d48:	85 b5       	in	r24, 0x25	; 37
     d4a:	82 60       	ori	r24, 0x02	; 2
     d4c:	85 bd       	out	0x25, r24	; 37
     d4e:	85 b5       	in	r24, 0x25	; 37
     d50:	8b 7f       	andi	r24, 0xFB	; 251
     d52:	85 bd       	out	0x25, r24	; 37
     d54:	80 e0       	ldi	r24, 0x00	; 0
     d56:	3b c0       	rjmp	.+118    	; 0xdce <set_prescalar+0x306>
     d58:	85 b5       	in	r24, 0x25	; 37
     d5a:	8e 7f       	andi	r24, 0xFE	; 254
     d5c:	85 bd       	out	0x25, r24	; 37
     d5e:	85 b5       	in	r24, 0x25	; 37
     d60:	8d 7f       	andi	r24, 0xFD	; 253
     d62:	85 bd       	out	0x25, r24	; 37
     d64:	85 b5       	in	r24, 0x25	; 37
     d66:	84 60       	ori	r24, 0x04	; 4
     d68:	85 bd       	out	0x25, r24	; 37
     d6a:	80 e0       	ldi	r24, 0x00	; 0
     d6c:	30 c0       	rjmp	.+96     	; 0xdce <set_prescalar+0x306>
     d6e:	85 b5       	in	r24, 0x25	; 37
     d70:	81 60       	ori	r24, 0x01	; 1
     d72:	85 bd       	out	0x25, r24	; 37
     d74:	85 b5       	in	r24, 0x25	; 37
     d76:	8d 7f       	andi	r24, 0xFD	; 253
     d78:	85 bd       	out	0x25, r24	; 37
     d7a:	85 b5       	in	r24, 0x25	; 37
     d7c:	84 60       	ori	r24, 0x04	; 4
     d7e:	85 bd       	out	0x25, r24	; 37
     d80:	80 e0       	ldi	r24, 0x00	; 0
     d82:	25 c0       	rjmp	.+74     	; 0xdce <set_prescalar+0x306>
     d84:	85 b5       	in	r24, 0x25	; 37
     d86:	8e 7f       	andi	r24, 0xFE	; 254
     d88:	85 bd       	out	0x25, r24	; 37
     d8a:	85 b5       	in	r24, 0x25	; 37
     d8c:	82 60       	ori	r24, 0x02	; 2
     d8e:	85 bd       	out	0x25, r24	; 37
     d90:	85 b5       	in	r24, 0x25	; 37
     d92:	84 60       	ori	r24, 0x04	; 4
     d94:	85 bd       	out	0x25, r24	; 37
     d96:	80 e0       	ldi	r24, 0x00	; 0
     d98:	1a c0       	rjmp	.+52     	; 0xdce <set_prescalar+0x306>
     d9a:	85 b5       	in	r24, 0x25	; 37
     d9c:	81 60       	ori	r24, 0x01	; 1
     d9e:	85 bd       	out	0x25, r24	; 37
     da0:	85 b5       	in	r24, 0x25	; 37
     da2:	82 60       	ori	r24, 0x02	; 2
     da4:	85 bd       	out	0x25, r24	; 37
     da6:	85 b5       	in	r24, 0x25	; 37
     da8:	84 60       	ori	r24, 0x04	; 4
     daa:	85 bd       	out	0x25, r24	; 37
     dac:	80 e0       	ldi	r24, 0x00	; 0
     dae:	0f c0       	rjmp	.+30     	; 0xdce <set_prescalar+0x306>
     db0:	81 e0       	ldi	r24, 0x01	; 1
     db2:	0d c0       	rjmp	.+26     	; 0xdce <set_prescalar+0x306>
     db4:	80 e0       	ldi	r24, 0x00	; 0
     db6:	0b c0       	rjmp	.+22     	; 0xdce <set_prescalar+0x306>
     db8:	82 e0       	ldi	r24, 0x02	; 2
     dba:	09 c0       	rjmp	.+18     	; 0xdce <set_prescalar+0x306>
     dbc:	80 e0       	ldi	r24, 0x00	; 0
     dbe:	07 c0       	rjmp	.+14     	; 0xdce <set_prescalar+0x306>
     dc0:	82 e0       	ldi	r24, 0x02	; 2
     dc2:	05 c0       	rjmp	.+10     	; 0xdce <set_prescalar+0x306>
     dc4:	80 e0       	ldi	r24, 0x00	; 0
     dc6:	03 c0       	rjmp	.+6      	; 0xdce <set_prescalar+0x306>
     dc8:	82 e0       	ldi	r24, 0x02	; 2
     dca:	01 c0       	rjmp	.+2      	; 0xdce <set_prescalar+0x306>
     dcc:	80 e0       	ldi	r24, 0x00	; 0
     dce:	df 91       	pop	r29
     dd0:	cf 91       	pop	r28
     dd2:	1f 91       	pop	r17
     dd4:	08 95       	ret

00000dd6 <Timer_normal_init>:
     dd6:	0f 93       	push	r16
     dd8:	1f 93       	push	r17
     dda:	cf 93       	push	r28
     ddc:	c8 2f       	mov	r28, r24
     dde:	8b 01       	movw	r16, r22
     de0:	0e 94 5e 05 	call	0xabc	; 0xabc <isValidTimer>
     de4:	88 23       	and	r24, r24
     de6:	81 f1       	breq	.+96     	; 0xe48 <Timer_normal_init+0x72>
     de8:	cc 23       	and	r28, r28
     dea:	11 f0       	breq	.+4      	; 0xdf0 <Timer_normal_init+0x1a>
     dec:	c2 30       	cpi	r28, 0x02	; 2
     dee:	21 f4       	brne	.+8      	; 0xdf8 <Timer_normal_init+0x22>
     df0:	0f 3f       	cpi	r16, 0xFF	; 255
     df2:	11 05       	cpc	r17, r1
     df4:	09 f0       	breq	.+2      	; 0xdf8 <Timer_normal_init+0x22>
     df6:	50 f5       	brcc	.+84     	; 0xe4c <Timer_normal_init+0x76>
     df8:	c1 30       	cpi	r28, 0x01	; 1
     dfa:	69 f0       	breq	.+26     	; 0xe16 <Timer_normal_init+0x40>
     dfc:	18 f0       	brcs	.+6      	; 0xe04 <Timer_normal_init+0x2e>
     dfe:	c2 30       	cpi	r28, 0x02	; 2
     e00:	d1 f0       	breq	.+52     	; 0xe36 <Timer_normal_init+0x60>
     e02:	26 c0       	rjmp	.+76     	; 0xe50 <Timer_normal_init+0x7a>
     e04:	83 b7       	in	r24, 0x33	; 51
     e06:	87 7f       	andi	r24, 0xF7	; 247
     e08:	83 bf       	out	0x33, r24	; 51
     e0a:	83 b7       	in	r24, 0x33	; 51
     e0c:	8f 7b       	andi	r24, 0xBF	; 191
     e0e:	83 bf       	out	0x33, r24	; 51
     e10:	02 bf       	out	0x32, r16	; 50
     e12:	80 e0       	ldi	r24, 0x00	; 0
     e14:	1e c0       	rjmp	.+60     	; 0xe52 <Timer_normal_init+0x7c>
     e16:	8f b5       	in	r24, 0x2f	; 47
     e18:	8e 7f       	andi	r24, 0xFE	; 254
     e1a:	8f bd       	out	0x2f, r24	; 47
     e1c:	8f b5       	in	r24, 0x2f	; 47
     e1e:	8d 7f       	andi	r24, 0xFD	; 253
     e20:	8f bd       	out	0x2f, r24	; 47
     e22:	8e b5       	in	r24, 0x2e	; 46
     e24:	87 7f       	andi	r24, 0xF7	; 247
     e26:	8e bd       	out	0x2e, r24	; 46
     e28:	8e b5       	in	r24, 0x2e	; 46
     e2a:	8f 7e       	andi	r24, 0xEF	; 239
     e2c:	8e bd       	out	0x2e, r24	; 46
     e2e:	1d bd       	out	0x2d, r17	; 45
     e30:	0c bd       	out	0x2c, r16	; 44
     e32:	80 e0       	ldi	r24, 0x00	; 0
     e34:	0e c0       	rjmp	.+28     	; 0xe52 <Timer_normal_init+0x7c>
     e36:	85 b5       	in	r24, 0x25	; 37
     e38:	87 7f       	andi	r24, 0xF7	; 247
     e3a:	85 bd       	out	0x25, r24	; 37
     e3c:	85 b5       	in	r24, 0x25	; 37
     e3e:	8f 7b       	andi	r24, 0xBF	; 191
     e40:	85 bd       	out	0x25, r24	; 37
     e42:	04 bd       	out	0x24, r16	; 36
     e44:	80 e0       	ldi	r24, 0x00	; 0
     e46:	05 c0       	rjmp	.+10     	; 0xe52 <Timer_normal_init+0x7c>
     e48:	81 e0       	ldi	r24, 0x01	; 1
     e4a:	03 c0       	rjmp	.+6      	; 0xe52 <Timer_normal_init+0x7c>
     e4c:	83 e0       	ldi	r24, 0x03	; 3
     e4e:	01 c0       	rjmp	.+2      	; 0xe52 <Timer_normal_init+0x7c>
     e50:	80 e0       	ldi	r24, 0x00	; 0
     e52:	cf 91       	pop	r28
     e54:	1f 91       	pop	r17
     e56:	0f 91       	pop	r16
     e58:	08 95       	ret

00000e5a <Timer_start>:
     e5a:	0f 93       	push	r16
     e5c:	1f 93       	push	r17
     e5e:	cf 93       	push	r28
     e60:	c8 2f       	mov	r28, r24
     e62:	8b 01       	movw	r16, r22
     e64:	0e 94 5e 05 	call	0xabc	; 0xabc <isValidTimer>
     e68:	88 23       	and	r24, r24
     e6a:	31 f0       	breq	.+12     	; 0xe78 <Timer_start+0x1e>
     e6c:	b8 01       	movw	r22, r16
     e6e:	8c 2f       	mov	r24, r28
     e70:	0e 94 64 05 	call	0xac8	; 0xac8 <set_prescalar>
     e74:	80 e0       	ldi	r24, 0x00	; 0
     e76:	01 c0       	rjmp	.+2      	; 0xe7a <Timer_start+0x20>
     e78:	81 e0       	ldi	r24, 0x01	; 1
     e7a:	cf 91       	pop	r28
     e7c:	1f 91       	pop	r17
     e7e:	0f 91       	pop	r16
     e80:	08 95       	ret

00000e82 <PWM_init>:
     e82:	cf 92       	push	r12
     e84:	df 92       	push	r13
     e86:	ef 92       	push	r14
     e88:	ff 92       	push	r15
     e8a:	84 30       	cpi	r24, 0x04	; 4
     e8c:	08 f0       	brcs	.+2      	; 0xe90 <PWM_init+0xe>
     e8e:	ad c0       	rjmp	.+346    	; 0xfea <PWM_init+0x168>
     e90:	9f ef       	ldi	r25, 0xFF	; 255
     e92:	92 0f       	add	r25, r18
     e94:	92 30       	cpi	r25, 0x02	; 2
     e96:	08 f0       	brcs	.+2      	; 0xe9a <PWM_init+0x18>
     e98:	aa c0       	rjmp	.+340    	; 0xfee <PWM_init+0x16c>
     e9a:	6a 01       	movw	r12, r20
     e9c:	7b 01       	movw	r14, r22
     e9e:	83 30       	cpi	r24, 0x03	; 3
     ea0:	18 f4       	brcc	.+6      	; 0xea8 <PWM_init+0x26>
     ea2:	81 30       	cpi	r24, 0x01	; 1
     ea4:	28 f0       	brcs	.+10     	; 0xeb0 <PWM_init+0x2e>
     ea6:	29 c0       	rjmp	.+82     	; 0xefa <PWM_init+0x78>
     ea8:	83 30       	cpi	r24, 0x03	; 3
     eaa:	09 f4       	brne	.+2      	; 0xeae <PWM_init+0x2c>
     eac:	79 c0       	rjmp	.+242    	; 0xfa0 <PWM_init+0x11e>
     eae:	a1 c0       	rjmp	.+322    	; 0xff2 <PWM_init+0x170>
     eb0:	21 30       	cpi	r18, 0x01	; 1
     eb2:	19 f0       	breq	.+6      	; 0xeba <PWM_init+0x38>
     eb4:	22 30       	cpi	r18, 0x02	; 2
     eb6:	41 f0       	breq	.+16     	; 0xec8 <PWM_init+0x46>
     eb8:	0d c0       	rjmp	.+26     	; 0xed4 <PWM_init+0x52>
     eba:	83 b7       	in	r24, 0x33	; 51
     ebc:	80 64       	ori	r24, 0x40	; 64
     ebe:	83 bf       	out	0x33, r24	; 51
     ec0:	83 b7       	in	r24, 0x33	; 51
     ec2:	88 60       	ori	r24, 0x08	; 8
     ec4:	83 bf       	out	0x33, r24	; 51
     ec6:	06 c0       	rjmp	.+12     	; 0xed4 <PWM_init+0x52>
     ec8:	83 b7       	in	r24, 0x33	; 51
     eca:	80 64       	ori	r24, 0x40	; 64
     ecc:	83 bf       	out	0x33, r24	; 51
     ece:	83 b7       	in	r24, 0x33	; 51
     ed0:	87 7f       	andi	r24, 0xF7	; 247
     ed2:	83 bf       	out	0x33, r24	; 51
     ed4:	83 b7       	in	r24, 0x33	; 51
     ed6:	8f 7e       	andi	r24, 0xEF	; 239
     ed8:	83 bf       	out	0x33, r24	; 51
     eda:	83 b7       	in	r24, 0x33	; 51
     edc:	80 62       	ori	r24, 0x20	; 32
     ede:	83 bf       	out	0x33, r24	; 51
     ee0:	20 e0       	ldi	r18, 0x00	; 0
     ee2:	30 e0       	ldi	r19, 0x00	; 0
     ee4:	4f e7       	ldi	r20, 0x7F	; 127
     ee6:	53 e4       	ldi	r21, 0x43	; 67
     ee8:	c7 01       	movw	r24, r14
     eea:	b6 01       	movw	r22, r12
     eec:	0e 94 be 11 	call	0x237c	; 0x237c <__mulsf3>
     ef0:	0e 94 01 11 	call	0x2202	; 0x2202 <__fixunssfsi>
     ef4:	6c bf       	out	0x3c, r22	; 60
     ef6:	80 e0       	ldi	r24, 0x00	; 0
     ef8:	7f c0       	rjmp	.+254    	; 0xff8 <PWM_init+0x176>
     efa:	21 30       	cpi	r18, 0x01	; 1
     efc:	19 f0       	breq	.+6      	; 0xf04 <PWM_init+0x82>
     efe:	22 30       	cpi	r18, 0x02	; 2
     f00:	91 f0       	breq	.+36     	; 0xf26 <PWM_init+0xa4>
     f02:	21 c0       	rjmp	.+66     	; 0xf46 <PWM_init+0xc4>
     f04:	9f b5       	in	r25, 0x2f	; 47
     f06:	9e 7f       	andi	r25, 0xFE	; 254
     f08:	9f bd       	out	0x2f, r25	; 47
     f0a:	9f b5       	in	r25, 0x2f	; 47
     f0c:	92 60       	ori	r25, 0x02	; 2
     f0e:	9f bd       	out	0x2f, r25	; 47
     f10:	9e b5       	in	r25, 0x2e	; 46
     f12:	98 60       	ori	r25, 0x08	; 8
     f14:	9e bd       	out	0x2e, r25	; 46
     f16:	9e b5       	in	r25, 0x2e	; 46
     f18:	90 61       	ori	r25, 0x10	; 16
     f1a:	9e bd       	out	0x2e, r25	; 46
     f1c:	20 e2       	ldi	r18, 0x20	; 32
     f1e:	3e e4       	ldi	r19, 0x4E	; 78
     f20:	37 bd       	out	0x27, r19	; 39
     f22:	26 bd       	out	0x26, r18	; 38
     f24:	10 c0       	rjmp	.+32     	; 0xf46 <PWM_init+0xc4>
     f26:	9f b5       	in	r25, 0x2f	; 47
     f28:	9e 7f       	andi	r25, 0xFE	; 254
     f2a:	9f bd       	out	0x2f, r25	; 47
     f2c:	9f b5       	in	r25, 0x2f	; 47
     f2e:	92 60       	ori	r25, 0x02	; 2
     f30:	9f bd       	out	0x2f, r25	; 47
     f32:	9e b5       	in	r25, 0x2e	; 46
     f34:	97 7f       	andi	r25, 0xF7	; 247
     f36:	9e bd       	out	0x2e, r25	; 46
     f38:	9e b5       	in	r25, 0x2e	; 46
     f3a:	90 61       	ori	r25, 0x10	; 16
     f3c:	9e bd       	out	0x2e, r25	; 46
     f3e:	20 e2       	ldi	r18, 0x20	; 32
     f40:	3e e4       	ldi	r19, 0x4E	; 78
     f42:	37 bd       	out	0x27, r19	; 39
     f44:	26 bd       	out	0x26, r18	; 38
     f46:	81 30       	cpi	r24, 0x01	; 1
     f48:	19 f0       	breq	.+6      	; 0xf50 <PWM_init+0xce>
     f4a:	82 30       	cpi	r24, 0x02	; 2
     f4c:	a9 f0       	breq	.+42     	; 0xf78 <PWM_init+0xf6>
     f4e:	53 c0       	rjmp	.+166    	; 0xff6 <PWM_init+0x174>
     f50:	8f b5       	in	r24, 0x2f	; 47
     f52:	8f 7b       	andi	r24, 0xBF	; 191
     f54:	8f bd       	out	0x2f, r24	; 47
     f56:	8f b5       	in	r24, 0x2f	; 47
     f58:	80 68       	ori	r24, 0x80	; 128
     f5a:	8f bd       	out	0x2f, r24	; 47
     f5c:	20 e0       	ldi	r18, 0x00	; 0
     f5e:	30 e4       	ldi	r19, 0x40	; 64
     f60:	4c e9       	ldi	r20, 0x9C	; 156
     f62:	56 e4       	ldi	r21, 0x46	; 70
     f64:	c7 01       	movw	r24, r14
     f66:	b6 01       	movw	r22, r12
     f68:	0e 94 be 11 	call	0x237c	; 0x237c <__mulsf3>
     f6c:	0e 94 01 11 	call	0x2202	; 0x2202 <__fixunssfsi>
     f70:	7b bd       	out	0x2b, r23	; 43
     f72:	6a bd       	out	0x2a, r22	; 42
     f74:	80 e0       	ldi	r24, 0x00	; 0
     f76:	40 c0       	rjmp	.+128    	; 0xff8 <PWM_init+0x176>
     f78:	8f b5       	in	r24, 0x2f	; 47
     f7a:	8f 7e       	andi	r24, 0xEF	; 239
     f7c:	8f bd       	out	0x2f, r24	; 47
     f7e:	8f b5       	in	r24, 0x2f	; 47
     f80:	80 62       	ori	r24, 0x20	; 32
     f82:	8f bd       	out	0x2f, r24	; 47
     f84:	20 e0       	ldi	r18, 0x00	; 0
     f86:	30 e4       	ldi	r19, 0x40	; 64
     f88:	4c e9       	ldi	r20, 0x9C	; 156
     f8a:	56 e4       	ldi	r21, 0x46	; 70
     f8c:	c7 01       	movw	r24, r14
     f8e:	b6 01       	movw	r22, r12
     f90:	0e 94 be 11 	call	0x237c	; 0x237c <__mulsf3>
     f94:	0e 94 01 11 	call	0x2202	; 0x2202 <__fixunssfsi>
     f98:	79 bd       	out	0x29, r23	; 41
     f9a:	68 bd       	out	0x28, r22	; 40
     f9c:	80 e0       	ldi	r24, 0x00	; 0
     f9e:	2c c0       	rjmp	.+88     	; 0xff8 <PWM_init+0x176>
     fa0:	21 30       	cpi	r18, 0x01	; 1
     fa2:	19 f0       	breq	.+6      	; 0xfaa <PWM_init+0x128>
     fa4:	22 30       	cpi	r18, 0x02	; 2
     fa6:	41 f0       	breq	.+16     	; 0xfb8 <PWM_init+0x136>
     fa8:	0d c0       	rjmp	.+26     	; 0xfc4 <PWM_init+0x142>
     faa:	85 b5       	in	r24, 0x25	; 37
     fac:	80 64       	ori	r24, 0x40	; 64
     fae:	85 bd       	out	0x25, r24	; 37
     fb0:	85 b5       	in	r24, 0x25	; 37
     fb2:	88 60       	ori	r24, 0x08	; 8
     fb4:	85 bd       	out	0x25, r24	; 37
     fb6:	06 c0       	rjmp	.+12     	; 0xfc4 <PWM_init+0x142>
     fb8:	85 b5       	in	r24, 0x25	; 37
     fba:	80 64       	ori	r24, 0x40	; 64
     fbc:	85 bd       	out	0x25, r24	; 37
     fbe:	85 b5       	in	r24, 0x25	; 37
     fc0:	87 7f       	andi	r24, 0xF7	; 247
     fc2:	85 bd       	out	0x25, r24	; 37
     fc4:	85 b5       	in	r24, 0x25	; 37
     fc6:	8f 7e       	andi	r24, 0xEF	; 239
     fc8:	85 bd       	out	0x25, r24	; 37
     fca:	85 b5       	in	r24, 0x25	; 37
     fcc:	80 62       	ori	r24, 0x20	; 32
     fce:	85 bd       	out	0x25, r24	; 37
     fd0:	20 e0       	ldi	r18, 0x00	; 0
     fd2:	30 e0       	ldi	r19, 0x00	; 0
     fd4:	4f e7       	ldi	r20, 0x7F	; 127
     fd6:	53 e4       	ldi	r21, 0x43	; 67
     fd8:	c7 01       	movw	r24, r14
     fda:	b6 01       	movw	r22, r12
     fdc:	0e 94 be 11 	call	0x237c	; 0x237c <__mulsf3>
     fe0:	0e 94 01 11 	call	0x2202	; 0x2202 <__fixunssfsi>
     fe4:	63 bd       	out	0x23, r22	; 35
     fe6:	80 e0       	ldi	r24, 0x00	; 0
     fe8:	07 c0       	rjmp	.+14     	; 0xff8 <PWM_init+0x176>
     fea:	87 e0       	ldi	r24, 0x07	; 7
     fec:	05 c0       	rjmp	.+10     	; 0xff8 <PWM_init+0x176>
     fee:	86 e0       	ldi	r24, 0x06	; 6
     ff0:	03 c0       	rjmp	.+6      	; 0xff8 <PWM_init+0x176>
     ff2:	80 e0       	ldi	r24, 0x00	; 0
     ff4:	01 c0       	rjmp	.+2      	; 0xff8 <PWM_init+0x176>
     ff6:	80 e0       	ldi	r24, 0x00	; 0
     ff8:	ff 90       	pop	r15
     ffa:	ef 90       	pop	r14
     ffc:	df 90       	pop	r13
     ffe:	cf 90       	pop	r12
    1000:	08 95       	ret

00001002 <PWM_set_DC>:

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
    1002:	28 2f       	mov	r18, r24
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    1004:	84 30       	cpi	r24, 0x04	; 4
    1006:	c0 f5       	brcc	.+112    	; 0x1078 <PWM_set_DC+0x76>
    1008:	cb 01       	movw	r24, r22
    100a:	ba 01       	movw	r22, r20
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    100c:	21 30       	cpi	r18, 0x01	; 1
    100e:	89 f0       	breq	.+34     	; 0x1032 <PWM_set_DC+0x30>
    1010:	28 f0       	brcs	.+10     	; 0x101c <PWM_set_DC+0x1a>
    1012:	22 30       	cpi	r18, 0x02	; 2
    1014:	d1 f0       	breq	.+52     	; 0x104a <PWM_set_DC+0x48>
    1016:	23 30       	cpi	r18, 0x03	; 3
    1018:	21 f1       	breq	.+72     	; 0x1062 <PWM_set_DC+0x60>
    101a:	30 c0       	rjmp	.+96     	; 0x107c <PWM_set_DC+0x7a>
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
    101c:	20 e0       	ldi	r18, 0x00	; 0
    101e:	30 e0       	ldi	r19, 0x00	; 0
    1020:	4f e7       	ldi	r20, 0x7F	; 127
    1022:	53 e4       	ldi	r21, 0x43	; 67
    1024:	0e 94 be 11 	call	0x237c	; 0x237c <__mulsf3>
    1028:	0e 94 01 11 	call	0x2202	; 0x2202 <__fixunssfsi>
    102c:	6c bf       	out	0x3c, r22	; 60
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    102e:	80 e0       	ldi	r24, 0x00	; 0
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
        break;
    1030:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    1032:	20 e0       	ldi	r18, 0x00	; 0
    1034:	30 e4       	ldi	r19, 0x40	; 64
    1036:	4c e9       	ldi	r20, 0x9C	; 156
    1038:	56 e4       	ldi	r21, 0x46	; 70
    103a:	0e 94 be 11 	call	0x237c	; 0x237c <__mulsf3>
    103e:	0e 94 01 11 	call	0x2202	; 0x2202 <__fixunssfsi>
    1042:	7b bd       	out	0x2b, r23	; 43
    1044:	6a bd       	out	0x2a, r22	; 42
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    1046:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1A = (u16)(dutyCycle * 65535);
#endif
        break;
    1048:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    104a:	20 e0       	ldi	r18, 0x00	; 0
    104c:	30 e4       	ldi	r19, 0x40	; 64
    104e:	4c e9       	ldi	r20, 0x9C	; 156
    1050:	56 e4       	ldi	r21, 0x46	; 70
    1052:	0e 94 be 11 	call	0x237c	; 0x237c <__mulsf3>
    1056:	0e 94 01 11 	call	0x2202	; 0x2202 <__fixunssfsi>
    105a:	79 bd       	out	0x29, r23	; 41
    105c:	68 bd       	out	0x28, r22	; 40
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    105e:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
    1060:	08 95       	ret
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
    1062:	20 e0       	ldi	r18, 0x00	; 0
    1064:	30 e0       	ldi	r19, 0x00	; 0
    1066:	4f e7       	ldi	r20, 0x7F	; 127
    1068:	53 e4       	ldi	r21, 0x43	; 67
    106a:	0e 94 be 11 	call	0x237c	; 0x237c <__mulsf3>
    106e:	0e 94 01 11 	call	0x2202	; 0x2202 <__fixunssfsi>
    1072:	63 bd       	out	0x23, r22	; 35
        break;
    }
  return TIMER_OK;
    1074:	80 e0       	ldi	r24, 0x00	; 0
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    1076:	08 95       	ret
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    1078:	87 e0       	ldi	r24, 0x07	; 7
    107a:	08 95       	ret
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    107c:	80 e0       	ldi	r24, 0x00	; 0
  }
    107e:	08 95       	ret

00001080 <UART_init>:
  }

// Receive a Char using UART
void UART_receiveChar(s8* x) {
  while (!read_bit(UCSRA, RXC)); // Wait for the data to be received.
  *x = UDR;
    1080:	61 15       	cp	r22, r1
    1082:	26 e9       	ldi	r18, 0x96	; 150
    1084:	72 07       	cpc	r23, r18
    1086:	81 05       	cpc	r24, r1
    1088:	91 05       	cpc	r25, r1
    108a:	09 f4       	brne	.+2      	; 0x108e <UART_init+0xe>
    108c:	72 c0       	rjmp	.+228    	; 0x1172 <UART_init+0xf2>
    108e:	58 f5       	brcc	.+86     	; 0x10e6 <UART_init+0x66>
    1090:	60 38       	cpi	r22, 0x80	; 128
    1092:	25 e2       	ldi	r18, 0x25	; 37
    1094:	72 07       	cpc	r23, r18
    1096:	81 05       	cpc	r24, r1
    1098:	91 05       	cpc	r25, r1
    109a:	09 f4       	brne	.+2      	; 0x109e <UART_init+0x1e>
    109c:	5e c0       	rjmp	.+188    	; 0x115a <UART_init+0xda>
    109e:	70 f4       	brcc	.+28     	; 0x10bc <UART_init+0x3c>
    10a0:	60 36       	cpi	r22, 0x60	; 96
    10a2:	29 e0       	ldi	r18, 0x09	; 9
    10a4:	72 07       	cpc	r23, r18
    10a6:	81 05       	cpc	r24, r1
    10a8:	91 05       	cpc	r25, r1
    10aa:	09 f4       	brne	.+2      	; 0x10ae <UART_init+0x2e>
    10ac:	4e c0       	rjmp	.+156    	; 0x114a <UART_init+0xca>
    10ae:	60 3c       	cpi	r22, 0xC0	; 192
    10b0:	72 41       	sbci	r23, 0x12	; 18
    10b2:	81 05       	cpc	r24, r1
    10b4:	91 05       	cpc	r25, r1
    10b6:	09 f4       	brne	.+2      	; 0x10ba <UART_init+0x3a>
    10b8:	4d c0       	rjmp	.+154    	; 0x1154 <UART_init+0xd4>
    10ba:	82 c0       	rjmp	.+260    	; 0x11c0 <UART_init+0x140>
    10bc:	61 15       	cp	r22, r1
    10be:	2b e4       	ldi	r18, 0x4B	; 75
    10c0:	72 07       	cpc	r23, r18
    10c2:	81 05       	cpc	r24, r1
    10c4:	91 05       	cpc	r25, r1
    10c6:	09 f4       	brne	.+2      	; 0x10ca <UART_init+0x4a>
    10c8:	4e c0       	rjmp	.+156    	; 0x1166 <UART_init+0xe6>
    10ca:	60 38       	cpi	r22, 0x80	; 128
    10cc:	20 e7       	ldi	r18, 0x70	; 112
    10ce:	72 07       	cpc	r23, r18
    10d0:	81 05       	cpc	r24, r1
    10d2:	91 05       	cpc	r25, r1
    10d4:	09 f4       	brne	.+2      	; 0x10d8 <UART_init+0x58>
    10d6:	4a c0       	rjmp	.+148    	; 0x116c <UART_init+0xec>
    10d8:	60 34       	cpi	r22, 0x40	; 64
    10da:	78 43       	sbci	r23, 0x38	; 56
    10dc:	81 05       	cpc	r24, r1
    10de:	91 05       	cpc	r25, r1
    10e0:	09 f0       	breq	.+2      	; 0x10e4 <UART_init+0x64>
    10e2:	6e c0       	rjmp	.+220    	; 0x11c0 <UART_init+0x140>
    10e4:	3d c0       	rjmp	.+122    	; 0x1160 <UART_init+0xe0>
    10e6:	61 15       	cp	r22, r1
    10e8:	24 e8       	ldi	r18, 0x84	; 132
    10ea:	72 07       	cpc	r23, r18
    10ec:	23 e0       	ldi	r18, 0x03	; 3
    10ee:	82 07       	cpc	r24, r18
    10f0:	91 05       	cpc	r25, r1
    10f2:	09 f4       	brne	.+2      	; 0x10f6 <UART_init+0x76>
    10f4:	4a c0       	rjmp	.+148    	; 0x118a <UART_init+0x10a>
    10f6:	a8 f4       	brcc	.+42     	; 0x1122 <UART_init+0xa2>
    10f8:	61 15       	cp	r22, r1
    10fa:	2c e2       	ldi	r18, 0x2C	; 44
    10fc:	72 07       	cpc	r23, r18
    10fe:	21 e0       	ldi	r18, 0x01	; 1
    1100:	82 07       	cpc	r24, r18
    1102:	91 05       	cpc	r25, r1
    1104:	e1 f1       	breq	.+120    	; 0x117e <UART_init+0xfe>
    1106:	61 15       	cp	r22, r1
    1108:	22 ec       	ldi	r18, 0xC2	; 194
    110a:	72 07       	cpc	r23, r18
    110c:	21 e0       	ldi	r18, 0x01	; 1
    110e:	82 07       	cpc	r24, r18
    1110:	91 05       	cpc	r25, r1
    1112:	c1 f1       	breq	.+112    	; 0x1184 <UART_init+0x104>
    1114:	61 15       	cp	r22, r1
    1116:	71 4e       	sbci	r23, 0xE1	; 225
    1118:	81 05       	cpc	r24, r1
    111a:	91 05       	cpc	r25, r1
    111c:	09 f0       	breq	.+2      	; 0x1120 <UART_init+0xa0>
    111e:	50 c0       	rjmp	.+160    	; 0x11c0 <UART_init+0x140>
    1120:	2b c0       	rjmp	.+86     	; 0x1178 <UART_init+0xf8>
    1122:	60 32       	cpi	r22, 0x20	; 32
    1124:	21 ea       	ldi	r18, 0xA1	; 161
    1126:	72 07       	cpc	r23, r18
    1128:	27 e0       	ldi	r18, 0x07	; 7
    112a:	82 07       	cpc	r24, r18
    112c:	91 05       	cpc	r25, r1
    112e:	99 f1       	breq	.+102    	; 0x1196 <UART_init+0x116>
    1130:	60 34       	cpi	r22, 0x40	; 64
    1132:	22 e4       	ldi	r18, 0x42	; 66
    1134:	72 07       	cpc	r23, r18
    1136:	2f e0       	ldi	r18, 0x0F	; 15
    1138:	82 07       	cpc	r24, r18
    113a:	91 05       	cpc	r25, r1
    113c:	79 f1       	breq	.+94     	; 0x119c <UART_init+0x11c>
    113e:	60 39       	cpi	r22, 0x90	; 144
    1140:	70 4d       	sbci	r23, 0xD0	; 208
    1142:	83 40       	sbci	r24, 0x03	; 3
    1144:	91 05       	cpc	r25, r1
    1146:	e1 f5       	brne	.+120    	; 0x11c0 <UART_init+0x140>
    1148:	23 c0       	rjmp	.+70     	; 0x1190 <UART_init+0x110>
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	80 bd       	out	0x20, r24	; 32
    114e:	80 ea       	ldi	r24, 0xA0	; 160
    1150:	89 b9       	out	0x09, r24	; 9
    1152:	25 c0       	rjmp	.+74     	; 0x119e <UART_init+0x11e>
    1154:	8f ec       	ldi	r24, 0xCF	; 207
    1156:	89 b9       	out	0x09, r24	; 9
    1158:	22 c0       	rjmp	.+68     	; 0x119e <UART_init+0x11e>
    115a:	87 e6       	ldi	r24, 0x67	; 103
    115c:	89 b9       	out	0x09, r24	; 9
    115e:	1f c0       	rjmp	.+62     	; 0x119e <UART_init+0x11e>
    1160:	84 e4       	ldi	r24, 0x44	; 68
    1162:	89 b9       	out	0x09, r24	; 9
    1164:	1c c0       	rjmp	.+56     	; 0x119e <UART_init+0x11e>
    1166:	83 e3       	ldi	r24, 0x33	; 51
    1168:	89 b9       	out	0x09, r24	; 9
    116a:	19 c0       	rjmp	.+50     	; 0x119e <UART_init+0x11e>
    116c:	82 e2       	ldi	r24, 0x22	; 34
    116e:	89 b9       	out	0x09, r24	; 9
    1170:	16 c0       	rjmp	.+44     	; 0x119e <UART_init+0x11e>
    1172:	89 e1       	ldi	r24, 0x19	; 25
    1174:	89 b9       	out	0x09, r24	; 9
    1176:	13 c0       	rjmp	.+38     	; 0x119e <UART_init+0x11e>
    1178:	80 e1       	ldi	r24, 0x10	; 16
    117a:	89 b9       	out	0x09, r24	; 9
    117c:	10 c0       	rjmp	.+32     	; 0x119e <UART_init+0x11e>
    117e:	8c e0       	ldi	r24, 0x0C	; 12
    1180:	89 b9       	out	0x09, r24	; 9
    1182:	0d c0       	rjmp	.+26     	; 0x119e <UART_init+0x11e>
    1184:	88 e0       	ldi	r24, 0x08	; 8
    1186:	89 b9       	out	0x09, r24	; 9
    1188:	0a c0       	rjmp	.+20     	; 0x119e <UART_init+0x11e>
    118a:	83 e0       	ldi	r24, 0x03	; 3
    118c:	89 b9       	out	0x09, r24	; 9
    118e:	07 c0       	rjmp	.+14     	; 0x119e <UART_init+0x11e>
    1190:	83 e0       	ldi	r24, 0x03	; 3
    1192:	89 b9       	out	0x09, r24	; 9
    1194:	04 c0       	rjmp	.+8      	; 0x119e <UART_init+0x11e>
    1196:	81 e0       	ldi	r24, 0x01	; 1
    1198:	89 b9       	out	0x09, r24	; 9
    119a:	01 c0       	rjmp	.+2      	; 0x119e <UART_init+0x11e>
    119c:	19 b8       	out	0x09, r1	; 9
    119e:	8a b1       	in	r24, 0x0a	; 10
    11a0:	88 60       	ori	r24, 0x08	; 8
    11a2:	8a b9       	out	0x0a, r24	; 10
    11a4:	8a b1       	in	r24, 0x0a	; 10
    11a6:	80 61       	ori	r24, 0x10	; 16
    11a8:	8a b9       	out	0x0a, r24	; 10
    11aa:	80 b5       	in	r24, 0x20	; 32
    11ac:	80 68       	ori	r24, 0x80	; 128
    11ae:	80 bd       	out	0x20, r24	; 32
    11b0:	80 b5       	in	r24, 0x20	; 32
    11b2:	82 60       	ori	r24, 0x02	; 2
    11b4:	80 bd       	out	0x20, r24	; 32
    11b6:	80 b5       	in	r24, 0x20	; 32
    11b8:	84 60       	ori	r24, 0x04	; 4
    11ba:	80 bd       	out	0x20, r24	; 32
    11bc:	80 e0       	ldi	r24, 0x00	; 0
    11be:	08 95       	ret
    11c0:	81 e0       	ldi	r24, 0x01	; 1
    11c2:	08 95       	ret

000011c4 <UART_sendChar>:
    11c4:	5d 9b       	sbis	0x0b, 5	; 11
    11c6:	fe cf       	rjmp	.-4      	; 0x11c4 <UART_sendChar>
    11c8:	8c b9       	out	0x0c, r24	; 12
    11ca:	5e 9b       	sbis	0x0b, 6	; 11
    11cc:	fe cf       	rjmp	.-4      	; 0x11ca <UART_sendChar+0x6>
    11ce:	08 95       	ret

000011d0 <UART_sendString>:
  }

void UART_sendString(s8* str) {
    11d0:	cf 92       	push	r12
    11d2:	df 92       	push	r13
    11d4:	ef 92       	push	r14
    11d6:	ff 92       	push	r15
    11d8:	cf 93       	push	r28
    11da:	df 93       	push	r29
    11dc:	ec 01       	movw	r28, r24
  u32 i = 0;
    11de:	c1 2c       	mov	r12, r1
    11e0:	d1 2c       	mov	r13, r1
    11e2:	76 01       	movw	r14, r12
  while (str[i] != 0) {
    11e4:	07 c0       	rjmp	.+14     	; 0x11f4 <UART_sendString+0x24>
    UART_sendChar(str[i]);
    11e6:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <UART_sendChar>
    i++;
    11ea:	8f ef       	ldi	r24, 0xFF	; 255
    11ec:	c8 1a       	sub	r12, r24
    11ee:	d8 0a       	sbc	r13, r24
    11f0:	e8 0a       	sbc	r14, r24
    11f2:	f8 0a       	sbc	r15, r24
  *x = UDR;
  }

void UART_sendString(s8* str) {
  u32 i = 0;
  while (str[i] != 0) {
    11f4:	fe 01       	movw	r30, r28
    11f6:	ec 0d       	add	r30, r12
    11f8:	fd 1d       	adc	r31, r13
    11fa:	80 81       	ld	r24, Z
    11fc:	81 11       	cpse	r24, r1
    11fe:	f3 cf       	rjmp	.-26     	; 0x11e6 <UART_sendString+0x16>
    UART_sendChar(str[i]);
    i++;
    }
  UART_sendChar(0); // Send null to terminate the string
    1200:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <UART_sendChar>
  }
    1204:	df 91       	pop	r29
    1206:	cf 91       	pop	r28
    1208:	ff 90       	pop	r15
    120a:	ef 90       	pop	r14
    120c:	df 90       	pop	r13
    120e:	cf 90       	pop	r12
    1210:	08 95       	ret

00001212 <Door_init>:

#include "door.h"

 // Initialize the servo for the door
void Door_init(void) {
  Servo_init();
    1212:	0e 94 1a 03 	call	0x634	; 0x634 <Servo_init>
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    1216:	80 e0       	ldi	r24, 0x00	; 0
    1218:	0e 94 2d 03 	call	0x65a	; 0x65a <Servo_move_to_angle>
    121c:	08 95       	ret

0000121e <Door_open>:
  }

// Open the door by moving the servo to the open angle
void Door_open(void) {
  Servo_move_to_angle(DOOR_OPEN_ANGLE);
    121e:	84 eb       	ldi	r24, 0xB4	; 180
    1220:	0e 94 2d 03 	call	0x65a	; 0x65a <Servo_move_to_angle>
    1224:	08 95       	ret

00001226 <Door_close>:
  }

// Close the door by moving the servo to the close angle
void Door_close(void) {
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    1226:	80 e0       	ldi	r24, 0x00	; 0
    1228:	0e 94 2d 03 	call	0x65a	; 0x65a <Servo_move_to_angle>
    122c:	08 95       	ret

0000122e <Lamps_init>:
        break;
      case LAMP_5:
        LED_toggle(LAMP_5_PORT, LAMP_5_PIN);
        break;
      case LAMP_6:
        LED_toggle(LAMP_6_DIMMABLE_PORT, LAMP_6_DIMMABLE_PIN);
    122e:	62 e0       	ldi	r22, 0x02	; 2
    1230:	83 e4       	ldi	r24, 0x43	; 67
    1232:	0e 94 ee 02 	call	0x5dc	; 0x5dc <LED_init>
    1236:	63 e0       	ldi	r22, 0x03	; 3
    1238:	83 e4       	ldi	r24, 0x43	; 67
    123a:	0e 94 ee 02 	call	0x5dc	; 0x5dc <LED_init>
    123e:	64 e0       	ldi	r22, 0x04	; 4
    1240:	83 e4       	ldi	r24, 0x43	; 67
    1242:	0e 94 ee 02 	call	0x5dc	; 0x5dc <LED_init>
    1246:	65 e0       	ldi	r22, 0x05	; 5
    1248:	83 e4       	ldi	r24, 0x43	; 67
    124a:	0e 94 ee 02 	call	0x5dc	; 0x5dc <LED_init>
    124e:	66 e0       	ldi	r22, 0x06	; 6
    1250:	83 e4       	ldi	r24, 0x43	; 67
    1252:	0e 94 ee 02 	call	0x5dc	; 0x5dc <LED_init>
    1256:	67 e0       	ldi	r22, 0x07	; 7
    1258:	84 e4       	ldi	r24, 0x44	; 68
    125a:	0e 94 ee 02 	call	0x5dc	; 0x5dc <LED_init>
    125e:	21 e0       	ldi	r18, 0x01	; 1
    1260:	40 e0       	ldi	r20, 0x00	; 0
    1262:	50 e0       	ldi	r21, 0x00	; 0
    1264:	60 e8       	ldi	r22, 0x80	; 128
    1266:	7f e3       	ldi	r23, 0x3F	; 63
    1268:	83 e0       	ldi	r24, 0x03	; 3
    126a:	0e 94 41 07 	call	0xe82	; 0xe82 <PWM_init>
    126e:	61 e0       	ldi	r22, 0x01	; 1
    1270:	70 e0       	ldi	r23, 0x00	; 0
    1272:	82 e0       	ldi	r24, 0x02	; 2
    1274:	0e 94 2d 07 	call	0xe5a	; 0xe5a <Timer_start>
    1278:	08 95       	ret

0000127a <Lamp_on>:
    127a:	83 30       	cpi	r24, 0x03	; 3
    127c:	b1 f0       	breq	.+44     	; 0x12aa <Lamp_on+0x30>
    127e:	28 f4       	brcc	.+10     	; 0x128a <Lamp_on+0x10>
    1280:	81 30       	cpi	r24, 0x01	; 1
    1282:	49 f0       	breq	.+18     	; 0x1296 <Lamp_on+0x1c>
    1284:	82 30       	cpi	r24, 0x02	; 2
    1286:	61 f0       	breq	.+24     	; 0x12a0 <Lamp_on+0x26>
    1288:	08 95       	ret
    128a:	85 30       	cpi	r24, 0x05	; 5
    128c:	c1 f0       	breq	.+48     	; 0x12be <Lamp_on+0x44>
    128e:	90 f0       	brcs	.+36     	; 0x12b4 <Lamp_on+0x3a>
    1290:	86 30       	cpi	r24, 0x06	; 6
    1292:	d1 f0       	breq	.+52     	; 0x12c8 <Lamp_on+0x4e>
    1294:	08 95       	ret
    1296:	62 e0       	ldi	r22, 0x02	; 2
    1298:	83 e4       	ldi	r24, 0x43	; 67
    129a:	0e 94 f7 02 	call	0x5ee	; 0x5ee <LED_on>
    129e:	08 95       	ret
    12a0:	63 e0       	ldi	r22, 0x03	; 3
    12a2:	83 e4       	ldi	r24, 0x43	; 67
    12a4:	0e 94 f7 02 	call	0x5ee	; 0x5ee <LED_on>
    12a8:	08 95       	ret
    12aa:	64 e0       	ldi	r22, 0x04	; 4
    12ac:	83 e4       	ldi	r24, 0x43	; 67
    12ae:	0e 94 f7 02 	call	0x5ee	; 0x5ee <LED_on>
    12b2:	08 95       	ret
    12b4:	65 e0       	ldi	r22, 0x05	; 5
    12b6:	83 e4       	ldi	r24, 0x43	; 67
    12b8:	0e 94 f7 02 	call	0x5ee	; 0x5ee <LED_on>
    12bc:	08 95       	ret
    12be:	66 e0       	ldi	r22, 0x06	; 6
    12c0:	83 e4       	ldi	r24, 0x43	; 67
    12c2:	0e 94 f7 02 	call	0x5ee	; 0x5ee <LED_on>
    12c6:	08 95       	ret
    12c8:	67 e0       	ldi	r22, 0x07	; 7
    12ca:	84 e4       	ldi	r24, 0x44	; 68
    12cc:	0e 94 f7 02 	call	0x5ee	; 0x5ee <LED_on>
    12d0:	08 95       	ret

000012d2 <Lamp_off>:
    12d2:	83 30       	cpi	r24, 0x03	; 3
    12d4:	b1 f0       	breq	.+44     	; 0x1302 <Lamp_off+0x30>
    12d6:	28 f4       	brcc	.+10     	; 0x12e2 <Lamp_off+0x10>
    12d8:	81 30       	cpi	r24, 0x01	; 1
    12da:	49 f0       	breq	.+18     	; 0x12ee <Lamp_off+0x1c>
    12dc:	82 30       	cpi	r24, 0x02	; 2
    12de:	61 f0       	breq	.+24     	; 0x12f8 <Lamp_off+0x26>
    12e0:	08 95       	ret
    12e2:	85 30       	cpi	r24, 0x05	; 5
    12e4:	c1 f0       	breq	.+48     	; 0x1316 <Lamp_off+0x44>
    12e6:	90 f0       	brcs	.+36     	; 0x130c <Lamp_off+0x3a>
    12e8:	86 30       	cpi	r24, 0x06	; 6
    12ea:	d1 f0       	breq	.+52     	; 0x1320 <Lamp_off+0x4e>
    12ec:	08 95       	ret
    12ee:	62 e0       	ldi	r22, 0x02	; 2
    12f0:	83 e4       	ldi	r24, 0x43	; 67
    12f2:	0e 94 00 03 	call	0x600	; 0x600 <LED_off>
    12f6:	08 95       	ret
    12f8:	63 e0       	ldi	r22, 0x03	; 3
    12fa:	83 e4       	ldi	r24, 0x43	; 67
    12fc:	0e 94 00 03 	call	0x600	; 0x600 <LED_off>
    1300:	08 95       	ret
    1302:	64 e0       	ldi	r22, 0x04	; 4
    1304:	83 e4       	ldi	r24, 0x43	; 67
    1306:	0e 94 00 03 	call	0x600	; 0x600 <LED_off>
    130a:	08 95       	ret
    130c:	65 e0       	ldi	r22, 0x05	; 5
    130e:	83 e4       	ldi	r24, 0x43	; 67
    1310:	0e 94 00 03 	call	0x600	; 0x600 <LED_off>
    1314:	08 95       	ret
    1316:	66 e0       	ldi	r22, 0x06	; 6
    1318:	83 e4       	ldi	r24, 0x43	; 67
    131a:	0e 94 00 03 	call	0x600	; 0x600 <LED_off>
    131e:	08 95       	ret
    1320:	67 e0       	ldi	r22, 0x07	; 7
    1322:	84 e4       	ldi	r24, 0x44	; 68
    1324:	0e 94 00 03 	call	0x600	; 0x600 <LED_off>
    1328:	08 95       	ret

0000132a <Lamp_dimmable_set_brightness>:
        break;
    }
  }

// Adjust the brightness of the dimmable lamp
void Lamp_dimmable_set_brightness(double brightness) {
    132a:	ab 01       	movw	r20, r22
    132c:	bc 01       	movw	r22, r24
  PWM_set_DC(LAMP_6_DIMMABLE_PWM_PIN, brightness);
    132e:	83 e0       	ldi	r24, 0x03	; 3
    1330:	0e 94 01 08 	call	0x1002	; 0x1002 <PWM_set_DC>
    1334:	08 95       	ret

00001336 <Local_access_init>:
 */

#include "local.h"

void Local_access_init(void) {
  LCD_init();
    1336:	0e 94 ae 02 	call	0x55c	; 0x55c <LCD_init>
  Keypad_init();
    133a:	0e 94 11 02 	call	0x422	; 0x422 <Keypad_init>
    133e:	08 95       	ret

00001340 <Remote_init>:
void initial_options_menu(void);
void print_initial_options_menu(void);
void remote_control(void);

void Remote_init(u32 baudRate) {
  BT_init(baudRate);
    1340:	0e 94 f7 01 	call	0x3ee	; 0x3ee <BT_init>
    1344:	08 95       	ret

00001346 <callFunWhenBufferReady>:
  }

void callFunWhenBufferReady(void) {
  requesting_function();
    1346:	e0 91 54 06 	lds	r30, 0x0654	; 0x800654 <requesting_function>
    134a:	f0 91 55 06 	lds	r31, 0x0655	; 0x800655 <requesting_function+0x1>
    134e:	09 95       	icall
    1350:	08 95       	ret

00001352 <println_msg>:
  }

void println_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    1352:	0e 94 0e 02 	call	0x41c	; 0x41c <BT_sendString>
  // Send CRLF - carriage return + new line
  BT_sendString("\r\n");
    1356:	81 e6       	ldi	r24, 0x61	; 97
    1358:	90 e0       	ldi	r25, 0x00	; 0
    135a:	0e 94 0e 02 	call	0x41c	; 0x41c <BT_sendString>
    135e:	08 95       	ret

00001360 <print_msg>:
  }

void print_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    1360:	0e 94 0e 02 	call	0x41c	; 0x41c <BT_sendString>
    1364:	08 95       	ret

00001366 <request_user_input>:
  }

void request_user_input(void (*requestingFunction)(void), u8 msgLength) {
  requesting_function = requestingFunction;
    1366:	90 93 55 06 	sts	0x0655, r25	; 0x800655 <requesting_function+0x1>
    136a:	80 93 54 06 	sts	0x0654, r24	; 0x800654 <requesting_function>
  msg_length = msgLength;
    136e:	60 93 ec 05 	sts	0x05EC, r22	; 0x8005ec <msg_length>
    1372:	08 95       	ret

00001374 <print_remote_control_menu>:
      }
    }
  }

void print_remote_control_menu(void) {
  println_msg("Select one of the following devices to control:\t");
    1374:	84 e6       	ldi	r24, 0x64	; 100
    1376:	90 e0       	ldi	r25, 0x00	; 0
    1378:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
  println_msg("[1] Lamp 1");
    137c:	85 e9       	ldi	r24, 0x95	; 149
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
  println_msg("[2] Lamp 2");
    1384:	80 ea       	ldi	r24, 0xA0	; 160
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
  println_msg("[3] Lamp 3");
    138c:	8b ea       	ldi	r24, 0xAB	; 171
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
  println_msg("[4] Lamp 4");
    1394:	86 eb       	ldi	r24, 0xB6	; 182
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
  println_msg("[5] Lamp 5");
    139c:	81 ec       	ldi	r24, 0xC1	; 193
    139e:	90 e0       	ldi	r25, 0x00	; 0
    13a0:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
  println_msg("[6] Lamp 6");
    13a4:	8c ec       	ldi	r24, 0xCC	; 204
    13a6:	90 e0       	ldi	r25, 0x00	; 0
    13a8:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
  if (remote_user.isAdmin) {
    13ac:	80 91 ee 05 	lds	r24, 0x05EE	; 0x8005ee <remote_user>
    13b0:	88 23       	and	r24, r24
    13b2:	21 f0       	breq	.+8      	; 0x13bc <print_remote_control_menu+0x48>
    println_msg("[7] The Door");
    13b4:	87 ed       	ldi	r24, 0xD7	; 215
    13b6:	90 e0       	ldi	r25, 0x00	; 0
    13b8:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    13bc:	08 95       	ret

000013be <control_device>:
  }

// TODO: Send the status of each device to the user instead of just asking him to switch the device on or off.

void control_device(void) {
  u8 option = msg_buffer[0];
    13be:	60 91 dd 05 	lds	r22, 0x05DD	; 0x8005dd <msg_buffer>
  if (invalid_user_input || option < '0' || option > '9') {
    13c2:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <invalid_user_input>
    13c6:	81 11       	cpse	r24, r1
    13c8:	04 c0       	rjmp	.+8      	; 0x13d2 <control_device+0x14>
    13ca:	60 33       	cpi	r22, 0x30	; 48
    13cc:	10 f0       	brcs	.+4      	; 0x13d2 <control_device+0x14>
    13ce:	6a 33       	cpi	r22, 0x3A	; 58
    13d0:	60 f0       	brcs	.+24     	; 0x13ea <control_device+0x2c>
    println_msg("\r\nInvalid input!!\t");
    13d2:	84 ee       	ldi	r24, 0xE4	; 228
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    print_remote_control_menu();
    13da:	0e 94 ba 09 	call	0x1374	; 0x1374 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    13de:	62 e0       	ldi	r22, 0x02	; 2
    13e0:	88 e3       	ldi	r24, 0x38	; 56
    13e2:	9a e0       	ldi	r25, 0x0A	; 10
    13e4:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    13e8:	08 95       	ret
    }
  else {
    if (device_number < 6) {
    13ea:	80 91 33 06 	lds	r24, 0x0633	; 0x800633 <device_number>
    13ee:	86 30       	cpi	r24, 0x06	; 6
    13f0:	80 f4       	brcc	.+32     	; 0x1412 <control_device+0x54>
      if (option == '1') {
    13f2:	61 33       	cpi	r22, 0x31	; 49
    13f4:	39 f4       	brne	.+14     	; 0x1404 <control_device+0x46>
        Lamp_on(device_number);
    13f6:	0e 94 3d 09 	call	0x127a	; 0x127a <Lamp_on>
        println_msg("The device has been turned on!");
    13fa:	87 ef       	ldi	r24, 0xF7	; 247
    13fc:	90 e0       	ldi	r25, 0x00	; 0
    13fe:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    1402:	2e c0       	rjmp	.+92     	; 0x1460 <control_device+0xa2>
        }
      else {
        Lamp_off(device_number);
    1404:	0e 94 69 09 	call	0x12d2	; 0x12d2 <Lamp_off>
        println_msg("The device has been turned off!");
    1408:	86 e1       	ldi	r24, 0x16	; 22
    140a:	91 e0       	ldi	r25, 0x01	; 1
    140c:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    1410:	27 c0       	rjmp	.+78     	; 0x1460 <control_device+0xa2>
        }
      }
    else if (device_number == 6) { // Dimmable led
    1412:	86 30       	cpi	r24, 0x06	; 6
    1414:	b1 f4       	brne	.+44     	; 0x1442 <control_device+0x84>
      Lamp_dimmable_set_brightness((double)(option - 48) / 9.0);
    1416:	70 e0       	ldi	r23, 0x00	; 0
    1418:	60 53       	subi	r22, 0x30	; 48
    141a:	71 09       	sbc	r23, r1
    141c:	07 2e       	mov	r0, r23
    141e:	00 0c       	add	r0, r0
    1420:	88 0b       	sbc	r24, r24
    1422:	99 0b       	sbc	r25, r25
    1424:	0e 94 32 11 	call	0x2264	; 0x2264 <__floatsisf>
    1428:	20 e0       	ldi	r18, 0x00	; 0
    142a:	30 e0       	ldi	r19, 0x00	; 0
    142c:	40 e1       	ldi	r20, 0x10	; 16
    142e:	51 e4       	ldi	r21, 0x41	; 65
    1430:	0e 94 8f 10 	call	0x211e	; 0x211e <__divsf3>
    1434:	0e 94 95 09 	call	0x132a	; 0x132a <Lamp_dimmable_set_brightness>
      println_msg("The brightness has been adjusted!");
    1438:	86 e3       	ldi	r24, 0x36	; 54
    143a:	91 e0       	ldi	r25, 0x01	; 1
    143c:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    1440:	0f c0       	rjmp	.+30     	; 0x1460 <control_device+0xa2>
      }
    else {
      if (option == '1') {
    1442:	61 33       	cpi	r22, 0x31	; 49
    1444:	39 f4       	brne	.+14     	; 0x1454 <control_device+0x96>
        Door_open();
    1446:	0e 94 0f 09 	call	0x121e	; 0x121e <Door_open>
        println_msg("The Door is open now.");
    144a:	88 e5       	ldi	r24, 0x58	; 88
    144c:	91 e0       	ldi	r25, 0x01	; 1
    144e:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    1452:	06 c0       	rjmp	.+12     	; 0x1460 <control_device+0xa2>
        }
      else {
        Door_close();
    1454:	0e 94 13 09 	call	0x1226	; 0x1226 <Door_close>
        println_msg("The Door is closed now.");
    1458:	8e e6       	ldi	r24, 0x6E	; 110
    145a:	91 e0       	ldi	r25, 0x01	; 1
    145c:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
        }
      }
    print_remote_control_menu();
    1460:	0e 94 ba 09 	call	0x1374	; 0x1374 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    1464:	62 e0       	ldi	r22, 0x02	; 2
    1466:	88 e3       	ldi	r24, 0x38	; 56
    1468:	9a e0       	ldi	r25, 0x0A	; 10
    146a:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    146e:	08 95       	ret

00001470 <remote_control>:
    }
  }

void remote_control(void) {
    1470:	cf 93       	push	r28
  u8 option = msg_buffer[0];
    1472:	c0 91 dd 05 	lds	r28, 0x05DD	; 0x8005dd <msg_buffer>
  if (remote_user.isAdmin) {
    1476:	80 91 ee 05 	lds	r24, 0x05EE	; 0x8005ee <remote_user>
    147a:	88 23       	and	r24, r24
    147c:	49 f1       	breq	.+82     	; 0x14d0 <remote_control+0x60>
    if (invalid_user_input || option < '1' || option > '7') {
    147e:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <invalid_user_input>
    1482:	81 11       	cpse	r24, r1
    1484:	04 c0       	rjmp	.+8      	; 0x148e <remote_control+0x1e>
    1486:	c1 33       	cpi	r28, 0x31	; 49
    1488:	10 f0       	brcs	.+4      	; 0x148e <remote_control+0x1e>
    148a:	c8 33       	cpi	r28, 0x38	; 56
    148c:	60 f0       	brcs	.+24     	; 0x14a6 <remote_control+0x36>
      println_msg("Invalid option!\t");
    148e:	86 e8       	ldi	r24, 0x86	; 134
    1490:	91 e0       	ldi	r25, 0x01	; 1
    1492:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      print_remote_control_menu();
    1496:	0e 94 ba 09 	call	0x1374	; 0x1374 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    149a:	62 e0       	ldi	r22, 0x02	; 2
    149c:	88 e3       	ldi	r24, 0x38	; 56
    149e:	9a e0       	ldi	r25, 0x0A	; 10
    14a0:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    14a4:	3d c0       	rjmp	.+122    	; 0x1520 <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    14a6:	87 e9       	ldi	r24, 0x97	; 151
    14a8:	91 e0       	ldi	r25, 0x01	; 1
    14aa:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    14ae:	8d ee       	ldi	r24, 0xED	; 237
    14b0:	91 e0       	ldi	r25, 0x01	; 1
    14b2:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    14b6:	86 e2       	ldi	r24, 0x26	; 38
    14b8:	92 e0       	ldi	r25, 0x02	; 2
    14ba:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      request_user_input(control_device, 2);
    14be:	62 e0       	ldi	r22, 0x02	; 2
    14c0:	8f ed       	ldi	r24, 0xDF	; 223
    14c2:	99 e0       	ldi	r25, 0x09	; 9
    14c4:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
      device_number = option - 48;
    14c8:	c0 53       	subi	r28, 0x30	; 48
    14ca:	c0 93 33 06 	sts	0x0633, r28	; 0x800633 <device_number>
    14ce:	28 c0       	rjmp	.+80     	; 0x1520 <remote_control+0xb0>
      }
    }
  else {
    if (invalid_user_input || option < '1' || option > '6') {
    14d0:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <invalid_user_input>
    14d4:	81 11       	cpse	r24, r1
    14d6:	04 c0       	rjmp	.+8      	; 0x14e0 <remote_control+0x70>
    14d8:	c1 33       	cpi	r28, 0x31	; 49
    14da:	10 f0       	brcs	.+4      	; 0x14e0 <remote_control+0x70>
    14dc:	c7 33       	cpi	r28, 0x37	; 55
    14de:	60 f0       	brcs	.+24     	; 0x14f8 <remote_control+0x88>
      println_msg("Invalid option!\t");
    14e0:	86 e8       	ldi	r24, 0x86	; 134
    14e2:	91 e0       	ldi	r25, 0x01	; 1
    14e4:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      print_remote_control_menu();
    14e8:	0e 94 ba 09 	call	0x1374	; 0x1374 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    14ec:	62 e0       	ldi	r22, 0x02	; 2
    14ee:	88 e3       	ldi	r24, 0x38	; 56
    14f0:	9a e0       	ldi	r25, 0x0A	; 10
    14f2:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    14f6:	14 c0       	rjmp	.+40     	; 0x1520 <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    14f8:	87 e9       	ldi	r24, 0x97	; 151
    14fa:	91 e0       	ldi	r25, 0x01	; 1
    14fc:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    1500:	8d ee       	ldi	r24, 0xED	; 237
    1502:	91 e0       	ldi	r25, 0x01	; 1
    1504:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    1508:	86 e2       	ldi	r24, 0x26	; 38
    150a:	92 e0       	ldi	r25, 0x02	; 2
    150c:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      request_user_input(control_device, 2);
    1510:	62 e0       	ldi	r22, 0x02	; 2
    1512:	8f ed       	ldi	r24, 0xDF	; 223
    1514:	99 e0       	ldi	r25, 0x09	; 9
    1516:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
      device_number = option - 48;
    151a:	c0 53       	subi	r28, 0x30	; 48
    151c:	c0 93 33 06 	sts	0x0633, r28	; 0x800633 <device_number>
      }
    }
  }
    1520:	cf 91       	pop	r28
    1522:	08 95       	ret

00001524 <print_initial_options_menu>:

void print_initial_options_menu(void) {
  if (remote_user.isAdmin) {
    1524:	80 91 ee 05 	lds	r24, 0x05EE	; 0x8005ee <remote_user>
    1528:	88 23       	and	r24, r24
    152a:	a9 f0       	breq	.+42     	; 0x1556 <print_initial_options_menu+0x32>
    println_msg("Select one of the following options(by entering its number):\t");
    152c:	8e e5       	ldi	r24, 0x5E	; 94
    152e:	92 e0       	ldi	r25, 0x02	; 2
    1530:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    println_msg("[1] Add user\t");
    1534:	8c e9       	ldi	r24, 0x9C	; 156
    1536:	92 e0       	ldi	r25, 0x02	; 2
    1538:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    println_msg("[2] Delete user\t");
    153c:	8a ea       	ldi	r24, 0xAA	; 170
    153e:	92 e0       	ldi	r25, 0x02	; 2
    1540:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    println_msg("[3] Control a device\t");
    1544:	8b eb       	ldi	r24, 0xBB	; 187
    1546:	92 e0       	ldi	r25, 0x02	; 2
    1548:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    println_msg("[4] Log out\t");
    154c:	81 ed       	ldi	r24, 0xD1	; 209
    154e:	92 e0       	ldi	r25, 0x02	; 2
    1550:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    1554:	08 95       	ret
    }
  else {
    println_msg("Select one of the following options(by entering its number):\t");
    1556:	8e e5       	ldi	r24, 0x5E	; 94
    1558:	92 e0       	ldi	r25, 0x02	; 2
    155a:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    println_msg("[1] Control a device\t");
    155e:	8e ed       	ldi	r24, 0xDE	; 222
    1560:	92 e0       	ldi	r25, 0x02	; 2
    1562:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    println_msg("[2] Log out\t");
    1566:	84 ef       	ldi	r24, 0xF4	; 244
    1568:	92 e0       	ldi	r25, 0x02	; 2
    156a:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    156e:	08 95       	ret

00001570 <delete_user_prompt>:
  requesting_function = requestingFunction;
  msg_length = msgLength;
  }

void delete_user_prompt(void) {
  if (invalid_user_input) {
    1570:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <invalid_user_input>
    1574:	88 23       	and	r24, r24
    1576:	61 f0       	breq	.+24     	; 0x1590 <delete_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    1578:	81 e0       	ldi	r24, 0x01	; 1
    157a:	93 e0       	ldi	r25, 0x03	; 3
    157c:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1580:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1584:	62 e0       	ldi	r22, 0x02	; 2
    1586:	8c ee       	ldi	r24, 0xEC	; 236
    1588:	9a e0       	ldi	r25, 0x0A	; 10
    158a:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    158e:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    1590:	6e e0       	ldi	r22, 0x0E	; 14
    1592:	76 e0       	ldi	r23, 0x06	; 6
    1594:	8d ed       	ldi	r24, 0xDD	; 221
    1596:	95 e0       	ldi	r25, 0x05	; 5
    1598:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    159c:	83 30       	cpi	r24, 0x03	; 3
    159e:	61 f4       	brne	.+24     	; 0x15b8 <delete_user_prompt+0x48>
      println_msg("\rError! User not found. Returning to the main menu...");
    15a0:	87 e1       	ldi	r24, 0x17	; 23
    15a2:	93 e0       	ldi	r25, 0x03	; 3
    15a4:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      print_initial_options_menu();
    15a8:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    15ac:	62 e0       	ldi	r22, 0x02	; 2
    15ae:	8c ee       	ldi	r24, 0xEC	; 236
    15b0:	9a e0       	ldi	r25, 0x0A	; 10
    15b2:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    15b6:	08 95       	ret
      }
    else {
      // Delete the user
      delete_user(&temp_user);
    15b8:	8e e0       	ldi	r24, 0x0E	; 14
    15ba:	96 e0       	ldi	r25, 0x06	; 6
    15bc:	0e 94 af 0f 	call	0x1f5e	; 0x1f5e <delete_user>
      println_msg("The user has been deleted successfully!\t");
    15c0:	8d e4       	ldi	r24, 0x4D	; 77
    15c2:	93 e0       	ldi	r25, 0x03	; 3
    15c4:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    15c8:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    15cc:	62 e0       	ldi	r22, 0x02	; 2
    15ce:	8c ee       	ldi	r24, 0xEC	; 236
    15d0:	9a e0       	ldi	r25, 0x0A	; 10
    15d2:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    15d6:	08 95       	ret

000015d8 <initial_options_menu>:
    println_msg("[2] Log out\t");
    }
  }

void initial_options_menu() {
  if (remote_user.isAdmin) {
    15d8:	80 91 ee 05 	lds	r24, 0x05EE	; 0x8005ee <remote_user>
    15dc:	88 23       	and	r24, r24
    15de:	09 f4       	brne	.+2      	; 0x15e2 <initial_options_menu+0xa>
    15e0:	4b c0       	rjmp	.+150    	; 0x1678 <initial_options_menu+0xa0>
    u8 option = msg_buffer[0];
    15e2:	80 91 dd 05 	lds	r24, 0x05DD	; 0x8005dd <msg_buffer>
    if (invalid_user_input || option < '1' || option > '4') {
    15e6:	90 91 ed 05 	lds	r25, 0x05ED	; 0x8005ed <invalid_user_input>
    15ea:	91 11       	cpse	r25, r1
    15ec:	04 c0       	rjmp	.+8      	; 0x15f6 <initial_options_menu+0x1e>
    15ee:	81 33       	cpi	r24, 0x31	; 49
    15f0:	10 f0       	brcs	.+4      	; 0x15f6 <initial_options_menu+0x1e>
    15f2:	85 33       	cpi	r24, 0x35	; 53
    15f4:	60 f0       	brcs	.+24     	; 0x160e <initial_options_menu+0x36>
      println_msg("Invalid option!\t");
    15f6:	86 e8       	ldi	r24, 0x86	; 134
    15f8:	91 e0       	ldi	r25, 0x01	; 1
    15fa:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      print_initial_options_menu();
    15fe:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1602:	62 e0       	ldi	r22, 0x02	; 2
    1604:	8c ee       	ldi	r24, 0xEC	; 236
    1606:	9a e0       	ldi	r25, 0x0A	; 10
    1608:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    160c:	08 95       	ret
      }
    else {
      switch (option) {
    160e:	82 33       	cpi	r24, 0x32	; 50
    1610:	99 f0       	breq	.+38     	; 0x1638 <initial_options_menu+0x60>
    1612:	18 f4       	brcc	.+6      	; 0x161a <initial_options_menu+0x42>
    1614:	81 33       	cpi	r24, 0x31	; 49
    1616:	31 f0       	breq	.+12     	; 0x1624 <initial_options_menu+0x4c>
    1618:	08 95       	ret
    161a:	83 33       	cpi	r24, 0x33	; 51
    161c:	b9 f0       	breq	.+46     	; 0x164c <initial_options_menu+0x74>
    161e:	84 33       	cpi	r24, 0x34	; 52
    1620:	e9 f0       	breq	.+58     	; 0x165c <initial_options_menu+0x84>
    1622:	08 95       	ret
          case '1':
            print_msg("Enter the user name: ");
    1624:	86 e7       	ldi	r24, 0x76	; 118
    1626:	93 e0       	ldi	r25, 0x03	; 3
    1628:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
            request_user_input(add_user_prompt, 13);
    162c:	6d e0       	ldi	r22, 0x0D	; 13
    162e:	8e ee       	ldi	r24, 0xEE	; 238
    1630:	9b e0       	ldi	r25, 0x0B	; 11
    1632:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
            break;
    1636:	08 95       	ret
          case '2':
            print_msg("Enter the user name: ");
    1638:	86 e7       	ldi	r24, 0x76	; 118
    163a:	93 e0       	ldi	r25, 0x03	; 3
    163c:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
            request_user_input(delete_user_prompt, 13);
    1640:	6d e0       	ldi	r22, 0x0D	; 13
    1642:	88 eb       	ldi	r24, 0xB8	; 184
    1644:	9a e0       	ldi	r25, 0x0A	; 10
    1646:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
            break;
    164a:	08 95       	ret
          case '3':
            print_remote_control_menu();
    164c:	0e 94 ba 09 	call	0x1374	; 0x1374 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    1650:	62 e0       	ldi	r22, 0x02	; 2
    1652:	88 e3       	ldi	r24, 0x38	; 56
    1654:	9a e0       	ldi	r25, 0x0A	; 10
    1656:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
            break;
    165a:	08 95       	ret
          case '4':
            remote_user_loggedin = true;
    165c:	81 e0       	ldi	r24, 0x01	; 1
    165e:	80 93 db 05 	sts	0x05DB, r24	; 0x8005db <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    1662:	8c e8       	ldi	r24, 0x8C	; 140
    1664:	93 e0       	ldi	r25, 0x03	; 3
    1666:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
            println_msg("You have successfully logged out...");
    166a:	84 ed       	ldi	r24, 0xD4	; 212
    166c:	93 e0       	ldi	r25, 0x03	; 3
    166e:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
            msg_length = 0;
    1672:	10 92 ec 05 	sts	0x05EC, r1	; 0x8005ec <msg_length>
            break;
    1676:	08 95       	ret
        }
      }
    }
  else {
    u8 option = msg_buffer[0];
    1678:	80 91 dd 05 	lds	r24, 0x05DD	; 0x8005dd <msg_buffer>
    if (invalid_user_input || option < '1' || option > '2') {
    167c:	90 91 ed 05 	lds	r25, 0x05ED	; 0x8005ed <invalid_user_input>
    1680:	91 11       	cpse	r25, r1
    1682:	04 c0       	rjmp	.+8      	; 0x168c <initial_options_menu+0xb4>
    1684:	81 33       	cpi	r24, 0x31	; 49
    1686:	10 f0       	brcs	.+4      	; 0x168c <initial_options_menu+0xb4>
    1688:	83 33       	cpi	r24, 0x33	; 51
    168a:	60 f0       	brcs	.+24     	; 0x16a4 <initial_options_menu+0xcc>
      println_msg("Invalid option!\t");
    168c:	86 e8       	ldi	r24, 0x86	; 134
    168e:	91 e0       	ldi	r25, 0x01	; 1
    1690:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      print_initial_options_menu();
    1694:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1698:	62 e0       	ldi	r22, 0x02	; 2
    169a:	8c ee       	ldi	r24, 0xEC	; 236
    169c:	9a e0       	ldi	r25, 0x0A	; 10
    169e:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    16a2:	08 95       	ret
      }
    else {
      switch (option) {
    16a4:	81 33       	cpi	r24, 0x31	; 49
    16a6:	19 f0       	breq	.+6      	; 0x16ae <initial_options_menu+0xd6>
    16a8:	82 33       	cpi	r24, 0x32	; 50
    16aa:	49 f0       	breq	.+18     	; 0x16be <initial_options_menu+0xe6>
    16ac:	08 95       	ret
          case '1':
            print_remote_control_menu();
    16ae:	0e 94 ba 09 	call	0x1374	; 0x1374 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    16b2:	62 e0       	ldi	r22, 0x02	; 2
    16b4:	88 e3       	ldi	r24, 0x38	; 56
    16b6:	9a e0       	ldi	r25, 0x0A	; 10
    16b8:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
            break;
    16bc:	08 95       	ret
          case '2':
            remote_user_loggedin = true;
    16be:	81 e0       	ldi	r24, 0x01	; 1
    16c0:	80 93 db 05 	sts	0x05DB, r24	; 0x8005db <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    16c4:	8c e8       	ldi	r24, 0x8C	; 140
    16c6:	93 e0       	ldi	r25, 0x03	; 3
    16c8:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
            println_msg("You have successfully logged out...");
    16cc:	84 ed       	ldi	r24, 0xD4	; 212
    16ce:	93 e0       	ldi	r25, 0x03	; 3
    16d0:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
            msg_length = 0;
    16d4:	10 92 ec 05 	sts	0x05EC, r1	; 0x8005ec <msg_length>
    16d8:	08 95       	ret

000016da <add_user_isAdmin_prompt>:
      }
    }
  }

void add_user_isAdmin_prompt(void) {
  if (invalid_user_input) {
    16da:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <invalid_user_input>
    16de:	88 23       	and	r24, r24
    16e0:	61 f0       	breq	.+24     	; 0x16fa <add_user_isAdmin_prompt+0x20>
    println_msg("\r\nInvalid input!!\t");
    16e2:	84 ee       	ldi	r24, 0xE4	; 228
    16e4:	90 e0       	ldi	r25, 0x00	; 0
    16e6:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    //! The system should ask the user wether he wants to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    16ea:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    16ee:	62 e0       	ldi	r22, 0x02	; 2
    16f0:	8c ee       	ldi	r24, 0xEC	; 236
    16f2:	9a e0       	ldi	r25, 0x0A	; 10
    16f4:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    16f8:	08 95       	ret
    }
  else {
    new_user.isAdmin = (msg_buffer[0] == 'y' || msg_buffer[0] == 'Y');
    16fa:	80 91 dd 05 	lds	r24, 0x05DD	; 0x8005dd <msg_buffer>
    16fe:	89 37       	cpi	r24, 0x79	; 121
    1700:	21 f0       	breq	.+8      	; 0x170a <add_user_isAdmin_prompt+0x30>
    1702:	89 35       	cpi	r24, 0x59	; 89
    1704:	21 f4       	brne	.+8      	; 0x170e <add_user_isAdmin_prompt+0x34>
    1706:	81 e0       	ldi	r24, 0x01	; 1
    1708:	03 c0       	rjmp	.+6      	; 0x1710 <add_user_isAdmin_prompt+0x36>
    170a:	81 e0       	ldi	r24, 0x01	; 1
    170c:	01 c0       	rjmp	.+2      	; 0x1710 <add_user_isAdmin_prompt+0x36>
    170e:	80 e0       	ldi	r24, 0x00	; 0
    1710:	80 93 34 06 	sts	0x0634, r24	; 0x800634 <new_user>
    add_user(&new_user);
    1714:	84 e3       	ldi	r24, 0x34	; 52
    1716:	96 e0       	ldi	r25, 0x06	; 6
    1718:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <add_user>
    println_msg("User has been added successfully!");
    171c:	88 ef       	ldi	r24, 0xF8	; 248
    171e:	93 e0       	ldi	r25, 0x03	; 3
    1720:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    //! Return to the main menu
    print_initial_options_menu();
    1724:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1728:	62 e0       	ldi	r22, 0x02	; 2
    172a:	8c ee       	ldi	r24, 0xEC	; 236
    172c:	9a e0       	ldi	r25, 0x0A	; 10
    172e:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    1732:	08 95       	ret

00001734 <add_user_password_prompt>:
    }
  }

void add_user_password_prompt(void) {
  if (invalid_user_input) {
    1734:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <invalid_user_input>
    1738:	88 23       	and	r24, r24
    173a:	61 f0       	breq	.+24     	; 0x1754 <add_user_password_prompt+0x20>
    println_msg("\r\nPassword too long!!\t");
    173c:	8a e1       	ldi	r24, 0x1A	; 26
    173e:	94 e0       	ldi	r25, 0x04	; 4
    1740:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1744:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1748:	62 e0       	ldi	r22, 0x02	; 2
    174a:	8c ee       	ldi	r24, 0xEC	; 236
    174c:	9a e0       	ldi	r25, 0x0A	; 10
    174e:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    1752:	08 95       	ret
    }
  else {
    strcpy(new_user.password, msg_buffer);
    1754:	6d ed       	ldi	r22, 0xDD	; 221
    1756:	75 e0       	ldi	r23, 0x05	; 5
    1758:	89 e4       	ldi	r24, 0x49	; 73
    175a:	96 e0       	ldi	r25, 0x06	; 6
    175c:	0e 94 3a 12 	call	0x2474	; 0x2474 <strcpy>
    print_msg("Do you want to make the new user an admin? (y/n) ");
    1760:	81 e3       	ldi	r24, 0x31	; 49
    1762:	94 e0       	ldi	r25, 0x04	; 4
    1764:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
    request_user_input(add_user_isAdmin_prompt, 2);
    1768:	62 e0       	ldi	r22, 0x02	; 2
    176a:	8d e6       	ldi	r24, 0x6D	; 109
    176c:	9b e0       	ldi	r25, 0x0B	; 11
    176e:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    1772:	08 95       	ret

00001774 <add_user_code_prompt>:
    }
  }

void add_user_code_prompt(void) {
  if (invalid_user_input) {
    1774:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <invalid_user_input>
    1778:	88 23       	and	r24, r24
    177a:	61 f0       	breq	.+24     	; 0x1794 <add_user_code_prompt+0x20>
    println_msg("\r\nInvalid user code!\t");
    177c:	83 e6       	ldi	r24, 0x63	; 99
    177e:	94 e0       	ldi	r25, 0x04	; 4
    1780:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1784:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1788:	62 e0       	ldi	r22, 0x02	; 2
    178a:	8c ee       	ldi	r24, 0xEC	; 236
    178c:	9a e0       	ldi	r25, 0x0A	; 10
    178e:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    1792:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByCode(msg_buffer, &temp_user);
    1794:	6e e0       	ldi	r22, 0x0E	; 14
    1796:	76 e0       	ldi	r23, 0x06	; 6
    1798:	8d ed       	ldi	r24, 0xDD	; 221
    179a:	95 e0       	ldi	r25, 0x05	; 5
    179c:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <getUserByCode>
    if (userExists == USER_NOT_FOUND) {
    17a0:	83 30       	cpi	r24, 0x03	; 3
    17a2:	81 f4       	brne	.+32     	; 0x17c4 <add_user_code_prompt+0x50>
      strcpy(new_user.code, msg_buffer);
    17a4:	6d ed       	ldi	r22, 0xDD	; 221
    17a6:	75 e0       	ldi	r23, 0x05	; 5
    17a8:	82 e4       	ldi	r24, 0x42	; 66
    17aa:	96 e0       	ldi	r25, 0x06	; 6
    17ac:	0e 94 3a 12 	call	0x2474	; 0x2474 <strcpy>
      print_msg("Enter the new user's password: ");
    17b0:	89 e7       	ldi	r24, 0x79	; 121
    17b2:	94 e0       	ldi	r25, 0x04	; 4
    17b4:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
      request_user_input(add_user_password_prompt, 11);
    17b8:	6b e0       	ldi	r22, 0x0B	; 11
    17ba:	8a e9       	ldi	r24, 0x9A	; 154
    17bc:	9b e0       	ldi	r25, 0x0B	; 11
    17be:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    17c2:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      println_msg("\rThe user code already exists!\t");
    17c4:	89 e9       	ldi	r24, 0x99	; 153
    17c6:	94 e0       	ldi	r25, 0x04	; 4
    17c8:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    17cc:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    17d0:	62 e0       	ldi	r22, 0x02	; 2
    17d2:	8c ee       	ldi	r24, 0xEC	; 236
    17d4:	9a e0       	ldi	r25, 0x0A	; 10
    17d6:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    17da:	08 95       	ret

000017dc <add_user_prompt>:
      }
    }
  }

void add_user_prompt(void) {
  if (invalid_user_input) {
    17dc:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <invalid_user_input>
    17e0:	88 23       	and	r24, r24
    17e2:	61 f0       	breq	.+24     	; 0x17fc <add_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    17e4:	81 e0       	ldi	r24, 0x01	; 1
    17e6:	93 e0       	ldi	r25, 0x03	; 3
    17e8:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    17ec:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    17f0:	62 e0       	ldi	r22, 0x02	; 2
    17f2:	8c ee       	ldi	r24, 0xEC	; 236
    17f4:	9a e0       	ldi	r25, 0x0A	; 10
    17f6:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    17fa:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    17fc:	6e e0       	ldi	r22, 0x0E	; 14
    17fe:	76 e0       	ldi	r23, 0x06	; 6
    1800:	8d ed       	ldi	r24, 0xDD	; 221
    1802:	95 e0       	ldi	r25, 0x05	; 5
    1804:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    1808:	83 30       	cpi	r24, 0x03	; 3
    180a:	81 f4       	brne	.+32     	; 0x182c <add_user_prompt+0x50>
      strcpy(new_user.name, msg_buffer);
    180c:	6d ed       	ldi	r22, 0xDD	; 221
    180e:	75 e0       	ldi	r23, 0x05	; 5
    1810:	85 e3       	ldi	r24, 0x35	; 53
    1812:	96 e0       	ldi	r25, 0x06	; 6
    1814:	0e 94 3a 12 	call	0x2474	; 0x2474 <strcpy>
      print_msg("Enter the new user's code(must be a unique six digit code): ");
    1818:	89 eb       	ldi	r24, 0xB9	; 185
    181a:	94 e0       	ldi	r25, 0x04	; 4
    181c:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
      request_user_input(add_user_code_prompt, 7);
    1820:	67 e0       	ldi	r22, 0x07	; 7
    1822:	8a eb       	ldi	r24, 0xBA	; 186
    1824:	9b e0       	ldi	r25, 0x0B	; 11
    1826:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    182a:	08 95       	ret
      }
    else {
      // Prompt the user to enter the user code
      println_msg("\rThe user already exists!\t");
    182c:	86 ef       	ldi	r24, 0xF6	; 246
    182e:	94 e0       	ldi	r25, 0x04	; 4
    1830:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1834:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1838:	62 e0       	ldi	r22, 0x02	; 2
    183a:	8c ee       	ldi	r24, 0xEC	; 236
    183c:	9a e0       	ldi	r25, 0x0A	; 10
    183e:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    1842:	08 95       	ret

00001844 <invalid_remote_login_attempt>:
      }
    }
  }

void invalid_remote_login_attempt(void) {
    1844:	0f 93       	push	r16
    1846:	1f 93       	push	r17
    1848:	cf 93       	push	r28
    184a:	df 93       	push	r29
    184c:	cd b7       	in	r28, 0x3d	; 61
    184e:	de b7       	in	r29, 0x3e	; 62
    1850:	e2 97       	sbiw	r28, 0x32	; 50
    1852:	0f b6       	in	r0, 0x3f	; 63
    1854:	f8 94       	cli
    1856:	de bf       	out	0x3e, r29	; 62
    1858:	0f be       	out	0x3f, r0	; 63
    185a:	cd bf       	out	0x3d, r28	; 61
  invalid_trails++;
    185c:	80 91 da 05 	lds	r24, 0x05DA	; 0x8005da <__data_end>
    1860:	8f 5f       	subi	r24, 0xFF	; 255
    1862:	80 93 da 05 	sts	0x05DA, r24	; 0x8005da <__data_end>
  if (invalid_trails < 3) {
    1866:	83 30       	cpi	r24, 0x03	; 3
    1868:	e8 f4       	brcc	.+58     	; 0x18a4 <invalid_remote_login_attempt+0x60>
    s8 msg[50];
    sprintf(msg, "\r\nInvalid login attempt! \r\n%d attempts remaining.", 3 - invalid_trails);
    186a:	23 e0       	ldi	r18, 0x03	; 3
    186c:	30 e0       	ldi	r19, 0x00	; 0
    186e:	a9 01       	movw	r20, r18
    1870:	48 1b       	sub	r20, r24
    1872:	51 09       	sbc	r21, r1
    1874:	ca 01       	movw	r24, r20
    1876:	9f 93       	push	r25
    1878:	4f 93       	push	r20
    187a:	81 e1       	ldi	r24, 0x11	; 17
    187c:	95 e0       	ldi	r25, 0x05	; 5
    187e:	9f 93       	push	r25
    1880:	8f 93       	push	r24
    1882:	8e 01       	movw	r16, r28
    1884:	0f 5f       	subi	r16, 0xFF	; 255
    1886:	1f 4f       	sbci	r17, 0xFF	; 255
    1888:	1f 93       	push	r17
    188a:	0f 93       	push	r16
    188c:	0e 94 41 12 	call	0x2482	; 0x2482 <sprintf>
    println_msg(msg);
    1890:	c8 01       	movw	r24, r16
    1892:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
    1896:	0f 90       	pop	r0
    1898:	0f 90       	pop	r0
    189a:	0f 90       	pop	r0
    189c:	0f 90       	pop	r0
    189e:	0f 90       	pop	r0
    18a0:	0f 90       	pop	r0
    18a2:	04 c0       	rjmp	.+8      	; 0x18ac <invalid_remote_login_attempt+0x68>
    return;
    }
  set_alarm();
    18a4:	0e 94 0b 0f 	call	0x1e16	; 0x1e16 <set_alarm>
  run_system = false;
    18a8:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
  }
    18ac:	e2 96       	adiw	r28, 0x32	; 50
    18ae:	0f b6       	in	r0, 0x3f	; 63
    18b0:	f8 94       	cli
    18b2:	de bf       	out	0x3e, r29	; 62
    18b4:	0f be       	out	0x3f, r0	; 63
    18b6:	cd bf       	out	0x3d, r28	; 61
    18b8:	df 91       	pop	r29
    18ba:	cf 91       	pop	r28
    18bc:	1f 91       	pop	r17
    18be:	0f 91       	pop	r16
    18c0:	08 95       	ret

000018c2 <userPassword_prompt_handler>:

void userPassword_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    18c2:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <invalid_user_input>
    18c6:	88 23       	and	r24, r24
    18c8:	61 f0       	breq	.+24     	; 0x18e2 <userPassword_prompt_handler+0x20>
    invalid_remote_login_attempt();
    18ca:	0e 94 22 0c 	call	0x1844	; 0x1844 <invalid_remote_login_attempt>
    print_msg("Enter your password:\t");
    18ce:	83 e4       	ldi	r24, 0x43	; 67
    18d0:	95 e0       	ldi	r25, 0x05	; 5
    18d2:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
    request_user_input(userPassword_prompt_handler, 11);
    18d6:	6b e0       	ldi	r22, 0x0B	; 11
    18d8:	81 e6       	ldi	r24, 0x61	; 97
    18da:	9c e0       	ldi	r25, 0x0C	; 12
    18dc:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    18e0:	08 95       	ret
    }
  else {
    if (strcmp(remote_user.password, msg_buffer)) { // Wrong password
    18e2:	6d ed       	ldi	r22, 0xDD	; 221
    18e4:	75 e0       	ldi	r23, 0x05	; 5
    18e6:	83 e0       	ldi	r24, 0x03	; 3
    18e8:	96 e0       	ldi	r25, 0x06	; 6
    18ea:	0e 94 31 12 	call	0x2462	; 0x2462 <strcmp>
    18ee:	89 2b       	or	r24, r25
    18f0:	81 f0       	breq	.+32     	; 0x1912 <userPassword_prompt_handler+0x50>
      print_msg("Wrong password!");
    18f2:	89 e5       	ldi	r24, 0x59	; 89
    18f4:	95 e0       	ldi	r25, 0x05	; 5
    18f6:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
      invalid_remote_login_attempt();
    18fa:	0e 94 22 0c 	call	0x1844	; 0x1844 <invalid_remote_login_attempt>
      print_msg("Enter your password:\t");
    18fe:	83 e4       	ldi	r24, 0x43	; 67
    1900:	95 e0       	ldi	r25, 0x05	; 5
    1902:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    1906:	6b e0       	ldi	r22, 0x0B	; 11
    1908:	81 e6       	ldi	r24, 0x61	; 97
    190a:	9c e0       	ldi	r25, 0x0C	; 12
    190c:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    1910:	08 95       	ret
      }
    else {
      remote_user_loggedin = true;
    1912:	81 e0       	ldi	r24, 0x01	; 1
    1914:	80 93 db 05 	sts	0x05DB, r24	; 0x8005db <remote_user_loggedin>
      print_msg("Welcome ");
    1918:	89 e6       	ldi	r24, 0x69	; 105
    191a:	95 e0       	ldi	r25, 0x05	; 5
    191c:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
      print_msg(remote_user.name);
    1920:	8f ee       	ldi	r24, 0xEF	; 239
    1922:	95 e0       	ldi	r25, 0x05	; 5
    1924:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
      println_msg("!");
    1928:	86 e5       	ldi	r24, 0x56	; 86
    192a:	91 e0       	ldi	r25, 0x01	; 1
    192c:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
      // Show the options menu
      print_initial_options_menu();
    1930:	0e 94 92 0a 	call	0x1524	; 0x1524 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1934:	62 e0       	ldi	r22, 0x02	; 2
    1936:	8c ee       	ldi	r24, 0xEC	; 236
    1938:	9a e0       	ldi	r25, 0x0A	; 10
    193a:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    193e:	08 95       	ret

00001940 <userName_prompt_handler>:
    }
  }

void userName_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    1940:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <invalid_user_input>
    1944:	88 23       	and	r24, r24
    1946:	61 f0       	breq	.+24     	; 0x1960 <userName_prompt_handler+0x20>
    invalid_remote_login_attempt();
    1948:	0e 94 22 0c 	call	0x1844	; 0x1844 <invalid_remote_login_attempt>
    print_msg("Enter your user name:\t");
    194c:	82 e7       	ldi	r24, 0x72	; 114
    194e:	95 e0       	ldi	r25, 0x05	; 5
    1950:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
    request_user_input(userName_prompt_handler, 13);
    1954:	6d e0       	ldi	r22, 0x0D	; 13
    1956:	80 ea       	ldi	r24, 0xA0	; 160
    1958:	9c e0       	ldi	r25, 0x0C	; 12
    195a:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    195e:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &remote_user);
    1960:	6e ee       	ldi	r22, 0xEE	; 238
    1962:	75 e0       	ldi	r23, 0x05	; 5
    1964:	8d ed       	ldi	r24, 0xDD	; 221
    1966:	95 e0       	ldi	r25, 0x05	; 5
    1968:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    196c:	83 30       	cpi	r24, 0x03	; 3
    196e:	81 f4       	brne	.+32     	; 0x1990 <userName_prompt_handler+0x50>
      print_msg("User doesn't exist!");
    1970:	89 e8       	ldi	r24, 0x89	; 137
    1972:	95 e0       	ldi	r25, 0x05	; 5
    1974:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
      invalid_remote_login_attempt();
    1978:	0e 94 22 0c 	call	0x1844	; 0x1844 <invalid_remote_login_attempt>
      print_msg("Enter your user name:\t");
    197c:	82 e7       	ldi	r24, 0x72	; 114
    197e:	95 e0       	ldi	r25, 0x05	; 5
    1980:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
      request_user_input(userName_prompt_handler, 13);
    1984:	6d e0       	ldi	r22, 0x0D	; 13
    1986:	80 ea       	ldi	r24, 0xA0	; 160
    1988:	9c e0       	ldi	r25, 0x0C	; 12
    198a:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    198e:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      print_msg("Enter your password:\t");
    1990:	83 e4       	ldi	r24, 0x43	; 67
    1992:	95 e0       	ldi	r25, 0x05	; 5
    1994:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    1998:	6b e0       	ldi	r22, 0x0B	; 11
    199a:	81 e6       	ldi	r24, 0x61	; 97
    199c:	9c e0       	ldi	r25, 0x0C	; 12
    199e:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    19a2:	08 95       	ret

000019a4 <remote_login_prompt>:
      }
    }
  }

void remote_login_prompt(void) {
  println_msg("Welcome to the Smart Home System!");
    19a4:	8d e9       	ldi	r24, 0x9D	; 157
    19a6:	95 e0       	ldi	r25, 0x05	; 5
    19a8:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
  println_msg("To proceed, please login.");
    19ac:	8f eb       	ldi	r24, 0xBF	; 191
    19ae:	95 e0       	ldi	r25, 0x05	; 5
    19b0:	0e 94 a9 09 	call	0x1352	; 0x1352 <println_msg>
  print_msg("Enter your user name:\t");
    19b4:	82 e7       	ldi	r24, 0x72	; 114
    19b6:	95 e0       	ldi	r25, 0x05	; 5
    19b8:	0e 94 b0 09 	call	0x1360	; 0x1360 <print_msg>
  request_user_input(userName_prompt_handler, 13);
    19bc:	6d e0       	ldi	r22, 0x0D	; 13
    19be:	80 ea       	ldi	r24, 0xA0	; 160
    19c0:	9c e0       	ldi	r25, 0x0C	; 12
    19c2:	0e 94 b3 09 	call	0x1366	; 0x1366 <request_user_input>
    19c6:	08 95       	ret

000019c8 <__vector_13>:
  }

// Handles the user input asynchronously.
ISR(USART_RXC_vect) {
    19c8:	1f 92       	push	r1
    19ca:	0f 92       	push	r0
    19cc:	0f b6       	in	r0, 0x3f	; 63
    19ce:	0f 92       	push	r0
    19d0:	11 24       	eor	r1, r1
    19d2:	2f 93       	push	r18
    19d4:	3f 93       	push	r19
    19d6:	4f 93       	push	r20
    19d8:	5f 93       	push	r21
    19da:	6f 93       	push	r22
    19dc:	7f 93       	push	r23
    19de:	8f 93       	push	r24
    19e0:	9f 93       	push	r25
    19e2:	af 93       	push	r26
    19e4:	bf 93       	push	r27
    19e6:	ef 93       	push	r30
    19e8:	ff 93       	push	r31
#if UART_COMMUNICATION_INTERFACE ==  PROTEUS_VIRTUAL_TERMINAL
  // Read the UDR to clear the RXC bit
  udr_temp = UDR;
    19ea:	8c b1       	in	r24, 0x0c	; 12
    19ec:	80 93 32 06 	sts	0x0632, r24	; 0x800632 <udr_temp>

  // If no input requested, ignore the input. No input requested is indicated by msg length of zero
  if (msg_length == 0) return;
    19f0:	90 91 ec 05 	lds	r25, 0x05EC	; 0x8005ec <msg_length>
    19f4:	99 23       	and	r25, r25
    19f6:	09 f4       	brne	.+2      	; 0x19fa <__vector_13+0x32>
    19f8:	51 c0       	rjmp	.+162    	; 0x1a9c <__vector_13+0xd4>

  // Handling backspaces
  if (udr_temp == '\b') {
    19fa:	88 30       	cpi	r24, 0x08	; 8
    19fc:	59 f4       	brne	.+22     	; 0x1a14 <__vector_13+0x4c>
    if (msg_buffer_pointer > 0) {
    19fe:	90 91 dc 05 	lds	r25, 0x05DC	; 0x8005dc <msg_buffer_pointer>
    1a02:	99 23       	and	r25, r25
    1a04:	09 f4       	brne	.+2      	; 0x1a08 <__vector_13+0x40>
    1a06:	4a c0       	rjmp	.+148    	; 0x1a9c <__vector_13+0xd4>
      msg_buffer_pointer--;
    1a08:	91 50       	subi	r25, 0x01	; 1
    1a0a:	90 93 dc 05 	sts	0x05DC, r25	; 0x8005dc <msg_buffer_pointer>
      BT_sendChar(udr_temp);
    1a0e:	0e 94 0b 02 	call	0x416	; 0x416 <BT_sendChar>
    1a12:	44 c0       	rjmp	.+136    	; 0x1a9c <__vector_13+0xd4>
      }
    return;
    }

  msg_buffer[msg_buffer_pointer] = udr_temp;
    1a14:	90 91 dc 05 	lds	r25, 0x05DC	; 0x8005dc <msg_buffer_pointer>
    1a18:	e9 2f       	mov	r30, r25
    1a1a:	f0 e0       	ldi	r31, 0x00	; 0
    1a1c:	e3 52       	subi	r30, 0x23	; 35
    1a1e:	fa 4f       	sbci	r31, 0xFA	; 250
    1a20:	80 83       	st	Z, r24
  msg_buffer_pointer++;
    1a22:	9f 5f       	subi	r25, 0xFF	; 255
    1a24:	90 93 dc 05 	sts	0x05DC, r25	; 0x8005dc <msg_buffer_pointer>

  // Msg is empty
  // Ignore null msgs
  if (msg_buffer_pointer == 1) {
    1a28:	91 30       	cpi	r25, 0x01	; 1
    1a2a:	39 f4       	brne	.+14     	; 0x1a3a <__vector_13+0x72>
    if (msg_buffer[0] == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1a2c:	90 91 dd 05 	lds	r25, 0x05DD	; 0x8005dd <msg_buffer>
    1a30:	9d 30       	cpi	r25, 0x0D	; 13
    1a32:	19 f4       	brne	.+6      	; 0x1a3a <__vector_13+0x72>
      msg_buffer_pointer = 0;
    1a34:	10 92 dc 05 	sts	0x05DC, r1	; 0x8005dc <msg_buffer_pointer>
      return;
    1a38:	31 c0       	rjmp	.+98     	; 0x1a9c <__vector_13+0xd4>
      }
    }

  // Echo the sent char on the terminal
  //! Proteus virtual terminal doesn't send a line feed char (ASCII code: 10). Instead it sends a carriage return (ASCII code: 13).
  if (udr_temp != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER)
    1a3a:	8d 30       	cpi	r24, 0x0D	; 13
    1a3c:	11 f0       	breq	.+4      	; 0x1a42 <__vector_13+0x7a>
    BT_sendChar(udr_temp);
    1a3e:	0e 94 0b 02 	call	0x416	; 0x416 <BT_sendChar>

  // Msg is longer than required
  if (msg_buffer_pointer == msg_length) {
    1a42:	e0 91 dc 05 	lds	r30, 0x05DC	; 0x8005dc <msg_buffer_pointer>
    1a46:	80 91 ec 05 	lds	r24, 0x05EC	; 0x8005ec <msg_length>
    1a4a:	e8 13       	cpse	r30, r24
    1a4c:	12 c0       	rjmp	.+36     	; 0x1a72 <__vector_13+0xaa>
    if (msg_buffer[msg_buffer_pointer - 1] != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1a4e:	f0 e0       	ldi	r31, 0x00	; 0
    1a50:	e4 52       	subi	r30, 0x24	; 36
    1a52:	fa 4f       	sbci	r31, 0xFA	; 250
    1a54:	80 81       	ld	r24, Z
    1a56:	8d 30       	cpi	r24, 0x0D	; 13
    1a58:	61 f0       	breq	.+24     	; 0x1a72 <__vector_13+0xaa>
      invalid_user_input = true;
    1a5a:	81 e0       	ldi	r24, 0x01	; 1
    1a5c:	80 93 ed 05 	sts	0x05ED, r24	; 0x8005ed <invalid_user_input>
      dump_invalid_data = true;
    1a60:	80 93 2e 06 	sts	0x062E, r24	; 0x80062e <dump_invalid_data>
      msg_buffer_pointer = 0;
    1a64:	10 92 dc 05 	sts	0x05DC, r1	; 0x8005dc <msg_buffer_pointer>
      BT_sendChar('\r');
    1a68:	8d e0       	ldi	r24, 0x0D	; 13
    1a6a:	0e 94 0b 02 	call	0x416	; 0x416 <BT_sendChar>
      callFunWhenBufferReady();
    1a6e:	0e 94 a3 09 	call	0x1346	; 0x1346 <callFunWhenBufferReady>
      }
    }

  // Msg has ended and is within the required length
  if (udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1a72:	80 91 32 06 	lds	r24, 0x0632	; 0x800632 <udr_temp>
    1a76:	8d 30       	cpi	r24, 0x0D	; 13
    1a78:	89 f4       	brne	.+34     	; 0x1a9c <__vector_13+0xd4>
    if (msg_buffer_pointer <= msg_length) {
    1a7a:	e0 91 dc 05 	lds	r30, 0x05DC	; 0x8005dc <msg_buffer_pointer>
    1a7e:	80 91 ec 05 	lds	r24, 0x05EC	; 0x8005ec <msg_length>
    1a82:	8e 17       	cp	r24, r30
    1a84:	58 f0       	brcs	.+22     	; 0x1a9c <__vector_13+0xd4>
      // Replace the carriage return with null to terminate the string correctly
      msg_buffer[msg_buffer_pointer - 1] = '\0';
    1a86:	f0 e0       	ldi	r31, 0x00	; 0
    1a88:	e4 52       	subi	r30, 0x24	; 36
    1a8a:	fa 4f       	sbci	r31, 0xFA	; 250
    1a8c:	10 82       	st	Z, r1
      BT_sendChar('\r');
    1a8e:	8d e0       	ldi	r24, 0x0D	; 13
    1a90:	0e 94 0b 02 	call	0x416	; 0x416 <BT_sendChar>
      callFunWhenBufferReady();
    1a94:	0e 94 a3 09 	call	0x1346	; 0x1346 <callFunWhenBufferReady>
      msg_buffer_pointer = 0;
    1a98:	10 92 dc 05 	sts	0x05DC, r1	; 0x8005dc <msg_buffer_pointer>
      callFunWhenBufferReady();
      msg_buffer_pointer = 0;
      }
    }
#endif
  }
    1a9c:	ff 91       	pop	r31
    1a9e:	ef 91       	pop	r30
    1aa0:	bf 91       	pop	r27
    1aa2:	af 91       	pop	r26
    1aa4:	9f 91       	pop	r25
    1aa6:	8f 91       	pop	r24
    1aa8:	7f 91       	pop	r23
    1aaa:	6f 91       	pop	r22
    1aac:	5f 91       	pop	r21
    1aae:	4f 91       	pop	r20
    1ab0:	3f 91       	pop	r19
    1ab2:	2f 91       	pop	r18
    1ab4:	0f 90       	pop	r0
    1ab6:	0f be       	out	0x3f, r0	; 63
    1ab8:	0f 90       	pop	r0
    1aba:	1f 90       	pop	r1
    1abc:	18 95       	reti

00001abe <__vector_1>:

ISR(INT0_vect) {
    1abe:	1f 92       	push	r1
    1ac0:	0f 92       	push	r0
    1ac2:	0f b6       	in	r0, 0x3f	; 63
    1ac4:	0f 92       	push	r0
    1ac6:	11 24       	eor	r1, r1
    1ac8:	2f 93       	push	r18
    1aca:	3f 93       	push	r19
    1acc:	4f 93       	push	r20
    1ace:	5f 93       	push	r21
    1ad0:	6f 93       	push	r22
    1ad2:	7f 93       	push	r23
    1ad4:	8f 93       	push	r24
    1ad6:	9f 93       	push	r25
    1ad8:	af 93       	push	r26
    1ada:	bf 93       	push	r27
    1adc:	ef 93       	push	r30
    1ade:	ff 93       	push	r31
  // Initialize communication with the user
  // Request user login credentials
  remote_login_prompt();
    1ae0:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <remote_login_prompt>
  }
    1ae4:	ff 91       	pop	r31
    1ae6:	ef 91       	pop	r30
    1ae8:	bf 91       	pop	r27
    1aea:	af 91       	pop	r26
    1aec:	9f 91       	pop	r25
    1aee:	8f 91       	pop	r24
    1af0:	7f 91       	pop	r23
    1af2:	6f 91       	pop	r22
    1af4:	5f 91       	pop	r21
    1af6:	4f 91       	pop	r20
    1af8:	3f 91       	pop	r19
    1afa:	2f 91       	pop	r18
    1afc:	0f 90       	pop	r0
    1afe:	0f be       	out	0x3f, r0	; 63
    1b00:	0f 90       	pop	r0
    1b02:	1f 90       	pop	r1
    1b04:	18 95       	reti

00001b06 <AC_auto_control_service_start>:
  DIO_write(AC_PIN, AC_PORT, LOW);
  // Turn off the timer
#if AC_ADC_TRIGGER == TIMER_0_COMPARE_MATCH_TRIGGER
  Timer_stop(TIMER_0);
#elif AC_ADC_TRIGGER == TIMER_0_OVF_TRIGGER
  Timer_stop(TIMER_0);
    1b06:	64 e0       	ldi	r22, 0x04	; 4
    1b08:	87 e0       	ldi	r24, 0x07	; 7
    1b0a:	0e 94 09 03 	call	0x612	; 0x612 <LM35_init_INT>
    1b0e:	41 e0       	ldi	r20, 0x01	; 1
    1b10:	63 e4       	ldi	r22, 0x43	; 67
    1b12:	87 e0       	ldi	r24, 0x07	; 7
    1b14:	0e 94 ac 03 	call	0x758	; 0x758 <DIO_init>
    1b18:	0e 94 54 05 	call	0xaa8	; 0xaa8 <ADC_INT_init>
    1b1c:	60 e0       	ldi	r22, 0x00	; 0
    1b1e:	70 e0       	ldi	r23, 0x00	; 0
    1b20:	80 e0       	ldi	r24, 0x00	; 0
    1b22:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <Timer_normal_init>
    1b26:	60 e0       	ldi	r22, 0x00	; 0
    1b28:	74 e0       	ldi	r23, 0x04	; 4
    1b2a:	80 e0       	ldi	r24, 0x00	; 0
    1b2c:	0e 94 2d 07 	call	0xe5a	; 0xe5a <Timer_start>
    1b30:	08 95       	ret

00001b32 <__vector_16>:
#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_BY_ACTIVATING_TIMER0_OVF_INT
// To reset the TOV0 flag. Alternatively, it can be reset in the ADC complete interrupt.
ISR(TIMER0_OVF_vect) {}
#endif

ISR(ADC_vect) {
    1b32:	1f 92       	push	r1
    1b34:	0f 92       	push	r0
    1b36:	0f b6       	in	r0, 0x3f	; 63
    1b38:	0f 92       	push	r0
    1b3a:	11 24       	eor	r1, r1
    1b3c:	2f 93       	push	r18
    1b3e:	3f 93       	push	r19
    1b40:	4f 93       	push	r20
    1b42:	5f 93       	push	r21
    1b44:	6f 93       	push	r22
    1b46:	7f 93       	push	r23
    1b48:	8f 93       	push	r24
    1b4a:	9f 93       	push	r25
    1b4c:	af 93       	push	r26
    1b4e:	bf 93       	push	r27
    1b50:	cf 93       	push	r28
    1b52:	df 93       	push	r29
    1b54:	ef 93       	push	r30
    1b56:	ff 93       	push	r31
  u16 temperature;
  temperature = ADCL + (ADCH << 8);
    1b58:	84 b1       	in	r24, 0x04	; 4
    1b5a:	c5 b1       	in	r28, 0x05	; 5
    1b5c:	d0 e0       	ldi	r29, 0x00	; 0
    1b5e:	dc 2f       	mov	r29, r28
    1b60:	cc 27       	eor	r28, r28
    1b62:	c8 0f       	add	r28, r24
    1b64:	d1 1d       	adc	r29, r1
  // Since the ADC is set to use the internal VREF of 2.56 V, the resolution of the ADC is 2.5 mV. This resolution allows to measure the temperature
  // out of the LM35 with a resolution of 0.25 degree celsius, since each 10mV  increment on the LM35 output is 1 degree C.
  // If the temperature is higher than the maximum specified temperature, turn on the AC.
  if (temperature > AMBIENT_HIGH_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, HIGH);
    1b66:	c1 37       	cpi	r28, 0x71	; 113
    1b68:	d1 05       	cpc	r29, r1
    1b6a:	28 f0       	brcs	.+10     	; 0x1b76 <__vector_16+0x44>
    1b6c:	41 e0       	ldi	r20, 0x01	; 1
    1b6e:	63 e4       	ldi	r22, 0x43	; 67
    1b70:	87 e0       	ldi	r24, 0x07	; 7
    1b72:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>
  // If the temperature became below the minimum specified temperature turn off the AC.
  if (temperature < AMBIENT_LOW_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, LOW);
    1b76:	c4 35       	cpi	r28, 0x54	; 84
    1b78:	d1 05       	cpc	r29, r1
    1b7a:	28 f4       	brcc	.+10     	; 0x1b86 <__vector_16+0x54>
    1b7c:	40 e0       	ldi	r20, 0x00	; 0
    1b7e:	63 e4       	ldi	r22, 0x43	; 67
    1b80:	87 e0       	ldi	r24, 0x07	; 7
    1b82:	0e 94 46 04 	call	0x88c	; 0x88c <DIO_write>

#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_VIA_ADC_COMPLETE_INTERRUPT
  // Since the ADC is configured in auto trigger mode with timer 0 overflow as the trigger, 
  // The overflow interrupt flag bit must be cleared by software if timer 0 overflow interrupt isn't used. 
  // Otherwise the triggering won't work and the ADC will halt.
  set_bit(TIFR, TOV0);
    1b86:	88 b7       	in	r24, 0x38	; 56
    1b88:	81 60       	ori	r24, 0x01	; 1
    1b8a:	88 bf       	out	0x38, r24	; 56
#endif
    1b8c:	ff 91       	pop	r31
    1b8e:	ef 91       	pop	r30
    1b90:	df 91       	pop	r29
    1b92:	cf 91       	pop	r28
    1b94:	bf 91       	pop	r27
    1b96:	af 91       	pop	r26
    1b98:	9f 91       	pop	r25
    1b9a:	8f 91       	pop	r24
    1b9c:	7f 91       	pop	r23
    1b9e:	6f 91       	pop	r22
    1ba0:	5f 91       	pop	r21
    1ba2:	4f 91       	pop	r20
    1ba4:	3f 91       	pop	r19
    1ba6:	2f 91       	pop	r18
    1ba8:	0f 90       	pop	r0
    1baa:	0f be       	out	0x3f, r0	; 63
    1bac:	0f 90       	pop	r0
    1bae:	1f 90       	pop	r1
    1bb0:	18 95       	reti

00001bb2 <getUserByName>:
    }
  }

bool validate_user_password(ST_User_t* user, s8* password) {
  return (strcmp(user->password, password) == 0);
  }
    1bb2:	9f 92       	push	r9
    1bb4:	af 92       	push	r10
    1bb6:	bf 92       	push	r11
    1bb8:	cf 92       	push	r12
    1bba:	df 92       	push	r13
    1bbc:	ef 92       	push	r14
    1bbe:	ff 92       	push	r15
    1bc0:	0f 93       	push	r16
    1bc2:	1f 93       	push	r17
    1bc4:	cf 93       	push	r28
    1bc6:	df 93       	push	r29
    1bc8:	cd b7       	in	r28, 0x3d	; 61
    1bca:	de b7       	in	r29, 0x3e	; 62
    1bcc:	6d 97       	sbiw	r28, 0x1d	; 29
    1bce:	0f b6       	in	r0, 0x3f	; 63
    1bd0:	f8 94       	cli
    1bd2:	de bf       	out	0x3e, r29	; 62
    1bd4:	0f be       	out	0x3f, r0	; 63
    1bd6:	cd bf       	out	0x3d, r28	; 61
    1bd8:	7c 01       	movw	r14, r24
    1bda:	6b 01       	movw	r12, r22
    1bdc:	91 2c       	mov	r9, r1
    1bde:	6b c0       	rjmp	.+214    	; 0x1cb6 <getUserByName+0x104>
    1be0:	ae 01       	movw	r20, r28
    1be2:	4f 5f       	subi	r20, 0xFF	; 255
    1be4:	5f 4f       	sbci	r21, 0xFF	; 255
    1be6:	60 e0       	ldi	r22, 0x00	; 0
    1be8:	89 2d       	mov	r24, r9
    1bea:	0e 94 cc 00 	call	0x198	; 0x198 <EEPROM_read_byte>
    1bee:	ae 01       	movw	r20, r28
    1bf0:	4e 5f       	subi	r20, 0xFE	; 254
    1bf2:	5f 4f       	sbci	r21, 0xFF	; 255
    1bf4:	61 e0       	ldi	r22, 0x01	; 1
    1bf6:	89 2d       	mov	r24, r9
    1bf8:	0e 94 cc 00 	call	0x198	; 0x198 <EEPROM_read_byte>
    1bfc:	b1 2c       	mov	r11, r1
    1bfe:	56 c0       	rjmp	.+172    	; 0x1cac <getUserByName+0xfa>
    1c00:	89 81       	ldd	r24, Y+1	; 0x01
    1c02:	90 e0       	ldi	r25, 0x00	; 0
    1c04:	0b 2c       	mov	r0, r11
    1c06:	02 c0       	rjmp	.+4      	; 0x1c0c <getUserByName+0x5a>
    1c08:	95 95       	asr	r25
    1c0a:	87 95       	ror	r24
    1c0c:	0a 94       	dec	r0
    1c0e:	e2 f7       	brpl	.-8      	; 0x1c08 <getUserByName+0x56>
    1c10:	80 ff       	sbrs	r24, 0
    1c12:	4b c0       	rjmp	.+150    	; 0x1caa <getUserByName+0xf8>
    1c14:	6f e1       	ldi	r22, 0x1F	; 31
    1c16:	b6 9e       	mul	r11, r22
    1c18:	a0 2c       	mov	r10, r0
    1c1a:	11 24       	eor	r1, r1
    1c1c:	68 e0       	ldi	r22, 0x08	; 8
    1c1e:	6a 0d       	add	r22, r10
    1c20:	9e 01       	movw	r18, r28
    1c22:	2d 5f       	subi	r18, 0xFD	; 253
    1c24:	3f 4f       	sbci	r19, 0xFF	; 255
    1c26:	4d e0       	ldi	r20, 0x0D	; 13
    1c28:	50 e0       	ldi	r21, 0x00	; 0
    1c2a:	89 2d       	mov	r24, r9
    1c2c:	0e 94 ed 00 	call	0x1da	; 0x1da <EEPROM_read_block>
    1c30:	be 01       	movw	r22, r28
    1c32:	6d 5f       	subi	r22, 0xFD	; 253
    1c34:	7f 4f       	sbci	r23, 0xFF	; 255
    1c36:	c7 01       	movw	r24, r14
    1c38:	0e 94 31 12 	call	0x2462	; 0x2462 <strcmp>
    1c3c:	89 2b       	or	r24, r25
    1c3e:	a9 f5       	brne	.+106    	; 0x1caa <getUserByName+0xf8>
    1c40:	65 e1       	ldi	r22, 0x15	; 21
    1c42:	6a 0d       	add	r22, r10
    1c44:	9e 01       	movw	r18, r28
    1c46:	20 5f       	subi	r18, 0xF0	; 240
    1c48:	3f 4f       	sbci	r19, 0xFF	; 255
    1c4a:	47 e0       	ldi	r20, 0x07	; 7
    1c4c:	50 e0       	ldi	r21, 0x00	; 0
    1c4e:	89 2d       	mov	r24, r9
    1c50:	0e 94 ed 00 	call	0x1da	; 0x1da <EEPROM_read_block>
    1c54:	6c e1       	ldi	r22, 0x1C	; 28
    1c56:	6a 0d       	add	r22, r10
    1c58:	9e 01       	movw	r18, r28
    1c5a:	29 5e       	subi	r18, 0xE9	; 233
    1c5c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c5e:	47 e0       	ldi	r20, 0x07	; 7
    1c60:	50 e0       	ldi	r21, 0x00	; 0
    1c62:	89 2d       	mov	r24, r9
    1c64:	0e 94 ed 00 	call	0x1da	; 0x1da <EEPROM_read_block>
    1c68:	8a 81       	ldd	r24, Y+2	; 0x02
    1c6a:	90 e0       	ldi	r25, 0x00	; 0
    1c6c:	02 c0       	rjmp	.+4      	; 0x1c72 <getUserByName+0xc0>
    1c6e:	95 95       	asr	r25
    1c70:	87 95       	ror	r24
    1c72:	ba 94       	dec	r11
    1c74:	e2 f7       	brpl	.-8      	; 0x1c6e <getUserByName+0xbc>
    1c76:	98 2f       	mov	r25, r24
    1c78:	91 70       	andi	r25, 0x01	; 1
    1c7a:	f6 01       	movw	r30, r12
    1c7c:	91 93       	st	Z+, r25
    1c7e:	be 01       	movw	r22, r28
    1c80:	6d 5f       	subi	r22, 0xFD	; 253
    1c82:	7f 4f       	sbci	r23, 0xFF	; 255
    1c84:	cf 01       	movw	r24, r30
    1c86:	0e 94 3a 12 	call	0x2474	; 0x2474 <strcpy>
    1c8a:	be 01       	movw	r22, r28
    1c8c:	60 5f       	subi	r22, 0xF0	; 240
    1c8e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c90:	c6 01       	movw	r24, r12
    1c92:	0e 96       	adiw	r24, 0x0e	; 14
    1c94:	0e 94 3a 12 	call	0x2474	; 0x2474 <strcpy>
    1c98:	be 01       	movw	r22, r28
    1c9a:	69 5e       	subi	r22, 0xE9	; 233
    1c9c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c9e:	c6 01       	movw	r24, r12
    1ca0:	45 96       	adiw	r24, 0x15	; 21
    1ca2:	0e 94 3a 12 	call	0x2474	; 0x2474 <strcpy>
    1ca6:	82 e0       	ldi	r24, 0x02	; 2
    1ca8:	0b c0       	rjmp	.+22     	; 0x1cc0 <getUserByName+0x10e>
    1caa:	b3 94       	inc	r11
    1cac:	87 e0       	ldi	r24, 0x07	; 7
    1cae:	8b 15       	cp	r24, r11
    1cb0:	08 f0       	brcs	.+2      	; 0x1cb4 <getUserByName+0x102>
    1cb2:	a6 cf       	rjmp	.-180    	; 0x1c00 <getUserByName+0x4e>
    1cb4:	93 94       	inc	r9
    1cb6:	87 e0       	ldi	r24, 0x07	; 7
    1cb8:	89 15       	cp	r24, r9
    1cba:	08 f0       	brcs	.+2      	; 0x1cbe <getUserByName+0x10c>
    1cbc:	91 cf       	rjmp	.-222    	; 0x1be0 <getUserByName+0x2e>
    1cbe:	83 e0       	ldi	r24, 0x03	; 3
    1cc0:	6d 96       	adiw	r28, 0x1d	; 29
    1cc2:	0f b6       	in	r0, 0x3f	; 63
    1cc4:	f8 94       	cli
    1cc6:	de bf       	out	0x3e, r29	; 62
    1cc8:	0f be       	out	0x3f, r0	; 63
    1cca:	cd bf       	out	0x3d, r28	; 61
    1ccc:	df 91       	pop	r29
    1cce:	cf 91       	pop	r28
    1cd0:	1f 91       	pop	r17
    1cd2:	0f 91       	pop	r16
    1cd4:	ff 90       	pop	r15
    1cd6:	ef 90       	pop	r14
    1cd8:	df 90       	pop	r13
    1cda:	cf 90       	pop	r12
    1cdc:	bf 90       	pop	r11
    1cde:	af 90       	pop	r10
    1ce0:	9f 90       	pop	r9
    1ce2:	08 95       	ret

00001ce4 <getUserByCode>:
    1ce4:	9f 92       	push	r9
    1ce6:	af 92       	push	r10
    1ce8:	bf 92       	push	r11
    1cea:	cf 92       	push	r12
    1cec:	df 92       	push	r13
    1cee:	ef 92       	push	r14
    1cf0:	ff 92       	push	r15
    1cf2:	0f 93       	push	r16
    1cf4:	1f 93       	push	r17
    1cf6:	cf 93       	push	r28
    1cf8:	df 93       	push	r29
    1cfa:	cd b7       	in	r28, 0x3d	; 61
    1cfc:	de b7       	in	r29, 0x3e	; 62
    1cfe:	6d 97       	sbiw	r28, 0x1d	; 29
    1d00:	0f b6       	in	r0, 0x3f	; 63
    1d02:	f8 94       	cli
    1d04:	de bf       	out	0x3e, r29	; 62
    1d06:	0f be       	out	0x3f, r0	; 63
    1d08:	cd bf       	out	0x3d, r28	; 61
    1d0a:	7c 01       	movw	r14, r24
    1d0c:	6b 01       	movw	r12, r22
    1d0e:	91 2c       	mov	r9, r1
    1d10:	6b c0       	rjmp	.+214    	; 0x1de8 <getUserByCode+0x104>
    1d12:	ae 01       	movw	r20, r28
    1d14:	4f 5f       	subi	r20, 0xFF	; 255
    1d16:	5f 4f       	sbci	r21, 0xFF	; 255
    1d18:	60 e0       	ldi	r22, 0x00	; 0
    1d1a:	89 2d       	mov	r24, r9
    1d1c:	0e 94 cc 00 	call	0x198	; 0x198 <EEPROM_read_byte>
    1d20:	ae 01       	movw	r20, r28
    1d22:	4e 5f       	subi	r20, 0xFE	; 254
    1d24:	5f 4f       	sbci	r21, 0xFF	; 255
    1d26:	61 e0       	ldi	r22, 0x01	; 1
    1d28:	89 2d       	mov	r24, r9
    1d2a:	0e 94 cc 00 	call	0x198	; 0x198 <EEPROM_read_byte>
    1d2e:	b1 2c       	mov	r11, r1
    1d30:	56 c0       	rjmp	.+172    	; 0x1dde <getUserByCode+0xfa>
    1d32:	89 81       	ldd	r24, Y+1	; 0x01
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	0b 2c       	mov	r0, r11
    1d38:	02 c0       	rjmp	.+4      	; 0x1d3e <getUserByCode+0x5a>
    1d3a:	95 95       	asr	r25
    1d3c:	87 95       	ror	r24
    1d3e:	0a 94       	dec	r0
    1d40:	e2 f7       	brpl	.-8      	; 0x1d3a <getUserByCode+0x56>
    1d42:	80 ff       	sbrs	r24, 0
    1d44:	4b c0       	rjmp	.+150    	; 0x1ddc <getUserByCode+0xf8>
    1d46:	6f e1       	ldi	r22, 0x1F	; 31
    1d48:	b6 9e       	mul	r11, r22
    1d4a:	a0 2c       	mov	r10, r0
    1d4c:	11 24       	eor	r1, r1
    1d4e:	65 e1       	ldi	r22, 0x15	; 21
    1d50:	6a 0d       	add	r22, r10
    1d52:	9e 01       	movw	r18, r28
    1d54:	20 5f       	subi	r18, 0xF0	; 240
    1d56:	3f 4f       	sbci	r19, 0xFF	; 255
    1d58:	47 e0       	ldi	r20, 0x07	; 7
    1d5a:	50 e0       	ldi	r21, 0x00	; 0
    1d5c:	89 2d       	mov	r24, r9
    1d5e:	0e 94 ed 00 	call	0x1da	; 0x1da <EEPROM_read_block>
    1d62:	be 01       	movw	r22, r28
    1d64:	60 5f       	subi	r22, 0xF0	; 240
    1d66:	7f 4f       	sbci	r23, 0xFF	; 255
    1d68:	c7 01       	movw	r24, r14
    1d6a:	0e 94 31 12 	call	0x2462	; 0x2462 <strcmp>
    1d6e:	89 2b       	or	r24, r25
    1d70:	a9 f5       	brne	.+106    	; 0x1ddc <getUserByCode+0xf8>
    1d72:	68 e0       	ldi	r22, 0x08	; 8
    1d74:	6a 0d       	add	r22, r10
    1d76:	9e 01       	movw	r18, r28
    1d78:	2d 5f       	subi	r18, 0xFD	; 253
    1d7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1d7c:	4d e0       	ldi	r20, 0x0D	; 13
    1d7e:	50 e0       	ldi	r21, 0x00	; 0
    1d80:	89 2d       	mov	r24, r9
    1d82:	0e 94 ed 00 	call	0x1da	; 0x1da <EEPROM_read_block>
    1d86:	6c e1       	ldi	r22, 0x1C	; 28
    1d88:	6a 0d       	add	r22, r10
    1d8a:	9e 01       	movw	r18, r28
    1d8c:	29 5e       	subi	r18, 0xE9	; 233
    1d8e:	3f 4f       	sbci	r19, 0xFF	; 255
    1d90:	47 e0       	ldi	r20, 0x07	; 7
    1d92:	50 e0       	ldi	r21, 0x00	; 0
    1d94:	89 2d       	mov	r24, r9
    1d96:	0e 94 ed 00 	call	0x1da	; 0x1da <EEPROM_read_block>
    1d9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
    1d9e:	02 c0       	rjmp	.+4      	; 0x1da4 <getUserByCode+0xc0>
    1da0:	95 95       	asr	r25
    1da2:	87 95       	ror	r24
    1da4:	ba 94       	dec	r11
    1da6:	e2 f7       	brpl	.-8      	; 0x1da0 <getUserByCode+0xbc>
    1da8:	98 2f       	mov	r25, r24
    1daa:	91 70       	andi	r25, 0x01	; 1
    1dac:	f6 01       	movw	r30, r12
    1dae:	91 93       	st	Z+, r25
    1db0:	be 01       	movw	r22, r28
    1db2:	6d 5f       	subi	r22, 0xFD	; 253
    1db4:	7f 4f       	sbci	r23, 0xFF	; 255
    1db6:	cf 01       	movw	r24, r30
    1db8:	0e 94 3a 12 	call	0x2474	; 0x2474 <strcpy>
    1dbc:	be 01       	movw	r22, r28
    1dbe:	60 5f       	subi	r22, 0xF0	; 240
    1dc0:	7f 4f       	sbci	r23, 0xFF	; 255
    1dc2:	c6 01       	movw	r24, r12
    1dc4:	0e 96       	adiw	r24, 0x0e	; 14
    1dc6:	0e 94 3a 12 	call	0x2474	; 0x2474 <strcpy>
    1dca:	be 01       	movw	r22, r28
    1dcc:	69 5e       	subi	r22, 0xE9	; 233
    1dce:	7f 4f       	sbci	r23, 0xFF	; 255
    1dd0:	c6 01       	movw	r24, r12
    1dd2:	45 96       	adiw	r24, 0x15	; 21
    1dd4:	0e 94 3a 12 	call	0x2474	; 0x2474 <strcpy>
    1dd8:	82 e0       	ldi	r24, 0x02	; 2
    1dda:	0b c0       	rjmp	.+22     	; 0x1df2 <getUserByCode+0x10e>
    1ddc:	b3 94       	inc	r11
    1dde:	87 e0       	ldi	r24, 0x07	; 7
    1de0:	8b 15       	cp	r24, r11
    1de2:	08 f0       	brcs	.+2      	; 0x1de6 <getUserByCode+0x102>
    1de4:	a6 cf       	rjmp	.-180    	; 0x1d32 <getUserByCode+0x4e>
    1de6:	93 94       	inc	r9
    1de8:	87 e0       	ldi	r24, 0x07	; 7
    1dea:	89 15       	cp	r24, r9
    1dec:	08 f0       	brcs	.+2      	; 0x1df0 <getUserByCode+0x10c>
    1dee:	91 cf       	rjmp	.-222    	; 0x1d12 <getUserByCode+0x2e>
    1df0:	83 e0       	ldi	r24, 0x03	; 3
    1df2:	6d 96       	adiw	r28, 0x1d	; 29
    1df4:	0f b6       	in	r0, 0x3f	; 63
    1df6:	f8 94       	cli
    1df8:	de bf       	out	0x3e, r29	; 62
    1dfa:	0f be       	out	0x3f, r0	; 63
    1dfc:	cd bf       	out	0x3d, r28	; 61
    1dfe:	df 91       	pop	r29
    1e00:	cf 91       	pop	r28
    1e02:	1f 91       	pop	r17
    1e04:	0f 91       	pop	r16
    1e06:	ff 90       	pop	r15
    1e08:	ef 90       	pop	r14
    1e0a:	df 90       	pop	r13
    1e0c:	cf 90       	pop	r12
    1e0e:	bf 90       	pop	r11
    1e10:	af 90       	pop	r10
    1e12:	9f 90       	pop	r9
    1e14:	08 95       	ret

00001e16 <set_alarm>:

void set_alarm(void) {
  Buzzer_on(BUZZER_PORT, BUZZER_PIN);
    1e16:	66 e0       	ldi	r22, 0x06	; 6
    1e18:	84 e4       	ldi	r24, 0x44	; 68
    1e1a:	0e 94 c0 00 	call	0x180	; 0x180 <Buzzer_on>
    1e1e:	08 95       	ret

00001e20 <write_user>:
  }

void write_user(u8 userBlockIndex, ST_User_t* user) {
    1e20:	ef 92       	push	r14
    1e22:	ff 92       	push	r15
    1e24:	0f 93       	push	r16
    1e26:	1f 93       	push	r17
    1e28:	cf 93       	push	r28
    1e2a:	df 93       	push	r29
    1e2c:	00 d0       	rcall	.+0      	; 0x1e2e <write_user+0xe>
    1e2e:	cd b7       	in	r28, 0x3d	; 61
    1e30:	de b7       	in	r29, 0x3e	; 62
    1e32:	7b 01       	movw	r14, r22
  // Get the user block location (page - index)
  u8 page = userBlockIndex / 8;
    1e34:	08 2f       	mov	r16, r24
    1e36:	06 95       	lsr	r16
    1e38:	06 95       	lsr	r16
    1e3a:	06 95       	lsr	r16
  u8 blockNumber = userBlockIndex % 8;
    1e3c:	18 2f       	mov	r17, r24
    1e3e:	17 70       	andi	r17, 0x07	; 7
  // Read and update the block status (reserve the block). And update the user authority level flag if the user is admin
  u8 usersBlockStatus, usersAuthorityLevel;
  EEPROM_read_byte(page, 0, &usersBlockStatus);
    1e40:	ae 01       	movw	r20, r28
    1e42:	4f 5f       	subi	r20, 0xFF	; 255
    1e44:	5f 4f       	sbci	r21, 0xFF	; 255
    1e46:	60 e0       	ldi	r22, 0x00	; 0
    1e48:	80 2f       	mov	r24, r16
    1e4a:	0e 94 cc 00 	call	0x198	; 0x198 <EEPROM_read_byte>
  EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    1e4e:	ae 01       	movw	r20, r28
    1e50:	4e 5f       	subi	r20, 0xFE	; 254
    1e52:	5f 4f       	sbci	r21, 0xFF	; 255
    1e54:	61 e0       	ldi	r22, 0x01	; 1
    1e56:	80 2f       	mov	r24, r16
    1e58:	0e 94 cc 00 	call	0x198	; 0x198 <EEPROM_read_byte>
  set_bit(usersBlockStatus, blockNumber);
    1e5c:	81 e0       	ldi	r24, 0x01	; 1
    1e5e:	90 e0       	ldi	r25, 0x00	; 0
    1e60:	01 2e       	mov	r0, r17
    1e62:	02 c0       	rjmp	.+4      	; 0x1e68 <write_user+0x48>
    1e64:	88 0f       	add	r24, r24
    1e66:	99 1f       	adc	r25, r25
    1e68:	0a 94       	dec	r0
    1e6a:	e2 f7       	brpl	.-8      	; 0x1e64 <write_user+0x44>
    1e6c:	49 81       	ldd	r20, Y+1	; 0x01
    1e6e:	48 2b       	or	r20, r24
    1e70:	49 83       	std	Y+1, r20	; 0x01
  if (user->isAdmin) set_bit(usersAuthorityLevel, blockNumber);
    1e72:	f7 01       	movw	r30, r14
    1e74:	20 81       	ld	r18, Z
    1e76:	22 23       	and	r18, r18
    1e78:	19 f0       	breq	.+6      	; 0x1e80 <write_user+0x60>
    1e7a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e7c:	89 2b       	or	r24, r25
    1e7e:	8a 83       	std	Y+2, r24	; 0x02
  EEPROM_write_byte(page, 0, usersBlockStatus);
    1e80:	60 e0       	ldi	r22, 0x00	; 0
    1e82:	80 2f       	mov	r24, r16
    1e84:	0e 94 23 01 	call	0x246	; 0x246 <EEPROM_write_byte>
  EEPROM_write_byte(page, 1, usersAuthorityLevel);
    1e88:	4a 81       	ldd	r20, Y+2	; 0x02
    1e8a:	61 e0       	ldi	r22, 0x01	; 1
    1e8c:	80 2f       	mov	r24, r16
    1e8e:	0e 94 23 01 	call	0x246	; 0x246 <EEPROM_write_byte>
  // Write the user data
  EEPROM_write_block(page, 8 + 31 * blockNumber, 13, user->name);
    1e92:	97 01       	movw	r18, r14
    1e94:	2f 5f       	subi	r18, 0xFF	; 255
    1e96:	3f 4f       	sbci	r19, 0xFF	; 255
    1e98:	6f e1       	ldi	r22, 0x1F	; 31
    1e9a:	16 9f       	mul	r17, r22
    1e9c:	10 2d       	mov	r17, r0
    1e9e:	11 24       	eor	r1, r1
    1ea0:	68 e0       	ldi	r22, 0x08	; 8
    1ea2:	61 0f       	add	r22, r17
    1ea4:	4d e0       	ldi	r20, 0x0D	; 13
    1ea6:	50 e0       	ldi	r21, 0x00	; 0
    1ea8:	80 2f       	mov	r24, r16
    1eaa:	0e 94 42 01 	call	0x284	; 0x284 <EEPROM_write_block>
  EEPROM_write_block(page, 21 + 31 * blockNumber, 7, user->code);
    1eae:	97 01       	movw	r18, r14
    1eb0:	22 5f       	subi	r18, 0xF2	; 242
    1eb2:	3f 4f       	sbci	r19, 0xFF	; 255
    1eb4:	65 e1       	ldi	r22, 0x15	; 21
    1eb6:	61 0f       	add	r22, r17
    1eb8:	47 e0       	ldi	r20, 0x07	; 7
    1eba:	50 e0       	ldi	r21, 0x00	; 0
    1ebc:	80 2f       	mov	r24, r16
    1ebe:	0e 94 42 01 	call	0x284	; 0x284 <EEPROM_write_block>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
    1ec2:	97 01       	movw	r18, r14
    1ec4:	2b 5e       	subi	r18, 0xEB	; 235
    1ec6:	3f 4f       	sbci	r19, 0xFF	; 255
    1ec8:	6c e1       	ldi	r22, 0x1C	; 28
    1eca:	61 0f       	add	r22, r17
    1ecc:	4b e0       	ldi	r20, 0x0B	; 11
    1ece:	50 e0       	ldi	r21, 0x00	; 0
    1ed0:	80 2f       	mov	r24, r16
    1ed2:	0e 94 42 01 	call	0x284	; 0x284 <EEPROM_write_block>
  }
    1ed6:	0f 90       	pop	r0
    1ed8:	0f 90       	pop	r0
    1eda:	df 91       	pop	r29
    1edc:	cf 91       	pop	r28
    1ede:	1f 91       	pop	r17
    1ee0:	0f 91       	pop	r16
    1ee2:	ff 90       	pop	r15
    1ee4:	ef 90       	pop	r14
    1ee6:	08 95       	ret

00001ee8 <add_user>:

EN_UserStatusCode_t add_user(ST_User_t* user) {
    1ee8:	ef 92       	push	r14
    1eea:	ff 92       	push	r15
    1eec:	1f 93       	push	r17
    1eee:	cf 93       	push	r28
    1ef0:	df 93       	push	r29
    1ef2:	1f 92       	push	r1
    1ef4:	cd b7       	in	r28, 0x3d	; 61
    1ef6:	de b7       	in	r29, 0x3e	; 62
    1ef8:	7c 01       	movw	r14, r24
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    1efa:	10 e0       	ldi	r17, 0x00	; 0
    1efc:	1a c0       	rjmp	.+52     	; 0x1f32 <add_user+0x4a>
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    1efe:	ae 01       	movw	r20, r28
    1f00:	4f 5f       	subi	r20, 0xFF	; 255
    1f02:	5f 4f       	sbci	r21, 0xFF	; 255
    1f04:	60 e0       	ldi	r22, 0x00	; 0
    1f06:	81 2f       	mov	r24, r17
    1f08:	0e 94 cc 00 	call	0x198	; 0x198 <EEPROM_read_byte>
    if (usersBlockStatus != 0xFF) {
    1f0c:	99 81       	ldd	r25, Y+1	; 0x01
    1f0e:	9f 3f       	cpi	r25, 0xFF	; 255
    1f10:	79 f0       	breq	.+30     	; 0x1f30 <add_user+0x48>
    1f12:	02 c0       	rjmp	.+4      	; 0x1f18 <add_user+0x30>
      // Find the block number in the page
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
    1f14:	8f 5f       	subi	r24, 0xFF	; 255
    1f16:	01 c0       	rjmp	.+2      	; 0x1f1a <add_user+0x32>
    1f18:	80 e0       	ldi	r24, 0x00	; 0
    1f1a:	29 2f       	mov	r18, r25
    1f1c:	30 e0       	ldi	r19, 0x00	; 0
    1f1e:	08 2e       	mov	r0, r24
    1f20:	02 c0       	rjmp	.+4      	; 0x1f26 <add_user+0x3e>
    1f22:	35 95       	asr	r19
    1f24:	27 95       	ror	r18
    1f26:	0a 94       	dec	r0
    1f28:	e2 f7       	brpl	.-8      	; 0x1f22 <add_user+0x3a>
    1f2a:	20 fd       	sbrc	r18, 0
    1f2c:	f3 cf       	rjmp	.-26     	; 0x1f14 <add_user+0x2c>
    1f2e:	04 c0       	rjmp	.+8      	; 0x1f38 <add_user+0x50>
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    1f30:	1f 5f       	subi	r17, 0xFF	; 255
    1f32:	18 30       	cpi	r17, 0x08	; 8
    1f34:	20 f3       	brcs	.-56     	; 0x1efe <add_user+0x16>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
    1f36:	80 e0       	ldi	r24, 0x00	; 0
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    1f38:	18 30       	cpi	r17, 0x08	; 8
    1f3a:	49 f0       	breq	.+18     	; 0x1f4e <add_user+0x66>
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
    1f3c:	11 0f       	add	r17, r17
    1f3e:	11 0f       	add	r17, r17
    1f40:	11 0f       	add	r17, r17
  write_user(availableUserBlockIndex, user);
    1f42:	b7 01       	movw	r22, r14
    1f44:	81 0f       	add	r24, r17
    1f46:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <write_user>
  return USER_ADDED_SUCCESSFULLY;
    1f4a:	89 e0       	ldi	r24, 0x09	; 9
    1f4c:	01 c0       	rjmp	.+2      	; 0x1f50 <add_user+0x68>
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    1f4e:	8b e0       	ldi	r24, 0x0B	; 11
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
  write_user(availableUserBlockIndex, user);
  return USER_ADDED_SUCCESSFULLY;
  }
    1f50:	0f 90       	pop	r0
    1f52:	df 91       	pop	r29
    1f54:	cf 91       	pop	r28
    1f56:	1f 91       	pop	r17
    1f58:	ff 90       	pop	r15
    1f5a:	ef 90       	pop	r14
    1f5c:	08 95       	ret

00001f5e <delete_user>:

EN_UserStatusCode_t delete_user(ST_User_t* user) {
    1f5e:	cf 92       	push	r12
    1f60:	df 92       	push	r13
    1f62:	ef 92       	push	r14
    1f64:	ff 92       	push	r15
    1f66:	0f 93       	push	r16
    1f68:	1f 93       	push	r17
    1f6a:	cf 93       	push	r28
    1f6c:	df 93       	push	r29
    1f6e:	cd b7       	in	r28, 0x3d	; 61
    1f70:	de b7       	in	r29, 0x3e	; 62
    1f72:	29 97       	sbiw	r28, 0x09	; 9
    1f74:	0f b6       	in	r0, 0x3f	; 63
    1f76:	f8 94       	cli
    1f78:	de bf       	out	0x3e, r29	; 62
    1f7a:	0f be       	out	0x3f, r0	; 63
    1f7c:	cd bf       	out	0x3d, r28	; 61
    1f7e:	6c 01       	movw	r12, r24
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    1f80:	00 e0       	ldi	r16, 0x00	; 0
    1f82:	4d c0       	rjmp	.+154    	; 0x201e <delete_user+0xc0>
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    1f84:	ae 01       	movw	r20, r28
    1f86:	4f 5f       	subi	r20, 0xFF	; 255
    1f88:	5f 4f       	sbci	r21, 0xFF	; 255
    1f8a:	60 e0       	ldi	r22, 0x00	; 0
    1f8c:	80 2f       	mov	r24, r16
    1f8e:	0e 94 cc 00 	call	0x198	; 0x198 <EEPROM_read_byte>
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    1f92:	ae 01       	movw	r20, r28
    1f94:	4e 5f       	subi	r20, 0xFE	; 254
    1f96:	5f 4f       	sbci	r21, 0xFF	; 255
    1f98:	61 e0       	ldi	r22, 0x01	; 1
    1f9a:	80 2f       	mov	r24, r16
    1f9c:	0e 94 cc 00 	call	0x198	; 0x198 <EEPROM_read_byte>
    for (userIndex = 0; userIndex < 8;userIndex++) {
    1fa0:	10 e0       	ldi	r17, 0x00	; 0
    1fa2:	3a c0       	rjmp	.+116    	; 0x2018 <delete_user+0xba>
      if (read_bit(usersBlockStatus, userIndex)) {  // If the user isn't deleted
    1fa4:	89 81       	ldd	r24, Y+1	; 0x01
    1fa6:	90 e0       	ldi	r25, 0x00	; 0
    1fa8:	01 2e       	mov	r0, r17
    1faa:	02 c0       	rjmp	.+4      	; 0x1fb0 <delete_user+0x52>
    1fac:	95 95       	asr	r25
    1fae:	87 95       	ror	r24
    1fb0:	0a 94       	dec	r0
    1fb2:	e2 f7       	brpl	.-8      	; 0x1fac <delete_user+0x4e>
    1fb4:	80 ff       	sbrs	r24, 0
    1fb6:	2f c0       	rjmp	.+94     	; 0x2016 <delete_user+0xb8>
        EEPROM_read_block(page, 21 + 31 * userIndex, 7, tempUserCode);
    1fb8:	6f e1       	ldi	r22, 0x1F	; 31
    1fba:	16 9f       	mul	r17, r22
    1fbc:	60 2d       	mov	r22, r0
    1fbe:	11 24       	eor	r1, r1
    1fc0:	6b 5e       	subi	r22, 0xEB	; 235
    1fc2:	9e 01       	movw	r18, r28
    1fc4:	2d 5f       	subi	r18, 0xFD	; 253
    1fc6:	3f 4f       	sbci	r19, 0xFF	; 255
    1fc8:	47 e0       	ldi	r20, 0x07	; 7
    1fca:	50 e0       	ldi	r21, 0x00	; 0
    1fcc:	80 2f       	mov	r24, r16
    1fce:	0e 94 ed 00 	call	0x1da	; 0x1da <EEPROM_read_block>
        if (strcmp(user->code, tempUserCode) == 0) { // User has been found
    1fd2:	be 01       	movw	r22, r28
    1fd4:	6d 5f       	subi	r22, 0xFD	; 253
    1fd6:	7f 4f       	sbci	r23, 0xFF	; 255
    1fd8:	c6 01       	movw	r24, r12
    1fda:	0e 96       	adiw	r24, 0x0e	; 14
    1fdc:	0e 94 31 12 	call	0x2462	; 0x2462 <strcmp>
    1fe0:	89 2b       	or	r24, r25
    1fe2:	c9 f4       	brne	.+50     	; 0x2016 <delete_user+0xb8>
          // Mark it as deleted
          clear_bit(usersBlockStatus, userIndex);
    1fe4:	81 e0       	ldi	r24, 0x01	; 1
    1fe6:	90 e0       	ldi	r25, 0x00	; 0
    1fe8:	02 c0       	rjmp	.+4      	; 0x1fee <delete_user+0x90>
    1fea:	88 0f       	add	r24, r24
    1fec:	99 1f       	adc	r25, r25
    1fee:	1a 95       	dec	r17
    1ff0:	e2 f7       	brpl	.-8      	; 0x1fea <delete_user+0x8c>
    1ff2:	80 95       	com	r24
    1ff4:	49 81       	ldd	r20, Y+1	; 0x01
    1ff6:	48 23       	and	r20, r24
    1ff8:	49 83       	std	Y+1, r20	; 0x01
          clear_bit(usersAuthorityLevel, userIndex);
    1ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffc:	89 23       	and	r24, r25
    1ffe:	8a 83       	std	Y+2, r24	; 0x02
          EEPROM_write_byte(page, 0, usersBlockStatus);
    2000:	60 e0       	ldi	r22, 0x00	; 0
    2002:	80 2f       	mov	r24, r16
    2004:	0e 94 23 01 	call	0x246	; 0x246 <EEPROM_write_byte>
          EEPROM_write_byte(page, 1, usersAuthorityLevel);
    2008:	4a 81       	ldd	r20, Y+2	; 0x02
    200a:	61 e0       	ldi	r22, 0x01	; 1
    200c:	80 2f       	mov	r24, r16
    200e:	0e 94 23 01 	call	0x246	; 0x246 <EEPROM_write_byte>
          return USER_DELETED_SUCCESSFULLY;
    2012:	8a e0       	ldi	r24, 0x0A	; 10
    2014:	08 c0       	rjmp	.+16     	; 0x2026 <delete_user+0xc8>
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    for (userIndex = 0; userIndex < 8;userIndex++) {
    2016:	1f 5f       	subi	r17, 0xFF	; 255
    2018:	18 30       	cpi	r17, 0x08	; 8
    201a:	20 f2       	brcs	.-120    	; 0x1fa4 <delete_user+0x46>
EN_UserStatusCode_t delete_user(ST_User_t* user) {
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    201c:	0f 5f       	subi	r16, 0xFF	; 255
    201e:	08 30       	cpi	r16, 0x08	; 8
    2020:	08 f4       	brcc	.+2      	; 0x2024 <delete_user+0xc6>
    2022:	b0 cf       	rjmp	.-160    	; 0x1f84 <delete_user+0x26>
          return USER_DELETED_SUCCESSFULLY;
          }
        }
      }
    }
  return USER_NOT_FOUND;
    2024:	83 e0       	ldi	r24, 0x03	; 3
  }
    2026:	29 96       	adiw	r28, 0x09	; 9
    2028:	0f b6       	in	r0, 0x3f	; 63
    202a:	f8 94       	cli
    202c:	de bf       	out	0x3e, r29	; 62
    202e:	0f be       	out	0x3f, r0	; 63
    2030:	cd bf       	out	0x3d, r28	; 61
    2032:	df 91       	pop	r29
    2034:	cf 91       	pop	r28
    2036:	1f 91       	pop	r17
    2038:	0f 91       	pop	r16
    203a:	ff 90       	pop	r15
    203c:	ef 90       	pop	r14
    203e:	df 90       	pop	r13
    2040:	cf 90       	pop	r12
    2042:	08 95       	ret

00002044 <__subsf3>:
    2044:	50 58       	subi	r21, 0x80	; 128

00002046 <__addsf3>:
    2046:	bb 27       	eor	r27, r27
    2048:	aa 27       	eor	r26, r26
    204a:	0e 94 3a 10 	call	0x2074	; 0x2074 <__addsf3x>
    204e:	0c 94 84 11 	jmp	0x2308	; 0x2308 <__fp_round>
    2052:	0e 94 76 11 	call	0x22ec	; 0x22ec <__fp_pscA>
    2056:	38 f0       	brcs	.+14     	; 0x2066 <__addsf3+0x20>
    2058:	0e 94 7d 11 	call	0x22fa	; 0x22fa <__fp_pscB>
    205c:	20 f0       	brcs	.+8      	; 0x2066 <__addsf3+0x20>
    205e:	39 f4       	brne	.+14     	; 0x206e <__addsf3+0x28>
    2060:	9f 3f       	cpi	r25, 0xFF	; 255
    2062:	19 f4       	brne	.+6      	; 0x206a <__addsf3+0x24>
    2064:	26 f4       	brtc	.+8      	; 0x206e <__addsf3+0x28>
    2066:	0c 94 73 11 	jmp	0x22e6	; 0x22e6 <__fp_nan>
    206a:	0e f4       	brtc	.+2      	; 0x206e <__addsf3+0x28>
    206c:	e0 95       	com	r30
    206e:	e7 fb       	bst	r30, 7
    2070:	0c 94 6d 11 	jmp	0x22da	; 0x22da <__fp_inf>

00002074 <__addsf3x>:
    2074:	e9 2f       	mov	r30, r25
    2076:	0e 94 95 11 	call	0x232a	; 0x232a <__fp_split3>
    207a:	58 f3       	brcs	.-42     	; 0x2052 <__addsf3+0xc>
    207c:	ba 17       	cp	r27, r26
    207e:	62 07       	cpc	r22, r18
    2080:	73 07       	cpc	r23, r19
    2082:	84 07       	cpc	r24, r20
    2084:	95 07       	cpc	r25, r21
    2086:	20 f0       	brcs	.+8      	; 0x2090 <__addsf3x+0x1c>
    2088:	79 f4       	brne	.+30     	; 0x20a8 <__addsf3x+0x34>
    208a:	a6 f5       	brtc	.+104    	; 0x20f4 <__addsf3x+0x80>
    208c:	0c 94 b7 11 	jmp	0x236e	; 0x236e <__fp_zero>
    2090:	0e f4       	brtc	.+2      	; 0x2094 <__addsf3x+0x20>
    2092:	e0 95       	com	r30
    2094:	0b 2e       	mov	r0, r27
    2096:	ba 2f       	mov	r27, r26
    2098:	a0 2d       	mov	r26, r0
    209a:	0b 01       	movw	r0, r22
    209c:	b9 01       	movw	r22, r18
    209e:	90 01       	movw	r18, r0
    20a0:	0c 01       	movw	r0, r24
    20a2:	ca 01       	movw	r24, r20
    20a4:	a0 01       	movw	r20, r0
    20a6:	11 24       	eor	r1, r1
    20a8:	ff 27       	eor	r31, r31
    20aa:	59 1b       	sub	r21, r25
    20ac:	99 f0       	breq	.+38     	; 0x20d4 <__addsf3x+0x60>
    20ae:	59 3f       	cpi	r21, 0xF9	; 249
    20b0:	50 f4       	brcc	.+20     	; 0x20c6 <__addsf3x+0x52>
    20b2:	50 3e       	cpi	r21, 0xE0	; 224
    20b4:	68 f1       	brcs	.+90     	; 0x2110 <__addsf3x+0x9c>
    20b6:	1a 16       	cp	r1, r26
    20b8:	f0 40       	sbci	r31, 0x00	; 0
    20ba:	a2 2f       	mov	r26, r18
    20bc:	23 2f       	mov	r18, r19
    20be:	34 2f       	mov	r19, r20
    20c0:	44 27       	eor	r20, r20
    20c2:	58 5f       	subi	r21, 0xF8	; 248
    20c4:	f3 cf       	rjmp	.-26     	; 0x20ac <__addsf3x+0x38>
    20c6:	46 95       	lsr	r20
    20c8:	37 95       	ror	r19
    20ca:	27 95       	ror	r18
    20cc:	a7 95       	ror	r26
    20ce:	f0 40       	sbci	r31, 0x00	; 0
    20d0:	53 95       	inc	r21
    20d2:	c9 f7       	brne	.-14     	; 0x20c6 <__addsf3x+0x52>
    20d4:	7e f4       	brtc	.+30     	; 0x20f4 <__addsf3x+0x80>
    20d6:	1f 16       	cp	r1, r31
    20d8:	ba 0b       	sbc	r27, r26
    20da:	62 0b       	sbc	r22, r18
    20dc:	73 0b       	sbc	r23, r19
    20de:	84 0b       	sbc	r24, r20
    20e0:	ba f0       	brmi	.+46     	; 0x2110 <__addsf3x+0x9c>
    20e2:	91 50       	subi	r25, 0x01	; 1
    20e4:	a1 f0       	breq	.+40     	; 0x210e <__addsf3x+0x9a>
    20e6:	ff 0f       	add	r31, r31
    20e8:	bb 1f       	adc	r27, r27
    20ea:	66 1f       	adc	r22, r22
    20ec:	77 1f       	adc	r23, r23
    20ee:	88 1f       	adc	r24, r24
    20f0:	c2 f7       	brpl	.-16     	; 0x20e2 <__addsf3x+0x6e>
    20f2:	0e c0       	rjmp	.+28     	; 0x2110 <__addsf3x+0x9c>
    20f4:	ba 0f       	add	r27, r26
    20f6:	62 1f       	adc	r22, r18
    20f8:	73 1f       	adc	r23, r19
    20fa:	84 1f       	adc	r24, r20
    20fc:	48 f4       	brcc	.+18     	; 0x2110 <__addsf3x+0x9c>
    20fe:	87 95       	ror	r24
    2100:	77 95       	ror	r23
    2102:	67 95       	ror	r22
    2104:	b7 95       	ror	r27
    2106:	f7 95       	ror	r31
    2108:	9e 3f       	cpi	r25, 0xFE	; 254
    210a:	08 f0       	brcs	.+2      	; 0x210e <__addsf3x+0x9a>
    210c:	b0 cf       	rjmp	.-160    	; 0x206e <__addsf3+0x28>
    210e:	93 95       	inc	r25
    2110:	88 0f       	add	r24, r24
    2112:	08 f0       	brcs	.+2      	; 0x2116 <__addsf3x+0xa2>
    2114:	99 27       	eor	r25, r25
    2116:	ee 0f       	add	r30, r30
    2118:	97 95       	ror	r25
    211a:	87 95       	ror	r24
    211c:	08 95       	ret

0000211e <__divsf3>:
    211e:	0e 94 a3 10 	call	0x2146	; 0x2146 <__divsf3x>
    2122:	0c 94 84 11 	jmp	0x2308	; 0x2308 <__fp_round>
    2126:	0e 94 7d 11 	call	0x22fa	; 0x22fa <__fp_pscB>
    212a:	58 f0       	brcs	.+22     	; 0x2142 <__divsf3+0x24>
    212c:	0e 94 76 11 	call	0x22ec	; 0x22ec <__fp_pscA>
    2130:	40 f0       	brcs	.+16     	; 0x2142 <__divsf3+0x24>
    2132:	29 f4       	brne	.+10     	; 0x213e <__divsf3+0x20>
    2134:	5f 3f       	cpi	r21, 0xFF	; 255
    2136:	29 f0       	breq	.+10     	; 0x2142 <__divsf3+0x24>
    2138:	0c 94 6d 11 	jmp	0x22da	; 0x22da <__fp_inf>
    213c:	51 11       	cpse	r21, r1
    213e:	0c 94 b8 11 	jmp	0x2370	; 0x2370 <__fp_szero>
    2142:	0c 94 73 11 	jmp	0x22e6	; 0x22e6 <__fp_nan>

00002146 <__divsf3x>:
    2146:	0e 94 95 11 	call	0x232a	; 0x232a <__fp_split3>
    214a:	68 f3       	brcs	.-38     	; 0x2126 <__divsf3+0x8>

0000214c <__divsf3_pse>:
    214c:	99 23       	and	r25, r25
    214e:	b1 f3       	breq	.-20     	; 0x213c <__divsf3+0x1e>
    2150:	55 23       	and	r21, r21
    2152:	91 f3       	breq	.-28     	; 0x2138 <__divsf3+0x1a>
    2154:	95 1b       	sub	r25, r21
    2156:	55 0b       	sbc	r21, r21
    2158:	bb 27       	eor	r27, r27
    215a:	aa 27       	eor	r26, r26
    215c:	62 17       	cp	r22, r18
    215e:	73 07       	cpc	r23, r19
    2160:	84 07       	cpc	r24, r20
    2162:	38 f0       	brcs	.+14     	; 0x2172 <__divsf3_pse+0x26>
    2164:	9f 5f       	subi	r25, 0xFF	; 255
    2166:	5f 4f       	sbci	r21, 0xFF	; 255
    2168:	22 0f       	add	r18, r18
    216a:	33 1f       	adc	r19, r19
    216c:	44 1f       	adc	r20, r20
    216e:	aa 1f       	adc	r26, r26
    2170:	a9 f3       	breq	.-22     	; 0x215c <__divsf3_pse+0x10>
    2172:	35 d0       	rcall	.+106    	; 0x21de <__divsf3_pse+0x92>
    2174:	0e 2e       	mov	r0, r30
    2176:	3a f0       	brmi	.+14     	; 0x2186 <__divsf3_pse+0x3a>
    2178:	e0 e8       	ldi	r30, 0x80	; 128
    217a:	32 d0       	rcall	.+100    	; 0x21e0 <__divsf3_pse+0x94>
    217c:	91 50       	subi	r25, 0x01	; 1
    217e:	50 40       	sbci	r21, 0x00	; 0
    2180:	e6 95       	lsr	r30
    2182:	00 1c       	adc	r0, r0
    2184:	ca f7       	brpl	.-14     	; 0x2178 <__divsf3_pse+0x2c>
    2186:	2b d0       	rcall	.+86     	; 0x21de <__divsf3_pse+0x92>
    2188:	fe 2f       	mov	r31, r30
    218a:	29 d0       	rcall	.+82     	; 0x21de <__divsf3_pse+0x92>
    218c:	66 0f       	add	r22, r22
    218e:	77 1f       	adc	r23, r23
    2190:	88 1f       	adc	r24, r24
    2192:	bb 1f       	adc	r27, r27
    2194:	26 17       	cp	r18, r22
    2196:	37 07       	cpc	r19, r23
    2198:	48 07       	cpc	r20, r24
    219a:	ab 07       	cpc	r26, r27
    219c:	b0 e8       	ldi	r27, 0x80	; 128
    219e:	09 f0       	breq	.+2      	; 0x21a2 <__divsf3_pse+0x56>
    21a0:	bb 0b       	sbc	r27, r27
    21a2:	80 2d       	mov	r24, r0
    21a4:	bf 01       	movw	r22, r30
    21a6:	ff 27       	eor	r31, r31
    21a8:	93 58       	subi	r25, 0x83	; 131
    21aa:	5f 4f       	sbci	r21, 0xFF	; 255
    21ac:	3a f0       	brmi	.+14     	; 0x21bc <__divsf3_pse+0x70>
    21ae:	9e 3f       	cpi	r25, 0xFE	; 254
    21b0:	51 05       	cpc	r21, r1
    21b2:	78 f0       	brcs	.+30     	; 0x21d2 <__divsf3_pse+0x86>
    21b4:	0c 94 6d 11 	jmp	0x22da	; 0x22da <__fp_inf>
    21b8:	0c 94 b8 11 	jmp	0x2370	; 0x2370 <__fp_szero>
    21bc:	5f 3f       	cpi	r21, 0xFF	; 255
    21be:	e4 f3       	brlt	.-8      	; 0x21b8 <__divsf3_pse+0x6c>
    21c0:	98 3e       	cpi	r25, 0xE8	; 232
    21c2:	d4 f3       	brlt	.-12     	; 0x21b8 <__divsf3_pse+0x6c>
    21c4:	86 95       	lsr	r24
    21c6:	77 95       	ror	r23
    21c8:	67 95       	ror	r22
    21ca:	b7 95       	ror	r27
    21cc:	f7 95       	ror	r31
    21ce:	9f 5f       	subi	r25, 0xFF	; 255
    21d0:	c9 f7       	brne	.-14     	; 0x21c4 <__divsf3_pse+0x78>
    21d2:	88 0f       	add	r24, r24
    21d4:	91 1d       	adc	r25, r1
    21d6:	96 95       	lsr	r25
    21d8:	87 95       	ror	r24
    21da:	97 f9       	bld	r25, 7
    21dc:	08 95       	ret
    21de:	e1 e0       	ldi	r30, 0x01	; 1
    21e0:	66 0f       	add	r22, r22
    21e2:	77 1f       	adc	r23, r23
    21e4:	88 1f       	adc	r24, r24
    21e6:	bb 1f       	adc	r27, r27
    21e8:	62 17       	cp	r22, r18
    21ea:	73 07       	cpc	r23, r19
    21ec:	84 07       	cpc	r24, r20
    21ee:	ba 07       	cpc	r27, r26
    21f0:	20 f0       	brcs	.+8      	; 0x21fa <__divsf3_pse+0xae>
    21f2:	62 1b       	sub	r22, r18
    21f4:	73 0b       	sbc	r23, r19
    21f6:	84 0b       	sbc	r24, r20
    21f8:	ba 0b       	sbc	r27, r26
    21fa:	ee 1f       	adc	r30, r30
    21fc:	88 f7       	brcc	.-30     	; 0x21e0 <__divsf3_pse+0x94>
    21fe:	e0 95       	com	r30
    2200:	08 95       	ret

00002202 <__fixunssfsi>:
    2202:	0e 94 9d 11 	call	0x233a	; 0x233a <__fp_splitA>
    2206:	88 f0       	brcs	.+34     	; 0x222a <__fixunssfsi+0x28>
    2208:	9f 57       	subi	r25, 0x7F	; 127
    220a:	98 f0       	brcs	.+38     	; 0x2232 <__fixunssfsi+0x30>
    220c:	b9 2f       	mov	r27, r25
    220e:	99 27       	eor	r25, r25
    2210:	b7 51       	subi	r27, 0x17	; 23
    2212:	b0 f0       	brcs	.+44     	; 0x2240 <__fixunssfsi+0x3e>
    2214:	e1 f0       	breq	.+56     	; 0x224e <__fixunssfsi+0x4c>
    2216:	66 0f       	add	r22, r22
    2218:	77 1f       	adc	r23, r23
    221a:	88 1f       	adc	r24, r24
    221c:	99 1f       	adc	r25, r25
    221e:	1a f0       	brmi	.+6      	; 0x2226 <__fixunssfsi+0x24>
    2220:	ba 95       	dec	r27
    2222:	c9 f7       	brne	.-14     	; 0x2216 <__fixunssfsi+0x14>
    2224:	14 c0       	rjmp	.+40     	; 0x224e <__fixunssfsi+0x4c>
    2226:	b1 30       	cpi	r27, 0x01	; 1
    2228:	91 f0       	breq	.+36     	; 0x224e <__fixunssfsi+0x4c>
    222a:	0e 94 b7 11 	call	0x236e	; 0x236e <__fp_zero>
    222e:	b1 e0       	ldi	r27, 0x01	; 1
    2230:	08 95       	ret
    2232:	0c 94 b7 11 	jmp	0x236e	; 0x236e <__fp_zero>
    2236:	67 2f       	mov	r22, r23
    2238:	78 2f       	mov	r23, r24
    223a:	88 27       	eor	r24, r24
    223c:	b8 5f       	subi	r27, 0xF8	; 248
    223e:	39 f0       	breq	.+14     	; 0x224e <__fixunssfsi+0x4c>
    2240:	b9 3f       	cpi	r27, 0xF9	; 249
    2242:	cc f3       	brlt	.-14     	; 0x2236 <__fixunssfsi+0x34>
    2244:	86 95       	lsr	r24
    2246:	77 95       	ror	r23
    2248:	67 95       	ror	r22
    224a:	b3 95       	inc	r27
    224c:	d9 f7       	brne	.-10     	; 0x2244 <__fixunssfsi+0x42>
    224e:	3e f4       	brtc	.+14     	; 0x225e <__fixunssfsi+0x5c>
    2250:	90 95       	com	r25
    2252:	80 95       	com	r24
    2254:	70 95       	com	r23
    2256:	61 95       	neg	r22
    2258:	7f 4f       	sbci	r23, 0xFF	; 255
    225a:	8f 4f       	sbci	r24, 0xFF	; 255
    225c:	9f 4f       	sbci	r25, 0xFF	; 255
    225e:	08 95       	ret

00002260 <__floatunsisf>:
    2260:	e8 94       	clt
    2262:	09 c0       	rjmp	.+18     	; 0x2276 <__floatsisf+0x12>

00002264 <__floatsisf>:
    2264:	97 fb       	bst	r25, 7
    2266:	3e f4       	brtc	.+14     	; 0x2276 <__floatsisf+0x12>
    2268:	90 95       	com	r25
    226a:	80 95       	com	r24
    226c:	70 95       	com	r23
    226e:	61 95       	neg	r22
    2270:	7f 4f       	sbci	r23, 0xFF	; 255
    2272:	8f 4f       	sbci	r24, 0xFF	; 255
    2274:	9f 4f       	sbci	r25, 0xFF	; 255
    2276:	99 23       	and	r25, r25
    2278:	a9 f0       	breq	.+42     	; 0x22a4 <__floatsisf+0x40>
    227a:	f9 2f       	mov	r31, r25
    227c:	96 e9       	ldi	r25, 0x96	; 150
    227e:	bb 27       	eor	r27, r27
    2280:	93 95       	inc	r25
    2282:	f6 95       	lsr	r31
    2284:	87 95       	ror	r24
    2286:	77 95       	ror	r23
    2288:	67 95       	ror	r22
    228a:	b7 95       	ror	r27
    228c:	f1 11       	cpse	r31, r1
    228e:	f8 cf       	rjmp	.-16     	; 0x2280 <__floatsisf+0x1c>
    2290:	fa f4       	brpl	.+62     	; 0x22d0 <__floatsisf+0x6c>
    2292:	bb 0f       	add	r27, r27
    2294:	11 f4       	brne	.+4      	; 0x229a <__floatsisf+0x36>
    2296:	60 ff       	sbrs	r22, 0
    2298:	1b c0       	rjmp	.+54     	; 0x22d0 <__floatsisf+0x6c>
    229a:	6f 5f       	subi	r22, 0xFF	; 255
    229c:	7f 4f       	sbci	r23, 0xFF	; 255
    229e:	8f 4f       	sbci	r24, 0xFF	; 255
    22a0:	9f 4f       	sbci	r25, 0xFF	; 255
    22a2:	16 c0       	rjmp	.+44     	; 0x22d0 <__floatsisf+0x6c>
    22a4:	88 23       	and	r24, r24
    22a6:	11 f0       	breq	.+4      	; 0x22ac <__floatsisf+0x48>
    22a8:	96 e9       	ldi	r25, 0x96	; 150
    22aa:	11 c0       	rjmp	.+34     	; 0x22ce <__floatsisf+0x6a>
    22ac:	77 23       	and	r23, r23
    22ae:	21 f0       	breq	.+8      	; 0x22b8 <__floatsisf+0x54>
    22b0:	9e e8       	ldi	r25, 0x8E	; 142
    22b2:	87 2f       	mov	r24, r23
    22b4:	76 2f       	mov	r23, r22
    22b6:	05 c0       	rjmp	.+10     	; 0x22c2 <__floatsisf+0x5e>
    22b8:	66 23       	and	r22, r22
    22ba:	71 f0       	breq	.+28     	; 0x22d8 <__floatsisf+0x74>
    22bc:	96 e8       	ldi	r25, 0x86	; 134
    22be:	86 2f       	mov	r24, r22
    22c0:	70 e0       	ldi	r23, 0x00	; 0
    22c2:	60 e0       	ldi	r22, 0x00	; 0
    22c4:	2a f0       	brmi	.+10     	; 0x22d0 <__floatsisf+0x6c>
    22c6:	9a 95       	dec	r25
    22c8:	66 0f       	add	r22, r22
    22ca:	77 1f       	adc	r23, r23
    22cc:	88 1f       	adc	r24, r24
    22ce:	da f7       	brpl	.-10     	; 0x22c6 <__floatsisf+0x62>
    22d0:	88 0f       	add	r24, r24
    22d2:	96 95       	lsr	r25
    22d4:	87 95       	ror	r24
    22d6:	97 f9       	bld	r25, 7
    22d8:	08 95       	ret

000022da <__fp_inf>:
    22da:	97 f9       	bld	r25, 7
    22dc:	9f 67       	ori	r25, 0x7F	; 127
    22de:	80 e8       	ldi	r24, 0x80	; 128
    22e0:	70 e0       	ldi	r23, 0x00	; 0
    22e2:	60 e0       	ldi	r22, 0x00	; 0
    22e4:	08 95       	ret

000022e6 <__fp_nan>:
    22e6:	9f ef       	ldi	r25, 0xFF	; 255
    22e8:	80 ec       	ldi	r24, 0xC0	; 192
    22ea:	08 95       	ret

000022ec <__fp_pscA>:
    22ec:	00 24       	eor	r0, r0
    22ee:	0a 94       	dec	r0
    22f0:	16 16       	cp	r1, r22
    22f2:	17 06       	cpc	r1, r23
    22f4:	18 06       	cpc	r1, r24
    22f6:	09 06       	cpc	r0, r25
    22f8:	08 95       	ret

000022fa <__fp_pscB>:
    22fa:	00 24       	eor	r0, r0
    22fc:	0a 94       	dec	r0
    22fe:	12 16       	cp	r1, r18
    2300:	13 06       	cpc	r1, r19
    2302:	14 06       	cpc	r1, r20
    2304:	05 06       	cpc	r0, r21
    2306:	08 95       	ret

00002308 <__fp_round>:
    2308:	09 2e       	mov	r0, r25
    230a:	03 94       	inc	r0
    230c:	00 0c       	add	r0, r0
    230e:	11 f4       	brne	.+4      	; 0x2314 <__fp_round+0xc>
    2310:	88 23       	and	r24, r24
    2312:	52 f0       	brmi	.+20     	; 0x2328 <__fp_round+0x20>
    2314:	bb 0f       	add	r27, r27
    2316:	40 f4       	brcc	.+16     	; 0x2328 <__fp_round+0x20>
    2318:	bf 2b       	or	r27, r31
    231a:	11 f4       	brne	.+4      	; 0x2320 <__fp_round+0x18>
    231c:	60 ff       	sbrs	r22, 0
    231e:	04 c0       	rjmp	.+8      	; 0x2328 <__fp_round+0x20>
    2320:	6f 5f       	subi	r22, 0xFF	; 255
    2322:	7f 4f       	sbci	r23, 0xFF	; 255
    2324:	8f 4f       	sbci	r24, 0xFF	; 255
    2326:	9f 4f       	sbci	r25, 0xFF	; 255
    2328:	08 95       	ret

0000232a <__fp_split3>:
    232a:	57 fd       	sbrc	r21, 7
    232c:	90 58       	subi	r25, 0x80	; 128
    232e:	44 0f       	add	r20, r20
    2330:	55 1f       	adc	r21, r21
    2332:	59 f0       	breq	.+22     	; 0x234a <__fp_splitA+0x10>
    2334:	5f 3f       	cpi	r21, 0xFF	; 255
    2336:	71 f0       	breq	.+28     	; 0x2354 <__fp_splitA+0x1a>
    2338:	47 95       	ror	r20

0000233a <__fp_splitA>:
    233a:	88 0f       	add	r24, r24
    233c:	97 fb       	bst	r25, 7
    233e:	99 1f       	adc	r25, r25
    2340:	61 f0       	breq	.+24     	; 0x235a <__fp_splitA+0x20>
    2342:	9f 3f       	cpi	r25, 0xFF	; 255
    2344:	79 f0       	breq	.+30     	; 0x2364 <__fp_splitA+0x2a>
    2346:	87 95       	ror	r24
    2348:	08 95       	ret
    234a:	12 16       	cp	r1, r18
    234c:	13 06       	cpc	r1, r19
    234e:	14 06       	cpc	r1, r20
    2350:	55 1f       	adc	r21, r21
    2352:	f2 cf       	rjmp	.-28     	; 0x2338 <__fp_split3+0xe>
    2354:	46 95       	lsr	r20
    2356:	f1 df       	rcall	.-30     	; 0x233a <__fp_splitA>
    2358:	08 c0       	rjmp	.+16     	; 0x236a <__fp_splitA+0x30>
    235a:	16 16       	cp	r1, r22
    235c:	17 06       	cpc	r1, r23
    235e:	18 06       	cpc	r1, r24
    2360:	99 1f       	adc	r25, r25
    2362:	f1 cf       	rjmp	.-30     	; 0x2346 <__fp_splitA+0xc>
    2364:	86 95       	lsr	r24
    2366:	71 05       	cpc	r23, r1
    2368:	61 05       	cpc	r22, r1
    236a:	08 94       	sec
    236c:	08 95       	ret

0000236e <__fp_zero>:
    236e:	e8 94       	clt

00002370 <__fp_szero>:
    2370:	bb 27       	eor	r27, r27
    2372:	66 27       	eor	r22, r22
    2374:	77 27       	eor	r23, r23
    2376:	cb 01       	movw	r24, r22
    2378:	97 f9       	bld	r25, 7
    237a:	08 95       	ret

0000237c <__mulsf3>:
    237c:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <__mulsf3x>
    2380:	0c 94 84 11 	jmp	0x2308	; 0x2308 <__fp_round>
    2384:	0e 94 76 11 	call	0x22ec	; 0x22ec <__fp_pscA>
    2388:	38 f0       	brcs	.+14     	; 0x2398 <__mulsf3+0x1c>
    238a:	0e 94 7d 11 	call	0x22fa	; 0x22fa <__fp_pscB>
    238e:	20 f0       	brcs	.+8      	; 0x2398 <__mulsf3+0x1c>
    2390:	95 23       	and	r25, r21
    2392:	11 f0       	breq	.+4      	; 0x2398 <__mulsf3+0x1c>
    2394:	0c 94 6d 11 	jmp	0x22da	; 0x22da <__fp_inf>
    2398:	0c 94 73 11 	jmp	0x22e6	; 0x22e6 <__fp_nan>
    239c:	11 24       	eor	r1, r1
    239e:	0c 94 b8 11 	jmp	0x2370	; 0x2370 <__fp_szero>

000023a2 <__mulsf3x>:
    23a2:	0e 94 95 11 	call	0x232a	; 0x232a <__fp_split3>
    23a6:	70 f3       	brcs	.-36     	; 0x2384 <__mulsf3+0x8>

000023a8 <__mulsf3_pse>:
    23a8:	95 9f       	mul	r25, r21
    23aa:	c1 f3       	breq	.-16     	; 0x239c <__mulsf3+0x20>
    23ac:	95 0f       	add	r25, r21
    23ae:	50 e0       	ldi	r21, 0x00	; 0
    23b0:	55 1f       	adc	r21, r21
    23b2:	62 9f       	mul	r22, r18
    23b4:	f0 01       	movw	r30, r0
    23b6:	72 9f       	mul	r23, r18
    23b8:	bb 27       	eor	r27, r27
    23ba:	f0 0d       	add	r31, r0
    23bc:	b1 1d       	adc	r27, r1
    23be:	63 9f       	mul	r22, r19
    23c0:	aa 27       	eor	r26, r26
    23c2:	f0 0d       	add	r31, r0
    23c4:	b1 1d       	adc	r27, r1
    23c6:	aa 1f       	adc	r26, r26
    23c8:	64 9f       	mul	r22, r20
    23ca:	66 27       	eor	r22, r22
    23cc:	b0 0d       	add	r27, r0
    23ce:	a1 1d       	adc	r26, r1
    23d0:	66 1f       	adc	r22, r22
    23d2:	82 9f       	mul	r24, r18
    23d4:	22 27       	eor	r18, r18
    23d6:	b0 0d       	add	r27, r0
    23d8:	a1 1d       	adc	r26, r1
    23da:	62 1f       	adc	r22, r18
    23dc:	73 9f       	mul	r23, r19
    23de:	b0 0d       	add	r27, r0
    23e0:	a1 1d       	adc	r26, r1
    23e2:	62 1f       	adc	r22, r18
    23e4:	83 9f       	mul	r24, r19
    23e6:	a0 0d       	add	r26, r0
    23e8:	61 1d       	adc	r22, r1
    23ea:	22 1f       	adc	r18, r18
    23ec:	74 9f       	mul	r23, r20
    23ee:	33 27       	eor	r19, r19
    23f0:	a0 0d       	add	r26, r0
    23f2:	61 1d       	adc	r22, r1
    23f4:	23 1f       	adc	r18, r19
    23f6:	84 9f       	mul	r24, r20
    23f8:	60 0d       	add	r22, r0
    23fa:	21 1d       	adc	r18, r1
    23fc:	82 2f       	mov	r24, r18
    23fe:	76 2f       	mov	r23, r22
    2400:	6a 2f       	mov	r22, r26
    2402:	11 24       	eor	r1, r1
    2404:	9f 57       	subi	r25, 0x7F	; 127
    2406:	50 40       	sbci	r21, 0x00	; 0
    2408:	9a f0       	brmi	.+38     	; 0x2430 <__mulsf3_pse+0x88>
    240a:	f1 f0       	breq	.+60     	; 0x2448 <__mulsf3_pse+0xa0>
    240c:	88 23       	and	r24, r24
    240e:	4a f0       	brmi	.+18     	; 0x2422 <__mulsf3_pse+0x7a>
    2410:	ee 0f       	add	r30, r30
    2412:	ff 1f       	adc	r31, r31
    2414:	bb 1f       	adc	r27, r27
    2416:	66 1f       	adc	r22, r22
    2418:	77 1f       	adc	r23, r23
    241a:	88 1f       	adc	r24, r24
    241c:	91 50       	subi	r25, 0x01	; 1
    241e:	50 40       	sbci	r21, 0x00	; 0
    2420:	a9 f7       	brne	.-22     	; 0x240c <__mulsf3_pse+0x64>
    2422:	9e 3f       	cpi	r25, 0xFE	; 254
    2424:	51 05       	cpc	r21, r1
    2426:	80 f0       	brcs	.+32     	; 0x2448 <__mulsf3_pse+0xa0>
    2428:	0c 94 6d 11 	jmp	0x22da	; 0x22da <__fp_inf>
    242c:	0c 94 b8 11 	jmp	0x2370	; 0x2370 <__fp_szero>
    2430:	5f 3f       	cpi	r21, 0xFF	; 255
    2432:	e4 f3       	brlt	.-8      	; 0x242c <__mulsf3_pse+0x84>
    2434:	98 3e       	cpi	r25, 0xE8	; 232
    2436:	d4 f3       	brlt	.-12     	; 0x242c <__mulsf3_pse+0x84>
    2438:	86 95       	lsr	r24
    243a:	77 95       	ror	r23
    243c:	67 95       	ror	r22
    243e:	b7 95       	ror	r27
    2440:	f7 95       	ror	r31
    2442:	e7 95       	ror	r30
    2444:	9f 5f       	subi	r25, 0xFF	; 255
    2446:	c1 f7       	brne	.-16     	; 0x2438 <__mulsf3_pse+0x90>
    2448:	fe 2b       	or	r31, r30
    244a:	88 0f       	add	r24, r24
    244c:	91 1d       	adc	r25, r1
    244e:	96 95       	lsr	r25
    2450:	87 95       	ror	r24
    2452:	97 f9       	bld	r25, 7
    2454:	08 95       	ret

00002456 <__tablejump2__>:
    2456:	ee 0f       	add	r30, r30
    2458:	ff 1f       	adc	r31, r31
    245a:	05 90       	lpm	r0, Z+
    245c:	f4 91       	lpm	r31, Z
    245e:	e0 2d       	mov	r30, r0
    2460:	09 94       	ijmp

00002462 <strcmp>:
    2462:	fb 01       	movw	r30, r22
    2464:	dc 01       	movw	r26, r24
    2466:	8d 91       	ld	r24, X+
    2468:	01 90       	ld	r0, Z+
    246a:	80 19       	sub	r24, r0
    246c:	01 10       	cpse	r0, r1
    246e:	d9 f3       	breq	.-10     	; 0x2466 <strcmp+0x4>
    2470:	99 0b       	sbc	r25, r25
    2472:	08 95       	ret

00002474 <strcpy>:
    2474:	fb 01       	movw	r30, r22
    2476:	dc 01       	movw	r26, r24
    2478:	01 90       	ld	r0, Z+
    247a:	0d 92       	st	X+, r0
    247c:	00 20       	and	r0, r0
    247e:	e1 f7       	brne	.-8      	; 0x2478 <strcpy+0x4>
    2480:	08 95       	ret

00002482 <sprintf>:
    2482:	ae e0       	ldi	r26, 0x0E	; 14
    2484:	b0 e0       	ldi	r27, 0x00	; 0
    2486:	e7 e4       	ldi	r30, 0x47	; 71
    2488:	f2 e1       	ldi	r31, 0x12	; 18
    248a:	0c 94 02 15 	jmp	0x2a04	; 0x2a04 <__prologue_saves__+0x1c>
    248e:	0d 89       	ldd	r16, Y+21	; 0x15
    2490:	1e 89       	ldd	r17, Y+22	; 0x16
    2492:	86 e0       	ldi	r24, 0x06	; 6
    2494:	8c 83       	std	Y+4, r24	; 0x04
    2496:	1a 83       	std	Y+2, r17	; 0x02
    2498:	09 83       	std	Y+1, r16	; 0x01
    249a:	8f ef       	ldi	r24, 0xFF	; 255
    249c:	9f e7       	ldi	r25, 0x7F	; 127
    249e:	9e 83       	std	Y+6, r25	; 0x06
    24a0:	8d 83       	std	Y+5, r24	; 0x05
    24a2:	ae 01       	movw	r20, r28
    24a4:	47 5e       	subi	r20, 0xE7	; 231
    24a6:	5f 4f       	sbci	r21, 0xFF	; 255
    24a8:	6f 89       	ldd	r22, Y+23	; 0x17
    24aa:	78 8d       	ldd	r23, Y+24	; 0x18
    24ac:	ce 01       	movw	r24, r28
    24ae:	01 96       	adiw	r24, 0x01	; 1
    24b0:	0e 94 63 12 	call	0x24c6	; 0x24c6 <vfprintf>
    24b4:	ef 81       	ldd	r30, Y+7	; 0x07
    24b6:	f8 85       	ldd	r31, Y+8	; 0x08
    24b8:	e0 0f       	add	r30, r16
    24ba:	f1 1f       	adc	r31, r17
    24bc:	10 82       	st	Z, r1
    24be:	2e 96       	adiw	r28, 0x0e	; 14
    24c0:	e4 e0       	ldi	r30, 0x04	; 4
    24c2:	0c 94 1e 15 	jmp	0x2a3c	; 0x2a3c <__epilogue_restores__+0x1c>

000024c6 <vfprintf>:
    24c6:	ab e0       	ldi	r26, 0x0B	; 11
    24c8:	b0 e0       	ldi	r27, 0x00	; 0
    24ca:	e9 e6       	ldi	r30, 0x69	; 105
    24cc:	f2 e1       	ldi	r31, 0x12	; 18
    24ce:	0c 94 f4 14 	jmp	0x29e8	; 0x29e8 <__prologue_saves__>
    24d2:	6c 01       	movw	r12, r24
    24d4:	7b 01       	movw	r14, r22
    24d6:	8a 01       	movw	r16, r20
    24d8:	fc 01       	movw	r30, r24
    24da:	17 82       	std	Z+7, r1	; 0x07
    24dc:	16 82       	std	Z+6, r1	; 0x06
    24de:	83 81       	ldd	r24, Z+3	; 0x03
    24e0:	81 ff       	sbrs	r24, 1
    24e2:	cc c1       	rjmp	.+920    	; 0x287c <vfprintf+0x3b6>
    24e4:	ce 01       	movw	r24, r28
    24e6:	01 96       	adiw	r24, 0x01	; 1
    24e8:	3c 01       	movw	r6, r24
    24ea:	f6 01       	movw	r30, r12
    24ec:	93 81       	ldd	r25, Z+3	; 0x03
    24ee:	f7 01       	movw	r30, r14
    24f0:	93 fd       	sbrc	r25, 3
    24f2:	85 91       	lpm	r24, Z+
    24f4:	93 ff       	sbrs	r25, 3
    24f6:	81 91       	ld	r24, Z+
    24f8:	7f 01       	movw	r14, r30
    24fa:	88 23       	and	r24, r24
    24fc:	09 f4       	brne	.+2      	; 0x2500 <vfprintf+0x3a>
    24fe:	ba c1       	rjmp	.+884    	; 0x2874 <vfprintf+0x3ae>
    2500:	85 32       	cpi	r24, 0x25	; 37
    2502:	39 f4       	brne	.+14     	; 0x2512 <vfprintf+0x4c>
    2504:	93 fd       	sbrc	r25, 3
    2506:	85 91       	lpm	r24, Z+
    2508:	93 ff       	sbrs	r25, 3
    250a:	81 91       	ld	r24, Z+
    250c:	7f 01       	movw	r14, r30
    250e:	85 32       	cpi	r24, 0x25	; 37
    2510:	29 f4       	brne	.+10     	; 0x251c <vfprintf+0x56>
    2512:	b6 01       	movw	r22, r12
    2514:	90 e0       	ldi	r25, 0x00	; 0
    2516:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <fputc>
    251a:	e7 cf       	rjmp	.-50     	; 0x24ea <vfprintf+0x24>
    251c:	91 2c       	mov	r9, r1
    251e:	21 2c       	mov	r2, r1
    2520:	31 2c       	mov	r3, r1
    2522:	ff e1       	ldi	r31, 0x1F	; 31
    2524:	f3 15       	cp	r31, r3
    2526:	d8 f0       	brcs	.+54     	; 0x255e <vfprintf+0x98>
    2528:	8b 32       	cpi	r24, 0x2B	; 43
    252a:	79 f0       	breq	.+30     	; 0x254a <vfprintf+0x84>
    252c:	38 f4       	brcc	.+14     	; 0x253c <vfprintf+0x76>
    252e:	80 32       	cpi	r24, 0x20	; 32
    2530:	79 f0       	breq	.+30     	; 0x2550 <vfprintf+0x8a>
    2532:	83 32       	cpi	r24, 0x23	; 35
    2534:	a1 f4       	brne	.+40     	; 0x255e <vfprintf+0x98>
    2536:	23 2d       	mov	r18, r3
    2538:	20 61       	ori	r18, 0x10	; 16
    253a:	1d c0       	rjmp	.+58     	; 0x2576 <vfprintf+0xb0>
    253c:	8d 32       	cpi	r24, 0x2D	; 45
    253e:	61 f0       	breq	.+24     	; 0x2558 <vfprintf+0x92>
    2540:	80 33       	cpi	r24, 0x30	; 48
    2542:	69 f4       	brne	.+26     	; 0x255e <vfprintf+0x98>
    2544:	23 2d       	mov	r18, r3
    2546:	21 60       	ori	r18, 0x01	; 1
    2548:	16 c0       	rjmp	.+44     	; 0x2576 <vfprintf+0xb0>
    254a:	83 2d       	mov	r24, r3
    254c:	82 60       	ori	r24, 0x02	; 2
    254e:	38 2e       	mov	r3, r24
    2550:	e3 2d       	mov	r30, r3
    2552:	e4 60       	ori	r30, 0x04	; 4
    2554:	3e 2e       	mov	r3, r30
    2556:	2a c0       	rjmp	.+84     	; 0x25ac <vfprintf+0xe6>
    2558:	f3 2d       	mov	r31, r3
    255a:	f8 60       	ori	r31, 0x08	; 8
    255c:	1d c0       	rjmp	.+58     	; 0x2598 <vfprintf+0xd2>
    255e:	37 fc       	sbrc	r3, 7
    2560:	2d c0       	rjmp	.+90     	; 0x25bc <vfprintf+0xf6>
    2562:	20 ed       	ldi	r18, 0xD0	; 208
    2564:	28 0f       	add	r18, r24
    2566:	2a 30       	cpi	r18, 0x0A	; 10
    2568:	40 f0       	brcs	.+16     	; 0x257a <vfprintf+0xb4>
    256a:	8e 32       	cpi	r24, 0x2E	; 46
    256c:	b9 f4       	brne	.+46     	; 0x259c <vfprintf+0xd6>
    256e:	36 fc       	sbrc	r3, 6
    2570:	81 c1       	rjmp	.+770    	; 0x2874 <vfprintf+0x3ae>
    2572:	23 2d       	mov	r18, r3
    2574:	20 64       	ori	r18, 0x40	; 64
    2576:	32 2e       	mov	r3, r18
    2578:	19 c0       	rjmp	.+50     	; 0x25ac <vfprintf+0xe6>
    257a:	36 fe       	sbrs	r3, 6
    257c:	06 c0       	rjmp	.+12     	; 0x258a <vfprintf+0xc4>
    257e:	8a e0       	ldi	r24, 0x0A	; 10
    2580:	98 9e       	mul	r9, r24
    2582:	20 0d       	add	r18, r0
    2584:	11 24       	eor	r1, r1
    2586:	92 2e       	mov	r9, r18
    2588:	11 c0       	rjmp	.+34     	; 0x25ac <vfprintf+0xe6>
    258a:	ea e0       	ldi	r30, 0x0A	; 10
    258c:	2e 9e       	mul	r2, r30
    258e:	20 0d       	add	r18, r0
    2590:	11 24       	eor	r1, r1
    2592:	22 2e       	mov	r2, r18
    2594:	f3 2d       	mov	r31, r3
    2596:	f0 62       	ori	r31, 0x20	; 32
    2598:	3f 2e       	mov	r3, r31
    259a:	08 c0       	rjmp	.+16     	; 0x25ac <vfprintf+0xe6>
    259c:	8c 36       	cpi	r24, 0x6C	; 108
    259e:	21 f4       	brne	.+8      	; 0x25a8 <vfprintf+0xe2>
    25a0:	83 2d       	mov	r24, r3
    25a2:	80 68       	ori	r24, 0x80	; 128
    25a4:	38 2e       	mov	r3, r24
    25a6:	02 c0       	rjmp	.+4      	; 0x25ac <vfprintf+0xe6>
    25a8:	88 36       	cpi	r24, 0x68	; 104
    25aa:	41 f4       	brne	.+16     	; 0x25bc <vfprintf+0xf6>
    25ac:	f7 01       	movw	r30, r14
    25ae:	93 fd       	sbrc	r25, 3
    25b0:	85 91       	lpm	r24, Z+
    25b2:	93 ff       	sbrs	r25, 3
    25b4:	81 91       	ld	r24, Z+
    25b6:	7f 01       	movw	r14, r30
    25b8:	81 11       	cpse	r24, r1
    25ba:	b3 cf       	rjmp	.-154    	; 0x2522 <vfprintf+0x5c>
    25bc:	98 2f       	mov	r25, r24
    25be:	9f 7d       	andi	r25, 0xDF	; 223
    25c0:	95 54       	subi	r25, 0x45	; 69
    25c2:	93 30       	cpi	r25, 0x03	; 3
    25c4:	28 f4       	brcc	.+10     	; 0x25d0 <vfprintf+0x10a>
    25c6:	0c 5f       	subi	r16, 0xFC	; 252
    25c8:	1f 4f       	sbci	r17, 0xFF	; 255
    25ca:	9f e3       	ldi	r25, 0x3F	; 63
    25cc:	99 83       	std	Y+1, r25	; 0x01
    25ce:	0d c0       	rjmp	.+26     	; 0x25ea <vfprintf+0x124>
    25d0:	83 36       	cpi	r24, 0x63	; 99
    25d2:	31 f0       	breq	.+12     	; 0x25e0 <vfprintf+0x11a>
    25d4:	83 37       	cpi	r24, 0x73	; 115
    25d6:	71 f0       	breq	.+28     	; 0x25f4 <vfprintf+0x12e>
    25d8:	83 35       	cpi	r24, 0x53	; 83
    25da:	09 f0       	breq	.+2      	; 0x25de <vfprintf+0x118>
    25dc:	59 c0       	rjmp	.+178    	; 0x2690 <vfprintf+0x1ca>
    25de:	21 c0       	rjmp	.+66     	; 0x2622 <vfprintf+0x15c>
    25e0:	f8 01       	movw	r30, r16
    25e2:	80 81       	ld	r24, Z
    25e4:	89 83       	std	Y+1, r24	; 0x01
    25e6:	0e 5f       	subi	r16, 0xFE	; 254
    25e8:	1f 4f       	sbci	r17, 0xFF	; 255
    25ea:	88 24       	eor	r8, r8
    25ec:	83 94       	inc	r8
    25ee:	91 2c       	mov	r9, r1
    25f0:	53 01       	movw	r10, r6
    25f2:	13 c0       	rjmp	.+38     	; 0x261a <vfprintf+0x154>
    25f4:	28 01       	movw	r4, r16
    25f6:	f2 e0       	ldi	r31, 0x02	; 2
    25f8:	4f 0e       	add	r4, r31
    25fa:	51 1c       	adc	r5, r1
    25fc:	f8 01       	movw	r30, r16
    25fe:	a0 80       	ld	r10, Z
    2600:	b1 80       	ldd	r11, Z+1	; 0x01
    2602:	36 fe       	sbrs	r3, 6
    2604:	03 c0       	rjmp	.+6      	; 0x260c <vfprintf+0x146>
    2606:	69 2d       	mov	r22, r9
    2608:	70 e0       	ldi	r23, 0x00	; 0
    260a:	02 c0       	rjmp	.+4      	; 0x2610 <vfprintf+0x14a>
    260c:	6f ef       	ldi	r22, 0xFF	; 255
    260e:	7f ef       	ldi	r23, 0xFF	; 255
    2610:	c5 01       	movw	r24, r10
    2612:	0e 94 4f 14 	call	0x289e	; 0x289e <strnlen>
    2616:	4c 01       	movw	r8, r24
    2618:	82 01       	movw	r16, r4
    261a:	f3 2d       	mov	r31, r3
    261c:	ff 77       	andi	r31, 0x7F	; 127
    261e:	3f 2e       	mov	r3, r31
    2620:	16 c0       	rjmp	.+44     	; 0x264e <vfprintf+0x188>
    2622:	28 01       	movw	r4, r16
    2624:	22 e0       	ldi	r18, 0x02	; 2
    2626:	42 0e       	add	r4, r18
    2628:	51 1c       	adc	r5, r1
    262a:	f8 01       	movw	r30, r16
    262c:	a0 80       	ld	r10, Z
    262e:	b1 80       	ldd	r11, Z+1	; 0x01
    2630:	36 fe       	sbrs	r3, 6
    2632:	03 c0       	rjmp	.+6      	; 0x263a <vfprintf+0x174>
    2634:	69 2d       	mov	r22, r9
    2636:	70 e0       	ldi	r23, 0x00	; 0
    2638:	02 c0       	rjmp	.+4      	; 0x263e <vfprintf+0x178>
    263a:	6f ef       	ldi	r22, 0xFF	; 255
    263c:	7f ef       	ldi	r23, 0xFF	; 255
    263e:	c5 01       	movw	r24, r10
    2640:	0e 94 44 14 	call	0x2888	; 0x2888 <strnlen_P>
    2644:	4c 01       	movw	r8, r24
    2646:	f3 2d       	mov	r31, r3
    2648:	f0 68       	ori	r31, 0x80	; 128
    264a:	3f 2e       	mov	r3, r31
    264c:	82 01       	movw	r16, r4
    264e:	33 fc       	sbrc	r3, 3
    2650:	1b c0       	rjmp	.+54     	; 0x2688 <vfprintf+0x1c2>
    2652:	82 2d       	mov	r24, r2
    2654:	90 e0       	ldi	r25, 0x00	; 0
    2656:	88 16       	cp	r8, r24
    2658:	99 06       	cpc	r9, r25
    265a:	b0 f4       	brcc	.+44     	; 0x2688 <vfprintf+0x1c2>
    265c:	b6 01       	movw	r22, r12
    265e:	80 e2       	ldi	r24, 0x20	; 32
    2660:	90 e0       	ldi	r25, 0x00	; 0
    2662:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <fputc>
    2666:	2a 94       	dec	r2
    2668:	f4 cf       	rjmp	.-24     	; 0x2652 <vfprintf+0x18c>
    266a:	f5 01       	movw	r30, r10
    266c:	37 fc       	sbrc	r3, 7
    266e:	85 91       	lpm	r24, Z+
    2670:	37 fe       	sbrs	r3, 7
    2672:	81 91       	ld	r24, Z+
    2674:	5f 01       	movw	r10, r30
    2676:	b6 01       	movw	r22, r12
    2678:	90 e0       	ldi	r25, 0x00	; 0
    267a:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <fputc>
    267e:	21 10       	cpse	r2, r1
    2680:	2a 94       	dec	r2
    2682:	21 e0       	ldi	r18, 0x01	; 1
    2684:	82 1a       	sub	r8, r18
    2686:	91 08       	sbc	r9, r1
    2688:	81 14       	cp	r8, r1
    268a:	91 04       	cpc	r9, r1
    268c:	71 f7       	brne	.-36     	; 0x266a <vfprintf+0x1a4>
    268e:	e8 c0       	rjmp	.+464    	; 0x2860 <vfprintf+0x39a>
    2690:	84 36       	cpi	r24, 0x64	; 100
    2692:	11 f0       	breq	.+4      	; 0x2698 <vfprintf+0x1d2>
    2694:	89 36       	cpi	r24, 0x69	; 105
    2696:	41 f5       	brne	.+80     	; 0x26e8 <vfprintf+0x222>
    2698:	f8 01       	movw	r30, r16
    269a:	37 fe       	sbrs	r3, 7
    269c:	07 c0       	rjmp	.+14     	; 0x26ac <vfprintf+0x1e6>
    269e:	60 81       	ld	r22, Z
    26a0:	71 81       	ldd	r23, Z+1	; 0x01
    26a2:	82 81       	ldd	r24, Z+2	; 0x02
    26a4:	93 81       	ldd	r25, Z+3	; 0x03
    26a6:	0c 5f       	subi	r16, 0xFC	; 252
    26a8:	1f 4f       	sbci	r17, 0xFF	; 255
    26aa:	08 c0       	rjmp	.+16     	; 0x26bc <vfprintf+0x1f6>
    26ac:	60 81       	ld	r22, Z
    26ae:	71 81       	ldd	r23, Z+1	; 0x01
    26b0:	07 2e       	mov	r0, r23
    26b2:	00 0c       	add	r0, r0
    26b4:	88 0b       	sbc	r24, r24
    26b6:	99 0b       	sbc	r25, r25
    26b8:	0e 5f       	subi	r16, 0xFE	; 254
    26ba:	1f 4f       	sbci	r17, 0xFF	; 255
    26bc:	f3 2d       	mov	r31, r3
    26be:	ff 76       	andi	r31, 0x6F	; 111
    26c0:	3f 2e       	mov	r3, r31
    26c2:	97 ff       	sbrs	r25, 7
    26c4:	09 c0       	rjmp	.+18     	; 0x26d8 <vfprintf+0x212>
    26c6:	90 95       	com	r25
    26c8:	80 95       	com	r24
    26ca:	70 95       	com	r23
    26cc:	61 95       	neg	r22
    26ce:	7f 4f       	sbci	r23, 0xFF	; 255
    26d0:	8f 4f       	sbci	r24, 0xFF	; 255
    26d2:	9f 4f       	sbci	r25, 0xFF	; 255
    26d4:	f0 68       	ori	r31, 0x80	; 128
    26d6:	3f 2e       	mov	r3, r31
    26d8:	2a e0       	ldi	r18, 0x0A	; 10
    26da:	30 e0       	ldi	r19, 0x00	; 0
    26dc:	a3 01       	movw	r20, r6
    26de:	0e 94 96 14 	call	0x292c	; 0x292c <__ultoa_invert>
    26e2:	88 2e       	mov	r8, r24
    26e4:	86 18       	sub	r8, r6
    26e6:	45 c0       	rjmp	.+138    	; 0x2772 <vfprintf+0x2ac>
    26e8:	85 37       	cpi	r24, 0x75	; 117
    26ea:	31 f4       	brne	.+12     	; 0x26f8 <vfprintf+0x232>
    26ec:	23 2d       	mov	r18, r3
    26ee:	2f 7e       	andi	r18, 0xEF	; 239
    26f0:	b2 2e       	mov	r11, r18
    26f2:	2a e0       	ldi	r18, 0x0A	; 10
    26f4:	30 e0       	ldi	r19, 0x00	; 0
    26f6:	25 c0       	rjmp	.+74     	; 0x2742 <vfprintf+0x27c>
    26f8:	93 2d       	mov	r25, r3
    26fa:	99 7f       	andi	r25, 0xF9	; 249
    26fc:	b9 2e       	mov	r11, r25
    26fe:	8f 36       	cpi	r24, 0x6F	; 111
    2700:	c1 f0       	breq	.+48     	; 0x2732 <vfprintf+0x26c>
    2702:	18 f4       	brcc	.+6      	; 0x270a <vfprintf+0x244>
    2704:	88 35       	cpi	r24, 0x58	; 88
    2706:	79 f0       	breq	.+30     	; 0x2726 <vfprintf+0x260>
    2708:	b5 c0       	rjmp	.+362    	; 0x2874 <vfprintf+0x3ae>
    270a:	80 37       	cpi	r24, 0x70	; 112
    270c:	19 f0       	breq	.+6      	; 0x2714 <vfprintf+0x24e>
    270e:	88 37       	cpi	r24, 0x78	; 120
    2710:	21 f0       	breq	.+8      	; 0x271a <vfprintf+0x254>
    2712:	b0 c0       	rjmp	.+352    	; 0x2874 <vfprintf+0x3ae>
    2714:	e9 2f       	mov	r30, r25
    2716:	e0 61       	ori	r30, 0x10	; 16
    2718:	be 2e       	mov	r11, r30
    271a:	b4 fe       	sbrs	r11, 4
    271c:	0d c0       	rjmp	.+26     	; 0x2738 <vfprintf+0x272>
    271e:	fb 2d       	mov	r31, r11
    2720:	f4 60       	ori	r31, 0x04	; 4
    2722:	bf 2e       	mov	r11, r31
    2724:	09 c0       	rjmp	.+18     	; 0x2738 <vfprintf+0x272>
    2726:	34 fe       	sbrs	r3, 4
    2728:	0a c0       	rjmp	.+20     	; 0x273e <vfprintf+0x278>
    272a:	29 2f       	mov	r18, r25
    272c:	26 60       	ori	r18, 0x06	; 6
    272e:	b2 2e       	mov	r11, r18
    2730:	06 c0       	rjmp	.+12     	; 0x273e <vfprintf+0x278>
    2732:	28 e0       	ldi	r18, 0x08	; 8
    2734:	30 e0       	ldi	r19, 0x00	; 0
    2736:	05 c0       	rjmp	.+10     	; 0x2742 <vfprintf+0x27c>
    2738:	20 e1       	ldi	r18, 0x10	; 16
    273a:	30 e0       	ldi	r19, 0x00	; 0
    273c:	02 c0       	rjmp	.+4      	; 0x2742 <vfprintf+0x27c>
    273e:	20 e1       	ldi	r18, 0x10	; 16
    2740:	32 e0       	ldi	r19, 0x02	; 2
    2742:	f8 01       	movw	r30, r16
    2744:	b7 fe       	sbrs	r11, 7
    2746:	07 c0       	rjmp	.+14     	; 0x2756 <vfprintf+0x290>
    2748:	60 81       	ld	r22, Z
    274a:	71 81       	ldd	r23, Z+1	; 0x01
    274c:	82 81       	ldd	r24, Z+2	; 0x02
    274e:	93 81       	ldd	r25, Z+3	; 0x03
    2750:	0c 5f       	subi	r16, 0xFC	; 252
    2752:	1f 4f       	sbci	r17, 0xFF	; 255
    2754:	06 c0       	rjmp	.+12     	; 0x2762 <vfprintf+0x29c>
    2756:	60 81       	ld	r22, Z
    2758:	71 81       	ldd	r23, Z+1	; 0x01
    275a:	80 e0       	ldi	r24, 0x00	; 0
    275c:	90 e0       	ldi	r25, 0x00	; 0
    275e:	0e 5f       	subi	r16, 0xFE	; 254
    2760:	1f 4f       	sbci	r17, 0xFF	; 255
    2762:	a3 01       	movw	r20, r6
    2764:	0e 94 96 14 	call	0x292c	; 0x292c <__ultoa_invert>
    2768:	88 2e       	mov	r8, r24
    276a:	86 18       	sub	r8, r6
    276c:	fb 2d       	mov	r31, r11
    276e:	ff 77       	andi	r31, 0x7F	; 127
    2770:	3f 2e       	mov	r3, r31
    2772:	36 fe       	sbrs	r3, 6
    2774:	0d c0       	rjmp	.+26     	; 0x2790 <vfprintf+0x2ca>
    2776:	23 2d       	mov	r18, r3
    2778:	2e 7f       	andi	r18, 0xFE	; 254
    277a:	a2 2e       	mov	r10, r18
    277c:	89 14       	cp	r8, r9
    277e:	58 f4       	brcc	.+22     	; 0x2796 <vfprintf+0x2d0>
    2780:	34 fe       	sbrs	r3, 4
    2782:	0b c0       	rjmp	.+22     	; 0x279a <vfprintf+0x2d4>
    2784:	32 fc       	sbrc	r3, 2
    2786:	09 c0       	rjmp	.+18     	; 0x279a <vfprintf+0x2d4>
    2788:	83 2d       	mov	r24, r3
    278a:	8e 7e       	andi	r24, 0xEE	; 238
    278c:	a8 2e       	mov	r10, r24
    278e:	05 c0       	rjmp	.+10     	; 0x279a <vfprintf+0x2d4>
    2790:	b8 2c       	mov	r11, r8
    2792:	a3 2c       	mov	r10, r3
    2794:	03 c0       	rjmp	.+6      	; 0x279c <vfprintf+0x2d6>
    2796:	b8 2c       	mov	r11, r8
    2798:	01 c0       	rjmp	.+2      	; 0x279c <vfprintf+0x2d6>
    279a:	b9 2c       	mov	r11, r9
    279c:	a4 fe       	sbrs	r10, 4
    279e:	0f c0       	rjmp	.+30     	; 0x27be <vfprintf+0x2f8>
    27a0:	fe 01       	movw	r30, r28
    27a2:	e8 0d       	add	r30, r8
    27a4:	f1 1d       	adc	r31, r1
    27a6:	80 81       	ld	r24, Z
    27a8:	80 33       	cpi	r24, 0x30	; 48
    27aa:	21 f4       	brne	.+8      	; 0x27b4 <vfprintf+0x2ee>
    27ac:	9a 2d       	mov	r25, r10
    27ae:	99 7e       	andi	r25, 0xE9	; 233
    27b0:	a9 2e       	mov	r10, r25
    27b2:	09 c0       	rjmp	.+18     	; 0x27c6 <vfprintf+0x300>
    27b4:	a2 fe       	sbrs	r10, 2
    27b6:	06 c0       	rjmp	.+12     	; 0x27c4 <vfprintf+0x2fe>
    27b8:	b3 94       	inc	r11
    27ba:	b3 94       	inc	r11
    27bc:	04 c0       	rjmp	.+8      	; 0x27c6 <vfprintf+0x300>
    27be:	8a 2d       	mov	r24, r10
    27c0:	86 78       	andi	r24, 0x86	; 134
    27c2:	09 f0       	breq	.+2      	; 0x27c6 <vfprintf+0x300>
    27c4:	b3 94       	inc	r11
    27c6:	a3 fc       	sbrc	r10, 3
    27c8:	11 c0       	rjmp	.+34     	; 0x27ec <vfprintf+0x326>
    27ca:	a0 fe       	sbrs	r10, 0
    27cc:	06 c0       	rjmp	.+12     	; 0x27da <vfprintf+0x314>
    27ce:	b2 14       	cp	r11, r2
    27d0:	88 f4       	brcc	.+34     	; 0x27f4 <vfprintf+0x32e>
    27d2:	28 0c       	add	r2, r8
    27d4:	92 2c       	mov	r9, r2
    27d6:	9b 18       	sub	r9, r11
    27d8:	0e c0       	rjmp	.+28     	; 0x27f6 <vfprintf+0x330>
    27da:	b2 14       	cp	r11, r2
    27dc:	60 f4       	brcc	.+24     	; 0x27f6 <vfprintf+0x330>
    27de:	b6 01       	movw	r22, r12
    27e0:	80 e2       	ldi	r24, 0x20	; 32
    27e2:	90 e0       	ldi	r25, 0x00	; 0
    27e4:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <fputc>
    27e8:	b3 94       	inc	r11
    27ea:	f7 cf       	rjmp	.-18     	; 0x27da <vfprintf+0x314>
    27ec:	b2 14       	cp	r11, r2
    27ee:	18 f4       	brcc	.+6      	; 0x27f6 <vfprintf+0x330>
    27f0:	2b 18       	sub	r2, r11
    27f2:	02 c0       	rjmp	.+4      	; 0x27f8 <vfprintf+0x332>
    27f4:	98 2c       	mov	r9, r8
    27f6:	21 2c       	mov	r2, r1
    27f8:	a4 fe       	sbrs	r10, 4
    27fa:	10 c0       	rjmp	.+32     	; 0x281c <vfprintf+0x356>
    27fc:	b6 01       	movw	r22, r12
    27fe:	80 e3       	ldi	r24, 0x30	; 48
    2800:	90 e0       	ldi	r25, 0x00	; 0
    2802:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <fputc>
    2806:	a2 fe       	sbrs	r10, 2
    2808:	17 c0       	rjmp	.+46     	; 0x2838 <vfprintf+0x372>
    280a:	a1 fc       	sbrc	r10, 1
    280c:	03 c0       	rjmp	.+6      	; 0x2814 <vfprintf+0x34e>
    280e:	88 e7       	ldi	r24, 0x78	; 120
    2810:	90 e0       	ldi	r25, 0x00	; 0
    2812:	02 c0       	rjmp	.+4      	; 0x2818 <vfprintf+0x352>
    2814:	88 e5       	ldi	r24, 0x58	; 88
    2816:	90 e0       	ldi	r25, 0x00	; 0
    2818:	b6 01       	movw	r22, r12
    281a:	0c c0       	rjmp	.+24     	; 0x2834 <vfprintf+0x36e>
    281c:	8a 2d       	mov	r24, r10
    281e:	86 78       	andi	r24, 0x86	; 134
    2820:	59 f0       	breq	.+22     	; 0x2838 <vfprintf+0x372>
    2822:	a1 fe       	sbrs	r10, 1
    2824:	02 c0       	rjmp	.+4      	; 0x282a <vfprintf+0x364>
    2826:	8b e2       	ldi	r24, 0x2B	; 43
    2828:	01 c0       	rjmp	.+2      	; 0x282c <vfprintf+0x366>
    282a:	80 e2       	ldi	r24, 0x20	; 32
    282c:	a7 fc       	sbrc	r10, 7
    282e:	8d e2       	ldi	r24, 0x2D	; 45
    2830:	b6 01       	movw	r22, r12
    2832:	90 e0       	ldi	r25, 0x00	; 0
    2834:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <fputc>
    2838:	89 14       	cp	r8, r9
    283a:	38 f4       	brcc	.+14     	; 0x284a <vfprintf+0x384>
    283c:	b6 01       	movw	r22, r12
    283e:	80 e3       	ldi	r24, 0x30	; 48
    2840:	90 e0       	ldi	r25, 0x00	; 0
    2842:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <fputc>
    2846:	9a 94       	dec	r9
    2848:	f7 cf       	rjmp	.-18     	; 0x2838 <vfprintf+0x372>
    284a:	8a 94       	dec	r8
    284c:	f3 01       	movw	r30, r6
    284e:	e8 0d       	add	r30, r8
    2850:	f1 1d       	adc	r31, r1
    2852:	80 81       	ld	r24, Z
    2854:	b6 01       	movw	r22, r12
    2856:	90 e0       	ldi	r25, 0x00	; 0
    2858:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <fputc>
    285c:	81 10       	cpse	r8, r1
    285e:	f5 cf       	rjmp	.-22     	; 0x284a <vfprintf+0x384>
    2860:	22 20       	and	r2, r2
    2862:	09 f4       	brne	.+2      	; 0x2866 <vfprintf+0x3a0>
    2864:	42 ce       	rjmp	.-892    	; 0x24ea <vfprintf+0x24>
    2866:	b6 01       	movw	r22, r12
    2868:	80 e2       	ldi	r24, 0x20	; 32
    286a:	90 e0       	ldi	r25, 0x00	; 0
    286c:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <fputc>
    2870:	2a 94       	dec	r2
    2872:	f6 cf       	rjmp	.-20     	; 0x2860 <vfprintf+0x39a>
    2874:	f6 01       	movw	r30, r12
    2876:	86 81       	ldd	r24, Z+6	; 0x06
    2878:	97 81       	ldd	r25, Z+7	; 0x07
    287a:	02 c0       	rjmp	.+4      	; 0x2880 <vfprintf+0x3ba>
    287c:	8f ef       	ldi	r24, 0xFF	; 255
    287e:	9f ef       	ldi	r25, 0xFF	; 255
    2880:	2b 96       	adiw	r28, 0x0b	; 11
    2882:	e2 e1       	ldi	r30, 0x12	; 18
    2884:	0c 94 10 15 	jmp	0x2a20	; 0x2a20 <__epilogue_restores__>

00002888 <strnlen_P>:
    2888:	fc 01       	movw	r30, r24
    288a:	05 90       	lpm	r0, Z+
    288c:	61 50       	subi	r22, 0x01	; 1
    288e:	70 40       	sbci	r23, 0x00	; 0
    2890:	01 10       	cpse	r0, r1
    2892:	d8 f7       	brcc	.-10     	; 0x288a <strnlen_P+0x2>
    2894:	80 95       	com	r24
    2896:	90 95       	com	r25
    2898:	8e 0f       	add	r24, r30
    289a:	9f 1f       	adc	r25, r31
    289c:	08 95       	ret

0000289e <strnlen>:
    289e:	fc 01       	movw	r30, r24
    28a0:	61 50       	subi	r22, 0x01	; 1
    28a2:	70 40       	sbci	r23, 0x00	; 0
    28a4:	01 90       	ld	r0, Z+
    28a6:	01 10       	cpse	r0, r1
    28a8:	d8 f7       	brcc	.-10     	; 0x28a0 <strnlen+0x2>
    28aa:	80 95       	com	r24
    28ac:	90 95       	com	r25
    28ae:	8e 0f       	add	r24, r30
    28b0:	9f 1f       	adc	r25, r31
    28b2:	08 95       	ret

000028b4 <fputc>:
    28b4:	0f 93       	push	r16
    28b6:	1f 93       	push	r17
    28b8:	cf 93       	push	r28
    28ba:	df 93       	push	r29
    28bc:	fb 01       	movw	r30, r22
    28be:	23 81       	ldd	r18, Z+3	; 0x03
    28c0:	21 fd       	sbrc	r18, 1
    28c2:	03 c0       	rjmp	.+6      	; 0x28ca <fputc+0x16>
    28c4:	8f ef       	ldi	r24, 0xFF	; 255
    28c6:	9f ef       	ldi	r25, 0xFF	; 255
    28c8:	2c c0       	rjmp	.+88     	; 0x2922 <fputc+0x6e>
    28ca:	22 ff       	sbrs	r18, 2
    28cc:	16 c0       	rjmp	.+44     	; 0x28fa <fputc+0x46>
    28ce:	46 81       	ldd	r20, Z+6	; 0x06
    28d0:	57 81       	ldd	r21, Z+7	; 0x07
    28d2:	24 81       	ldd	r18, Z+4	; 0x04
    28d4:	35 81       	ldd	r19, Z+5	; 0x05
    28d6:	42 17       	cp	r20, r18
    28d8:	53 07       	cpc	r21, r19
    28da:	44 f4       	brge	.+16     	; 0x28ec <fputc+0x38>
    28dc:	a0 81       	ld	r26, Z
    28de:	b1 81       	ldd	r27, Z+1	; 0x01
    28e0:	9d 01       	movw	r18, r26
    28e2:	2f 5f       	subi	r18, 0xFF	; 255
    28e4:	3f 4f       	sbci	r19, 0xFF	; 255
    28e6:	31 83       	std	Z+1, r19	; 0x01
    28e8:	20 83       	st	Z, r18
    28ea:	8c 93       	st	X, r24
    28ec:	26 81       	ldd	r18, Z+6	; 0x06
    28ee:	37 81       	ldd	r19, Z+7	; 0x07
    28f0:	2f 5f       	subi	r18, 0xFF	; 255
    28f2:	3f 4f       	sbci	r19, 0xFF	; 255
    28f4:	37 83       	std	Z+7, r19	; 0x07
    28f6:	26 83       	std	Z+6, r18	; 0x06
    28f8:	14 c0       	rjmp	.+40     	; 0x2922 <fputc+0x6e>
    28fa:	8b 01       	movw	r16, r22
    28fc:	ec 01       	movw	r28, r24
    28fe:	fb 01       	movw	r30, r22
    2900:	00 84       	ldd	r0, Z+8	; 0x08
    2902:	f1 85       	ldd	r31, Z+9	; 0x09
    2904:	e0 2d       	mov	r30, r0
    2906:	09 95       	icall
    2908:	89 2b       	or	r24, r25
    290a:	e1 f6       	brne	.-72     	; 0x28c4 <fputc+0x10>
    290c:	d8 01       	movw	r26, r16
    290e:	16 96       	adiw	r26, 0x06	; 6
    2910:	8d 91       	ld	r24, X+
    2912:	9c 91       	ld	r25, X
    2914:	17 97       	sbiw	r26, 0x07	; 7
    2916:	01 96       	adiw	r24, 0x01	; 1
    2918:	17 96       	adiw	r26, 0x07	; 7
    291a:	9c 93       	st	X, r25
    291c:	8e 93       	st	-X, r24
    291e:	16 97       	sbiw	r26, 0x06	; 6
    2920:	ce 01       	movw	r24, r28
    2922:	df 91       	pop	r29
    2924:	cf 91       	pop	r28
    2926:	1f 91       	pop	r17
    2928:	0f 91       	pop	r16
    292a:	08 95       	ret

0000292c <__ultoa_invert>:
    292c:	fa 01       	movw	r30, r20
    292e:	aa 27       	eor	r26, r26
    2930:	28 30       	cpi	r18, 0x08	; 8
    2932:	51 f1       	breq	.+84     	; 0x2988 <__ultoa_invert+0x5c>
    2934:	20 31       	cpi	r18, 0x10	; 16
    2936:	81 f1       	breq	.+96     	; 0x2998 <__ultoa_invert+0x6c>
    2938:	e8 94       	clt
    293a:	6f 93       	push	r22
    293c:	6e 7f       	andi	r22, 0xFE	; 254
    293e:	6e 5f       	subi	r22, 0xFE	; 254
    2940:	7f 4f       	sbci	r23, 0xFF	; 255
    2942:	8f 4f       	sbci	r24, 0xFF	; 255
    2944:	9f 4f       	sbci	r25, 0xFF	; 255
    2946:	af 4f       	sbci	r26, 0xFF	; 255
    2948:	b1 e0       	ldi	r27, 0x01	; 1
    294a:	3e d0       	rcall	.+124    	; 0x29c8 <__ultoa_invert+0x9c>
    294c:	b4 e0       	ldi	r27, 0x04	; 4
    294e:	3c d0       	rcall	.+120    	; 0x29c8 <__ultoa_invert+0x9c>
    2950:	67 0f       	add	r22, r23
    2952:	78 1f       	adc	r23, r24
    2954:	89 1f       	adc	r24, r25
    2956:	9a 1f       	adc	r25, r26
    2958:	a1 1d       	adc	r26, r1
    295a:	68 0f       	add	r22, r24
    295c:	79 1f       	adc	r23, r25
    295e:	8a 1f       	adc	r24, r26
    2960:	91 1d       	adc	r25, r1
    2962:	a1 1d       	adc	r26, r1
    2964:	6a 0f       	add	r22, r26
    2966:	71 1d       	adc	r23, r1
    2968:	81 1d       	adc	r24, r1
    296a:	91 1d       	adc	r25, r1
    296c:	a1 1d       	adc	r26, r1
    296e:	20 d0       	rcall	.+64     	; 0x29b0 <__ultoa_invert+0x84>
    2970:	09 f4       	brne	.+2      	; 0x2974 <__ultoa_invert+0x48>
    2972:	68 94       	set
    2974:	3f 91       	pop	r19
    2976:	2a e0       	ldi	r18, 0x0A	; 10
    2978:	26 9f       	mul	r18, r22
    297a:	11 24       	eor	r1, r1
    297c:	30 19       	sub	r19, r0
    297e:	30 5d       	subi	r19, 0xD0	; 208
    2980:	31 93       	st	Z+, r19
    2982:	de f6       	brtc	.-74     	; 0x293a <__ultoa_invert+0xe>
    2984:	cf 01       	movw	r24, r30
    2986:	08 95       	ret
    2988:	46 2f       	mov	r20, r22
    298a:	47 70       	andi	r20, 0x07	; 7
    298c:	40 5d       	subi	r20, 0xD0	; 208
    298e:	41 93       	st	Z+, r20
    2990:	b3 e0       	ldi	r27, 0x03	; 3
    2992:	0f d0       	rcall	.+30     	; 0x29b2 <__ultoa_invert+0x86>
    2994:	c9 f7       	brne	.-14     	; 0x2988 <__ultoa_invert+0x5c>
    2996:	f6 cf       	rjmp	.-20     	; 0x2984 <__ultoa_invert+0x58>
    2998:	46 2f       	mov	r20, r22
    299a:	4f 70       	andi	r20, 0x0F	; 15
    299c:	40 5d       	subi	r20, 0xD0	; 208
    299e:	4a 33       	cpi	r20, 0x3A	; 58
    29a0:	18 f0       	brcs	.+6      	; 0x29a8 <__ultoa_invert+0x7c>
    29a2:	49 5d       	subi	r20, 0xD9	; 217
    29a4:	31 fd       	sbrc	r19, 1
    29a6:	40 52       	subi	r20, 0x20	; 32
    29a8:	41 93       	st	Z+, r20
    29aa:	02 d0       	rcall	.+4      	; 0x29b0 <__ultoa_invert+0x84>
    29ac:	a9 f7       	brne	.-22     	; 0x2998 <__ultoa_invert+0x6c>
    29ae:	ea cf       	rjmp	.-44     	; 0x2984 <__ultoa_invert+0x58>
    29b0:	b4 e0       	ldi	r27, 0x04	; 4
    29b2:	a6 95       	lsr	r26
    29b4:	97 95       	ror	r25
    29b6:	87 95       	ror	r24
    29b8:	77 95       	ror	r23
    29ba:	67 95       	ror	r22
    29bc:	ba 95       	dec	r27
    29be:	c9 f7       	brne	.-14     	; 0x29b2 <__ultoa_invert+0x86>
    29c0:	00 97       	sbiw	r24, 0x00	; 0
    29c2:	61 05       	cpc	r22, r1
    29c4:	71 05       	cpc	r23, r1
    29c6:	08 95       	ret
    29c8:	9b 01       	movw	r18, r22
    29ca:	ac 01       	movw	r20, r24
    29cc:	0a 2e       	mov	r0, r26
    29ce:	06 94       	lsr	r0
    29d0:	57 95       	ror	r21
    29d2:	47 95       	ror	r20
    29d4:	37 95       	ror	r19
    29d6:	27 95       	ror	r18
    29d8:	ba 95       	dec	r27
    29da:	c9 f7       	brne	.-14     	; 0x29ce <__ultoa_invert+0xa2>
    29dc:	62 0f       	add	r22, r18
    29de:	73 1f       	adc	r23, r19
    29e0:	84 1f       	adc	r24, r20
    29e2:	95 1f       	adc	r25, r21
    29e4:	a0 1d       	adc	r26, r0
    29e6:	08 95       	ret

000029e8 <__prologue_saves__>:
    29e8:	2f 92       	push	r2
    29ea:	3f 92       	push	r3
    29ec:	4f 92       	push	r4
    29ee:	5f 92       	push	r5
    29f0:	6f 92       	push	r6
    29f2:	7f 92       	push	r7
    29f4:	8f 92       	push	r8
    29f6:	9f 92       	push	r9
    29f8:	af 92       	push	r10
    29fa:	bf 92       	push	r11
    29fc:	cf 92       	push	r12
    29fe:	df 92       	push	r13
    2a00:	ef 92       	push	r14
    2a02:	ff 92       	push	r15
    2a04:	0f 93       	push	r16
    2a06:	1f 93       	push	r17
    2a08:	cf 93       	push	r28
    2a0a:	df 93       	push	r29
    2a0c:	cd b7       	in	r28, 0x3d	; 61
    2a0e:	de b7       	in	r29, 0x3e	; 62
    2a10:	ca 1b       	sub	r28, r26
    2a12:	db 0b       	sbc	r29, r27
    2a14:	0f b6       	in	r0, 0x3f	; 63
    2a16:	f8 94       	cli
    2a18:	de bf       	out	0x3e, r29	; 62
    2a1a:	0f be       	out	0x3f, r0	; 63
    2a1c:	cd bf       	out	0x3d, r28	; 61
    2a1e:	09 94       	ijmp

00002a20 <__epilogue_restores__>:
    2a20:	2a 88       	ldd	r2, Y+18	; 0x12
    2a22:	39 88       	ldd	r3, Y+17	; 0x11
    2a24:	48 88       	ldd	r4, Y+16	; 0x10
    2a26:	5f 84       	ldd	r5, Y+15	; 0x0f
    2a28:	6e 84       	ldd	r6, Y+14	; 0x0e
    2a2a:	7d 84       	ldd	r7, Y+13	; 0x0d
    2a2c:	8c 84       	ldd	r8, Y+12	; 0x0c
    2a2e:	9b 84       	ldd	r9, Y+11	; 0x0b
    2a30:	aa 84       	ldd	r10, Y+10	; 0x0a
    2a32:	b9 84       	ldd	r11, Y+9	; 0x09
    2a34:	c8 84       	ldd	r12, Y+8	; 0x08
    2a36:	df 80       	ldd	r13, Y+7	; 0x07
    2a38:	ee 80       	ldd	r14, Y+6	; 0x06
    2a3a:	fd 80       	ldd	r15, Y+5	; 0x05
    2a3c:	0c 81       	ldd	r16, Y+4	; 0x04
    2a3e:	1b 81       	ldd	r17, Y+3	; 0x03
    2a40:	aa 81       	ldd	r26, Y+2	; 0x02
    2a42:	b9 81       	ldd	r27, Y+1	; 0x01
    2a44:	ce 0f       	add	r28, r30
    2a46:	d1 1d       	adc	r29, r1
    2a48:	0f b6       	in	r0, 0x3f	; 63
    2a4a:	f8 94       	cli
    2a4c:	de bf       	out	0x3e, r29	; 62
    2a4e:	0f be       	out	0x3f, r0	; 63
    2a50:	cd bf       	out	0x3d, r28	; 61
    2a52:	ed 01       	movw	r28, r26
    2a54:	08 95       	ret

00002a56 <_exit>:
    2a56:	f8 94       	cli

00002a58 <__stop_program>:
    2a58:	ff cf       	rjmp	.-2      	; 0x2a58 <__stop_program>
