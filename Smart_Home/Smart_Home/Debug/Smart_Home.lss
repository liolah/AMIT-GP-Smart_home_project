
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002d36  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000060e  00800060  00002d36  00002dca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000007c  0080066e  0080066e  000033d8  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000033d8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00003434  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000640  00000000  00000000  00003470  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006a03  00000000  00000000  00003ab0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001abf  00000000  00000000  0000a4b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000043fa  00000000  00000000  0000bf72  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ef4  00000000  00000000  0001036c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000015a2  00000000  00000000  00011260  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000399c  00000000  00000000  00012802  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004e0  00000000  00000000  0001619e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 82 00 	jmp	0x104	; 0x104 <__ctors_end>
       4:	0c 94 ce 0e 	jmp	0x1d9c	; 0x1d9c <__vector_1>
       8:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
       c:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      10:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      14:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      18:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      1c:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      20:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      24:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      28:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      2c:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      30:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      34:	0c 94 49 0e 	jmp	0x1c92	; 0x1c92 <__vector_13>
      38:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      3c:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      40:	0c 94 08 0f 	jmp	0x1e10	; 0x1e10 <__vector_16>
      44:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      48:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      4c:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      50:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__bad_interrupt>
      54:	87 03       	fmuls	r16, r23
      56:	8b 03       	fmulsu	r16, r19
      58:	8f 03       	fmulsu	r16, r23
      5a:	93 03       	fmuls	r17, r19
      5c:	97 03       	fmuls	r17, r23
      5e:	9b 03       	fmulsu	r17, r19
      60:	9f 03       	fmulsu	r17, r23
      62:	a9 05       	cpc	r26, r9
      64:	bd 05       	cpc	r27, r13
      66:	bd 05       	cpc	r27, r13
      68:	bd 05       	cpc	r27, r13
      6a:	bd 05       	cpc	r27, r13
      6c:	bd 05       	cpc	r27, r13
      6e:	bd 05       	cpc	r27, r13
      70:	bd 05       	cpc	r27, r13
      72:	bf 05       	cpc	r27, r15
      74:	bd 05       	cpc	r27, r13
      76:	bd 05       	cpc	r27, r13
      78:	bd 05       	cpc	r27, r13
      7a:	bd 05       	cpc	r27, r13
      7c:	bd 05       	cpc	r27, r13
      7e:	bd 05       	cpc	r27, r13
      80:	bd 05       	cpc	r27, r13
      82:	ab 05       	cpc	r26, r11
      84:	bd 05       	cpc	r27, r13
      86:	bd 05       	cpc	r27, r13
      88:	bd 05       	cpc	r27, r13
      8a:	bd 05       	cpc	r27, r13
      8c:	bd 05       	cpc	r27, r13
      8e:	bd 05       	cpc	r27, r13
      90:	bd 05       	cpc	r27, r13
      92:	ad 05       	cpc	r26, r13
      94:	bd 05       	cpc	r27, r13
      96:	bd 05       	cpc	r27, r13
      98:	bd 05       	cpc	r27, r13
      9a:	bd 05       	cpc	r27, r13
      9c:	bd 05       	cpc	r27, r13
      9e:	bd 05       	cpc	r27, r13
      a0:	bd 05       	cpc	r27, r13
      a2:	af 05       	cpc	r26, r15
      a4:	bd 05       	cpc	r27, r13
      a6:	bd 05       	cpc	r27, r13
      a8:	bd 05       	cpc	r27, r13
      aa:	bd 05       	cpc	r27, r13
      ac:	bd 05       	cpc	r27, r13
      ae:	bd 05       	cpc	r27, r13
      b0:	bd 05       	cpc	r27, r13
      b2:	b1 05       	cpc	r27, r1
      b4:	bd 05       	cpc	r27, r13
      b6:	bd 05       	cpc	r27, r13
      b8:	bd 05       	cpc	r27, r13
      ba:	bd 05       	cpc	r27, r13
      bc:	bd 05       	cpc	r27, r13
      be:	bd 05       	cpc	r27, r13
      c0:	bd 05       	cpc	r27, r13
      c2:	b3 05       	cpc	r27, r3
      c4:	bd 05       	cpc	r27, r13
      c6:	bd 05       	cpc	r27, r13
      c8:	bd 05       	cpc	r27, r13
      ca:	bd 05       	cpc	r27, r13
      cc:	bd 05       	cpc	r27, r13
      ce:	bd 05       	cpc	r27, r13
      d0:	bd 05       	cpc	r27, r13
      d2:	b5 05       	cpc	r27, r5
      d4:	bd 05       	cpc	r27, r13
      d6:	bd 05       	cpc	r27, r13
      d8:	bd 05       	cpc	r27, r13
      da:	bd 05       	cpc	r27, r13
      dc:	bd 05       	cpc	r27, r13
      de:	bd 05       	cpc	r27, r13
      e0:	bd 05       	cpc	r27, r13
      e2:	b7 05       	cpc	r27, r7
      e4:	bd 05       	cpc	r27, r13
      e6:	bd 05       	cpc	r27, r13
      e8:	bd 05       	cpc	r27, r13
      ea:	bd 05       	cpc	r27, r13
      ec:	bd 05       	cpc	r27, r13
      ee:	bd 05       	cpc	r27, r13
      f0:	bd 05       	cpc	r27, r13
      f2:	b9 05       	cpc	r27, r9
      f4:	bd 05       	cpc	r27, r13
      f6:	bd 05       	cpc	r27, r13
      f8:	bd 05       	cpc	r27, r13
      fa:	bd 05       	cpc	r27, r13
      fc:	bd 05       	cpc	r27, r13
      fe:	bd 05       	cpc	r27, r13
     100:	bd 05       	cpc	r27, r13
     102:	bb 05       	cpc	r27, r11

00000104 <__ctors_end>:
     104:	11 24       	eor	r1, r1
     106:	1f be       	out	0x3f, r1	; 63
     108:	cf e5       	ldi	r28, 0x5F	; 95
     10a:	d8 e0       	ldi	r29, 0x08	; 8
     10c:	de bf       	out	0x3e, r29	; 62
     10e:	cd bf       	out	0x3d, r28	; 61

00000110 <__do_copy_data>:
     110:	16 e0       	ldi	r17, 0x06	; 6
     112:	a0 e6       	ldi	r26, 0x60	; 96
     114:	b0 e0       	ldi	r27, 0x00	; 0
     116:	e6 e3       	ldi	r30, 0x36	; 54
     118:	fd e2       	ldi	r31, 0x2D	; 45
     11a:	02 c0       	rjmp	.+4      	; 0x120 <__do_copy_data+0x10>
     11c:	05 90       	lpm	r0, Z+
     11e:	0d 92       	st	X+, r0
     120:	ae 36       	cpi	r26, 0x6E	; 110
     122:	b1 07       	cpc	r27, r17
     124:	d9 f7       	brne	.-10     	; 0x11c <__do_copy_data+0xc>

00000126 <__do_clear_bss>:
     126:	26 e0       	ldi	r18, 0x06	; 6
     128:	ae e6       	ldi	r26, 0x6E	; 110
     12a:	b6 e0       	ldi	r27, 0x06	; 6
     12c:	01 c0       	rjmp	.+2      	; 0x130 <.do_clear_bss_start>

0000012e <.do_clear_bss_loop>:
     12e:	1d 92       	st	X+, r1

00000130 <.do_clear_bss_start>:
     130:	aa 3e       	cpi	r26, 0xEA	; 234
     132:	b2 07       	cpc	r27, r18
     134:	e1 f7       	brne	.-8      	; 0x12e <.do_clear_bss_loop>
     136:	0e 94 59 03 	call	0x6b2	; 0x6b2 <main>
     13a:	0c 94 99 16 	jmp	0x2d32	; 0x2d32 <_exit>

0000013e <__bad_interrupt>:
     13e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000142 <App_init>:

#include "app.h"

 // Does all the initializations required in the app
void App_init(void) {
  Remote_init(9600);
     142:	60 e8       	ldi	r22, 0x80	; 128
     144:	75 e2       	ldi	r23, 0x25	; 37
     146:	80 e0       	ldi	r24, 0x00	; 0
     148:	90 e0       	ldi	r25, 0x00	; 0
     14a:	0e 94 cf 0a 	call	0x159e	; 0x159e <Remote_init>
  Local_access_init();
     14e:	0e 94 c8 0a 	call	0x1590	; 0x1590 <Local_access_init>
  Lamps_init();
     152:	0e 94 15 0a 	call	0x142a	; 0x142a <Lamps_init>
  Door_init();
     156:	0e 94 07 0a 	call	0x140e	; 0x140e <Door_init>
  AC_auto_control_service_start();
     15a:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <AC_auto_control_service_start>
  Buzzer_init(BUZZER_PORT, BUZZER_PIN);
     15e:	63 e0       	ldi	r22, 0x03	; 3
     160:	84 e4       	ldi	r24, 0x44	; 68
     162:	0e 94 c2 00 	call	0x184	; 0x184 <Buzzer_init>
  sei();
     166:	78 94       	sei

  // Uncomment and use only one time to initialize the DB
  // User_DB_format();

  run_system = true;
     168:	81 e0       	ldi	r24, 0x01	; 1
     16a:	80 93 71 06 	sts	0x0671, r24	; 0x800671 <run_system>
     16e:	08 95       	ret

00000170 <App_start>:
  }

// Contains all functionalities and top level logic of the app
void App_start(void) {
  while (run_system) {
     170:	80 91 71 06 	lds	r24, 0x0671	; 0x800671 <run_system>
     174:	81 11       	cpse	r24, r1
     176:	fc cf       	rjmp	.-8      	; 0x170 <App_start>
    // Local_control_input_handler();
    }
  cli();
     178:	f8 94       	cli
  // If the invalid attempts are exhausted, the program will halt.
  // The program can halt by returning  and letting it reach the end of main. Or by just entering another infinite loop.
    // Set the alarm
  Buzzer_on(BUZZER_PORT, BUZZER_PIN);
     17a:	63 e0       	ldi	r22, 0x03	; 3
     17c:	84 e4       	ldi	r24, 0x44	; 68
     17e:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_on>
     182:	ff cf       	rjmp	.-2      	; 0x182 <App_start+0x12>

00000184 <Buzzer_init>:
 */

#include "buzzer.h"

 // Initialize the buzzer
EN_BuzzerError_t Buzzer_init(u8 buzzerPort, u8 buzzerPin) {
     184:	98 2f       	mov	r25, r24
     186:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(buzzerPin, buzzerPort, OUT) == DIO_OK) {
     188:	41 e0       	ldi	r20, 0x01	; 1
     18a:	69 2f       	mov	r22, r25
     18c:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
     190:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that the buzzer initialization failed
  return BUZZER_ERROR_INIT;
     192:	81 e0       	ldi	r24, 0x01	; 1
  }
     194:	08 95       	ret

00000196 <Buzzer_on>:

// Turn on the buzzer
EN_BuzzerError_t Buzzer_on(u8 buzzerPort, u8 buzzerPin) {
     196:	98 2f       	mov	r25, r24
     198:	86 2f       	mov	r24, r22
  if (DIO_write(buzzerPin, buzzerPort, HIGH) == DIO_OK) {
     19a:	41 e0       	ldi	r20, 0x01	; 1
     19c:	69 2f       	mov	r22, r25
     19e:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
     1a2:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that attempting to turn on the buzzer has failed
  return BUZZER_ERROR_ON;
     1a4:	82 e0       	ldi	r24, 0x02	; 2
  }
     1a6:	08 95       	ret

000001a8 <EEPROM_init>:
 */

#include "eeprom.h"

void EEPROM_init() {
  I2C_init();
     1a8:	0e 94 c1 05 	call	0xb82	; 0xb82 <I2C_init>
     1ac:	08 95       	ret

000001ae <EEPROM_read_byte>:
  }

void EEPROM_read_byte(u8 page, u8 address, s8* data) {
     1ae:	0f 93       	push	r16
     1b0:	1f 93       	push	r17
     1b2:	cf 93       	push	r28
     1b4:	df 93       	push	r29
     1b6:	c8 2f       	mov	r28, r24
     1b8:	d6 2f       	mov	r29, r22
     1ba:	8a 01       	movw	r16, r20
  I2C_start();
     1bc:	0e 94 c5 05 	call	0xb8a	; 0xb8a <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     1c0:	cc 0f       	add	r28, r28
     1c2:	80 ea       	ldi	r24, 0xA0	; 160
     1c4:	8c 0f       	add	r24, r28
     1c6:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  I2C_write(address);
     1ca:	8d 2f       	mov	r24, r29
     1cc:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  I2C_start();
     1d0:	0e 94 c5 05 	call	0xb8a	; 0xb8a <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     1d4:	81 ea       	ldi	r24, 0xA1	; 161
     1d6:	8c 0f       	add	r24, r28
     1d8:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  // read_Ack will halt the reading here, because it will send the next byte, which will not be received and wait for ack, which will not be sent. 
  // Nack must be sent after the arrival of the last requested byte. It's used basically to indicate that no further data transmission is required and then the stop condition is sent
  I2C_read_Nack(data);
     1dc:	c8 01       	movw	r24, r16
     1de:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <I2C_read_Nack>
  I2C_stop();
     1e2:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <I2C_stop>
  }
     1e6:	df 91       	pop	r29
     1e8:	cf 91       	pop	r28
     1ea:	1f 91       	pop	r17
     1ec:	0f 91       	pop	r16
     1ee:	08 95       	ret

000001f0 <EEPROM_read_block>:

void EEPROM_read_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     1f0:	ef 92       	push	r14
     1f2:	ff 92       	push	r15
     1f4:	0f 93       	push	r16
     1f6:	1f 93       	push	r17
     1f8:	cf 93       	push	r28
     1fa:	df 93       	push	r29
     1fc:	c8 2f       	mov	r28, r24
     1fe:	d6 2f       	mov	r29, r22
     200:	7a 01       	movw	r14, r20
     202:	89 01       	movw	r16, r18
  u16 i;
  for (i = 0;i < bytes_number;i++) {
    EEPROM_read_byte(page, address + i, &data[i]);
    }
#elif READ_BLOCK_METHOD == MULTIBYTE
  I2C_start();
     204:	0e 94 c5 05 	call	0xb8a	; 0xb8a <I2C_start>
  I2C_write(0xA0 + (page << 1));
     208:	cc 0f       	add	r28, r28
     20a:	80 ea       	ldi	r24, 0xA0	; 160
     20c:	8c 0f       	add	r24, r28
     20e:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  I2C_write(address);
     212:	8d 2f       	mov	r24, r29
     214:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  I2C_start();
     218:	0e 94 c5 05 	call	0xb8a	; 0xb8a <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     21c:	81 ea       	ldi	r24, 0xA1	; 161
     21e:	8c 0f       	add	r24, r28
     220:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     224:	c0 e0       	ldi	r28, 0x00	; 0
     226:	d0 e0       	ldi	r29, 0x00	; 0
     228:	06 c0       	rjmp	.+12     	; 0x236 <EEPROM_read_block+0x46>
    I2C_read_Ack(&data[i]);
     22a:	c8 01       	movw	r24, r16
     22c:	8c 0f       	add	r24, r28
     22e:	9d 1f       	adc	r25, r29
     230:	0e 94 d6 05 	call	0xbac	; 0xbac <I2C_read_Ack>
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  I2C_start();
  I2C_write(0xA0 + (page << 1) + 1);
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     234:	21 96       	adiw	r28, 0x01	; 1
     236:	c7 01       	movw	r24, r14
     238:	01 97       	sbiw	r24, 0x01	; 1
     23a:	c8 17       	cp	r28, r24
     23c:	d9 07       	cpc	r29, r25
     23e:	a8 f3       	brcs	.-22     	; 0x22a <EEPROM_read_block+0x3a>
    I2C_read_Ack(&data[i]);
    }
  I2C_read_Nack(&data[i]);
     240:	c8 01       	movw	r24, r16
     242:	8c 0f       	add	r24, r28
     244:	9d 1f       	adc	r25, r29
     246:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <I2C_read_Nack>
  I2C_stop();
     24a:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <I2C_stop>
#endif
  }
     24e:	df 91       	pop	r29
     250:	cf 91       	pop	r28
     252:	1f 91       	pop	r17
     254:	0f 91       	pop	r16
     256:	ff 90       	pop	r15
     258:	ef 90       	pop	r14
     25a:	08 95       	ret

0000025c <EEPROM_write_byte>:

void EEPROM_write_byte(u8 page, u8 address, s8 data) {
     25c:	1f 93       	push	r17
     25e:	cf 93       	push	r28
     260:	df 93       	push	r29
     262:	c8 2f       	mov	r28, r24
     264:	16 2f       	mov	r17, r22
     266:	d4 2f       	mov	r29, r20
  I2C_start();
     268:	0e 94 c5 05 	call	0xb8a	; 0xb8a <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     26c:	8c 2f       	mov	r24, r28
     26e:	88 0f       	add	r24, r24
     270:	80 56       	subi	r24, 0x60	; 96
     272:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  I2C_write(address);
     276:	81 2f       	mov	r24, r17
     278:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  I2C_write(data);
     27c:	8d 2f       	mov	r24, r29
     27e:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  I2C_stop();
     282:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <I2C_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     286:	8f e3       	ldi	r24, 0x3F	; 63
     288:	9c e9       	ldi	r25, 0x9C	; 156
     28a:	01 97       	sbiw	r24, 0x01	; 1
     28c:	f1 f7       	brne	.-4      	; 0x28a <EEPROM_write_byte+0x2e>
     28e:	00 c0       	rjmp	.+0      	; 0x290 <EEPROM_write_byte+0x34>
     290:	00 00       	nop

#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
  }
     292:	df 91       	pop	r29
     294:	cf 91       	pop	r28
     296:	1f 91       	pop	r17
     298:	08 95       	ret

0000029a <EEPROM_write_block>:

// bytes_number must be within page size (256 bytes)
void EEPROM_write_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     29a:	6f 92       	push	r6
     29c:	7f 92       	push	r7
     29e:	8f 92       	push	r8
     2a0:	9f 92       	push	r9
     2a2:	af 92       	push	r10
     2a4:	bf 92       	push	r11
     2a6:	cf 92       	push	r12
     2a8:	df 92       	push	r13
     2aa:	ef 92       	push	r14
     2ac:	ff 92       	push	r15
     2ae:	0f 93       	push	r16
     2b0:	1f 93       	push	r17
     2b2:	cf 93       	push	r28
     2b4:	df 93       	push	r29
     2b6:	78 2e       	mov	r7, r24
     2b8:	66 2e       	mov	r6, r22
     2ba:	6a 01       	movw	r12, r20
     2bc:	89 01       	movw	r16, r18
  //! If data is required to be written in the first 16 bytes starting from byte 10 for example, the data will be stored starting from bytes 10, 
  //! and if the data exceeds the row limit ** IT WILL ROLL OVER AND OVERWRITE THE ROW **. Therefore, in a single multibyte write cycle, we can't write more than 16 bytes at maximum if starting from the first byte in the row
  //! or the remaining bytes till the end of the row from the starting position. The remaining bytes must be written in another write cycle to avoind the roll over problem.

  u16 dataIndex, blockNumber, i;
  u16 first_block_size = 16 - (address % 16);
     2be:	86 2f       	mov	r24, r22
     2c0:	8f 70       	andi	r24, 0x0F	; 15
     2c2:	20 e1       	ldi	r18, 0x10	; 16
     2c4:	30 e0       	ldi	r19, 0x00	; 0
     2c6:	79 01       	movw	r14, r18
     2c8:	e8 1a       	sub	r14, r24
     2ca:	f1 08       	sbc	r15, r1
  if (16 - (address % 16) > bytes_number) first_block_size = bytes_number;
     2cc:	4e 15       	cp	r20, r14
     2ce:	5f 05       	cpc	r21, r15
     2d0:	08 f4       	brcc	.+2      	; 0x2d4 <EEPROM_write_block+0x3a>
     2d2:	7a 01       	movw	r14, r20

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
     2d4:	0e 94 c5 05 	call	0xb8a	; 0xb8a <I2C_start>
  I2C_write(0xA0 + (page << 1));
     2d8:	87 2d       	mov	r24, r7
     2da:	88 0f       	add	r24, r24
     2dc:	0f 2e       	mov	r0, r31
     2de:	f0 ea       	ldi	r31, 0xA0	; 160
     2e0:	7f 2e       	mov	r7, r31
     2e2:	f0 2d       	mov	r31, r0
     2e4:	78 0e       	add	r7, r24
     2e6:	87 2d       	mov	r24, r7
     2e8:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  I2C_write(address);
     2ec:	86 2d       	mov	r24, r6
     2ee:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2f2:	c0 e0       	ldi	r28, 0x00	; 0
     2f4:	d0 e0       	ldi	r29, 0x00	; 0
     2f6:	07 c0       	rjmp	.+14     	; 0x306 <EEPROM_write_block+0x6c>
    I2C_write(data[dataIndex]);
     2f8:	f8 01       	movw	r30, r16
     2fa:	ec 0f       	add	r30, r28
     2fc:	fd 1f       	adc	r31, r29
     2fe:	80 81       	ld	r24, Z
     300:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     304:	21 96       	adiw	r28, 0x01	; 1
     306:	ce 15       	cp	r28, r14
     308:	df 05       	cpc	r29, r15
     30a:	b0 f3       	brcs	.-20     	; 0x2f8 <EEPROM_write_block+0x5e>
    I2C_write(data[dataIndex]);
    }
  I2C_stop();
     30c:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <I2C_stop>
     310:	8f e3       	ldi	r24, 0x3F	; 63
     312:	9c e9       	ldi	r25, 0x9C	; 156
     314:	01 97       	sbiw	r24, 0x01	; 1
     316:	f1 f7       	brne	.-4      	; 0x314 <EEPROM_write_block+0x7a>
     318:	00 c0       	rjmp	.+0      	; 0x31a <EEPROM_write_block+0x80>
     31a:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif

  // Return if the data fits in the row (data fits in a single row or the remaining part of it after the address)
  if (first_block_size == bytes_number) return;
     31c:	ec 14       	cp	r14, r12
     31e:	fd 04       	cpc	r15, r13
     320:	09 f4       	brne	.+2      	; 0x324 <EEPROM_write_block+0x8a>
     322:	61 c0       	rjmp	.+194    	; 0x3e6 <EEPROM_write_block+0x14c>

  u16 last_block_size = (address + bytes_number) % 16;
     324:	56 01       	movw	r10, r12
     326:	a6 0c       	add	r10, r6
     328:	b1 1c       	adc	r11, r1
     32a:	9f e0       	ldi	r25, 0x0F	; 15
     32c:	a9 22       	and	r10, r25
     32e:	bb 24       	eor	r11, r11
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
     330:	ce 18       	sub	r12, r14
     332:	df 08       	sbc	r13, r15
     334:	ca 18       	sub	r12, r10
     336:	db 08       	sbc	r13, r11
     338:	d6 94       	lsr	r13
     33a:	c7 94       	ror	r12
     33c:	d6 94       	lsr	r13
     33e:	c7 94       	ror	r12
     340:	d6 94       	lsr	r13
     342:	c7 94       	ror	r12
     344:	d6 94       	lsr	r13
     346:	c7 94       	ror	r12
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     348:	e1 2c       	mov	r14, r1
     34a:	f1 2c       	mov	r15, r1
     34c:	27 c0       	rjmp	.+78     	; 0x39c <EEPROM_write_block+0x102>
    I2C_start();
     34e:	0e 94 c5 05 	call	0xb8a	; 0xb8a <I2C_start>
    I2C_write(0xA0 + (page << 1));
     352:	87 2d       	mov	r24, r7
     354:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
    I2C_write(address + dataIndex);
     358:	8c 2f       	mov	r24, r28
     35a:	86 0d       	add	r24, r6
     35c:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
    for (i = 0;i < 16;i++) {
     360:	81 2c       	mov	r8, r1
     362:	91 2c       	mov	r9, r1
     364:	0b c0       	rjmp	.+22     	; 0x37c <EEPROM_write_block+0xe2>
      I2C_write(data[dataIndex + i]);
     366:	fe 01       	movw	r30, r28
     368:	e8 0d       	add	r30, r8
     36a:	f9 1d       	adc	r31, r9
     36c:	e0 0f       	add	r30, r16
     36e:	f1 1f       	adc	r31, r17
     370:	80 81       	ld	r24, Z
     372:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
    I2C_start();
    I2C_write(0xA0 + (page << 1));
    I2C_write(address + dataIndex);
    for (i = 0;i < 16;i++) {
     376:	8f ef       	ldi	r24, 0xFF	; 255
     378:	88 1a       	sub	r8, r24
     37a:	98 0a       	sbc	r9, r24
     37c:	90 e1       	ldi	r25, 0x10	; 16
     37e:	89 16       	cp	r8, r25
     380:	91 04       	cpc	r9, r1
     382:	88 f3       	brcs	.-30     	; 0x366 <EEPROM_write_block+0xcc>
      I2C_write(data[dataIndex + i]);
      }
    dataIndex += 16;
     384:	60 96       	adiw	r28, 0x10	; 16
    I2C_stop();
     386:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <I2C_stop>
     38a:	8f e3       	ldi	r24, 0x3F	; 63
     38c:	9c e9       	ldi	r25, 0x9C	; 156
     38e:	01 97       	sbiw	r24, 0x01	; 1
     390:	f1 f7       	brne	.-4      	; 0x38e <EEPROM_write_block+0xf4>
     392:	00 c0       	rjmp	.+0      	; 0x394 <EEPROM_write_block+0xfa>
     394:	00 00       	nop
  if (first_block_size == bytes_number) return;

  u16 last_block_size = (address + bytes_number) % 16;
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     396:	9f ef       	ldi	r25, 0xFF	; 255
     398:	e9 1a       	sub	r14, r25
     39a:	f9 0a       	sbc	r15, r25
     39c:	ec 14       	cp	r14, r12
     39e:	fd 04       	cpc	r15, r13
     3a0:	b0 f2       	brcs	.-84     	; 0x34e <EEPROM_write_block+0xb4>
    _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
    }

  // Write the last part of the data
  I2C_start();
     3a2:	0e 94 c5 05 	call	0xb8a	; 0xb8a <I2C_start>
  I2C_write(0xA0 + (page << 1));
     3a6:	87 2d       	mov	r24, r7
     3a8:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  I2C_write(address + dataIndex);
     3ac:	8c 2f       	mov	r24, r28
     3ae:	86 0d       	add	r24, r6
     3b0:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>
  for (i = 0;i < last_block_size;i++) {
     3b4:	e1 2c       	mov	r14, r1
     3b6:	f1 2c       	mov	r15, r1
     3b8:	0b c0       	rjmp	.+22     	; 0x3d0 <EEPROM_write_block+0x136>
    I2C_write(data[dataIndex + i]);
     3ba:	fe 01       	movw	r30, r28
     3bc:	ee 0d       	add	r30, r14
     3be:	ff 1d       	adc	r31, r15
     3c0:	e0 0f       	add	r30, r16
     3c2:	f1 1f       	adc	r31, r17
     3c4:	80 81       	ld	r24, Z
     3c6:	0e 94 cd 05 	call	0xb9a	; 0xb9a <I2C_write>

  // Write the last part of the data
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address + dataIndex);
  for (i = 0;i < last_block_size;i++) {
     3ca:	8f ef       	ldi	r24, 0xFF	; 255
     3cc:	e8 1a       	sub	r14, r24
     3ce:	f8 0a       	sbc	r15, r24
     3d0:	ea 14       	cp	r14, r10
     3d2:	fb 04       	cpc	r15, r11
     3d4:	90 f3       	brcs	.-28     	; 0x3ba <EEPROM_write_block+0x120>
    I2C_write(data[dataIndex + i]);
    }
  I2C_stop();
     3d6:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <I2C_stop>
     3da:	8f e3       	ldi	r24, 0x3F	; 63
     3dc:	9c e9       	ldi	r25, 0x9C	; 156
     3de:	01 97       	sbiw	r24, 0x01	; 1
     3e0:	f1 f7       	brne	.-4      	; 0x3de <EEPROM_write_block+0x144>
     3e2:	00 c0       	rjmp	.+0      	; 0x3e4 <EEPROM_write_block+0x14a>
     3e4:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
#endif
     3e6:	df 91       	pop	r29
     3e8:	cf 91       	pop	r28
     3ea:	1f 91       	pop	r17
     3ec:	0f 91       	pop	r16
     3ee:	ff 90       	pop	r15
     3f0:	ef 90       	pop	r14
     3f2:	df 90       	pop	r13
     3f4:	cf 90       	pop	r12
     3f6:	bf 90       	pop	r11
     3f8:	af 90       	pop	r10
     3fa:	9f 90       	pop	r9
     3fc:	8f 90       	pop	r8
     3fe:	7f 90       	pop	r7
     400:	6f 90       	pop	r6
     402:	08 95       	ret

00000404 <BT_init>:
 *  Author: Hesham Hany
 */

#include "hc_05.h"

void BT_init(u32 baudRate) {
     404:	cf 92       	push	r12
     406:	df 92       	push	r13
     408:	ef 92       	push	r14
     40a:	ff 92       	push	r15
     40c:	6b 01       	movw	r12, r22
     40e:	7c 01       	movw	r14, r24
  DIO_init(HC_05_STATUS_PIN, HC_05_STATUS_PORT, IN);
     410:	40 e0       	ldi	r20, 0x00	; 0
     412:	64 e4       	ldi	r22, 0x44	; 68
     414:	82 e0       	ldi	r24, 0x02	; 2
     416:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  UART_init(baudRate);
     41a:	c7 01       	movw	r24, r14
     41c:	b6 01       	movw	r22, r12
     41e:	0e 94 3e 09 	call	0x127c	; 0x127c <UART_init>
  }
     422:	ff 90       	pop	r15
     424:	ef 90       	pop	r14
     426:	df 90       	pop	r13
     428:	cf 90       	pop	r12
     42a:	08 95       	ret

0000042c <BT_sendChar>:

void BT_sendChar(s8 data) {
  UART_sendChar(data);
     42c:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <UART_sendChar>
     430:	08 95       	ret

00000432 <BT_sendString>:
  }

void BT_sendString(s8* str) {
  UART_sendString(str);
     432:	0e 94 e6 09 	call	0x13cc	; 0x13cc <UART_sendString>
     436:	08 95       	ret

00000438 <Keypad_init>:

#include "keypad.h"

EN_KeypadStatusCode_t Keypad_init(void) {
  // Set rows as outputs
  DIO_init(KEYPAD_R0_PIN, KEYPAD_PORT, OUT);
     438:	41 e0       	ldi	r20, 0x01	; 1
     43a:	62 e4       	ldi	r22, 0x42	; 66
     43c:	80 e0       	ldi	r24, 0x00	; 0
     43e:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  DIO_init(KEYPAD_R1_PIN, KEYPAD_PORT, OUT);
     442:	41 e0       	ldi	r20, 0x01	; 1
     444:	62 e4       	ldi	r22, 0x42	; 66
     446:	81 e0       	ldi	r24, 0x01	; 1
     448:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  DIO_init(KEYPAD_R2_PIN, KEYPAD_PORT, OUT);
     44c:	41 e0       	ldi	r20, 0x01	; 1
     44e:	62 e4       	ldi	r22, 0x42	; 66
     450:	82 e0       	ldi	r24, 0x02	; 2
     452:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  DIO_init(KEYPAD_R3_PIN, KEYPAD_PORT, OUT);
     456:	41 e0       	ldi	r20, 0x01	; 1
     458:	62 e4       	ldi	r22, 0x42	; 66
     45a:	83 e0       	ldi	r24, 0x03	; 3
     45c:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  // Set all high
  DIO_write(KEYPAD_R0_PIN, KEYPAD_PORT, HIGH);
     460:	41 e0       	ldi	r20, 0x01	; 1
     462:	62 e4       	ldi	r22, 0x42	; 66
     464:	80 e0       	ldi	r24, 0x00	; 0
     466:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
  DIO_write(KEYPAD_R1_PIN, KEYPAD_PORT, HIGH);
     46a:	41 e0       	ldi	r20, 0x01	; 1
     46c:	62 e4       	ldi	r22, 0x42	; 66
     46e:	81 e0       	ldi	r24, 0x01	; 1
     470:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
  DIO_write(KEYPAD_R2_PIN, KEYPAD_PORT, HIGH);
     474:	41 e0       	ldi	r20, 0x01	; 1
     476:	62 e4       	ldi	r22, 0x42	; 66
     478:	82 e0       	ldi	r24, 0x02	; 2
     47a:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
  DIO_write(KEYPAD_R3_PIN, KEYPAD_PORT, HIGH);
     47e:	41 e0       	ldi	r20, 0x01	; 1
     480:	62 e4       	ldi	r22, 0x42	; 66
     482:	83 e0       	ldi	r24, 0x03	; 3
     484:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
  // Set columns as inputs
  DIO_init(KEYPAD_C0_PIN, KEYPAD_PORT, IN);
     488:	40 e0       	ldi	r20, 0x00	; 0
     48a:	62 e4       	ldi	r22, 0x42	; 66
     48c:	84 e0       	ldi	r24, 0x04	; 4
     48e:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  DIO_init(KEYPAD_C1_PIN, KEYPAD_PORT, IN);
     492:	40 e0       	ldi	r20, 0x00	; 0
     494:	62 e4       	ldi	r22, 0x42	; 66
     496:	85 e0       	ldi	r24, 0x05	; 5
     498:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  DIO_init(KEYPAD_C2_PIN, KEYPAD_PORT, IN);
     49c:	40 e0       	ldi	r20, 0x00	; 0
     49e:	62 e4       	ldi	r22, 0x42	; 66
     4a0:	86 e0       	ldi	r24, 0x06	; 6
     4a2:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  DIO_init(KEYPAD_C3_PIN, KEYPAD_PORT, IN);
     4a6:	40 e0       	ldi	r20, 0x00	; 0
     4a8:	62 e4       	ldi	r22, 0x42	; 66
     4aa:	87 e0       	ldi	r24, 0x07	; 7
     4ac:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  // Activate the pull up resistors
  DIO_write(KEYPAD_C0_PIN, KEYPAD_PORT, HIGH);
     4b0:	41 e0       	ldi	r20, 0x01	; 1
     4b2:	62 e4       	ldi	r22, 0x42	; 66
     4b4:	84 e0       	ldi	r24, 0x04	; 4
     4b6:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
  DIO_write(KEYPAD_C1_PIN, KEYPAD_PORT, HIGH);
     4ba:	41 e0       	ldi	r20, 0x01	; 1
     4bc:	62 e4       	ldi	r22, 0x42	; 66
     4be:	85 e0       	ldi	r24, 0x05	; 5
     4c0:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
  DIO_write(KEYPAD_C2_PIN, KEYPAD_PORT, HIGH);
     4c4:	41 e0       	ldi	r20, 0x01	; 1
     4c6:	62 e4       	ldi	r22, 0x42	; 66
     4c8:	86 e0       	ldi	r24, 0x06	; 6
     4ca:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
  DIO_write(KEYPAD_C3_PIN, KEYPAD_PORT, HIGH);
     4ce:	41 e0       	ldi	r20, 0x01	; 1
     4d0:	62 e4       	ldi	r22, 0x42	; 66
     4d2:	87 e0       	ldi	r24, 0x07	; 7
     4d4:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>

  return KEYPAD_INIT_OK;
  }
     4d8:	80 e0       	ldi	r24, 0x00	; 0
     4da:	08 95       	ret

000004dc <LCD_sendEnablePulse>:

  _delay_us(1); // wait for the data to be processed
#else

#endif
  }
     4dc:	41 e0       	ldi	r20, 0x01	; 1
     4de:	61 e4       	ldi	r22, 0x41	; 65
     4e0:	86 e0       	ldi	r24, 0x06	; 6
     4e2:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
     4e6:	8a e1       	ldi	r24, 0x1A	; 26
     4e8:	8a 95       	dec	r24
     4ea:	f1 f7       	brne	.-4      	; 0x4e8 <LCD_sendEnablePulse+0xc>
     4ec:	00 c0       	rjmp	.+0      	; 0x4ee <LCD_sendEnablePulse+0x12>
     4ee:	40 e0       	ldi	r20, 0x00	; 0
     4f0:	61 e4       	ldi	r22, 0x41	; 65
     4f2:	86 e0       	ldi	r24, 0x06	; 6
     4f4:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
     4f8:	08 95       	ret

000004fa <LCD_write_4bits>:
     4fa:	cf 93       	push	r28
     4fc:	c8 2f       	mov	r28, r24
     4fe:	48 2f       	mov	r20, r24
     500:	41 70       	andi	r20, 0x01	; 1
     502:	61 e4       	ldi	r22, 0x41	; 65
     504:	80 e0       	ldi	r24, 0x00	; 0
     506:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
     50a:	c1 fb       	bst	r28, 1
     50c:	44 27       	eor	r20, r20
     50e:	40 f9       	bld	r20, 0
     510:	61 e4       	ldi	r22, 0x41	; 65
     512:	81 e0       	ldi	r24, 0x01	; 1
     514:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
     518:	c2 fb       	bst	r28, 2
     51a:	44 27       	eor	r20, r20
     51c:	40 f9       	bld	r20, 0
     51e:	61 e4       	ldi	r22, 0x41	; 65
     520:	82 e0       	ldi	r24, 0x02	; 2
     522:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
     526:	c3 fb       	bst	r28, 3
     528:	44 27       	eor	r20, r20
     52a:	40 f9       	bld	r20, 0
     52c:	61 e4       	ldi	r22, 0x41	; 65
     52e:	83 e0       	ldi	r24, 0x03	; 3
     530:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
     534:	cf 91       	pop	r28
     536:	08 95       	ret

00000538 <LCD_sendCommand>:

void LCD_sendCommand(u8 cmd) {
     538:	cf 93       	push	r28
     53a:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(cmd >> 4);
     53c:	82 95       	swap	r24
     53e:	8f 70       	andi	r24, 0x0F	; 15
     540:	0e 94 7d 02 	call	0x4fa	; 0x4fa <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, LOW); // To indicate that this a command
     544:	40 e0       	ldi	r20, 0x00	; 0
     546:	61 e4       	ldi	r22, 0x41	; 65
     548:	84 e0       	ldi	r24, 0x04	; 4
     54a:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>

  LCD_sendEnablePulse();
     54e:	0e 94 6e 02 	call	0x4dc	; 0x4dc <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the command to be sent

  LCD_write_4bits(cmd);
     552:	8c 2f       	mov	r24, r28
     554:	0e 94 7d 02 	call	0x4fa	; 0x4fa <LCD_write_4bits>

  LCD_sendEnablePulse();
     558:	0e 94 6e 02 	call	0x4dc	; 0x4dc <LCD_sendEnablePulse>
     55c:	8f ed       	ldi	r24, 0xDF	; 223
     55e:	9e e2       	ldi	r25, 0x2E	; 46
     560:	01 97       	sbiw	r24, 0x01	; 1
     562:	f1 f7       	brne	.-4      	; 0x560 <LCD_sendCommand+0x28>
     564:	00 c0       	rjmp	.+0      	; 0x566 <LCD_sendCommand+0x2e>
     566:	00 00       	nop

  _delay_ms(3); // wait for the command to be executed
#else

#endif
  }
     568:	cf 91       	pop	r28
     56a:	08 95       	ret

0000056c <LCD_clear_screen>:

void LCD_clear_screen() {
  LCD_sendCommand(0x01);
     56c:	81 e0       	ldi	r24, 0x01	; 1
     56e:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_sendCommand>
     572:	08 95       	ret

00000574 <LCD_init>:
     574:	2f ef       	ldi	r18, 0xFF	; 255
     576:	89 ef       	ldi	r24, 0xF9	; 249
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	21 50       	subi	r18, 0x01	; 1
     57c:	80 40       	sbci	r24, 0x00	; 0
     57e:	90 40       	sbci	r25, 0x00	; 0
     580:	e1 f7       	brne	.-8      	; 0x57a <LCD_init+0x6>
     582:	00 c0       	rjmp	.+0      	; 0x584 <LCD_init+0x10>
     584:	00 00       	nop

void LCD_init(void) {
  _delay_ms(20); // wait for the LCD to start up.

#if LCD_MODE == FOUR_BIT_MODE
  DIO_init(LCD_DATA_PIN4, LCD_DATA_PORT, OUT);
     586:	41 e0       	ldi	r20, 0x01	; 1
     588:	61 e4       	ldi	r22, 0x41	; 65
     58a:	80 e0       	ldi	r24, 0x00	; 0
     58c:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  DIO_init(LCD_DATA_PIN5, LCD_DATA_PORT, OUT);
     590:	41 e0       	ldi	r20, 0x01	; 1
     592:	61 e4       	ldi	r22, 0x41	; 65
     594:	81 e0       	ldi	r24, 0x01	; 1
     596:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  DIO_init(LCD_DATA_PIN6, LCD_DATA_PORT, OUT);
     59a:	41 e0       	ldi	r20, 0x01	; 1
     59c:	61 e4       	ldi	r22, 0x41	; 65
     59e:	82 e0       	ldi	r24, 0x02	; 2
     5a0:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  DIO_init(LCD_DATA_PIN7, LCD_DATA_PORT, OUT);
     5a4:	41 e0       	ldi	r20, 0x01	; 1
     5a6:	61 e4       	ldi	r22, 0x41	; 65
     5a8:	83 e0       	ldi	r24, 0x03	; 3
     5aa:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>

  DIO_init(RS, LCD_CTRL_PORT, OUT);
     5ae:	41 e0       	ldi	r20, 0x01	; 1
     5b0:	61 e4       	ldi	r22, 0x41	; 65
     5b2:	84 e0       	ldi	r24, 0x04	; 4
     5b4:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  DIO_init(RW, LCD_CTRL_PORT, OUT);
     5b8:	41 e0       	ldi	r20, 0x01	; 1
     5ba:	61 e4       	ldi	r22, 0x41	; 65
     5bc:	85 e0       	ldi	r24, 0x05	; 5
     5be:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  DIO_init(EN, LCD_CTRL_PORT, OUT);
     5c2:	41 e0       	ldi	r20, 0x01	; 1
     5c4:	61 e4       	ldi	r22, 0x41	; 65
     5c6:	86 e0       	ldi	r24, 0x06	; 6
     5c8:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>

  DIO_write(RW, LCD_CTRL_PORT, LOW);
     5cc:	40 e0       	ldi	r20, 0x00	; 0
     5ce:	61 e4       	ldi	r22, 0x41	; 65
     5d0:	85 e0       	ldi	r24, 0x05	; 5
     5d2:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>

  LCD_sendCommand(0x02);  // return home 
     5d6:	82 e0       	ldi	r24, 0x02	; 2
     5d8:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_sendCommand>
  LCD_sendCommand(0x28);  // 2 line  and 4 bit mode
     5dc:	88 e2       	ldi	r24, 0x28	; 40
     5de:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_sendCommand>
  LCD_sendCommand(0x0C);  // display on 
     5e2:	8c e0       	ldi	r24, 0x0C	; 12
     5e4:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_sendCommand>
  LCD_sendCommand(0x06);  // auto increment 
     5e8:	86 e0       	ldi	r24, 0x06	; 6
     5ea:	0e 94 9c 02 	call	0x538	; 0x538 <LCD_sendCommand>
  LCD_clear_screen();
     5ee:	0e 94 b6 02 	call	0x56c	; 0x56c <LCD_clear_screen>
     5f2:	08 95       	ret

000005f4 <LED_init>:
 */

#include "led.h"

 // Initialize the LED
EN_ledError_t LED_init(u8 ledPort, u8 ledPin) {
     5f4:	98 2f       	mov	r25, r24
     5f6:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(ledPin, ledPort, OUT) == DIO_OK) {
     5f8:	41 e0       	ldi	r20, 0x01	; 1
     5fa:	69 2f       	mov	r22, r25
     5fc:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
     600:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that the led initialization failed
  return LED_ERROR_INIT;
     602:	81 e0       	ldi	r24, 0x01	; 1
  }
     604:	08 95       	ret

00000606 <LED_on>:

// Turn on the LED
EN_ledError_t LED_on(u8 ledPort, u8 ledPin) {
     606:	98 2f       	mov	r25, r24
     608:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, HIGH) == DIO_OK) {
     60a:	41 e0       	ldi	r20, 0x01	; 1
     60c:	69 2f       	mov	r22, r25
     60e:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
     612:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn on the led has failed
  return LED_ERROR_ON;
     614:	82 e0       	ldi	r24, 0x02	; 2
  }
     616:	08 95       	ret

00000618 <LED_off>:

// Turn off the LED
EN_ledError_t LED_off(u8 ledPort, u8 ledPin) {
     618:	98 2f       	mov	r25, r24
     61a:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, LOW) == DIO_OK) {
     61c:	40 e0       	ldi	r20, 0x00	; 0
     61e:	69 2f       	mov	r22, r25
     620:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
     624:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn off the led has failed
  return LED_ERROR_OFF;
     626:	83 e0       	ldi	r24, 0x03	; 3
  }
     628:	08 95       	ret

0000062a <LED_toggle>:

// Toggle the LED
EN_ledError_t LED_toggle(u8 ledPort, u8 ledPin) {
     62a:	98 2f       	mov	r25, r24
     62c:	86 2f       	mov	r24, r22
  if (DIO_toggle(ledPin, ledPort) == DIO_OK) {
     62e:	69 2f       	mov	r22, r25
     630:	0e 94 4a 05 	call	0xa94	; 0xa94 <DIO_toggle>
     634:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to toggle the led has failed
  return LED_ERROR_TOGGLE;
     636:	84 e0       	ldi	r24, 0x04	; 4
     638:	08 95       	ret

0000063a <LM35_init_INT>:
  ADC_init();
  ADC_select_channel(pinNumber);
  }

// Initialize LM35 with the ADC in auto trigger mode
void LM35_init_INT(u8 pinNumber, u8 trigger) {
     63a:	cf 93       	push	r28
     63c:	df 93       	push	r29
     63e:	c8 2f       	mov	r28, r24
     640:	d6 2f       	mov	r29, r22
  DIO_init(pinNumber, PORT_A, IN);
     642:	40 e0       	ldi	r20, 0x00	; 0
     644:	61 e4       	ldi	r22, 0x41	; 65
     646:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  ADC_init_auto_trigger(trigger);
     64a:	8d 2f       	mov	r24, r29
     64c:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <ADC_init_auto_trigger>
  ADC_select_channel(pinNumber);
     650:	8c 2f       	mov	r24, r28
     652:	0e 94 60 03 	call	0x6c0	; 0x6c0 <ADC_select_channel>
     656:	df 91       	pop	r29
     658:	cf 91       	pop	r28
     65a:	08 95       	ret

0000065c <Servo_init>:

#include "servo.h"

 // Initialized the servo
void Servo_init() {
  DIO_init(SERVO_PIN, SERVO_PORT, OUT);
     65c:	41 e0       	ldi	r20, 0x01	; 1
     65e:	64 e4       	ldi	r22, 0x44	; 68
     660:	85 e0       	ldi	r24, 0x05	; 5
     662:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
  PWM_init(SERVO_PWM_PIN, (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS), PWM_PHASE_CORRECT);
     666:	22 e0       	ldi	r18, 0x02	; 2
     668:	4d ec       	ldi	r20, 0xCD	; 205
     66a:	5c ec       	ldi	r21, 0xCC	; 204
     66c:	6c ec       	ldi	r22, 0xCC	; 204
     66e:	7c e3       	ldi	r23, 0x3C	; 60
     670:	81 e0       	ldi	r24, 0x01	; 1
     672:	0e 94 58 08 	call	0x10b0	; 0x10b0 <PWM_init>
  Timer_start(TIMER_1, 8);
     676:	68 e0       	ldi	r22, 0x08	; 8
     678:	70 e0       	ldi	r23, 0x00	; 0
     67a:	81 e0       	ldi	r24, 0x01	; 1
     67c:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <Timer_start>
     680:	08 95       	ret

00000682 <Servo_move_to_angle>:
  }

// Moves the servo to a specific angle (relative to the 0 angle position, not the previous one).
void Servo_move_to_angle(u8 angle) {
  PWM_set_DC(SERVO_PWM_PIN, ((double)angle / ((SERVO_MAX_ANGLE - SERVO_MIN_ANGLE) * (SERVO_PULSE_PERIODIC_TIME_mS / (SERVO_MAX_HIGH_PULSE_DURATION_mS - SERVO_MIN_HIGH_PULSE_DURATION_mS)))) + (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS));
     682:	68 2f       	mov	r22, r24
     684:	70 e0       	ldi	r23, 0x00	; 0
     686:	80 e0       	ldi	r24, 0x00	; 0
     688:	90 e0       	ldi	r25, 0x00	; 0
     68a:	0e 94 9e 12 	call	0x253c	; 0x253c <__floatunsisf>
     68e:	20 e0       	ldi	r18, 0x00	; 0
     690:	30 e0       	ldi	r19, 0x00	; 0
     692:	41 ee       	ldi	r20, 0xE1	; 225
     694:	54 e4       	ldi	r21, 0x44	; 68
     696:	0e 94 fd 11 	call	0x23fa	; 0x23fa <__divsf3>
     69a:	2d ec       	ldi	r18, 0xCD	; 205
     69c:	3c ec       	ldi	r19, 0xCC	; 204
     69e:	4c ec       	ldi	r20, 0xCC	; 204
     6a0:	5c e3       	ldi	r21, 0x3C	; 60
     6a2:	0e 94 91 11 	call	0x2322	; 0x2322 <__addsf3>
     6a6:	ab 01       	movw	r20, r22
     6a8:	bc 01       	movw	r22, r24
     6aa:	81 e0       	ldi	r24, 0x01	; 1
     6ac:	0e 94 ff 08 	call	0x11fe	; 0x11fe <PWM_set_DC>
     6b0:	08 95       	ret

000006b2 <main>:
#include "Application/app.h"
// #include "Services/Local_access/local.h"

int main(void) {
	
	App_init();
     6b2:	0e 94 a1 00 	call	0x142	; 0x142 <App_init>
	
	App_start();
     6b6:	0e 94 b8 00 	call	0x170	; 0x170 <App_start>
	
	}
     6ba:	80 e0       	ldi	r24, 0x00	; 0
     6bc:	90 e0       	ldi	r25, 0x00	; 0
     6be:	08 95       	ret

000006c0 <ADC_select_channel>:
  //   adjusted and no more than 8 - bit precision is required, it is sufficient to read ADCH.Otherwise, ADCL must be read
  //   first, then ADCH.
  * result = (u16)ADCL + ((u16)ADCH << 8); //? This will work
  //! *result = ((u16)ADCH << 8) + (u16)ADCL; // This won't work
  return ADC_OK;
  }
     6c0:	88 30       	cpi	r24, 0x08	; 8
     6c2:	30 f4       	brcc	.+12     	; 0x6d0 <ADC_select_channel+0x10>
     6c4:	97 b1       	in	r25, 0x07	; 7
     6c6:	90 7e       	andi	r25, 0xE0	; 224
     6c8:	89 2b       	or	r24, r25
     6ca:	87 b9       	out	0x07, r24	; 7
     6cc:	80 e0       	ldi	r24, 0x00	; 0
     6ce:	08 95       	ret
     6d0:	81 e0       	ldi	r24, 0x01	; 1
     6d2:	08 95       	ret

000006d4 <ADC_init_auto_trigger>:

// Initialize the ADC in auto trigger mode
EN_ADCError_t ADC_init_auto_trigger(u8 trigger) {
     6d4:	e8 2f       	mov	r30, r24
  // since the defualt for pins is to be low (0) we don't need to change anything here(since it's 0).
  // I don't need to write anything too. Because the VREF won't be changed during the run time. The only case I will need to clear a bit is if it was set by the MCU or me.
#elif (ADC_VREF == AVCC)
  set_bit(ADMUX, REFS0);
#elif (ADC_VREF == INTERNAL_VREF)
  set_bit(ADMUX, REFS0);
     6d6:	87 b1       	in	r24, 0x07	; 7
     6d8:	80 64       	ori	r24, 0x40	; 64
     6da:	87 b9       	out	0x07, r24	; 7
  set_bit(ADMUX, REFS1);
     6dc:	87 b1       	in	r24, 0x07	; 7
     6de:	80 68       	ori	r24, 0x80	; 128
     6e0:	87 b9       	out	0x07, r24	; 7
#endif
  // Setting the prescalar to 128 so the operation frequency of the adc be within
  // the applicable range (50KHz-200KHz). The oscillator frequency is 16000000, Therefore the only applicable prescalar is 128.
  set_bit(ADCSRA, ADPS0);
     6e2:	86 b1       	in	r24, 0x06	; 6
     6e4:	81 60       	ori	r24, 0x01	; 1
     6e6:	86 b9       	out	0x06, r24	; 6
  set_bit(ADCSRA, ADPS1);
     6e8:	86 b1       	in	r24, 0x06	; 6
     6ea:	82 60       	ori	r24, 0x02	; 2
     6ec:	86 b9       	out	0x06, r24	; 6
  set_bit(ADCSRA, ADPS2);
     6ee:	86 b1       	in	r24, 0x06	; 6
     6f0:	84 60       	ori	r24, 0x04	; 4
     6f2:	86 b9       	out	0x06, r24	; 6
  // Enable the auto trigger mode
  set_bit(ADCSRA, ADATE);
     6f4:	86 b1       	in	r24, 0x06	; 6
     6f6:	80 62       	ori	r24, 0x20	; 32
     6f8:	86 b9       	out	0x06, r24	; 6
  // Select the auto trigger source
  //! Cause of a bug: setting ADTS bits one by one. when setting them one by one, only the last bit is set and the rest are cleared. 
  //! The bits must be set in one write operation.
  //^ Generally, in this project, setting bits in a register one by one has caused multiple issues, also sometimes the order matters. other times a register must be read before another.
  //? Setting one bit is okay. But multiple bits need to be set in one write operation.
  switch (trigger) {
     6fa:	8e 2f       	mov	r24, r30
     6fc:	90 e0       	ldi	r25, 0x00	; 0
     6fe:	87 30       	cpi	r24, 0x07	; 7
     700:	91 05       	cpc	r25, r1
     702:	00 f5       	brcc	.+64     	; 0x744 <ADC_init_auto_trigger+0x70>
     704:	fc 01       	movw	r30, r24
     706:	e6 5d       	subi	r30, 0xD6	; 214
     708:	ff 4f       	sbci	r31, 0xFF	; 255
     70a:	0c 94 99 13 	jmp	0x2732	; 0x2732 <__tablejump2__>
      case FREE_RUNNING_MODE_TRIGGER:
        // All bits are clear by default
        // Start free running mode first conversion
        set_bit(ADCSRA, ADSC);
     70e:	86 b1       	in	r24, 0x06	; 6
     710:	80 64       	ori	r24, 0x40	; 64
     712:	86 b9       	out	0x06, r24	; 6
        break;
     714:	17 c0       	rjmp	.+46     	; 0x744 <ADC_init_auto_trigger+0x70>
      case ANALOG_COMPARATOR_TRIGGER:
        set_bit(SFIOR, ADTS0);
     716:	80 b7       	in	r24, 0x30	; 48
     718:	80 62       	ori	r24, 0x20	; 32
     71a:	80 bf       	out	0x30, r24	; 48
        break;
     71c:	13 c0       	rjmp	.+38     	; 0x744 <ADC_init_auto_trigger+0x70>
      case INT0_TRIGGER:
        set_bit(SFIOR, ADTS1);
     71e:	80 b7       	in	r24, 0x30	; 48
     720:	80 64       	ori	r24, 0x40	; 64
     722:	80 bf       	out	0x30, r24	; 48
        break;
     724:	0f c0       	rjmp	.+30     	; 0x744 <ADC_init_auto_trigger+0x70>
      case TIMER_0_COMPARE_MATCH_TRIGGER:
        SFIOR |= (1 << ADTS0) | (1 << ADTS1);
     726:	80 b7       	in	r24, 0x30	; 48
     728:	80 66       	ori	r24, 0x60	; 96
     72a:	80 bf       	out	0x30, r24	; 48
        break;
     72c:	0b c0       	rjmp	.+22     	; 0x744 <ADC_init_auto_trigger+0x70>
      case TIMER_0_OVF_TRIGGER:
        set_bit(SFIOR, ADTS2);
     72e:	80 b7       	in	r24, 0x30	; 48
     730:	80 68       	ori	r24, 0x80	; 128
     732:	80 bf       	out	0x30, r24	; 48
        break;
     734:	07 c0       	rjmp	.+14     	; 0x744 <ADC_init_auto_trigger+0x70>
      case TIMER_1_COMPARE_MATCH_B_TRIGGER:
        SFIOR |= (1 << ADTS0) | (1 << ADTS2);
     736:	80 b7       	in	r24, 0x30	; 48
     738:	80 6a       	ori	r24, 0xA0	; 160
     73a:	80 bf       	out	0x30, r24	; 48
        break;
     73c:	03 c0       	rjmp	.+6      	; 0x744 <ADC_init_auto_trigger+0x70>
      case TIMER_1_OVF_TRIGGER:
        SFIOR |= (1 << ADTS1) | (1 << ADTS2);
     73e:	80 b7       	in	r24, 0x30	; 48
     740:	80 6c       	ori	r24, 0xC0	; 192
     742:	80 bf       	out	0x30, r24	; 48
        break;
    }
  // Enable the ADC
  set_bit(ADCSRA, ADEN);
     744:	86 b1       	in	r24, 0x06	; 6
     746:	80 68       	ori	r24, 0x80	; 128
     748:	86 b9       	out	0x06, r24	; 6
  return ADC_OK;
     74a:	80 e0       	ldi	r24, 0x00	; 0
     74c:	08 95       	ret

0000074e <isValidPinNumber>:
 */

#include "dio.h"

bool isValidPinNumber(u8 pinNumber) {
	if (pinNumber < 8) {
     74e:	88 30       	cpi	r24, 0x08	; 8
     750:	10 f4       	brcc	.+4      	; 0x756 <isValidPinNumber+0x8>
		return true;
     752:	81 e0       	ldi	r24, 0x01	; 1
     754:	08 95       	ret
		}
	return false;
     756:	80 e0       	ldi	r24, 0x00	; 0
	}
     758:	08 95       	ret

0000075a <isValidPortNumber>:

bool isValidPortNumber(u8 portNumber) {
	if (portNumber == PORT_A || portNumber == PORT_B || portNumber == PORT_C || portNumber == PORT_D) {
     75a:	81 54       	subi	r24, 0x41	; 65
     75c:	84 30       	cpi	r24, 0x04	; 4
     75e:	10 f4       	brcc	.+4      	; 0x764 <isValidPortNumber+0xa>
		return true;
     760:	81 e0       	ldi	r24, 0x01	; 1
     762:	08 95       	ret
		}
	return false;
     764:	80 e0       	ldi	r24, 0x00	; 0
	}
     766:	08 95       	ret

00000768 <isValidDirection>:

bool isValidDirection(u8 direction) {
	if (direction == IN || direction == OUT) {
     768:	82 30       	cpi	r24, 0x02	; 2
     76a:	10 f4       	brcc	.+4      	; 0x770 <isValidDirection+0x8>
		return true;
     76c:	81 e0       	ldi	r24, 0x01	; 1
     76e:	08 95       	ret
		}
	return false;
     770:	80 e0       	ldi	r24, 0x00	; 0
	}
     772:	08 95       	ret

00000774 <isValidState>:

bool isValidState(u8 state) {
	if (state == HIGH || state == LOW) {
     774:	82 30       	cpi	r24, 0x02	; 2
     776:	10 f4       	brcc	.+4      	; 0x77c <isValidState+0x8>
		return true;
     778:	81 e0       	ldi	r24, 0x01	; 1
     77a:	08 95       	ret
		}
	return false;
     77c:	80 e0       	ldi	r24, 0x00	; 0
	}
     77e:	08 95       	ret

00000780 <DIO_init>:

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
     780:	1f 93       	push	r17
     782:	cf 93       	push	r28
     784:	df 93       	push	r29
     786:	c8 2f       	mov	r28, r24
     788:	d6 2f       	mov	r29, r22
     78a:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     78c:	0e 94 a7 03 	call	0x74e	; 0x74e <isValidPinNumber>
     790:	88 23       	and	r24, r24
     792:	09 f4       	brne	.+2      	; 0x796 <DIO_init+0x16>
     794:	84 c0       	rjmp	.+264    	; 0x89e <__stack+0x3f>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     796:	8d 2f       	mov	r24, r29
     798:	0e 94 ad 03 	call	0x75a	; 0x75a <isValidPortNumber>
     79c:	88 23       	and	r24, r24
     79e:	09 f4       	brne	.+2      	; 0x7a2 <DIO_init+0x22>
     7a0:	80 c0       	rjmp	.+256    	; 0x8a2 <__stack+0x43>
		return WRONG_PORT;
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
     7a2:	81 2f       	mov	r24, r17
     7a4:	0e 94 b4 03 	call	0x768	; 0x768 <isValidDirection>
     7a8:	88 23       	and	r24, r24
     7aa:	09 f4       	brne	.+2      	; 0x7ae <DIO_init+0x2e>
     7ac:	7c c0       	rjmp	.+248    	; 0x8a6 <__stack+0x47>
		return WRONG_DIRECTION;
		}
	switch (portNumber) {
     7ae:	d2 34       	cpi	r29, 0x42	; 66
     7b0:	29 f1       	breq	.+74     	; 0x7fc <DIO_init+0x7c>
     7b2:	18 f4       	brcc	.+6      	; 0x7ba <DIO_init+0x3a>
     7b4:	d1 34       	cpi	r29, 0x41	; 65
     7b6:	39 f0       	breq	.+14     	; 0x7c6 <DIO_init+0x46>
     7b8:	78 c0       	rjmp	.+240    	; 0x8aa <__stack+0x4b>
     7ba:	d3 34       	cpi	r29, 0x43	; 67
     7bc:	d1 f1       	breq	.+116    	; 0x832 <__DATA_REGION_LENGTH__+0x32>
     7be:	d4 34       	cpi	r29, 0x44	; 68
     7c0:	09 f4       	brne	.+2      	; 0x7c4 <DIO_init+0x44>
     7c2:	52 c0       	rjmp	.+164    	; 0x868 <__stack+0x9>
     7c4:	72 c0       	rjmp	.+228    	; 0x8aa <__stack+0x4b>
			case PORT_A:
				if (direction == OUT) {
     7c6:	11 30       	cpi	r17, 0x01	; 1
     7c8:	61 f4       	brne	.+24     	; 0x7e2 <DIO_init+0x62>
					set_bit(DDRA, pinNumber);
     7ca:	2a b3       	in	r18, 0x1a	; 26
     7cc:	81 e0       	ldi	r24, 0x01	; 1
     7ce:	90 e0       	ldi	r25, 0x00	; 0
     7d0:	02 c0       	rjmp	.+4      	; 0x7d6 <DIO_init+0x56>
     7d2:	88 0f       	add	r24, r24
     7d4:	99 1f       	adc	r25, r25
     7d6:	ca 95       	dec	r28
     7d8:	e2 f7       	brpl	.-8      	; 0x7d2 <DIO_init+0x52>
     7da:	82 2b       	or	r24, r18
     7dc:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     7de:	80 e0       	ldi	r24, 0x00	; 0
     7e0:	65 c0       	rjmp	.+202    	; 0x8ac <__stack+0x4d>
			case PORT_A:
				if (direction == OUT) {
					set_bit(DDRA, pinNumber);
					}
				else {
					clear_bit(DDRA, pinNumber);
     7e2:	2a b3       	in	r18, 0x1a	; 26
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	90 e0       	ldi	r25, 0x00	; 0
     7e8:	02 c0       	rjmp	.+4      	; 0x7ee <DIO_init+0x6e>
     7ea:	88 0f       	add	r24, r24
     7ec:	99 1f       	adc	r25, r25
     7ee:	ca 95       	dec	r28
     7f0:	e2 f7       	brpl	.-8      	; 0x7ea <DIO_init+0x6a>
     7f2:	80 95       	com	r24
     7f4:	82 23       	and	r24, r18
     7f6:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     7f8:	80 e0       	ldi	r24, 0x00	; 0
     7fa:	58 c0       	rjmp	.+176    	; 0x8ac <__stack+0x4d>
				else {
					clear_bit(DDRA, pinNumber);
					}
				break;
			case PORT_B:
				if (direction == OUT) {
     7fc:	11 30       	cpi	r17, 0x01	; 1
     7fe:	61 f4       	brne	.+24     	; 0x818 <__DATA_REGION_LENGTH__+0x18>
					set_bit(DDRB, pinNumber);
     800:	27 b3       	in	r18, 0x17	; 23
     802:	81 e0       	ldi	r24, 0x01	; 1
     804:	90 e0       	ldi	r25, 0x00	; 0
     806:	02 c0       	rjmp	.+4      	; 0x80c <__DATA_REGION_LENGTH__+0xc>
     808:	88 0f       	add	r24, r24
     80a:	99 1f       	adc	r25, r25
     80c:	ca 95       	dec	r28
     80e:	e2 f7       	brpl	.-8      	; 0x808 <__DATA_REGION_LENGTH__+0x8>
     810:	82 2b       	or	r24, r18
     812:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	4a c0       	rjmp	.+148    	; 0x8ac <__stack+0x4d>
			case PORT_B:
				if (direction == OUT) {
					set_bit(DDRB, pinNumber);
					}
				else {
					clear_bit(DDRB, pinNumber);
     818:	27 b3       	in	r18, 0x17	; 23
     81a:	81 e0       	ldi	r24, 0x01	; 1
     81c:	90 e0       	ldi	r25, 0x00	; 0
     81e:	02 c0       	rjmp	.+4      	; 0x824 <__DATA_REGION_LENGTH__+0x24>
     820:	88 0f       	add	r24, r24
     822:	99 1f       	adc	r25, r25
     824:	ca 95       	dec	r28
     826:	e2 f7       	brpl	.-8      	; 0x820 <__DATA_REGION_LENGTH__+0x20>
     828:	80 95       	com	r24
     82a:	82 23       	and	r24, r18
     82c:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     82e:	80 e0       	ldi	r24, 0x00	; 0
     830:	3d c0       	rjmp	.+122    	; 0x8ac <__stack+0x4d>
				else {
					clear_bit(DDRB, pinNumber);
					}
				break;
			case PORT_C:
				if (direction == OUT) {
     832:	11 30       	cpi	r17, 0x01	; 1
     834:	61 f4       	brne	.+24     	; 0x84e <__DATA_REGION_LENGTH__+0x4e>
					set_bit(DDRC, pinNumber);
     836:	24 b3       	in	r18, 0x14	; 20
     838:	81 e0       	ldi	r24, 0x01	; 1
     83a:	90 e0       	ldi	r25, 0x00	; 0
     83c:	02 c0       	rjmp	.+4      	; 0x842 <__DATA_REGION_LENGTH__+0x42>
     83e:	88 0f       	add	r24, r24
     840:	99 1f       	adc	r25, r25
     842:	ca 95       	dec	r28
     844:	e2 f7       	brpl	.-8      	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
     846:	82 2b       	or	r24, r18
     848:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     84a:	80 e0       	ldi	r24, 0x00	; 0
     84c:	2f c0       	rjmp	.+94     	; 0x8ac <__stack+0x4d>
			case PORT_C:
				if (direction == OUT) {
					set_bit(DDRC, pinNumber);
					}
				else {
					clear_bit(DDRC, pinNumber);
     84e:	24 b3       	in	r18, 0x14	; 20
     850:	81 e0       	ldi	r24, 0x01	; 1
     852:	90 e0       	ldi	r25, 0x00	; 0
     854:	02 c0       	rjmp	.+4      	; 0x85a <__DATA_REGION_LENGTH__+0x5a>
     856:	88 0f       	add	r24, r24
     858:	99 1f       	adc	r25, r25
     85a:	ca 95       	dec	r28
     85c:	e2 f7       	brpl	.-8      	; 0x856 <__DATA_REGION_LENGTH__+0x56>
     85e:	80 95       	com	r24
     860:	82 23       	and	r24, r18
     862:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     864:	80 e0       	ldi	r24, 0x00	; 0
     866:	22 c0       	rjmp	.+68     	; 0x8ac <__stack+0x4d>
				else {
					clear_bit(DDRC, pinNumber);
					}
				break;
			case PORT_D:
				if (direction == OUT) {
     868:	11 30       	cpi	r17, 0x01	; 1
     86a:	61 f4       	brne	.+24     	; 0x884 <__stack+0x25>
					set_bit(DDRD, pinNumber);
     86c:	21 b3       	in	r18, 0x11	; 17
     86e:	81 e0       	ldi	r24, 0x01	; 1
     870:	90 e0       	ldi	r25, 0x00	; 0
     872:	02 c0       	rjmp	.+4      	; 0x878 <__stack+0x19>
     874:	88 0f       	add	r24, r24
     876:	99 1f       	adc	r25, r25
     878:	ca 95       	dec	r28
     87a:	e2 f7       	brpl	.-8      	; 0x874 <__stack+0x15>
     87c:	82 2b       	or	r24, r18
     87e:	81 bb       	out	0x11, r24	; 17
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     880:	80 e0       	ldi	r24, 0x00	; 0
     882:	14 c0       	rjmp	.+40     	; 0x8ac <__stack+0x4d>
			case PORT_D:
				if (direction == OUT) {
					set_bit(DDRD, pinNumber);
					}
				else {
					clear_bit(DDRD, pinNumber);
     884:	21 b3       	in	r18, 0x11	; 17
     886:	81 e0       	ldi	r24, 0x01	; 1
     888:	90 e0       	ldi	r25, 0x00	; 0
     88a:	02 c0       	rjmp	.+4      	; 0x890 <__stack+0x31>
     88c:	88 0f       	add	r24, r24
     88e:	99 1f       	adc	r25, r25
     890:	ca 95       	dec	r28
     892:	e2 f7       	brpl	.-8      	; 0x88c <__stack+0x2d>
     894:	80 95       	com	r24
     896:	82 23       	and	r24, r18
     898:	81 bb       	out	0x11, r24	; 17
					}
				break;
		}
	return DIO_OK;
     89a:	80 e0       	ldi	r24, 0x00	; 0
     89c:	07 c0       	rjmp	.+14     	; 0x8ac <__stack+0x4d>

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     89e:	81 e0       	ldi	r24, 0x01	; 1
     8a0:	05 c0       	rjmp	.+10     	; 0x8ac <__stack+0x4d>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     8a2:	82 e0       	ldi	r24, 0x02	; 2
     8a4:	03 c0       	rjmp	.+6      	; 0x8ac <__stack+0x4d>
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
		return WRONG_DIRECTION;
     8a6:	83 e0       	ldi	r24, 0x03	; 3
     8a8:	01 c0       	rjmp	.+2      	; 0x8ac <__stack+0x4d>
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     8aa:	80 e0       	ldi	r24, 0x00	; 0
	}
     8ac:	df 91       	pop	r29
     8ae:	cf 91       	pop	r28
     8b0:	1f 91       	pop	r17
     8b2:	08 95       	ret

000008b4 <DIO_write>:

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
     8b4:	1f 93       	push	r17
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	c8 2f       	mov	r28, r24
     8bc:	d6 2f       	mov	r29, r22
     8be:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     8c0:	0e 94 a7 03 	call	0x74e	; 0x74e <isValidPinNumber>
     8c4:	88 23       	and	r24, r24
     8c6:	09 f4       	brne	.+2      	; 0x8ca <DIO_write+0x16>
     8c8:	84 c0       	rjmp	.+264    	; 0x9d2 <DIO_write+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     8ca:	8d 2f       	mov	r24, r29
     8cc:	0e 94 ad 03 	call	0x75a	; 0x75a <isValidPortNumber>
     8d0:	88 23       	and	r24, r24
     8d2:	09 f4       	brne	.+2      	; 0x8d6 <DIO_write+0x22>
     8d4:	80 c0       	rjmp	.+256    	; 0x9d6 <DIO_write+0x122>
		return WRONG_PORT;
		}
	// Validate the pin state
	if (!isValidState(state)) {
     8d6:	81 2f       	mov	r24, r17
     8d8:	0e 94 ba 03 	call	0x774	; 0x774 <isValidState>
     8dc:	88 23       	and	r24, r24
     8de:	09 f4       	brne	.+2      	; 0x8e2 <DIO_write+0x2e>
     8e0:	7c c0       	rjmp	.+248    	; 0x9da <DIO_write+0x126>
		return WRONG_STATE;
		}
	switch (portNumber) {
     8e2:	d2 34       	cpi	r29, 0x42	; 66
     8e4:	29 f1       	breq	.+74     	; 0x930 <DIO_write+0x7c>
     8e6:	18 f4       	brcc	.+6      	; 0x8ee <DIO_write+0x3a>
     8e8:	d1 34       	cpi	r29, 0x41	; 65
     8ea:	39 f0       	breq	.+14     	; 0x8fa <DIO_write+0x46>
     8ec:	78 c0       	rjmp	.+240    	; 0x9de <DIO_write+0x12a>
     8ee:	d3 34       	cpi	r29, 0x43	; 67
     8f0:	d1 f1       	breq	.+116    	; 0x966 <DIO_write+0xb2>
     8f2:	d4 34       	cpi	r29, 0x44	; 68
     8f4:	09 f4       	brne	.+2      	; 0x8f8 <DIO_write+0x44>
     8f6:	52 c0       	rjmp	.+164    	; 0x99c <DIO_write+0xe8>
     8f8:	72 c0       	rjmp	.+228    	; 0x9de <DIO_write+0x12a>
			case PORT_A:
				if (state == HIGH) {
     8fa:	11 30       	cpi	r17, 0x01	; 1
     8fc:	61 f4       	brne	.+24     	; 0x916 <DIO_write+0x62>
					set_bit(PORTA, pinNumber);
     8fe:	2b b3       	in	r18, 0x1b	; 27
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	90 e0       	ldi	r25, 0x00	; 0
     904:	02 c0       	rjmp	.+4      	; 0x90a <DIO_write+0x56>
     906:	88 0f       	add	r24, r24
     908:	99 1f       	adc	r25, r25
     90a:	ca 95       	dec	r28
     90c:	e2 f7       	brpl	.-8      	; 0x906 <DIO_write+0x52>
     90e:	82 2b       	or	r24, r18
     910:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     912:	80 e0       	ldi	r24, 0x00	; 0
     914:	65 c0       	rjmp	.+202    	; 0x9e0 <DIO_write+0x12c>
			case PORT_A:
				if (state == HIGH) {
					set_bit(PORTA, pinNumber);
					}
				else {
					clear_bit(PORTA, pinNumber);
     916:	2b b3       	in	r18, 0x1b	; 27
     918:	81 e0       	ldi	r24, 0x01	; 1
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	02 c0       	rjmp	.+4      	; 0x922 <DIO_write+0x6e>
     91e:	88 0f       	add	r24, r24
     920:	99 1f       	adc	r25, r25
     922:	ca 95       	dec	r28
     924:	e2 f7       	brpl	.-8      	; 0x91e <DIO_write+0x6a>
     926:	80 95       	com	r24
     928:	82 23       	and	r24, r18
     92a:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     92c:	80 e0       	ldi	r24, 0x00	; 0
     92e:	58 c0       	rjmp	.+176    	; 0x9e0 <DIO_write+0x12c>
				else {
					clear_bit(PORTA, pinNumber);
					}
				break;
			case PORT_B:
				if (state == HIGH) {
     930:	11 30       	cpi	r17, 0x01	; 1
     932:	61 f4       	brne	.+24     	; 0x94c <DIO_write+0x98>
					set_bit(PORTB, pinNumber);
     934:	28 b3       	in	r18, 0x18	; 24
     936:	81 e0       	ldi	r24, 0x01	; 1
     938:	90 e0       	ldi	r25, 0x00	; 0
     93a:	02 c0       	rjmp	.+4      	; 0x940 <DIO_write+0x8c>
     93c:	88 0f       	add	r24, r24
     93e:	99 1f       	adc	r25, r25
     940:	ca 95       	dec	r28
     942:	e2 f7       	brpl	.-8      	; 0x93c <DIO_write+0x88>
     944:	82 2b       	or	r24, r18
     946:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     948:	80 e0       	ldi	r24, 0x00	; 0
     94a:	4a c0       	rjmp	.+148    	; 0x9e0 <DIO_write+0x12c>
			case PORT_B:
				if (state == HIGH) {
					set_bit(PORTB, pinNumber);
					}
				else {
					clear_bit(PORTB, pinNumber);
     94c:	28 b3       	in	r18, 0x18	; 24
     94e:	81 e0       	ldi	r24, 0x01	; 1
     950:	90 e0       	ldi	r25, 0x00	; 0
     952:	02 c0       	rjmp	.+4      	; 0x958 <DIO_write+0xa4>
     954:	88 0f       	add	r24, r24
     956:	99 1f       	adc	r25, r25
     958:	ca 95       	dec	r28
     95a:	e2 f7       	brpl	.-8      	; 0x954 <DIO_write+0xa0>
     95c:	80 95       	com	r24
     95e:	82 23       	and	r24, r18
     960:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     962:	80 e0       	ldi	r24, 0x00	; 0
     964:	3d c0       	rjmp	.+122    	; 0x9e0 <DIO_write+0x12c>
				else {
					clear_bit(PORTB, pinNumber);
					}
				break;
			case PORT_C:
				if (state == HIGH) {
     966:	11 30       	cpi	r17, 0x01	; 1
     968:	61 f4       	brne	.+24     	; 0x982 <DIO_write+0xce>
					set_bit(PORTC, pinNumber);
     96a:	25 b3       	in	r18, 0x15	; 21
     96c:	81 e0       	ldi	r24, 0x01	; 1
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	02 c0       	rjmp	.+4      	; 0x976 <DIO_write+0xc2>
     972:	88 0f       	add	r24, r24
     974:	99 1f       	adc	r25, r25
     976:	ca 95       	dec	r28
     978:	e2 f7       	brpl	.-8      	; 0x972 <DIO_write+0xbe>
     97a:	82 2b       	or	r24, r18
     97c:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     97e:	80 e0       	ldi	r24, 0x00	; 0
     980:	2f c0       	rjmp	.+94     	; 0x9e0 <DIO_write+0x12c>
			case PORT_C:
				if (state == HIGH) {
					set_bit(PORTC, pinNumber);
					}
				else {
					clear_bit(PORTC, pinNumber);
     982:	25 b3       	in	r18, 0x15	; 21
     984:	81 e0       	ldi	r24, 0x01	; 1
     986:	90 e0       	ldi	r25, 0x00	; 0
     988:	02 c0       	rjmp	.+4      	; 0x98e <DIO_write+0xda>
     98a:	88 0f       	add	r24, r24
     98c:	99 1f       	adc	r25, r25
     98e:	ca 95       	dec	r28
     990:	e2 f7       	brpl	.-8      	; 0x98a <DIO_write+0xd6>
     992:	80 95       	com	r24
     994:	82 23       	and	r24, r18
     996:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     998:	80 e0       	ldi	r24, 0x00	; 0
     99a:	22 c0       	rjmp	.+68     	; 0x9e0 <DIO_write+0x12c>
				else {
					clear_bit(PORTC, pinNumber);
					}
				break;
			case PORT_D:
				if (state == HIGH) {
     99c:	11 30       	cpi	r17, 0x01	; 1
     99e:	61 f4       	brne	.+24     	; 0x9b8 <DIO_write+0x104>
					set_bit(PORTD, pinNumber);
     9a0:	22 b3       	in	r18, 0x12	; 18
     9a2:	81 e0       	ldi	r24, 0x01	; 1
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	02 c0       	rjmp	.+4      	; 0x9ac <DIO_write+0xf8>
     9a8:	88 0f       	add	r24, r24
     9aa:	99 1f       	adc	r25, r25
     9ac:	ca 95       	dec	r28
     9ae:	e2 f7       	brpl	.-8      	; 0x9a8 <DIO_write+0xf4>
     9b0:	82 2b       	or	r24, r18
     9b2:	82 bb       	out	0x12, r24	; 18
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     9b4:	80 e0       	ldi	r24, 0x00	; 0
     9b6:	14 c0       	rjmp	.+40     	; 0x9e0 <DIO_write+0x12c>
			case PORT_D:
				if (state == HIGH) {
					set_bit(PORTD, pinNumber);
					}
				else {
					clear_bit(PORTD, pinNumber);
     9b8:	22 b3       	in	r18, 0x12	; 18
     9ba:	81 e0       	ldi	r24, 0x01	; 1
     9bc:	90 e0       	ldi	r25, 0x00	; 0
     9be:	02 c0       	rjmp	.+4      	; 0x9c4 <DIO_write+0x110>
     9c0:	88 0f       	add	r24, r24
     9c2:	99 1f       	adc	r25, r25
     9c4:	ca 95       	dec	r28
     9c6:	e2 f7       	brpl	.-8      	; 0x9c0 <DIO_write+0x10c>
     9c8:	80 95       	com	r24
     9ca:	82 23       	and	r24, r18
     9cc:	82 bb       	out	0x12, r24	; 18
					}
				break;
		}
	return DIO_OK;
     9ce:	80 e0       	ldi	r24, 0x00	; 0
     9d0:	07 c0       	rjmp	.+14     	; 0x9e0 <DIO_write+0x12c>

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     9d2:	81 e0       	ldi	r24, 0x01	; 1
     9d4:	05 c0       	rjmp	.+10     	; 0x9e0 <DIO_write+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     9d6:	82 e0       	ldi	r24, 0x02	; 2
     9d8:	03 c0       	rjmp	.+6      	; 0x9e0 <DIO_write+0x12c>
		}
	// Validate the pin state
	if (!isValidState(state)) {
		return WRONG_STATE;
     9da:	84 e0       	ldi	r24, 0x04	; 4
     9dc:	01 c0       	rjmp	.+2      	; 0x9e0 <DIO_write+0x12c>
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     9de:	80 e0       	ldi	r24, 0x00	; 0
	}
     9e0:	df 91       	pop	r29
     9e2:	cf 91       	pop	r28
     9e4:	1f 91       	pop	r17
     9e6:	08 95       	ret

000009e8 <DIO_Read>:

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
     9e8:	0f 93       	push	r16
     9ea:	1f 93       	push	r17
     9ec:	cf 93       	push	r28
     9ee:	df 93       	push	r29
     9f0:	d8 2f       	mov	r29, r24
     9f2:	c6 2f       	mov	r28, r22
     9f4:	8a 01       	movw	r16, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     9f6:	0e 94 a7 03 	call	0x74e	; 0x74e <isValidPinNumber>
     9fa:	88 23       	and	r24, r24
     9fc:	09 f4       	brne	.+2      	; 0xa00 <DIO_Read+0x18>
     9fe:	40 c0       	rjmp	.+128    	; 0xa80 <DIO_Read+0x98>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     a00:	8c 2f       	mov	r24, r28
     a02:	0e 94 ad 03 	call	0x75a	; 0x75a <isValidPortNumber>
     a06:	88 23       	and	r24, r24
     a08:	e9 f1       	breq	.+122    	; 0xa84 <DIO_Read+0x9c>
		return WRONG_PORT;
		}
	switch (portNumber) {
     a0a:	c2 34       	cpi	r28, 0x42	; 66
     a0c:	a9 f0       	breq	.+42     	; 0xa38 <DIO_Read+0x50>
     a0e:	18 f4       	brcc	.+6      	; 0xa16 <DIO_Read+0x2e>
     a10:	c1 34       	cpi	r28, 0x41	; 65
     a12:	31 f0       	breq	.+12     	; 0xa20 <DIO_Read+0x38>
     a14:	39 c0       	rjmp	.+114    	; 0xa88 <DIO_Read+0xa0>
     a16:	c3 34       	cpi	r28, 0x43	; 67
     a18:	d9 f0       	breq	.+54     	; 0xa50 <DIO_Read+0x68>
     a1a:	c4 34       	cpi	r28, 0x44	; 68
     a1c:	29 f1       	breq	.+74     	; 0xa68 <DIO_Read+0x80>
     a1e:	34 c0       	rjmp	.+104    	; 0xa88 <DIO_Read+0xa0>
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
     a20:	89 b3       	in	r24, 0x19	; 25
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	02 c0       	rjmp	.+4      	; 0xa2a <DIO_Read+0x42>
     a26:	95 95       	asr	r25
     a28:	87 95       	ror	r24
     a2a:	da 95       	dec	r29
     a2c:	e2 f7       	brpl	.-8      	; 0xa26 <DIO_Read+0x3e>
     a2e:	81 70       	andi	r24, 0x01	; 1
     a30:	f8 01       	movw	r30, r16
     a32:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     a34:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
     a36:	29 c0       	rjmp	.+82     	; 0xa8a <DIO_Read+0xa2>
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
     a38:	86 b3       	in	r24, 0x16	; 22
     a3a:	90 e0       	ldi	r25, 0x00	; 0
     a3c:	02 c0       	rjmp	.+4      	; 0xa42 <DIO_Read+0x5a>
     a3e:	95 95       	asr	r25
     a40:	87 95       	ror	r24
     a42:	da 95       	dec	r29
     a44:	e2 f7       	brpl	.-8      	; 0xa3e <DIO_Read+0x56>
     a46:	81 70       	andi	r24, 0x01	; 1
     a48:	f8 01       	movw	r30, r16
     a4a:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     a4c:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
     a4e:	1d c0       	rjmp	.+58     	; 0xa8a <DIO_Read+0xa2>
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
     a50:	83 b3       	in	r24, 0x13	; 19
     a52:	90 e0       	ldi	r25, 0x00	; 0
     a54:	02 c0       	rjmp	.+4      	; 0xa5a <DIO_Read+0x72>
     a56:	95 95       	asr	r25
     a58:	87 95       	ror	r24
     a5a:	da 95       	dec	r29
     a5c:	e2 f7       	brpl	.-8      	; 0xa56 <DIO_Read+0x6e>
     a5e:	81 70       	andi	r24, 0x01	; 1
     a60:	f8 01       	movw	r30, r16
     a62:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     a64:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
     a66:	11 c0       	rjmp	.+34     	; 0xa8a <DIO_Read+0xa2>
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
     a68:	80 b3       	in	r24, 0x10	; 16
     a6a:	90 e0       	ldi	r25, 0x00	; 0
     a6c:	02 c0       	rjmp	.+4      	; 0xa72 <DIO_Read+0x8a>
     a6e:	95 95       	asr	r25
     a70:	87 95       	ror	r24
     a72:	da 95       	dec	r29
     a74:	e2 f7       	brpl	.-8      	; 0xa6e <DIO_Read+0x86>
     a76:	81 70       	andi	r24, 0x01	; 1
     a78:	f8 01       	movw	r30, r16
     a7a:	80 83       	st	Z, r24
				break;
		}
	return DIO_OK;
     a7c:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
     a7e:	05 c0       	rjmp	.+10     	; 0xa8a <DIO_Read+0xa2>

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     a80:	81 e0       	ldi	r24, 0x01	; 1
     a82:	03 c0       	rjmp	.+6      	; 0xa8a <DIO_Read+0xa2>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     a84:	82 e0       	ldi	r24, 0x02	; 2
     a86:	01 c0       	rjmp	.+2      	; 0xa8a <DIO_Read+0xa2>
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     a88:	80 e0       	ldi	r24, 0x00	; 0
	}
     a8a:	df 91       	pop	r29
     a8c:	cf 91       	pop	r28
     a8e:	1f 91       	pop	r17
     a90:	0f 91       	pop	r16
     a92:	08 95       	ret

00000a94 <DIO_toggle>:

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
     a94:	cf 93       	push	r28
     a96:	df 93       	push	r29
     a98:	d8 2f       	mov	r29, r24
     a9a:	c6 2f       	mov	r28, r22
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     a9c:	0e 94 a7 03 	call	0x74e	; 0x74e <isValidPinNumber>
     aa0:	88 23       	and	r24, r24
     aa2:	09 f4       	brne	.+2      	; 0xaa6 <DIO_toggle+0x12>
     aa4:	40 c0       	rjmp	.+128    	; 0xb26 <DIO_toggle+0x92>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     aa6:	8c 2f       	mov	r24, r28
     aa8:	0e 94 ad 03 	call	0x75a	; 0x75a <isValidPortNumber>
     aac:	88 23       	and	r24, r24
     aae:	e9 f1       	breq	.+122    	; 0xb2a <DIO_toggle+0x96>
		return WRONG_PORT;
		}
	switch (portNumber) {
     ab0:	c2 34       	cpi	r28, 0x42	; 66
     ab2:	a9 f0       	breq	.+42     	; 0xade <DIO_toggle+0x4a>
     ab4:	18 f4       	brcc	.+6      	; 0xabc <DIO_toggle+0x28>
     ab6:	c1 34       	cpi	r28, 0x41	; 65
     ab8:	31 f0       	breq	.+12     	; 0xac6 <DIO_toggle+0x32>
     aba:	39 c0       	rjmp	.+114    	; 0xb2e <DIO_toggle+0x9a>
     abc:	c3 34       	cpi	r28, 0x43	; 67
     abe:	d9 f0       	breq	.+54     	; 0xaf6 <DIO_toggle+0x62>
     ac0:	c4 34       	cpi	r28, 0x44	; 68
     ac2:	29 f1       	breq	.+74     	; 0xb0e <DIO_toggle+0x7a>
     ac4:	34 c0       	rjmp	.+104    	; 0xb2e <DIO_toggle+0x9a>
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
     ac6:	2b b3       	in	r18, 0x1b	; 27
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	90 e0       	ldi	r25, 0x00	; 0
     acc:	02 c0       	rjmp	.+4      	; 0xad2 <DIO_toggle+0x3e>
     ace:	88 0f       	add	r24, r24
     ad0:	99 1f       	adc	r25, r25
     ad2:	da 95       	dec	r29
     ad4:	e2 f7       	brpl	.-8      	; 0xace <DIO_toggle+0x3a>
     ad6:	82 27       	eor	r24, r18
     ad8:	8b bb       	out	0x1b, r24	; 27
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     ada:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
     adc:	29 c0       	rjmp	.+82     	; 0xb30 <DIO_toggle+0x9c>
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
     ade:	28 b3       	in	r18, 0x18	; 24
     ae0:	81 e0       	ldi	r24, 0x01	; 1
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	02 c0       	rjmp	.+4      	; 0xaea <DIO_toggle+0x56>
     ae6:	88 0f       	add	r24, r24
     ae8:	99 1f       	adc	r25, r25
     aea:	da 95       	dec	r29
     aec:	e2 f7       	brpl	.-8      	; 0xae6 <DIO_toggle+0x52>
     aee:	82 27       	eor	r24, r18
     af0:	88 bb       	out	0x18, r24	; 24
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     af2:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
     af4:	1d c0       	rjmp	.+58     	; 0xb30 <DIO_toggle+0x9c>
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
     af6:	25 b3       	in	r18, 0x15	; 21
     af8:	81 e0       	ldi	r24, 0x01	; 1
     afa:	90 e0       	ldi	r25, 0x00	; 0
     afc:	02 c0       	rjmp	.+4      	; 0xb02 <DIO_toggle+0x6e>
     afe:	88 0f       	add	r24, r24
     b00:	99 1f       	adc	r25, r25
     b02:	da 95       	dec	r29
     b04:	e2 f7       	brpl	.-8      	; 0xafe <DIO_toggle+0x6a>
     b06:	82 27       	eor	r24, r18
     b08:	85 bb       	out	0x15, r24	; 21
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     b0a:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
     b0c:	11 c0       	rjmp	.+34     	; 0xb30 <DIO_toggle+0x9c>
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
     b0e:	22 b3       	in	r18, 0x12	; 18
     b10:	81 e0       	ldi	r24, 0x01	; 1
     b12:	90 e0       	ldi	r25, 0x00	; 0
     b14:	02 c0       	rjmp	.+4      	; 0xb1a <DIO_toggle+0x86>
     b16:	88 0f       	add	r24, r24
     b18:	99 1f       	adc	r25, r25
     b1a:	da 95       	dec	r29
     b1c:	e2 f7       	brpl	.-8      	; 0xb16 <DIO_toggle+0x82>
     b1e:	82 27       	eor	r24, r18
     b20:	82 bb       	out	0x12, r24	; 18
				break;
		}
	return DIO_OK;
     b22:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
     b24:	05 c0       	rjmp	.+10     	; 0xb30 <DIO_toggle+0x9c>

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     b26:	81 e0       	ldi	r24, 0x01	; 1
     b28:	03 c0       	rjmp	.+6      	; 0xb30 <DIO_toggle+0x9c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     b2a:	82 e0       	ldi	r24, 0x02	; 2
     b2c:	01 c0       	rjmp	.+2      	; 0xb30 <DIO_toggle+0x9c>
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     b2e:	80 e0       	ldi	r24, 0x00	; 0
     b30:	df 91       	pop	r29
     b32:	cf 91       	pop	r28
     b34:	08 95       	ret

00000b36 <getCurrentStatus>:

EN_I2CMasterStatusCode_t I2C_repeatedStart() {   // Same as start, just a different name
  TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  while (read_bit(TWCR, TWINT) == 0);
  return getCurrentStatus();
  }
     b36:	81 b1       	in	r24, 0x01	; 1
     b38:	e8 2f       	mov	r30, r24
     b3a:	e8 7f       	andi	r30, 0xF8	; 248
     b3c:	8e 2f       	mov	r24, r30
     b3e:	90 e0       	ldi	r25, 0x00	; 0
     b40:	fc 01       	movw	r30, r24
     b42:	38 97       	sbiw	r30, 0x08	; 8
     b44:	e1 35       	cpi	r30, 0x51	; 81
     b46:	f1 05       	cpc	r31, r1
     b48:	c0 f4       	brcc	.+48     	; 0xb7a <getCurrentStatus+0x44>
     b4a:	ef 5c       	subi	r30, 0xCF	; 207
     b4c:	ff 4f       	sbci	r31, 0xFF	; 255
     b4e:	0c 94 99 13 	jmp	0x2732	; 0x2732 <__tablejump2__>
     b52:	80 e0       	ldi	r24, 0x00	; 0
     b54:	08 95       	ret
     b56:	82 e0       	ldi	r24, 0x02	; 2
     b58:	08 95       	ret
     b5a:	83 e0       	ldi	r24, 0x03	; 3
     b5c:	08 95       	ret
     b5e:	84 e0       	ldi	r24, 0x04	; 4
     b60:	08 95       	ret
     b62:	85 e0       	ldi	r24, 0x05	; 5
     b64:	08 95       	ret
     b66:	86 e0       	ldi	r24, 0x06	; 6
     b68:	08 95       	ret
     b6a:	87 e0       	ldi	r24, 0x07	; 7
     b6c:	08 95       	ret
     b6e:	88 e0       	ldi	r24, 0x08	; 8
     b70:	08 95       	ret
     b72:	89 e0       	ldi	r24, 0x09	; 9
     b74:	08 95       	ret
     b76:	8a e0       	ldi	r24, 0x0A	; 10
     b78:	08 95       	ret
     b7a:	8b e0       	ldi	r24, 0x0B	; 11
     b7c:	08 95       	ret
     b7e:	81 e0       	ldi	r24, 0x01	; 1
     b80:	08 95       	ret

00000b82 <I2C_init>:
     b82:	11 b8       	out	0x01, r1	; 1
     b84:	8f ef       	ldi	r24, 0xFF	; 255
     b86:	80 b9       	out	0x00, r24	; 0
     b88:	08 95       	ret

00000b8a <I2C_start>:
     b8a:	84 ea       	ldi	r24, 0xA4	; 164
     b8c:	86 bf       	out	0x36, r24	; 54
     b8e:	06 b6       	in	r0, 0x36	; 54
     b90:	07 fe       	sbrs	r0, 7
     b92:	fd cf       	rjmp	.-6      	; 0xb8e <I2C_start+0x4>
     b94:	0e 94 9b 05 	call	0xb36	; 0xb36 <getCurrentStatus>
     b98:	08 95       	ret

00000b9a <I2C_write>:

EN_I2CMasterStatusCode_t I2C_write(u8 data) {
  TWDR = data;
     b9a:	83 b9       	out	0x03, r24	; 3
  TWCR = (1 << TWEN) | (1 << TWINT);
     b9c:	84 e8       	ldi	r24, 0x84	; 132
     b9e:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWINT) == 0);
     ba0:	06 b6       	in	r0, 0x36	; 54
     ba2:	07 fe       	sbrs	r0, 7
     ba4:	fd cf       	rjmp	.-6      	; 0xba0 <I2C_write+0x6>
  return getCurrentStatus();
     ba6:	0e 94 9b 05 	call	0xb36	; 0xb36 <getCurrentStatus>
  }
     baa:	08 95       	ret

00000bac <I2C_read_Ack>:

EN_I2CMasterStatusCode_t I2C_read_Ack(u8* data) {
  TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWINT);
     bac:	24 ec       	ldi	r18, 0xC4	; 196
     bae:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     bb0:	06 b6       	in	r0, 0x36	; 54
     bb2:	07 fe       	sbrs	r0, 7
     bb4:	fd cf       	rjmp	.-6      	; 0xbb0 <I2C_read_Ack+0x4>
  *data = TWDR;
     bb6:	23 b1       	in	r18, 0x03	; 3
     bb8:	fc 01       	movw	r30, r24
     bba:	20 83       	st	Z, r18
  return getCurrentStatus();
     bbc:	0e 94 9b 05 	call	0xb36	; 0xb36 <getCurrentStatus>
  }
     bc0:	08 95       	ret

00000bc2 <I2C_read_Nack>:

EN_I2CMasterStatusCode_t I2C_read_Nack(u8* data) {
  TWCR = (1 << TWEN) | (1 << TWINT);
     bc2:	24 e8       	ldi	r18, 0x84	; 132
     bc4:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     bc6:	06 b6       	in	r0, 0x36	; 54
     bc8:	07 fe       	sbrs	r0, 7
     bca:	fd cf       	rjmp	.-6      	; 0xbc6 <I2C_read_Nack+0x4>
  *data = TWDR;
     bcc:	23 b1       	in	r18, 0x03	; 3
     bce:	fc 01       	movw	r30, r24
     bd0:	20 83       	st	Z, r18
  return getCurrentStatus();
     bd2:	0e 94 9b 05 	call	0xb36	; 0xb36 <getCurrentStatus>
  }
     bd6:	08 95       	ret

00000bd8 <I2C_stop>:

void I2C_stop(void) {
  TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
     bd8:	84 e9       	ldi	r24, 0x94	; 148
     bda:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWSTO));	// Wait until stop condition finishes
     bdc:	06 b6       	in	r0, 0x36	; 54
     bde:	04 fc       	sbrc	r0, 4
     be0:	fd cf       	rjmp	.-6      	; 0xbdc <I2C_stop+0x4>
  }
     be2:	08 95       	ret

00000be4 <INT0_init>:
        break;
    }
  // Enable the external interrupt 
  set_bit(GICR, INT2);
  return INTERRUPT_INIT_OK;
  }
     be4:	84 30       	cpi	r24, 0x04	; 4
     be6:	c8 f4       	brcc	.+50     	; 0xc1a <INT0_init+0x36>
     be8:	82 30       	cpi	r24, 0x02	; 2
     bea:	41 f0       	breq	.+16     	; 0xbfc <INT0_init+0x18>
     bec:	83 30       	cpi	r24, 0x03	; 3
     bee:	51 f0       	breq	.+20     	; 0xc04 <INT0_init+0x20>
     bf0:	81 30       	cpi	r24, 0x01	; 1
     bf2:	71 f4       	brne	.+28     	; 0xc10 <INT0_init+0x2c>
     bf4:	85 b7       	in	r24, 0x35	; 53
     bf6:	81 60       	ori	r24, 0x01	; 1
     bf8:	85 bf       	out	0x35, r24	; 53
     bfa:	0a c0       	rjmp	.+20     	; 0xc10 <INT0_init+0x2c>
     bfc:	85 b7       	in	r24, 0x35	; 53
     bfe:	82 60       	ori	r24, 0x02	; 2
     c00:	85 bf       	out	0x35, r24	; 53
     c02:	06 c0       	rjmp	.+12     	; 0xc10 <INT0_init+0x2c>
     c04:	85 b7       	in	r24, 0x35	; 53
     c06:	81 60       	ori	r24, 0x01	; 1
     c08:	85 bf       	out	0x35, r24	; 53
     c0a:	85 b7       	in	r24, 0x35	; 53
     c0c:	82 60       	ori	r24, 0x02	; 2
     c0e:	85 bf       	out	0x35, r24	; 53
     c10:	8b b7       	in	r24, 0x3b	; 59
     c12:	80 64       	ori	r24, 0x40	; 64
     c14:	8b bf       	out	0x3b, r24	; 59
     c16:	80 e0       	ldi	r24, 0x00	; 0
     c18:	08 95       	ret
     c1a:	81 e0       	ldi	r24, 0x01	; 1
     c1c:	08 95       	ret

00000c1e <ADC_INT_init>:

// Initialize the ADC conversion complete interrupt
EN_INT_init_Status_t ADC_INT_init(void) {
  // Enable the ADC conversion complete interrupt
  set_bit(ADCSRA, ADIE);
     c1e:	86 b1       	in	r24, 0x06	; 6
     c20:	88 60       	ori	r24, 0x08	; 8
     c22:	86 b9       	out	0x06, r24	; 6
  return INTERRUPT_INIT_OK;
  }
     c24:	80 e0       	ldi	r24, 0x00	; 0
     c26:	08 95       	ret

00000c28 <UART_RXC_INT_init>:

// Initialize the UART RX complete interrupt
EN_INT_init_Status_t UART_RXC_INT_init(void) {
  // Enable the UART RX complete interrupt
  set_bit(UCSRB, RXCIE);
     c28:	8a b1       	in	r24, 0x0a	; 10
     c2a:	80 68       	ori	r24, 0x80	; 128
     c2c:	8a b9       	out	0x0a, r24	; 10
  return INTERRUPT_INIT_OK;
     c2e:	80 e0       	ldi	r24, 0x00	; 0
     c30:	08 95       	ret

00000c32 <isValidTimer>:
        clear_bit(TCCR2, COM21);
        set_prescalar(TIMER_2, 0);
        break;
    }
  return TIMER_OK;
  }
     c32:	83 30       	cpi	r24, 0x03	; 3
     c34:	10 f4       	brcc	.+4      	; 0xc3a <isValidTimer+0x8>
     c36:	81 e0       	ldi	r24, 0x01	; 1
     c38:	08 95       	ret
     c3a:	80 e0       	ldi	r24, 0x00	; 0
     c3c:	08 95       	ret

00000c3e <set_prescalar>:
     c3e:	1f 93       	push	r17
     c40:	cf 93       	push	r28
     c42:	df 93       	push	r29
     c44:	18 2f       	mov	r17, r24
     c46:	eb 01       	movw	r28, r22
     c48:	0e 94 19 06 	call	0xc32	; 0xc32 <isValidTimer>
     c4c:	88 23       	and	r24, r24
     c4e:	09 f4       	brne	.+2      	; 0xc52 <set_prescalar+0x14>
     c50:	6a c1       	rjmp	.+724    	; 0xf26 <set_prescalar+0x2e8>
     c52:	11 30       	cpi	r17, 0x01	; 1
     c54:	09 f4       	brne	.+2      	; 0xc58 <set_prescalar+0x1a>
     c56:	6f c0       	rjmp	.+222    	; 0xd36 <set_prescalar+0xf8>
     c58:	20 f0       	brcs	.+8      	; 0xc62 <set_prescalar+0x24>
     c5a:	12 30       	cpi	r17, 0x02	; 2
     c5c:	09 f4       	brne	.+2      	; 0xc60 <set_prescalar+0x22>
     c5e:	d5 c0       	rjmp	.+426    	; 0xe0a <set_prescalar+0x1cc>
     c60:	64 c1       	rjmp	.+712    	; 0xf2a <set_prescalar+0x2ec>
     c62:	c2 30       	cpi	r28, 0x02	; 2
     c64:	d1 05       	cpc	r29, r1
     c66:	78 f0       	brcs	.+30     	; 0xc86 <set_prescalar+0x48>
     c68:	c8 30       	cpi	r28, 0x08	; 8
     c6a:	d1 05       	cpc	r29, r1
     c6c:	61 f0       	breq	.+24     	; 0xc86 <set_prescalar+0x48>
     c6e:	c0 34       	cpi	r28, 0x40	; 64
     c70:	d1 05       	cpc	r29, r1
     c72:	49 f0       	breq	.+18     	; 0xc86 <set_prescalar+0x48>
     c74:	c1 15       	cp	r28, r1
     c76:	81 e0       	ldi	r24, 0x01	; 1
     c78:	d8 07       	cpc	r29, r24
     c7a:	29 f0       	breq	.+10     	; 0xc86 <set_prescalar+0x48>
     c7c:	c1 15       	cp	r28, r1
     c7e:	84 e0       	ldi	r24, 0x04	; 4
     c80:	d8 07       	cpc	r29, r24
     c82:	09 f0       	breq	.+2      	; 0xc86 <set_prescalar+0x48>
     c84:	54 c1       	rjmp	.+680    	; 0xf2e <set_prescalar+0x2f0>
     c86:	c8 30       	cpi	r28, 0x08	; 8
     c88:	d1 05       	cpc	r29, r1
     c8a:	49 f1       	breq	.+82     	; 0xcde <set_prescalar+0xa0>
     c8c:	28 f4       	brcc	.+10     	; 0xc98 <set_prescalar+0x5a>
     c8e:	20 97       	sbiw	r28, 0x00	; 0
     c90:	81 f0       	breq	.+32     	; 0xcb2 <set_prescalar+0x74>
     c92:	21 97       	sbiw	r28, 0x01	; 1
     c94:	c9 f0       	breq	.+50     	; 0xcc8 <set_prescalar+0x8a>
     c96:	4d c1       	rjmp	.+666    	; 0xf32 <set_prescalar+0x2f4>
     c98:	c1 15       	cp	r28, r1
     c9a:	81 e0       	ldi	r24, 0x01	; 1
     c9c:	d8 07       	cpc	r29, r24
     c9e:	a9 f1       	breq	.+106    	; 0xd0a <set_prescalar+0xcc>
     ca0:	c1 15       	cp	r28, r1
     ca2:	84 e0       	ldi	r24, 0x04	; 4
     ca4:	d8 07       	cpc	r29, r24
     ca6:	e1 f1       	breq	.+120    	; 0xd20 <set_prescalar+0xe2>
     ca8:	c0 34       	cpi	r28, 0x40	; 64
     caa:	d1 05       	cpc	r29, r1
     cac:	09 f0       	breq	.+2      	; 0xcb0 <set_prescalar+0x72>
     cae:	41 c1       	rjmp	.+642    	; 0xf32 <set_prescalar+0x2f4>
     cb0:	21 c0       	rjmp	.+66     	; 0xcf4 <set_prescalar+0xb6>
     cb2:	83 b7       	in	r24, 0x33	; 51
     cb4:	8e 7f       	andi	r24, 0xFE	; 254
     cb6:	83 bf       	out	0x33, r24	; 51
     cb8:	83 b7       	in	r24, 0x33	; 51
     cba:	8d 7f       	andi	r24, 0xFD	; 253
     cbc:	83 bf       	out	0x33, r24	; 51
     cbe:	83 b7       	in	r24, 0x33	; 51
     cc0:	8b 7f       	andi	r24, 0xFB	; 251
     cc2:	83 bf       	out	0x33, r24	; 51
     cc4:	80 e0       	ldi	r24, 0x00	; 0
     cc6:	3e c1       	rjmp	.+636    	; 0xf44 <set_prescalar+0x306>
     cc8:	83 b7       	in	r24, 0x33	; 51
     cca:	81 60       	ori	r24, 0x01	; 1
     ccc:	83 bf       	out	0x33, r24	; 51
     cce:	83 b7       	in	r24, 0x33	; 51
     cd0:	8d 7f       	andi	r24, 0xFD	; 253
     cd2:	83 bf       	out	0x33, r24	; 51
     cd4:	83 b7       	in	r24, 0x33	; 51
     cd6:	8b 7f       	andi	r24, 0xFB	; 251
     cd8:	83 bf       	out	0x33, r24	; 51
     cda:	80 e0       	ldi	r24, 0x00	; 0
     cdc:	33 c1       	rjmp	.+614    	; 0xf44 <set_prescalar+0x306>
     cde:	83 b7       	in	r24, 0x33	; 51
     ce0:	8e 7f       	andi	r24, 0xFE	; 254
     ce2:	83 bf       	out	0x33, r24	; 51
     ce4:	83 b7       	in	r24, 0x33	; 51
     ce6:	82 60       	ori	r24, 0x02	; 2
     ce8:	83 bf       	out	0x33, r24	; 51
     cea:	83 b7       	in	r24, 0x33	; 51
     cec:	8b 7f       	andi	r24, 0xFB	; 251
     cee:	83 bf       	out	0x33, r24	; 51
     cf0:	80 e0       	ldi	r24, 0x00	; 0
     cf2:	28 c1       	rjmp	.+592    	; 0xf44 <set_prescalar+0x306>
     cf4:	83 b7       	in	r24, 0x33	; 51
     cf6:	81 60       	ori	r24, 0x01	; 1
     cf8:	83 bf       	out	0x33, r24	; 51
     cfa:	83 b7       	in	r24, 0x33	; 51
     cfc:	82 60       	ori	r24, 0x02	; 2
     cfe:	83 bf       	out	0x33, r24	; 51
     d00:	83 b7       	in	r24, 0x33	; 51
     d02:	8b 7f       	andi	r24, 0xFB	; 251
     d04:	83 bf       	out	0x33, r24	; 51
     d06:	80 e0       	ldi	r24, 0x00	; 0
     d08:	1d c1       	rjmp	.+570    	; 0xf44 <set_prescalar+0x306>
     d0a:	83 b7       	in	r24, 0x33	; 51
     d0c:	8e 7f       	andi	r24, 0xFE	; 254
     d0e:	83 bf       	out	0x33, r24	; 51
     d10:	83 b7       	in	r24, 0x33	; 51
     d12:	8d 7f       	andi	r24, 0xFD	; 253
     d14:	83 bf       	out	0x33, r24	; 51
     d16:	83 b7       	in	r24, 0x33	; 51
     d18:	84 60       	ori	r24, 0x04	; 4
     d1a:	83 bf       	out	0x33, r24	; 51
     d1c:	80 e0       	ldi	r24, 0x00	; 0
     d1e:	12 c1       	rjmp	.+548    	; 0xf44 <set_prescalar+0x306>
     d20:	83 b7       	in	r24, 0x33	; 51
     d22:	81 60       	ori	r24, 0x01	; 1
     d24:	83 bf       	out	0x33, r24	; 51
     d26:	83 b7       	in	r24, 0x33	; 51
     d28:	8d 7f       	andi	r24, 0xFD	; 253
     d2a:	83 bf       	out	0x33, r24	; 51
     d2c:	83 b7       	in	r24, 0x33	; 51
     d2e:	84 60       	ori	r24, 0x04	; 4
     d30:	83 bf       	out	0x33, r24	; 51
     d32:	80 e0       	ldi	r24, 0x00	; 0
     d34:	07 c1       	rjmp	.+526    	; 0xf44 <set_prescalar+0x306>
     d36:	c2 30       	cpi	r28, 0x02	; 2
     d38:	d1 05       	cpc	r29, r1
     d3a:	78 f0       	brcs	.+30     	; 0xd5a <set_prescalar+0x11c>
     d3c:	c8 30       	cpi	r28, 0x08	; 8
     d3e:	d1 05       	cpc	r29, r1
     d40:	61 f0       	breq	.+24     	; 0xd5a <set_prescalar+0x11c>
     d42:	c0 34       	cpi	r28, 0x40	; 64
     d44:	d1 05       	cpc	r29, r1
     d46:	49 f0       	breq	.+18     	; 0xd5a <set_prescalar+0x11c>
     d48:	c1 15       	cp	r28, r1
     d4a:	81 e0       	ldi	r24, 0x01	; 1
     d4c:	d8 07       	cpc	r29, r24
     d4e:	29 f0       	breq	.+10     	; 0xd5a <set_prescalar+0x11c>
     d50:	c1 15       	cp	r28, r1
     d52:	84 e0       	ldi	r24, 0x04	; 4
     d54:	d8 07       	cpc	r29, r24
     d56:	09 f0       	breq	.+2      	; 0xd5a <set_prescalar+0x11c>
     d58:	ee c0       	rjmp	.+476    	; 0xf36 <set_prescalar+0x2f8>
     d5a:	c8 30       	cpi	r28, 0x08	; 8
     d5c:	d1 05       	cpc	r29, r1
     d5e:	49 f1       	breq	.+82     	; 0xdb2 <set_prescalar+0x174>
     d60:	28 f4       	brcc	.+10     	; 0xd6c <set_prescalar+0x12e>
     d62:	20 97       	sbiw	r28, 0x00	; 0
     d64:	81 f0       	breq	.+32     	; 0xd86 <set_prescalar+0x148>
     d66:	21 97       	sbiw	r28, 0x01	; 1
     d68:	c9 f0       	breq	.+50     	; 0xd9c <set_prescalar+0x15e>
     d6a:	e7 c0       	rjmp	.+462    	; 0xf3a <set_prescalar+0x2fc>
     d6c:	c1 15       	cp	r28, r1
     d6e:	81 e0       	ldi	r24, 0x01	; 1
     d70:	d8 07       	cpc	r29, r24
     d72:	a9 f1       	breq	.+106    	; 0xdde <set_prescalar+0x1a0>
     d74:	c1 15       	cp	r28, r1
     d76:	84 e0       	ldi	r24, 0x04	; 4
     d78:	d8 07       	cpc	r29, r24
     d7a:	e1 f1       	breq	.+120    	; 0xdf4 <set_prescalar+0x1b6>
     d7c:	c0 34       	cpi	r28, 0x40	; 64
     d7e:	d1 05       	cpc	r29, r1
     d80:	09 f0       	breq	.+2      	; 0xd84 <set_prescalar+0x146>
     d82:	db c0       	rjmp	.+438    	; 0xf3a <set_prescalar+0x2fc>
     d84:	21 c0       	rjmp	.+66     	; 0xdc8 <set_prescalar+0x18a>
     d86:	8e b5       	in	r24, 0x2e	; 46
     d88:	8e 7f       	andi	r24, 0xFE	; 254
     d8a:	8e bd       	out	0x2e, r24	; 46
     d8c:	8e b5       	in	r24, 0x2e	; 46
     d8e:	8d 7f       	andi	r24, 0xFD	; 253
     d90:	8e bd       	out	0x2e, r24	; 46
     d92:	8e b5       	in	r24, 0x2e	; 46
     d94:	8b 7f       	andi	r24, 0xFB	; 251
     d96:	8e bd       	out	0x2e, r24	; 46
     d98:	80 e0       	ldi	r24, 0x00	; 0
     d9a:	d4 c0       	rjmp	.+424    	; 0xf44 <set_prescalar+0x306>
     d9c:	8e b5       	in	r24, 0x2e	; 46
     d9e:	81 60       	ori	r24, 0x01	; 1
     da0:	8e bd       	out	0x2e, r24	; 46
     da2:	8e b5       	in	r24, 0x2e	; 46
     da4:	8d 7f       	andi	r24, 0xFD	; 253
     da6:	8e bd       	out	0x2e, r24	; 46
     da8:	8e b5       	in	r24, 0x2e	; 46
     daa:	8b 7f       	andi	r24, 0xFB	; 251
     dac:	8e bd       	out	0x2e, r24	; 46
     dae:	80 e0       	ldi	r24, 0x00	; 0
     db0:	c9 c0       	rjmp	.+402    	; 0xf44 <set_prescalar+0x306>
     db2:	8e b5       	in	r24, 0x2e	; 46
     db4:	8e 7f       	andi	r24, 0xFE	; 254
     db6:	8e bd       	out	0x2e, r24	; 46
     db8:	8e b5       	in	r24, 0x2e	; 46
     dba:	82 60       	ori	r24, 0x02	; 2
     dbc:	8e bd       	out	0x2e, r24	; 46
     dbe:	8e b5       	in	r24, 0x2e	; 46
     dc0:	8b 7f       	andi	r24, 0xFB	; 251
     dc2:	8e bd       	out	0x2e, r24	; 46
     dc4:	80 e0       	ldi	r24, 0x00	; 0
     dc6:	be c0       	rjmp	.+380    	; 0xf44 <set_prescalar+0x306>
     dc8:	8e b5       	in	r24, 0x2e	; 46
     dca:	81 60       	ori	r24, 0x01	; 1
     dcc:	8e bd       	out	0x2e, r24	; 46
     dce:	8e b5       	in	r24, 0x2e	; 46
     dd0:	82 60       	ori	r24, 0x02	; 2
     dd2:	8e bd       	out	0x2e, r24	; 46
     dd4:	8e b5       	in	r24, 0x2e	; 46
     dd6:	8b 7f       	andi	r24, 0xFB	; 251
     dd8:	8e bd       	out	0x2e, r24	; 46
     dda:	80 e0       	ldi	r24, 0x00	; 0
     ddc:	b3 c0       	rjmp	.+358    	; 0xf44 <set_prescalar+0x306>
     dde:	8e b5       	in	r24, 0x2e	; 46
     de0:	8e 7f       	andi	r24, 0xFE	; 254
     de2:	8e bd       	out	0x2e, r24	; 46
     de4:	8e b5       	in	r24, 0x2e	; 46
     de6:	8d 7f       	andi	r24, 0xFD	; 253
     de8:	8e bd       	out	0x2e, r24	; 46
     dea:	8e b5       	in	r24, 0x2e	; 46
     dec:	84 60       	ori	r24, 0x04	; 4
     dee:	8e bd       	out	0x2e, r24	; 46
     df0:	80 e0       	ldi	r24, 0x00	; 0
     df2:	a8 c0       	rjmp	.+336    	; 0xf44 <set_prescalar+0x306>
     df4:	8e b5       	in	r24, 0x2e	; 46
     df6:	81 60       	ori	r24, 0x01	; 1
     df8:	8e bd       	out	0x2e, r24	; 46
     dfa:	8e b5       	in	r24, 0x2e	; 46
     dfc:	8d 7f       	andi	r24, 0xFD	; 253
     dfe:	8e bd       	out	0x2e, r24	; 46
     e00:	8e b5       	in	r24, 0x2e	; 46
     e02:	84 60       	ori	r24, 0x04	; 4
     e04:	8e bd       	out	0x2e, r24	; 46
     e06:	80 e0       	ldi	r24, 0x00	; 0
     e08:	9d c0       	rjmp	.+314    	; 0xf44 <set_prescalar+0x306>
     e0a:	c2 30       	cpi	r28, 0x02	; 2
     e0c:	d1 05       	cpc	r29, r1
     e0e:	a8 f0       	brcs	.+42     	; 0xe3a <set_prescalar+0x1fc>
     e10:	c8 30       	cpi	r28, 0x08	; 8
     e12:	d1 05       	cpc	r29, r1
     e14:	91 f0       	breq	.+36     	; 0xe3a <set_prescalar+0x1fc>
     e16:	c0 32       	cpi	r28, 0x20	; 32
     e18:	d1 05       	cpc	r29, r1
     e1a:	79 f0       	breq	.+30     	; 0xe3a <set_prescalar+0x1fc>
     e1c:	c0 34       	cpi	r28, 0x40	; 64
     e1e:	d1 05       	cpc	r29, r1
     e20:	61 f0       	breq	.+24     	; 0xe3a <set_prescalar+0x1fc>
     e22:	c0 38       	cpi	r28, 0x80	; 128
     e24:	d1 05       	cpc	r29, r1
     e26:	49 f0       	breq	.+18     	; 0xe3a <set_prescalar+0x1fc>
     e28:	c1 15       	cp	r28, r1
     e2a:	81 e0       	ldi	r24, 0x01	; 1
     e2c:	d8 07       	cpc	r29, r24
     e2e:	29 f0       	breq	.+10     	; 0xe3a <set_prescalar+0x1fc>
     e30:	c1 15       	cp	r28, r1
     e32:	84 e0       	ldi	r24, 0x04	; 4
     e34:	d8 07       	cpc	r29, r24
     e36:	09 f0       	breq	.+2      	; 0xe3a <set_prescalar+0x1fc>
     e38:	82 c0       	rjmp	.+260    	; 0xf3e <set_prescalar+0x300>
     e3a:	c0 32       	cpi	r28, 0x20	; 32
     e3c:	d1 05       	cpc	r29, r1
     e3e:	e1 f1       	breq	.+120    	; 0xeb8 <set_prescalar+0x27a>
     e40:	38 f4       	brcc	.+14     	; 0xe50 <set_prescalar+0x212>
     e42:	c1 30       	cpi	r28, 0x01	; 1
     e44:	d1 05       	cpc	r29, r1
     e46:	11 f1       	breq	.+68     	; 0xe8c <set_prescalar+0x24e>
     e48:	b0 f0       	brcs	.+44     	; 0xe76 <set_prescalar+0x238>
     e4a:	28 97       	sbiw	r28, 0x08	; 8
     e4c:	51 f1       	breq	.+84     	; 0xea2 <set_prescalar+0x264>
     e4e:	79 c0       	rjmp	.+242    	; 0xf42 <set_prescalar+0x304>
     e50:	c0 38       	cpi	r28, 0x80	; 128
     e52:	d1 05       	cpc	r29, r1
     e54:	09 f4       	brne	.+2      	; 0xe58 <set_prescalar+0x21a>
     e56:	46 c0       	rjmp	.+140    	; 0xee4 <set_prescalar+0x2a6>
     e58:	20 f4       	brcc	.+8      	; 0xe62 <set_prescalar+0x224>
     e5a:	c0 34       	cpi	r28, 0x40	; 64
     e5c:	d1 05       	cpc	r29, r1
     e5e:	b9 f1       	breq	.+110    	; 0xece <set_prescalar+0x290>
     e60:	70 c0       	rjmp	.+224    	; 0xf42 <set_prescalar+0x304>
     e62:	c1 15       	cp	r28, r1
     e64:	81 e0       	ldi	r24, 0x01	; 1
     e66:	d8 07       	cpc	r29, r24
     e68:	09 f4       	brne	.+2      	; 0xe6c <set_prescalar+0x22e>
     e6a:	47 c0       	rjmp	.+142    	; 0xefa <set_prescalar+0x2bc>
     e6c:	c1 15       	cp	r28, r1
     e6e:	d4 40       	sbci	r29, 0x04	; 4
     e70:	09 f4       	brne	.+2      	; 0xe74 <set_prescalar+0x236>
     e72:	4e c0       	rjmp	.+156    	; 0xf10 <set_prescalar+0x2d2>
     e74:	66 c0       	rjmp	.+204    	; 0xf42 <set_prescalar+0x304>
     e76:	85 b5       	in	r24, 0x25	; 37
     e78:	8e 7f       	andi	r24, 0xFE	; 254
     e7a:	85 bd       	out	0x25, r24	; 37
     e7c:	85 b5       	in	r24, 0x25	; 37
     e7e:	8d 7f       	andi	r24, 0xFD	; 253
     e80:	85 bd       	out	0x25, r24	; 37
     e82:	85 b5       	in	r24, 0x25	; 37
     e84:	8b 7f       	andi	r24, 0xFB	; 251
     e86:	85 bd       	out	0x25, r24	; 37
     e88:	80 e0       	ldi	r24, 0x00	; 0
     e8a:	5c c0       	rjmp	.+184    	; 0xf44 <set_prescalar+0x306>
     e8c:	85 b5       	in	r24, 0x25	; 37
     e8e:	81 60       	ori	r24, 0x01	; 1
     e90:	85 bd       	out	0x25, r24	; 37
     e92:	85 b5       	in	r24, 0x25	; 37
     e94:	8d 7f       	andi	r24, 0xFD	; 253
     e96:	85 bd       	out	0x25, r24	; 37
     e98:	85 b5       	in	r24, 0x25	; 37
     e9a:	8b 7f       	andi	r24, 0xFB	; 251
     e9c:	85 bd       	out	0x25, r24	; 37
     e9e:	80 e0       	ldi	r24, 0x00	; 0
     ea0:	51 c0       	rjmp	.+162    	; 0xf44 <set_prescalar+0x306>
     ea2:	85 b5       	in	r24, 0x25	; 37
     ea4:	8e 7f       	andi	r24, 0xFE	; 254
     ea6:	85 bd       	out	0x25, r24	; 37
     ea8:	85 b5       	in	r24, 0x25	; 37
     eaa:	82 60       	ori	r24, 0x02	; 2
     eac:	85 bd       	out	0x25, r24	; 37
     eae:	85 b5       	in	r24, 0x25	; 37
     eb0:	8b 7f       	andi	r24, 0xFB	; 251
     eb2:	85 bd       	out	0x25, r24	; 37
     eb4:	80 e0       	ldi	r24, 0x00	; 0
     eb6:	46 c0       	rjmp	.+140    	; 0xf44 <set_prescalar+0x306>
     eb8:	85 b5       	in	r24, 0x25	; 37
     eba:	81 60       	ori	r24, 0x01	; 1
     ebc:	85 bd       	out	0x25, r24	; 37
     ebe:	85 b5       	in	r24, 0x25	; 37
     ec0:	82 60       	ori	r24, 0x02	; 2
     ec2:	85 bd       	out	0x25, r24	; 37
     ec4:	85 b5       	in	r24, 0x25	; 37
     ec6:	8b 7f       	andi	r24, 0xFB	; 251
     ec8:	85 bd       	out	0x25, r24	; 37
     eca:	80 e0       	ldi	r24, 0x00	; 0
     ecc:	3b c0       	rjmp	.+118    	; 0xf44 <set_prescalar+0x306>
     ece:	85 b5       	in	r24, 0x25	; 37
     ed0:	8e 7f       	andi	r24, 0xFE	; 254
     ed2:	85 bd       	out	0x25, r24	; 37
     ed4:	85 b5       	in	r24, 0x25	; 37
     ed6:	8d 7f       	andi	r24, 0xFD	; 253
     ed8:	85 bd       	out	0x25, r24	; 37
     eda:	85 b5       	in	r24, 0x25	; 37
     edc:	84 60       	ori	r24, 0x04	; 4
     ede:	85 bd       	out	0x25, r24	; 37
     ee0:	80 e0       	ldi	r24, 0x00	; 0
     ee2:	30 c0       	rjmp	.+96     	; 0xf44 <set_prescalar+0x306>
     ee4:	85 b5       	in	r24, 0x25	; 37
     ee6:	81 60       	ori	r24, 0x01	; 1
     ee8:	85 bd       	out	0x25, r24	; 37
     eea:	85 b5       	in	r24, 0x25	; 37
     eec:	8d 7f       	andi	r24, 0xFD	; 253
     eee:	85 bd       	out	0x25, r24	; 37
     ef0:	85 b5       	in	r24, 0x25	; 37
     ef2:	84 60       	ori	r24, 0x04	; 4
     ef4:	85 bd       	out	0x25, r24	; 37
     ef6:	80 e0       	ldi	r24, 0x00	; 0
     ef8:	25 c0       	rjmp	.+74     	; 0xf44 <set_prescalar+0x306>
     efa:	85 b5       	in	r24, 0x25	; 37
     efc:	8e 7f       	andi	r24, 0xFE	; 254
     efe:	85 bd       	out	0x25, r24	; 37
     f00:	85 b5       	in	r24, 0x25	; 37
     f02:	82 60       	ori	r24, 0x02	; 2
     f04:	85 bd       	out	0x25, r24	; 37
     f06:	85 b5       	in	r24, 0x25	; 37
     f08:	84 60       	ori	r24, 0x04	; 4
     f0a:	85 bd       	out	0x25, r24	; 37
     f0c:	80 e0       	ldi	r24, 0x00	; 0
     f0e:	1a c0       	rjmp	.+52     	; 0xf44 <set_prescalar+0x306>
     f10:	85 b5       	in	r24, 0x25	; 37
     f12:	81 60       	ori	r24, 0x01	; 1
     f14:	85 bd       	out	0x25, r24	; 37
     f16:	85 b5       	in	r24, 0x25	; 37
     f18:	82 60       	ori	r24, 0x02	; 2
     f1a:	85 bd       	out	0x25, r24	; 37
     f1c:	85 b5       	in	r24, 0x25	; 37
     f1e:	84 60       	ori	r24, 0x04	; 4
     f20:	85 bd       	out	0x25, r24	; 37
     f22:	80 e0       	ldi	r24, 0x00	; 0
     f24:	0f c0       	rjmp	.+30     	; 0xf44 <set_prescalar+0x306>
     f26:	81 e0       	ldi	r24, 0x01	; 1
     f28:	0d c0       	rjmp	.+26     	; 0xf44 <set_prescalar+0x306>
     f2a:	80 e0       	ldi	r24, 0x00	; 0
     f2c:	0b c0       	rjmp	.+22     	; 0xf44 <set_prescalar+0x306>
     f2e:	82 e0       	ldi	r24, 0x02	; 2
     f30:	09 c0       	rjmp	.+18     	; 0xf44 <set_prescalar+0x306>
     f32:	80 e0       	ldi	r24, 0x00	; 0
     f34:	07 c0       	rjmp	.+14     	; 0xf44 <set_prescalar+0x306>
     f36:	82 e0       	ldi	r24, 0x02	; 2
     f38:	05 c0       	rjmp	.+10     	; 0xf44 <set_prescalar+0x306>
     f3a:	80 e0       	ldi	r24, 0x00	; 0
     f3c:	03 c0       	rjmp	.+6      	; 0xf44 <set_prescalar+0x306>
     f3e:	82 e0       	ldi	r24, 0x02	; 2
     f40:	01 c0       	rjmp	.+2      	; 0xf44 <set_prescalar+0x306>
     f42:	80 e0       	ldi	r24, 0x00	; 0
     f44:	df 91       	pop	r29
     f46:	cf 91       	pop	r28
     f48:	1f 91       	pop	r17
     f4a:	08 95       	ret

00000f4c <Timer_normal_init>:
     f4c:	0f 93       	push	r16
     f4e:	1f 93       	push	r17
     f50:	cf 93       	push	r28
     f52:	c8 2f       	mov	r28, r24
     f54:	8b 01       	movw	r16, r22
     f56:	0e 94 19 06 	call	0xc32	; 0xc32 <isValidTimer>
     f5a:	88 23       	and	r24, r24
     f5c:	81 f1       	breq	.+96     	; 0xfbe <Timer_normal_init+0x72>
     f5e:	cc 23       	and	r28, r28
     f60:	11 f0       	breq	.+4      	; 0xf66 <Timer_normal_init+0x1a>
     f62:	c2 30       	cpi	r28, 0x02	; 2
     f64:	21 f4       	brne	.+8      	; 0xf6e <Timer_normal_init+0x22>
     f66:	0f 3f       	cpi	r16, 0xFF	; 255
     f68:	11 05       	cpc	r17, r1
     f6a:	09 f0       	breq	.+2      	; 0xf6e <Timer_normal_init+0x22>
     f6c:	50 f5       	brcc	.+84     	; 0xfc2 <Timer_normal_init+0x76>
     f6e:	c1 30       	cpi	r28, 0x01	; 1
     f70:	69 f0       	breq	.+26     	; 0xf8c <Timer_normal_init+0x40>
     f72:	18 f0       	brcs	.+6      	; 0xf7a <Timer_normal_init+0x2e>
     f74:	c2 30       	cpi	r28, 0x02	; 2
     f76:	d1 f0       	breq	.+52     	; 0xfac <Timer_normal_init+0x60>
     f78:	26 c0       	rjmp	.+76     	; 0xfc6 <Timer_normal_init+0x7a>
     f7a:	83 b7       	in	r24, 0x33	; 51
     f7c:	87 7f       	andi	r24, 0xF7	; 247
     f7e:	83 bf       	out	0x33, r24	; 51
     f80:	83 b7       	in	r24, 0x33	; 51
     f82:	8f 7b       	andi	r24, 0xBF	; 191
     f84:	83 bf       	out	0x33, r24	; 51
     f86:	02 bf       	out	0x32, r16	; 50
     f88:	80 e0       	ldi	r24, 0x00	; 0
     f8a:	1e c0       	rjmp	.+60     	; 0xfc8 <Timer_normal_init+0x7c>
     f8c:	8f b5       	in	r24, 0x2f	; 47
     f8e:	8e 7f       	andi	r24, 0xFE	; 254
     f90:	8f bd       	out	0x2f, r24	; 47
     f92:	8f b5       	in	r24, 0x2f	; 47
     f94:	8d 7f       	andi	r24, 0xFD	; 253
     f96:	8f bd       	out	0x2f, r24	; 47
     f98:	8e b5       	in	r24, 0x2e	; 46
     f9a:	87 7f       	andi	r24, 0xF7	; 247
     f9c:	8e bd       	out	0x2e, r24	; 46
     f9e:	8e b5       	in	r24, 0x2e	; 46
     fa0:	8f 7e       	andi	r24, 0xEF	; 239
     fa2:	8e bd       	out	0x2e, r24	; 46
     fa4:	1d bd       	out	0x2d, r17	; 45
     fa6:	0c bd       	out	0x2c, r16	; 44
     fa8:	80 e0       	ldi	r24, 0x00	; 0
     faa:	0e c0       	rjmp	.+28     	; 0xfc8 <Timer_normal_init+0x7c>
     fac:	85 b5       	in	r24, 0x25	; 37
     fae:	87 7f       	andi	r24, 0xF7	; 247
     fb0:	85 bd       	out	0x25, r24	; 37
     fb2:	85 b5       	in	r24, 0x25	; 37
     fb4:	8f 7b       	andi	r24, 0xBF	; 191
     fb6:	85 bd       	out	0x25, r24	; 37
     fb8:	04 bd       	out	0x24, r16	; 36
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	05 c0       	rjmp	.+10     	; 0xfc8 <Timer_normal_init+0x7c>
     fbe:	81 e0       	ldi	r24, 0x01	; 1
     fc0:	03 c0       	rjmp	.+6      	; 0xfc8 <Timer_normal_init+0x7c>
     fc2:	83 e0       	ldi	r24, 0x03	; 3
     fc4:	01 c0       	rjmp	.+2      	; 0xfc8 <Timer_normal_init+0x7c>
     fc6:	80 e0       	ldi	r24, 0x00	; 0
     fc8:	cf 91       	pop	r28
     fca:	1f 91       	pop	r17
     fcc:	0f 91       	pop	r16
     fce:	08 95       	ret

00000fd0 <Timer_start>:
     fd0:	0f 93       	push	r16
     fd2:	1f 93       	push	r17
     fd4:	cf 93       	push	r28
     fd6:	c8 2f       	mov	r28, r24
     fd8:	8b 01       	movw	r16, r22
     fda:	0e 94 19 06 	call	0xc32	; 0xc32 <isValidTimer>
     fde:	88 23       	and	r24, r24
     fe0:	31 f0       	breq	.+12     	; 0xfee <Timer_start+0x1e>
     fe2:	b8 01       	movw	r22, r16
     fe4:	8c 2f       	mov	r24, r28
     fe6:	0e 94 1f 06 	call	0xc3e	; 0xc3e <set_prescalar>
     fea:	80 e0       	ldi	r24, 0x00	; 0
     fec:	01 c0       	rjmp	.+2      	; 0xff0 <Timer_start+0x20>
     fee:	81 e0       	ldi	r24, 0x01	; 1
     ff0:	cf 91       	pop	r28
     ff2:	1f 91       	pop	r17
     ff4:	0f 91       	pop	r16
     ff6:	08 95       	ret

00000ff8 <PWM_OCP_disconnect>:

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
     ff8:	84 30       	cpi	r24, 0x04	; 4
     ffa:	40 f5       	brcc	.+80     	; 0x104c <PWM_OCP_disconnect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
     ffc:	81 30       	cpi	r24, 0x01	; 1
     ffe:	71 f0       	breq	.+28     	; 0x101c <PWM_OCP_disconnect+0x24>
    1000:	28 f0       	brcs	.+10     	; 0x100c <PWM_OCP_disconnect+0x14>
    1002:	82 30       	cpi	r24, 0x02	; 2
    1004:	99 f0       	breq	.+38     	; 0x102c <PWM_OCP_disconnect+0x34>
    1006:	83 30       	cpi	r24, 0x03	; 3
    1008:	c9 f0       	breq	.+50     	; 0x103c <PWM_OCP_disconnect+0x44>
    100a:	22 c0       	rjmp	.+68     	; 0x1050 <PWM_OCP_disconnect+0x58>
      case OC_0:
        clear_bit(TCCR0, COM00);
    100c:	83 b7       	in	r24, 0x33	; 51
    100e:	8f 7e       	andi	r24, 0xEF	; 239
    1010:	83 bf       	out	0x33, r24	; 51
        clear_bit(TCCR0, COM01);
    1012:	83 b7       	in	r24, 0x33	; 51
    1014:	8f 7d       	andi	r24, 0xDF	; 223
    1016:	83 bf       	out	0x33, r24	; 51
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1018:	80 e0       	ldi	r24, 0x00	; 0
    }
  switch (pwmPin) {
      case OC_0:
        clear_bit(TCCR0, COM00);
        clear_bit(TCCR0, COM01);
        break;
    101a:	08 95       	ret
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
    101c:	8f b5       	in	r24, 0x2f	; 47
    101e:	8f 7b       	andi	r24, 0xBF	; 191
    1020:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1A1);
    1022:	8f b5       	in	r24, 0x2f	; 47
    1024:	8f 77       	andi	r24, 0x7F	; 127
    1026:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1028:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR0, COM01);
        break;
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
        clear_bit(TCCR1A, COM1A1);
        break;
    102a:	08 95       	ret
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
    102c:	8f b5       	in	r24, 0x2f	; 47
    102e:	8f 7e       	andi	r24, 0xEF	; 239
    1030:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1B1);
    1032:	8f b5       	in	r24, 0x2f	; 47
    1034:	8f 7d       	andi	r24, 0xDF	; 223
    1036:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1038:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1A1);
        break;
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
        clear_bit(TCCR1A, COM1B1);
        break;
    103a:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
    103c:	85 b5       	in	r24, 0x25	; 37
    103e:	8f 7e       	andi	r24, 0xEF	; 239
    1040:	85 bd       	out	0x25, r24	; 37
        clear_bit(TCCR2, COM21);
    1042:	85 b5       	in	r24, 0x25	; 37
    1044:	8f 7d       	andi	r24, 0xDF	; 223
    1046:	85 bd       	out	0x25, r24	; 37
        break;
    }
  return TIMER_OK;
    1048:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1B1);
        break;
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    104a:	08 95       	ret
  }

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    104c:	87 e0       	ldi	r24, 0x07	; 7
    104e:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1050:	80 e0       	ldi	r24, 0x00	; 0
  }
    1052:	08 95       	ret

00001054 <PWM_OCP_connect>:

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    1054:	84 30       	cpi	r24, 0x04	; 4
    1056:	40 f5       	brcc	.+80     	; 0x10a8 <PWM_OCP_connect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    1058:	81 30       	cpi	r24, 0x01	; 1
    105a:	71 f0       	breq	.+28     	; 0x1078 <PWM_OCP_connect+0x24>
    105c:	28 f0       	brcs	.+10     	; 0x1068 <PWM_OCP_connect+0x14>
    105e:	82 30       	cpi	r24, 0x02	; 2
    1060:	99 f0       	breq	.+38     	; 0x1088 <PWM_OCP_connect+0x34>
    1062:	83 30       	cpi	r24, 0x03	; 3
    1064:	c9 f0       	breq	.+50     	; 0x1098 <PWM_OCP_connect+0x44>
    1066:	22 c0       	rjmp	.+68     	; 0x10ac <PWM_OCP_connect+0x58>
      case OC_0:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR0, COM00);
    1068:	83 b7       	in	r24, 0x33	; 51
    106a:	8f 7e       	andi	r24, 0xEF	; 239
    106c:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR0, COM01);
    106e:	83 b7       	in	r24, 0x33	; 51
    1070:	80 62       	ori	r24, 0x20	; 32
    1072:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    1074:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR0, COM01);
#else 
        set_bit(TCCR0, COM00);
        set_bit(TCCR0, COM01);
#endif
        break;
    1076:	08 95       	ret
      case OC_1A:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1A0);
    1078:	8f b5       	in	r24, 0x2f	; 47
    107a:	8f 7b       	andi	r24, 0xBF	; 191
    107c:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1A1);
    107e:	8f b5       	in	r24, 0x2f	; 47
    1080:	80 68       	ori	r24, 0x80	; 128
    1082:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    1084:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1A1);
#else 
        set_bit(TCCR1A, COM1A0);
        set_bit(TCCR1A, COM1A1);
#endif
        break;
    1086:	08 95       	ret
      case OC_1B:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1B0);
    1088:	8f b5       	in	r24, 0x2f	; 47
    108a:	8f 7e       	andi	r24, 0xEF	; 239
    108c:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1B1);
    108e:	8f b5       	in	r24, 0x2f	; 47
    1090:	80 62       	ori	r24, 0x20	; 32
    1092:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    1094:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1B1);
#else 
        set_bit(TCCR1A, COM1B0);
        set_bit(TCCR1A, COM1B1);
#endif
        break;
    1096:	08 95       	ret
      case OC_2:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR2, COM20);
    1098:	85 b5       	in	r24, 0x25	; 37
    109a:	8f 7e       	andi	r24, 0xEF	; 239
    109c:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM21);
    109e:	85 b5       	in	r24, 0x25	; 37
    10a0:	80 62       	ori	r24, 0x20	; 32
    10a2:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    10a4:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR2, COM21);
#else 
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    10a6:	08 95       	ret
  }

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    10a8:	87 e0       	ldi	r24, 0x07	; 7
    10aa:	08 95       	ret
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    10ac:	80 e0       	ldi	r24, 0x00	; 0
  }
    10ae:	08 95       	ret

000010b0 <PWM_init>:
  return TIMER_OK;
  }

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
    10b0:	cf 92       	push	r12
    10b2:	df 92       	push	r13
    10b4:	ef 92       	push	r14
    10b6:	ff 92       	push	r15
    10b8:	cf 93       	push	r28
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    10ba:	84 30       	cpi	r24, 0x04	; 4
    10bc:	08 f0       	brcs	.+2      	; 0x10c0 <PWM_init+0x10>
    10be:	96 c0       	rjmp	.+300    	; 0x11ec <PWM_init+0x13c>
    return WRONG_PWM_PIN;
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    10c0:	9f ef       	ldi	r25, 0xFF	; 255
    10c2:	92 0f       	add	r25, r18
    10c4:	92 30       	cpi	r25, 0x02	; 2
    10c6:	08 f0       	brcs	.+2      	; 0x10ca <PWM_init+0x1a>
    10c8:	93 c0       	rjmp	.+294    	; 0x11f0 <PWM_init+0x140>
    10ca:	6a 01       	movw	r12, r20
    10cc:	7b 01       	movw	r14, r22
    10ce:	c8 2f       	mov	r28, r24
    return WRONG_PWM_MODE;
    }
  switch (pwmPin) {
    10d0:	83 30       	cpi	r24, 0x03	; 3
    10d2:	18 f4       	brcc	.+6      	; 0x10da <PWM_init+0x2a>
    10d4:	81 30       	cpi	r24, 0x01	; 1
    10d6:	28 f0       	brcs	.+10     	; 0x10e2 <PWM_init+0x32>
    10d8:	22 c0       	rjmp	.+68     	; 0x111e <PWM_init+0x6e>
    10da:	83 30       	cpi	r24, 0x03	; 3
    10dc:	09 f4       	brne	.+2      	; 0x10e0 <PWM_init+0x30>
    10de:	64 c0       	rjmp	.+200    	; 0x11a8 <PWM_init+0xf8>
    10e0:	80 c0       	rjmp	.+256    	; 0x11e2 <PWM_init+0x132>
      case OC_0:
        switch (mode) {
    10e2:	21 30       	cpi	r18, 0x01	; 1
    10e4:	19 f0       	breq	.+6      	; 0x10ec <PWM_init+0x3c>
    10e6:	22 30       	cpi	r18, 0x02	; 2
    10e8:	41 f0       	breq	.+16     	; 0x10fa <PWM_init+0x4a>
    10ea:	0d c0       	rjmp	.+26     	; 0x1106 <PWM_init+0x56>
            case PWM_FAST:
              set_bit(TCCR0, WGM00);
    10ec:	83 b7       	in	r24, 0x33	; 51
    10ee:	80 64       	ori	r24, 0x40	; 64
    10f0:	83 bf       	out	0x33, r24	; 51
              set_bit(TCCR0, WGM01);
    10f2:	83 b7       	in	r24, 0x33	; 51
    10f4:	88 60       	ori	r24, 0x08	; 8
    10f6:	83 bf       	out	0x33, r24	; 51
              break;
    10f8:	06 c0       	rjmp	.+12     	; 0x1106 <PWM_init+0x56>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR0, WGM00);
    10fa:	83 b7       	in	r24, 0x33	; 51
    10fc:	80 64       	ori	r24, 0x40	; 64
    10fe:	83 bf       	out	0x33, r24	; 51
              clear_bit(TCCR0, WGM01);
    1100:	83 b7       	in	r24, 0x33	; 51
    1102:	87 7f       	andi	r24, 0xF7	; 247
    1104:	83 bf       	out	0x33, r24	; 51
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR0 = (u8)(dutyCycle * 255);
    1106:	20 e0       	ldi	r18, 0x00	; 0
    1108:	30 e0       	ldi	r19, 0x00	; 0
    110a:	4f e7       	ldi	r20, 0x7F	; 127
    110c:	53 e4       	ldi	r21, 0x43	; 67
    110e:	c7 01       	movw	r24, r14
    1110:	b6 01       	movw	r22, r12
    1112:	0e 94 2c 13 	call	0x2658	; 0x2658 <__mulsf3>
    1116:	0e 94 6f 12 	call	0x24de	; 0x24de <__fixunssfsi>
    111a:	6c bf       	out	0x3c, r22	; 60
        break;
    111c:	62 c0       	rjmp	.+196    	; 0x11e2 <PWM_init+0x132>
        //? The fix for this issue is to use ICR1 as TOP instead (mode 14 in fast pwm), thus allowing OCR1A and OCR1B to be used to set the duty cycle while ICR1 is used tyo set the frequency.
        //? Mode 15 can be used at the cost of disabling PWM on OC1A, but we get more glitch-free variable frequency PWM signal on OC1B due to the double buffering of OC1A, which ICR1 doesn't have.
        //? Since I don't need a variable frequency pwm signal, ICR1 will be used as TOP by default and set to MAX.
      case OC_1A:
      case OC_1B:
        switch (mode) {
    111e:	21 30       	cpi	r18, 0x01	; 1
    1120:	19 f0       	breq	.+6      	; 0x1128 <PWM_init+0x78>
    1122:	22 30       	cpi	r18, 0x02	; 2
    1124:	91 f0       	breq	.+36     	; 0x114a <PWM_init+0x9a>
    1126:	21 c0       	rjmp	.+66     	; 0x116a <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
    1128:	8f b5       	in	r24, 0x2f	; 47
    112a:	8e 7f       	andi	r24, 0xFE	; 254
    112c:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
    112e:	8f b5       	in	r24, 0x2f	; 47
    1130:	82 60       	ori	r24, 0x02	; 2
    1132:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1B, WGM12);
    1134:	8e b5       	in	r24, 0x2e	; 46
    1136:	88 60       	ori	r24, 0x08	; 8
    1138:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
    113a:	8e b5       	in	r24, 0x2e	; 46
    113c:	80 61       	ori	r24, 0x10	; 16
    113e:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
    1140:	80 e2       	ldi	r24, 0x20	; 32
    1142:	9e e4       	ldi	r25, 0x4E	; 78
    1144:	97 bd       	out	0x27, r25	; 39
    1146:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              set_bit(TCCR1B, WGM13);
#endif
              break;
    1148:	10 c0       	rjmp	.+32     	; 0x116a <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              clear_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
    114a:	8f b5       	in	r24, 0x2f	; 47
    114c:	8e 7f       	andi	r24, 0xFE	; 254
    114e:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
    1150:	8f b5       	in	r24, 0x2f	; 47
    1152:	82 60       	ori	r24, 0x02	; 2
    1154:	8f bd       	out	0x2f, r24	; 47
              clear_bit(TCCR1B, WGM12);
    1156:	8e b5       	in	r24, 0x2e	; 46
    1158:	87 7f       	andi	r24, 0xF7	; 247
    115a:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
    115c:	8e b5       	in	r24, 0x2e	; 46
    115e:	80 61       	ori	r24, 0x10	; 16
    1160:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
    1162:	80 e2       	ldi	r24, 0x20	; 32
    1164:	9e e4       	ldi	r25, 0x4E	; 78
    1166:	97 bd       	out	0x27, r25	; 39
    1168:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1B, WGM13);
#endif
              break;
          }
        // Enable the PWM function of the OC pin.
        switch (pwmPin) {
    116a:	c1 30       	cpi	r28, 0x01	; 1
    116c:	19 f0       	breq	.+6      	; 0x1174 <PWM_init+0xc4>
    116e:	c2 30       	cpi	r28, 0x02	; 2
    1170:	71 f0       	breq	.+28     	; 0x118e <PWM_init+0xde>
    1172:	37 c0       	rjmp	.+110    	; 0x11e2 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    1174:	20 e0       	ldi	r18, 0x00	; 0
    1176:	30 e4       	ldi	r19, 0x40	; 64
    1178:	4c e9       	ldi	r20, 0x9C	; 156
    117a:	56 e4       	ldi	r21, 0x46	; 70
    117c:	c7 01       	movw	r24, r14
    117e:	b6 01       	movw	r22, r12
    1180:	0e 94 2c 13 	call	0x2658	; 0x2658 <__mulsf3>
    1184:	0e 94 6f 12 	call	0x24de	; 0x24de <__fixunssfsi>
    1188:	7b bd       	out	0x2b, r23	; 43
    118a:	6a bd       	out	0x2a, r22	; 42
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1A = (u16)(dutyCycle * 65535);
#endif
              break;
    118c:	2a c0       	rjmp	.+84     	; 0x11e2 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    118e:	20 e0       	ldi	r18, 0x00	; 0
    1190:	30 e4       	ldi	r19, 0x40	; 64
    1192:	4c e9       	ldi	r20, 0x9C	; 156
    1194:	56 e4       	ldi	r21, 0x46	; 70
    1196:	c7 01       	movw	r24, r14
    1198:	b6 01       	movw	r22, r12
    119a:	0e 94 2c 13 	call	0x2658	; 0x2658 <__mulsf3>
    119e:	0e 94 6f 12 	call	0x24de	; 0x24de <__fixunssfsi>
    11a2:	79 bd       	out	0x29, r23	; 41
    11a4:	68 bd       	out	0x28, r22	; 40
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1B = (u16)(dutyCycle * 65535);
#endif
              break;
    11a6:	1d c0       	rjmp	.+58     	; 0x11e2 <PWM_init+0x132>
          }
        break;
      case OC_2:
        switch (mode) {
    11a8:	21 30       	cpi	r18, 0x01	; 1
    11aa:	19 f0       	breq	.+6      	; 0x11b2 <PWM_init+0x102>
    11ac:	22 30       	cpi	r18, 0x02	; 2
    11ae:	41 f0       	breq	.+16     	; 0x11c0 <PWM_init+0x110>
    11b0:	0d c0       	rjmp	.+26     	; 0x11cc <PWM_init+0x11c>
            case PWM_FAST:
              set_bit(TCCR2, WGM20);
    11b2:	85 b5       	in	r24, 0x25	; 37
    11b4:	80 64       	ori	r24, 0x40	; 64
    11b6:	85 bd       	out	0x25, r24	; 37
              set_bit(TCCR2, WGM21);
    11b8:	85 b5       	in	r24, 0x25	; 37
    11ba:	88 60       	ori	r24, 0x08	; 8
    11bc:	85 bd       	out	0x25, r24	; 37
              break;
    11be:	06 c0       	rjmp	.+12     	; 0x11cc <PWM_init+0x11c>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR2, WGM20);
    11c0:	85 b5       	in	r24, 0x25	; 37
    11c2:	80 64       	ori	r24, 0x40	; 64
    11c4:	85 bd       	out	0x25, r24	; 37
              clear_bit(TCCR2, WGM21);
    11c6:	85 b5       	in	r24, 0x25	; 37
    11c8:	87 7f       	andi	r24, 0xF7	; 247
    11ca:	85 bd       	out	0x25, r24	; 37
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR2 = (u8)(dutyCycle * 255);
    11cc:	20 e0       	ldi	r18, 0x00	; 0
    11ce:	30 e0       	ldi	r19, 0x00	; 0
    11d0:	4f e7       	ldi	r20, 0x7F	; 127
    11d2:	53 e4       	ldi	r21, 0x43	; 67
    11d4:	c7 01       	movw	r24, r14
    11d6:	b6 01       	movw	r22, r12
    11d8:	0e 94 2c 13 	call	0x2658	; 0x2658 <__mulsf3>
    11dc:	0e 94 6f 12 	call	0x24de	; 0x24de <__fixunssfsi>
    11e0:	63 bd       	out	0x23, r22	; 35
        break;
    }
  PWM_OCP_connect(pwmPin);
    11e2:	8c 2f       	mov	r24, r28
    11e4:	0e 94 2a 08 	call	0x1054	; 0x1054 <PWM_OCP_connect>
  return TIMER_OK;
    11e8:	80 e0       	ldi	r24, 0x00	; 0
    11ea:	03 c0       	rjmp	.+6      	; 0x11f2 <PWM_init+0x142>

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    11ec:	87 e0       	ldi	r24, 0x07	; 7
    11ee:	01 c0       	rjmp	.+2      	; 0x11f2 <PWM_init+0x142>
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    return WRONG_PWM_MODE;
    11f0:	86 e0       	ldi	r24, 0x06	; 6
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  PWM_OCP_connect(pwmPin);
  return TIMER_OK;
  }
    11f2:	cf 91       	pop	r28
    11f4:	ff 90       	pop	r15
    11f6:	ef 90       	pop	r14
    11f8:	df 90       	pop	r13
    11fa:	cf 90       	pop	r12
    11fc:	08 95       	ret

000011fe <PWM_set_DC>:
    }
  return TIMER_OK;
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
    11fe:	28 2f       	mov	r18, r24
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    1200:	84 30       	cpi	r24, 0x04	; 4
    1202:	c0 f5       	brcc	.+112    	; 0x1274 <PWM_set_DC+0x76>
    1204:	cb 01       	movw	r24, r22
    1206:	ba 01       	movw	r22, r20
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    1208:	21 30       	cpi	r18, 0x01	; 1
    120a:	89 f0       	breq	.+34     	; 0x122e <PWM_set_DC+0x30>
    120c:	28 f0       	brcs	.+10     	; 0x1218 <PWM_set_DC+0x1a>
    120e:	22 30       	cpi	r18, 0x02	; 2
    1210:	d1 f0       	breq	.+52     	; 0x1246 <PWM_set_DC+0x48>
    1212:	23 30       	cpi	r18, 0x03	; 3
    1214:	21 f1       	breq	.+72     	; 0x125e <PWM_set_DC+0x60>
    1216:	30 c0       	rjmp	.+96     	; 0x1278 <PWM_set_DC+0x7a>
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
    1218:	20 e0       	ldi	r18, 0x00	; 0
    121a:	30 e0       	ldi	r19, 0x00	; 0
    121c:	4f e7       	ldi	r20, 0x7F	; 127
    121e:	53 e4       	ldi	r21, 0x43	; 67
    1220:	0e 94 2c 13 	call	0x2658	; 0x2658 <__mulsf3>
    1224:	0e 94 6f 12 	call	0x24de	; 0x24de <__fixunssfsi>
    1228:	6c bf       	out	0x3c, r22	; 60
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    122a:	80 e0       	ldi	r24, 0x00	; 0
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
        break;
    122c:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    122e:	20 e0       	ldi	r18, 0x00	; 0
    1230:	30 e4       	ldi	r19, 0x40	; 64
    1232:	4c e9       	ldi	r20, 0x9C	; 156
    1234:	56 e4       	ldi	r21, 0x46	; 70
    1236:	0e 94 2c 13 	call	0x2658	; 0x2658 <__mulsf3>
    123a:	0e 94 6f 12 	call	0x24de	; 0x24de <__fixunssfsi>
    123e:	7b bd       	out	0x2b, r23	; 43
    1240:	6a bd       	out	0x2a, r22	; 42
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    1242:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1A = (u16)(dutyCycle * 65535);
#endif
        break;
    1244:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    1246:	20 e0       	ldi	r18, 0x00	; 0
    1248:	30 e4       	ldi	r19, 0x40	; 64
    124a:	4c e9       	ldi	r20, 0x9C	; 156
    124c:	56 e4       	ldi	r21, 0x46	; 70
    124e:	0e 94 2c 13 	call	0x2658	; 0x2658 <__mulsf3>
    1252:	0e 94 6f 12 	call	0x24de	; 0x24de <__fixunssfsi>
    1256:	79 bd       	out	0x29, r23	; 41
    1258:	68 bd       	out	0x28, r22	; 40
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    125a:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
    125c:	08 95       	ret
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
    125e:	20 e0       	ldi	r18, 0x00	; 0
    1260:	30 e0       	ldi	r19, 0x00	; 0
    1262:	4f e7       	ldi	r20, 0x7F	; 127
    1264:	53 e4       	ldi	r21, 0x43	; 67
    1266:	0e 94 2c 13 	call	0x2658	; 0x2658 <__mulsf3>
    126a:	0e 94 6f 12 	call	0x24de	; 0x24de <__fixunssfsi>
    126e:	63 bd       	out	0x23, r22	; 35
        break;
    }
  return TIMER_OK;
    1270:	80 e0       	ldi	r24, 0x00	; 0
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    1272:	08 95       	ret
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    1274:	87 e0       	ldi	r24, 0x07	; 7
    1276:	08 95       	ret
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    1278:	80 e0       	ldi	r24, 0x00	; 0
  }
    127a:	08 95       	ret

0000127c <UART_init>:
  }

// Receive a Char using UART
void UART_receiveChar(s8* x) {
  while (!read_bit(UCSRA, RXC)); // Wait for the data to be received.
  *x = UDR;
    127c:	61 15       	cp	r22, r1
    127e:	26 e9       	ldi	r18, 0x96	; 150
    1280:	72 07       	cpc	r23, r18
    1282:	81 05       	cpc	r24, r1
    1284:	91 05       	cpc	r25, r1
    1286:	09 f4       	brne	.+2      	; 0x128a <UART_init+0xe>
    1288:	72 c0       	rjmp	.+228    	; 0x136e <UART_init+0xf2>
    128a:	58 f5       	brcc	.+86     	; 0x12e2 <UART_init+0x66>
    128c:	60 38       	cpi	r22, 0x80	; 128
    128e:	25 e2       	ldi	r18, 0x25	; 37
    1290:	72 07       	cpc	r23, r18
    1292:	81 05       	cpc	r24, r1
    1294:	91 05       	cpc	r25, r1
    1296:	09 f4       	brne	.+2      	; 0x129a <UART_init+0x1e>
    1298:	5e c0       	rjmp	.+188    	; 0x1356 <UART_init+0xda>
    129a:	70 f4       	brcc	.+28     	; 0x12b8 <UART_init+0x3c>
    129c:	60 36       	cpi	r22, 0x60	; 96
    129e:	29 e0       	ldi	r18, 0x09	; 9
    12a0:	72 07       	cpc	r23, r18
    12a2:	81 05       	cpc	r24, r1
    12a4:	91 05       	cpc	r25, r1
    12a6:	09 f4       	brne	.+2      	; 0x12aa <UART_init+0x2e>
    12a8:	4e c0       	rjmp	.+156    	; 0x1346 <UART_init+0xca>
    12aa:	60 3c       	cpi	r22, 0xC0	; 192
    12ac:	72 41       	sbci	r23, 0x12	; 18
    12ae:	81 05       	cpc	r24, r1
    12b0:	91 05       	cpc	r25, r1
    12b2:	09 f4       	brne	.+2      	; 0x12b6 <UART_init+0x3a>
    12b4:	4d c0       	rjmp	.+154    	; 0x1350 <UART_init+0xd4>
    12b6:	82 c0       	rjmp	.+260    	; 0x13bc <UART_init+0x140>
    12b8:	61 15       	cp	r22, r1
    12ba:	2b e4       	ldi	r18, 0x4B	; 75
    12bc:	72 07       	cpc	r23, r18
    12be:	81 05       	cpc	r24, r1
    12c0:	91 05       	cpc	r25, r1
    12c2:	09 f4       	brne	.+2      	; 0x12c6 <UART_init+0x4a>
    12c4:	4e c0       	rjmp	.+156    	; 0x1362 <UART_init+0xe6>
    12c6:	60 38       	cpi	r22, 0x80	; 128
    12c8:	20 e7       	ldi	r18, 0x70	; 112
    12ca:	72 07       	cpc	r23, r18
    12cc:	81 05       	cpc	r24, r1
    12ce:	91 05       	cpc	r25, r1
    12d0:	09 f4       	brne	.+2      	; 0x12d4 <UART_init+0x58>
    12d2:	4a c0       	rjmp	.+148    	; 0x1368 <UART_init+0xec>
    12d4:	60 34       	cpi	r22, 0x40	; 64
    12d6:	78 43       	sbci	r23, 0x38	; 56
    12d8:	81 05       	cpc	r24, r1
    12da:	91 05       	cpc	r25, r1
    12dc:	09 f0       	breq	.+2      	; 0x12e0 <UART_init+0x64>
    12de:	6e c0       	rjmp	.+220    	; 0x13bc <UART_init+0x140>
    12e0:	3d c0       	rjmp	.+122    	; 0x135c <UART_init+0xe0>
    12e2:	61 15       	cp	r22, r1
    12e4:	24 e8       	ldi	r18, 0x84	; 132
    12e6:	72 07       	cpc	r23, r18
    12e8:	23 e0       	ldi	r18, 0x03	; 3
    12ea:	82 07       	cpc	r24, r18
    12ec:	91 05       	cpc	r25, r1
    12ee:	09 f4       	brne	.+2      	; 0x12f2 <UART_init+0x76>
    12f0:	4a c0       	rjmp	.+148    	; 0x1386 <UART_init+0x10a>
    12f2:	a8 f4       	brcc	.+42     	; 0x131e <UART_init+0xa2>
    12f4:	61 15       	cp	r22, r1
    12f6:	2c e2       	ldi	r18, 0x2C	; 44
    12f8:	72 07       	cpc	r23, r18
    12fa:	21 e0       	ldi	r18, 0x01	; 1
    12fc:	82 07       	cpc	r24, r18
    12fe:	91 05       	cpc	r25, r1
    1300:	e1 f1       	breq	.+120    	; 0x137a <UART_init+0xfe>
    1302:	61 15       	cp	r22, r1
    1304:	22 ec       	ldi	r18, 0xC2	; 194
    1306:	72 07       	cpc	r23, r18
    1308:	21 e0       	ldi	r18, 0x01	; 1
    130a:	82 07       	cpc	r24, r18
    130c:	91 05       	cpc	r25, r1
    130e:	c1 f1       	breq	.+112    	; 0x1380 <UART_init+0x104>
    1310:	61 15       	cp	r22, r1
    1312:	71 4e       	sbci	r23, 0xE1	; 225
    1314:	81 05       	cpc	r24, r1
    1316:	91 05       	cpc	r25, r1
    1318:	09 f0       	breq	.+2      	; 0x131c <UART_init+0xa0>
    131a:	50 c0       	rjmp	.+160    	; 0x13bc <UART_init+0x140>
    131c:	2b c0       	rjmp	.+86     	; 0x1374 <UART_init+0xf8>
    131e:	60 32       	cpi	r22, 0x20	; 32
    1320:	21 ea       	ldi	r18, 0xA1	; 161
    1322:	72 07       	cpc	r23, r18
    1324:	27 e0       	ldi	r18, 0x07	; 7
    1326:	82 07       	cpc	r24, r18
    1328:	91 05       	cpc	r25, r1
    132a:	99 f1       	breq	.+102    	; 0x1392 <UART_init+0x116>
    132c:	60 34       	cpi	r22, 0x40	; 64
    132e:	22 e4       	ldi	r18, 0x42	; 66
    1330:	72 07       	cpc	r23, r18
    1332:	2f e0       	ldi	r18, 0x0F	; 15
    1334:	82 07       	cpc	r24, r18
    1336:	91 05       	cpc	r25, r1
    1338:	79 f1       	breq	.+94     	; 0x1398 <UART_init+0x11c>
    133a:	60 39       	cpi	r22, 0x90	; 144
    133c:	70 4d       	sbci	r23, 0xD0	; 208
    133e:	83 40       	sbci	r24, 0x03	; 3
    1340:	91 05       	cpc	r25, r1
    1342:	e1 f5       	brne	.+120    	; 0x13bc <UART_init+0x140>
    1344:	23 c0       	rjmp	.+70     	; 0x138c <UART_init+0x110>
    1346:	81 e0       	ldi	r24, 0x01	; 1
    1348:	80 bd       	out	0x20, r24	; 32
    134a:	80 ea       	ldi	r24, 0xA0	; 160
    134c:	89 b9       	out	0x09, r24	; 9
    134e:	25 c0       	rjmp	.+74     	; 0x139a <UART_init+0x11e>
    1350:	8f ec       	ldi	r24, 0xCF	; 207
    1352:	89 b9       	out	0x09, r24	; 9
    1354:	22 c0       	rjmp	.+68     	; 0x139a <UART_init+0x11e>
    1356:	87 e6       	ldi	r24, 0x67	; 103
    1358:	89 b9       	out	0x09, r24	; 9
    135a:	1f c0       	rjmp	.+62     	; 0x139a <UART_init+0x11e>
    135c:	84 e4       	ldi	r24, 0x44	; 68
    135e:	89 b9       	out	0x09, r24	; 9
    1360:	1c c0       	rjmp	.+56     	; 0x139a <UART_init+0x11e>
    1362:	83 e3       	ldi	r24, 0x33	; 51
    1364:	89 b9       	out	0x09, r24	; 9
    1366:	19 c0       	rjmp	.+50     	; 0x139a <UART_init+0x11e>
    1368:	82 e2       	ldi	r24, 0x22	; 34
    136a:	89 b9       	out	0x09, r24	; 9
    136c:	16 c0       	rjmp	.+44     	; 0x139a <UART_init+0x11e>
    136e:	89 e1       	ldi	r24, 0x19	; 25
    1370:	89 b9       	out	0x09, r24	; 9
    1372:	13 c0       	rjmp	.+38     	; 0x139a <UART_init+0x11e>
    1374:	80 e1       	ldi	r24, 0x10	; 16
    1376:	89 b9       	out	0x09, r24	; 9
    1378:	10 c0       	rjmp	.+32     	; 0x139a <UART_init+0x11e>
    137a:	8c e0       	ldi	r24, 0x0C	; 12
    137c:	89 b9       	out	0x09, r24	; 9
    137e:	0d c0       	rjmp	.+26     	; 0x139a <UART_init+0x11e>
    1380:	88 e0       	ldi	r24, 0x08	; 8
    1382:	89 b9       	out	0x09, r24	; 9
    1384:	0a c0       	rjmp	.+20     	; 0x139a <UART_init+0x11e>
    1386:	83 e0       	ldi	r24, 0x03	; 3
    1388:	89 b9       	out	0x09, r24	; 9
    138a:	07 c0       	rjmp	.+14     	; 0x139a <UART_init+0x11e>
    138c:	83 e0       	ldi	r24, 0x03	; 3
    138e:	89 b9       	out	0x09, r24	; 9
    1390:	04 c0       	rjmp	.+8      	; 0x139a <UART_init+0x11e>
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	89 b9       	out	0x09, r24	; 9
    1396:	01 c0       	rjmp	.+2      	; 0x139a <UART_init+0x11e>
    1398:	19 b8       	out	0x09, r1	; 9
    139a:	8a b1       	in	r24, 0x0a	; 10
    139c:	88 60       	ori	r24, 0x08	; 8
    139e:	8a b9       	out	0x0a, r24	; 10
    13a0:	8a b1       	in	r24, 0x0a	; 10
    13a2:	80 61       	ori	r24, 0x10	; 16
    13a4:	8a b9       	out	0x0a, r24	; 10
    13a6:	80 b5       	in	r24, 0x20	; 32
    13a8:	80 68       	ori	r24, 0x80	; 128
    13aa:	80 bd       	out	0x20, r24	; 32
    13ac:	80 b5       	in	r24, 0x20	; 32
    13ae:	82 60       	ori	r24, 0x02	; 2
    13b0:	80 bd       	out	0x20, r24	; 32
    13b2:	80 b5       	in	r24, 0x20	; 32
    13b4:	84 60       	ori	r24, 0x04	; 4
    13b6:	80 bd       	out	0x20, r24	; 32
    13b8:	80 e0       	ldi	r24, 0x00	; 0
    13ba:	08 95       	ret
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	08 95       	ret

000013c0 <UART_sendChar>:
    13c0:	5d 9b       	sbis	0x0b, 5	; 11
    13c2:	fe cf       	rjmp	.-4      	; 0x13c0 <UART_sendChar>
    13c4:	8c b9       	out	0x0c, r24	; 12
    13c6:	5e 9b       	sbis	0x0b, 6	; 11
    13c8:	fe cf       	rjmp	.-4      	; 0x13c6 <UART_sendChar+0x6>
    13ca:	08 95       	ret

000013cc <UART_sendString>:
  }

void UART_sendString(s8* str) {
    13cc:	cf 92       	push	r12
    13ce:	df 92       	push	r13
    13d0:	ef 92       	push	r14
    13d2:	ff 92       	push	r15
    13d4:	cf 93       	push	r28
    13d6:	df 93       	push	r29
    13d8:	ec 01       	movw	r28, r24
  u32 i = 0;
    13da:	c1 2c       	mov	r12, r1
    13dc:	d1 2c       	mov	r13, r1
    13de:	76 01       	movw	r14, r12
  while (str[i] != 0) {
    13e0:	07 c0       	rjmp	.+14     	; 0x13f0 <UART_sendString+0x24>
    UART_sendChar(str[i]);
    13e2:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <UART_sendChar>
    i++;
    13e6:	8f ef       	ldi	r24, 0xFF	; 255
    13e8:	c8 1a       	sub	r12, r24
    13ea:	d8 0a       	sbc	r13, r24
    13ec:	e8 0a       	sbc	r14, r24
    13ee:	f8 0a       	sbc	r15, r24
  *x = UDR;
  }

void UART_sendString(s8* str) {
  u32 i = 0;
  while (str[i] != 0) {
    13f0:	fe 01       	movw	r30, r28
    13f2:	ec 0d       	add	r30, r12
    13f4:	fd 1d       	adc	r31, r13
    13f6:	80 81       	ld	r24, Z
    13f8:	81 11       	cpse	r24, r1
    13fa:	f3 cf       	rjmp	.-26     	; 0x13e2 <UART_sendString+0x16>
    UART_sendChar(str[i]);
    i++;
    }
  UART_sendChar(0); // Send null to terminate the string
    13fc:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <UART_sendChar>
  }
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	ff 90       	pop	r15
    1406:	ef 90       	pop	r14
    1408:	df 90       	pop	r13
    140a:	cf 90       	pop	r12
    140c:	08 95       	ret

0000140e <Door_init>:

#include "door.h"

 // Initialize the servo for the door
void Door_init(void) {
  Servo_init();
    140e:	0e 94 2e 03 	call	0x65c	; 0x65c <Servo_init>
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    1412:	80 e0       	ldi	r24, 0x00	; 0
    1414:	0e 94 41 03 	call	0x682	; 0x682 <Servo_move_to_angle>
    1418:	08 95       	ret

0000141a <Door_open>:
  }

// Open the door by moving the servo to the open angle
void Door_open(void) {
  Servo_move_to_angle(DOOR_OPEN_ANGLE);
    141a:	84 eb       	ldi	r24, 0xB4	; 180
    141c:	0e 94 41 03 	call	0x682	; 0x682 <Servo_move_to_angle>
    1420:	08 95       	ret

00001422 <Door_close>:
  }

// Close the door by moving the servo to the close angle
void Door_close(void) {
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    1422:	80 e0       	ldi	r24, 0x00	; 0
    1424:	0e 94 41 03 	call	0x682	; 0x682 <Servo_move_to_angle>
    1428:	08 95       	ret

0000142a <Lamps_init>:

#include "lights.h"

 // Initializes all six lamps
void Lamps_init(void) {
  LED_init(LAMP_1_PORT, LAMP_1_PIN);
    142a:	62 e0       	ldi	r22, 0x02	; 2
    142c:	83 e4       	ldi	r24, 0x43	; 67
    142e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
  LED_init(LAMP_2_PORT, LAMP_2_PIN);
    1432:	63 e0       	ldi	r22, 0x03	; 3
    1434:	83 e4       	ldi	r24, 0x43	; 67
    1436:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
  LED_init(LAMP_3_PORT, LAMP_3_PIN);
    143a:	64 e0       	ldi	r22, 0x04	; 4
    143c:	83 e4       	ldi	r24, 0x43	; 67
    143e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
  LED_init(LAMP_4_PORT, LAMP_4_PIN);
    1442:	65 e0       	ldi	r22, 0x05	; 5
    1444:	83 e4       	ldi	r24, 0x43	; 67
    1446:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
  LED_init(LAMP_5_PORT, LAMP_5_PIN);
    144a:	66 e0       	ldi	r22, 0x06	; 6
    144c:	83 e4       	ldi	r24, 0x43	; 67
    144e:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
  LED_init(LAMP_6_DIMMABLE_PORT, LAMP_6_DIMMABLE_PIN);
    1452:	67 e0       	ldi	r22, 0x07	; 7
    1454:	84 e4       	ldi	r24, 0x44	; 68
    1456:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <LED_init>
  // Initialize the pwm pin which lamp6 is on for brightness control
  PWM_init(LAMP_6_DIMMABLE_PWM_PIN, 0, PWM_FAST);
    145a:	21 e0       	ldi	r18, 0x01	; 1
    145c:	40 e0       	ldi	r20, 0x00	; 0
    145e:	50 e0       	ldi	r21, 0x00	; 0
    1460:	ba 01       	movw	r22, r20
    1462:	83 e0       	ldi	r24, 0x03	; 3
    1464:	0e 94 58 08 	call	0x10b0	; 0x10b0 <PWM_init>

  Timer_start(TIMER_2, LAMP_6_DIMMABLE_PRESCALAR);
    1468:	60 e0       	ldi	r22, 0x00	; 0
    146a:	71 e0       	ldi	r23, 0x01	; 1
    146c:	82 e0       	ldi	r24, 0x02	; 2
    146e:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <Timer_start>
    1472:	08 95       	ret

00001474 <Lamp_on>:
  }

// Turn on a lamp
void Lamp_on(u8 lampNumber) {
  switch (lampNumber) {
    1474:	83 30       	cpi	r24, 0x03	; 3
    1476:	b1 f0       	breq	.+44     	; 0x14a4 <Lamp_on+0x30>
    1478:	28 f4       	brcc	.+10     	; 0x1484 <Lamp_on+0x10>
    147a:	81 30       	cpi	r24, 0x01	; 1
    147c:	49 f0       	breq	.+18     	; 0x1490 <Lamp_on+0x1c>
    147e:	82 30       	cpi	r24, 0x02	; 2
    1480:	61 f0       	breq	.+24     	; 0x149a <Lamp_on+0x26>
    1482:	08 95       	ret
    1484:	85 30       	cpi	r24, 0x05	; 5
    1486:	c1 f0       	breq	.+48     	; 0x14b8 <Lamp_on+0x44>
    1488:	90 f0       	brcs	.+36     	; 0x14ae <Lamp_on+0x3a>
    148a:	86 30       	cpi	r24, 0x06	; 6
    148c:	d1 f0       	breq	.+52     	; 0x14c2 <Lamp_on+0x4e>
    148e:	08 95       	ret
      case LAMP_1:
        LED_on(LAMP_1_PORT, LAMP_1_PIN);
    1490:	62 e0       	ldi	r22, 0x02	; 2
    1492:	83 e4       	ldi	r24, 0x43	; 67
    1494:	0e 94 03 03 	call	0x606	; 0x606 <LED_on>
        break;
    1498:	08 95       	ret
      case LAMP_2:
        LED_on(LAMP_2_PORT, LAMP_2_PIN);
    149a:	63 e0       	ldi	r22, 0x03	; 3
    149c:	83 e4       	ldi	r24, 0x43	; 67
    149e:	0e 94 03 03 	call	0x606	; 0x606 <LED_on>
        break;
    14a2:	08 95       	ret
      case LAMP_3:
        LED_on(LAMP_3_PORT, LAMP_3_PIN);
    14a4:	64 e0       	ldi	r22, 0x04	; 4
    14a6:	83 e4       	ldi	r24, 0x43	; 67
    14a8:	0e 94 03 03 	call	0x606	; 0x606 <LED_on>
        break;
    14ac:	08 95       	ret
      case LAMP_4:
        LED_on(LAMP_4_PORT, LAMP_4_PIN);
    14ae:	65 e0       	ldi	r22, 0x05	; 5
    14b0:	83 e4       	ldi	r24, 0x43	; 67
    14b2:	0e 94 03 03 	call	0x606	; 0x606 <LED_on>
        break;
    14b6:	08 95       	ret
      case LAMP_5:
        LED_on(LAMP_5_PORT, LAMP_5_PIN);
    14b8:	66 e0       	ldi	r22, 0x06	; 6
    14ba:	83 e4       	ldi	r24, 0x43	; 67
    14bc:	0e 94 03 03 	call	0x606	; 0x606 <LED_on>
        break;
    14c0:	08 95       	ret
      case LAMP_6:
        PWM_OCP_connect(LAMP_6_DIMMABLE_PWM_PIN);
    14c2:	83 e0       	ldi	r24, 0x03	; 3
    14c4:	0e 94 2a 08 	call	0x1054	; 0x1054 <PWM_OCP_connect>
    14c8:	08 95       	ret

000014ca <Lamp_off>:
    }
  }

// Turn off a lamp
void Lamp_off(u8 lampNumber) {
  switch (lampNumber) {
    14ca:	83 30       	cpi	r24, 0x03	; 3
    14cc:	b1 f0       	breq	.+44     	; 0x14fa <Lamp_off+0x30>
    14ce:	28 f4       	brcc	.+10     	; 0x14da <Lamp_off+0x10>
    14d0:	81 30       	cpi	r24, 0x01	; 1
    14d2:	49 f0       	breq	.+18     	; 0x14e6 <Lamp_off+0x1c>
    14d4:	82 30       	cpi	r24, 0x02	; 2
    14d6:	61 f0       	breq	.+24     	; 0x14f0 <Lamp_off+0x26>
    14d8:	08 95       	ret
    14da:	85 30       	cpi	r24, 0x05	; 5
    14dc:	c1 f0       	breq	.+48     	; 0x150e <Lamp_off+0x44>
    14de:	90 f0       	brcs	.+36     	; 0x1504 <Lamp_off+0x3a>
    14e0:	86 30       	cpi	r24, 0x06	; 6
    14e2:	d1 f0       	breq	.+52     	; 0x1518 <Lamp_off+0x4e>
    14e4:	08 95       	ret
      case LAMP_1:
        LED_off(LAMP_1_PORT, LAMP_1_PIN);
    14e6:	62 e0       	ldi	r22, 0x02	; 2
    14e8:	83 e4       	ldi	r24, 0x43	; 67
    14ea:	0e 94 0c 03 	call	0x618	; 0x618 <LED_off>
        break;
    14ee:	08 95       	ret
      case LAMP_2:
        LED_off(LAMP_2_PORT, LAMP_2_PIN);
    14f0:	63 e0       	ldi	r22, 0x03	; 3
    14f2:	83 e4       	ldi	r24, 0x43	; 67
    14f4:	0e 94 0c 03 	call	0x618	; 0x618 <LED_off>
        break;
    14f8:	08 95       	ret
      case LAMP_3:
        LED_off(LAMP_3_PORT, LAMP_3_PIN);
    14fa:	64 e0       	ldi	r22, 0x04	; 4
    14fc:	83 e4       	ldi	r24, 0x43	; 67
    14fe:	0e 94 0c 03 	call	0x618	; 0x618 <LED_off>
        break;
    1502:	08 95       	ret
      case LAMP_4:
        LED_off(LAMP_4_PORT, LAMP_4_PIN);
    1504:	65 e0       	ldi	r22, 0x05	; 5
    1506:	83 e4       	ldi	r24, 0x43	; 67
    1508:	0e 94 0c 03 	call	0x618	; 0x618 <LED_off>
        break;
    150c:	08 95       	ret
      case LAMP_5:
        LED_off(LAMP_5_PORT, LAMP_5_PIN);
    150e:	66 e0       	ldi	r22, 0x06	; 6
    1510:	83 e4       	ldi	r24, 0x43	; 67
    1512:	0e 94 0c 03 	call	0x618	; 0x618 <LED_off>
        break;
    1516:	08 95       	ret
      case LAMP_6:
        PWM_OCP_disconnect(LAMP_6_DIMMABLE_PWM_PIN);
    1518:	83 e0       	ldi	r24, 0x03	; 3
    151a:	0e 94 fc 07 	call	0xff8	; 0xff8 <PWM_OCP_disconnect>
    151e:	08 95       	ret

00001520 <Lamp_toggle>:
    }
  }

// Toggle a lamp
void Lamp_toggle(u8 lampNumber) {
  switch (lampNumber) {
    1520:	83 30       	cpi	r24, 0x03	; 3
    1522:	b1 f0       	breq	.+44     	; 0x1550 <Lamp_toggle+0x30>
    1524:	28 f4       	brcc	.+10     	; 0x1530 <Lamp_toggle+0x10>
    1526:	81 30       	cpi	r24, 0x01	; 1
    1528:	49 f0       	breq	.+18     	; 0x153c <Lamp_toggle+0x1c>
    152a:	82 30       	cpi	r24, 0x02	; 2
    152c:	61 f0       	breq	.+24     	; 0x1546 <Lamp_toggle+0x26>
    152e:	08 95       	ret
    1530:	85 30       	cpi	r24, 0x05	; 5
    1532:	c1 f0       	breq	.+48     	; 0x1564 <Lamp_toggle+0x44>
    1534:	90 f0       	brcs	.+36     	; 0x155a <Lamp_toggle+0x3a>
    1536:	86 30       	cpi	r24, 0x06	; 6
    1538:	d1 f0       	breq	.+52     	; 0x156e <Lamp_toggle+0x4e>
    153a:	08 95       	ret
      case LAMP_1:
        LED_toggle(LAMP_1_PORT, LAMP_1_PIN);
    153c:	62 e0       	ldi	r22, 0x02	; 2
    153e:	83 e4       	ldi	r24, 0x43	; 67
    1540:	0e 94 15 03 	call	0x62a	; 0x62a <LED_toggle>
        break;
    1544:	08 95       	ret
      case LAMP_2:
        LED_toggle(LAMP_2_PORT, LAMP_2_PIN);
    1546:	63 e0       	ldi	r22, 0x03	; 3
    1548:	83 e4       	ldi	r24, 0x43	; 67
    154a:	0e 94 15 03 	call	0x62a	; 0x62a <LED_toggle>
        break;
    154e:	08 95       	ret
      case LAMP_3:
        LED_toggle(LAMP_3_PORT, LAMP_3_PIN);
    1550:	64 e0       	ldi	r22, 0x04	; 4
    1552:	83 e4       	ldi	r24, 0x43	; 67
    1554:	0e 94 15 03 	call	0x62a	; 0x62a <LED_toggle>
        break;
    1558:	08 95       	ret
      case LAMP_4:
        LED_toggle(LAMP_4_PORT, LAMP_4_PIN);
    155a:	65 e0       	ldi	r22, 0x05	; 5
    155c:	83 e4       	ldi	r24, 0x43	; 67
    155e:	0e 94 15 03 	call	0x62a	; 0x62a <LED_toggle>
        break;
    1562:	08 95       	ret
      case LAMP_5:
        LED_toggle(LAMP_5_PORT, LAMP_5_PIN);
    1564:	66 e0       	ldi	r22, 0x06	; 6
    1566:	83 e4       	ldi	r24, 0x43	; 67
    1568:	0e 94 15 03 	call	0x62a	; 0x62a <LED_toggle>
        break;
    156c:	08 95       	ret
      case LAMP_6:
        if (read_bit(TCCR2, COM21)) { // OC pin is connected and lamp6 is on
    156e:	05 b4       	in	r0, 0x25	; 37
    1570:	05 fe       	sbrs	r0, 5
    1572:	04 c0       	rjmp	.+8      	; 0x157c <Lamp_toggle+0x5c>
          Lamp_off(6);
    1574:	86 e0       	ldi	r24, 0x06	; 6
    1576:	0e 94 65 0a 	call	0x14ca	; 0x14ca <Lamp_off>
    157a:	08 95       	ret
          }
        else {
          Lamp_on(6);
    157c:	86 e0       	ldi	r24, 0x06	; 6
    157e:	0e 94 3a 0a 	call	0x1474	; 0x1474 <Lamp_on>
    1582:	08 95       	ret

00001584 <Lamp_dimmable_set_brightness>:
        break;
    }
  }

// Adjust the brightness of the dimmable lamp
void Lamp_dimmable_set_brightness(double brightness) {
    1584:	ab 01       	movw	r20, r22
    1586:	bc 01       	movw	r22, r24
  PWM_set_DC(LAMP_6_DIMMABLE_PWM_PIN, brightness);
    1588:	83 e0       	ldi	r24, 0x03	; 3
    158a:	0e 94 ff 08 	call	0x11fe	; 0x11fe <PWM_set_DC>
    158e:	08 95       	ret

00001590 <Local_access_init>:

ST_User_t local_user;

// Initialize the local control system
void Local_access_init(void) {
  LCD_init();
    1590:	0e 94 ba 02 	call	0x574	; 0x574 <LCD_init>
  Keypad_init();
    1594:	0e 94 1c 02 	call	0x438	; 0x438 <Keypad_init>
  User_DB_init();
    1598:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <User_DB_init>
    159c:	08 95       	ret

0000159e <Remote_init>:

void delete_user_prompt(void);

// ***************************************************************************

void Remote_init(u32 baudRate) {
    159e:	cf 92       	push	r12
    15a0:	df 92       	push	r13
    15a2:	ef 92       	push	r14
    15a4:	ff 92       	push	r15
    15a6:	6b 01       	movw	r12, r22
    15a8:	7c 01       	movw	r14, r24
  User_DB_init();
    15aa:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <User_DB_init>
  BT_init(baudRate);
    15ae:	c7 01       	movw	r24, r14
    15b0:	b6 01       	movw	r22, r12
    15b2:	0e 94 02 02 	call	0x404	; 0x404 <BT_init>
  INT0_init(RISING_EDGE_INTERRUPT_REQUEST);
    15b6:	83 e0       	ldi	r24, 0x03	; 3
    15b8:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <INT0_init>
  UART_RXC_INT_init();
    15bc:	0e 94 14 06 	call	0xc28	; 0xc28 <UART_RXC_INT_init>
  }
    15c0:	ff 90       	pop	r15
    15c2:	ef 90       	pop	r14
    15c4:	df 90       	pop	r13
    15c6:	cf 90       	pop	r12
    15c8:	08 95       	ret

000015ca <println_msg>:

void println_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    15ca:	0e 94 19 02 	call	0x432	; 0x432 <BT_sendString>
  // Send CRLF - carriage return + new line
  BT_sendString("\r\n");
    15ce:	80 e6       	ldi	r24, 0x60	; 96
    15d0:	90 e0       	ldi	r25, 0x00	; 0
    15d2:	0e 94 19 02 	call	0x432	; 0x432 <BT_sendString>
    15d6:	08 95       	ret

000015d8 <print_msg>:
  }

void print_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    15d8:	0e 94 19 02 	call	0x432	; 0x432 <BT_sendString>
    15dc:	08 95       	ret

000015de <callFunWhenBufferReady>:
  }

void callFunWhenBufferReady(void) {
  requesting_function();
    15de:	e0 91 e7 06 	lds	r30, 0x06E7	; 0x8006e7 <requesting_function>
    15e2:	f0 91 e8 06 	lds	r31, 0x06E8	; 0x8006e8 <requesting_function+0x1>
    15e6:	09 95       	icall
    15e8:	08 95       	ret

000015ea <request_user_input>:
  }

void request_user_input(void (*requestingFunction)(void), u8 msgLength, bool numericalInputOnly) {
  requesting_function = requestingFunction;
    15ea:	90 93 e8 06 	sts	0x06E8, r25	; 0x8006e8 <requesting_function+0x1>
    15ee:	80 93 e7 06 	sts	0x06E7, r24	; 0x8006e7 <requesting_function>
  msg_length = msgLength;
    15f2:	60 93 c4 06 	sts	0x06C4, r22	; 0x8006c4 <msg_length>
  numerical_input_mode = numericalInputOnly;
    15f6:	40 93 74 06 	sts	0x0674, r20	; 0x800674 <numerical_input_mode>
    15fa:	08 95       	ret

000015fc <get_lamp_state>:
  }

void get_lamp_state(u8 lamp, u8* state) {
    15fc:	ab 01       	movw	r20, r22
  DIO_Read(lamp + 2, PORT_C, state);
    15fe:	63 e4       	ldi	r22, 0x43	; 67
    1600:	8e 5f       	subi	r24, 0xFE	; 254
    1602:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <DIO_Read>
    1606:	08 95       	ret

00001608 <print_remote_control_menu>:
    initial_options_menu();
    }
  }

void print_remote_control_menu(void) {
  println_msg("Select one of the following devices to control:\t");
    1608:	83 e6       	ldi	r24, 0x63	; 99
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
  println_msg("[1] Lamp 1");
    1610:	84 e9       	ldi	r24, 0x94	; 148
    1612:	90 e0       	ldi	r25, 0x00	; 0
    1614:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
  println_msg("[2] Lamp 2");
    1618:	8f e9       	ldi	r24, 0x9F	; 159
    161a:	90 e0       	ldi	r25, 0x00	; 0
    161c:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
  println_msg("[3] Lamp 3");
    1620:	8a ea       	ldi	r24, 0xAA	; 170
    1622:	90 e0       	ldi	r25, 0x00	; 0
    1624:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
  println_msg("[4] Lamp 4");
    1628:	85 eb       	ldi	r24, 0xB5	; 181
    162a:	90 e0       	ldi	r25, 0x00	; 0
    162c:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
  println_msg("[5] Lamp 5");
    1630:	80 ec       	ldi	r24, 0xC0	; 192
    1632:	90 e0       	ldi	r25, 0x00	; 0
    1634:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
  println_msg("[6] Lamp 6 (dimmable)");
    1638:	8b ec       	ldi	r24, 0xCB	; 203
    163a:	90 e0       	ldi	r25, 0x00	; 0
    163c:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
  if (remote_user.isAdmin) {
    1640:	80 91 75 06 	lds	r24, 0x0675	; 0x800675 <remote_user>
    1644:	88 23       	and	r24, r24
    1646:	49 f0       	breq	.+18     	; 0x165a <print_remote_control_menu+0x52>
    println_msg("[7] The Door");
    1648:	81 ee       	ldi	r24, 0xE1	; 225
    164a:	90 e0       	ldi	r25, 0x00	; 0
    164c:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    println_msg("[8] Go back to main menu");
    1650:	8e ee       	ldi	r24, 0xEE	; 238
    1652:	90 e0       	ldi	r25, 0x00	; 0
    1654:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    1658:	08 95       	ret
    }
  else {
    println_msg("[7] Go back to main menu");
    165a:	87 e0       	ldi	r24, 0x07	; 7
    165c:	91 e0       	ldi	r25, 0x01	; 1
    165e:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    1662:	08 95       	ret

00001664 <print_initial_options_menu>:
      }
    }
  }

void print_initial_options_menu(void) {
  if (remote_user.isAdmin) {
    1664:	80 91 75 06 	lds	r24, 0x0675	; 0x800675 <remote_user>
    1668:	88 23       	and	r24, r24
    166a:	e9 f0       	breq	.+58     	; 0x16a6 <print_initial_options_menu+0x42>
    println_msg("Select one of the following options(by entering its number):\t");
    166c:	80 e2       	ldi	r24, 0x20	; 32
    166e:	91 e0       	ldi	r25, 0x01	; 1
    1670:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    println_msg("[1] Add user\t");
    1674:	8e e5       	ldi	r24, 0x5E	; 94
    1676:	91 e0       	ldi	r25, 0x01	; 1
    1678:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    println_msg("[2] Delete user\t");
    167c:	8c e6       	ldi	r24, 0x6C	; 108
    167e:	91 e0       	ldi	r25, 0x01	; 1
    1680:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    println_msg("[3] Control a device\t");
    1684:	8d e7       	ldi	r24, 0x7D	; 125
    1686:	91 e0       	ldi	r25, 0x01	; 1
    1688:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    println_msg("[4] Log out\t");
    168c:	83 e9       	ldi	r24, 0x93	; 147
    168e:	91 e0       	ldi	r25, 0x01	; 1
    1690:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    if (local_user_loggedin) {
    1694:	80 91 6e 06 	lds	r24, 0x066E	; 0x80066e <__data_end>
    1698:	88 23       	and	r24, r24
    169a:	89 f0       	breq	.+34     	; 0x16be <print_initial_options_menu+0x5a>
      println_msg("[5] Allow local user control\t");
    169c:	80 ea       	ldi	r24, 0xA0	; 160
    169e:	91 e0       	ldi	r25, 0x01	; 1
    16a0:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    16a4:	08 95       	ret
      }
    }
  else {
    println_msg("Select one of the following options(by entering its number):\t");
    16a6:	80 e2       	ldi	r24, 0x20	; 32
    16a8:	91 e0       	ldi	r25, 0x01	; 1
    16aa:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    println_msg("[1] Control a device\t");
    16ae:	8e eb       	ldi	r24, 0xBE	; 190
    16b0:	91 e0       	ldi	r25, 0x01	; 1
    16b2:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    println_msg("[2] Log out\t");
    16b6:	84 ed       	ldi	r24, 0xD4	; 212
    16b8:	91 e0       	ldi	r25, 0x01	; 1
    16ba:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    16be:	08 95       	ret

000016c0 <grant_local_control_permission>:
    }
  }

void grant_local_control_permission(void) {
  local_control_permission_granted = true;
    16c0:	81 e0       	ldi	r24, 0x01	; 1
    16c2:	80 93 6f 06 	sts	0x066F, r24	; 0x80066f <local_control_permission_granted>
    16c6:	08 95       	ret

000016c8 <logout>:
      }
    }
  }

void logout(void) {
  remote_user_loggedin = false;
    16c8:	10 92 70 06 	sts	0x0670, r1	; 0x800670 <remote_user_loggedin>
  println_msg("To login again you have to disconnect and reconnect to the BT module...");
    16cc:	81 ee       	ldi	r24, 0xE1	; 225
    16ce:	91 e0       	ldi	r25, 0x01	; 1
    16d0:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
  println_msg("You have successfully logged out...");
    16d4:	89 e2       	ldi	r24, 0x29	; 41
    16d6:	92 e0       	ldi	r25, 0x02	; 2
    16d8:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
  msg_length = 0;
    16dc:	10 92 c4 06 	sts	0x06C4, r1	; 0x8006c4 <msg_length>
    16e0:	08 95       	ret

000016e2 <initial_options_menu>:
void grant_local_control_permission(void) {
  local_control_permission_granted = true;
  }

void initial_options_menu(void) {
  if (!user_input_accepted) {
    16e2:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <user_input_accepted>
    16e6:	81 11       	cpse	r24, r1
    16e8:	0c c0       	rjmp	.+24     	; 0x1702 <initial_options_menu+0x20>
    print_initial_options_menu();
    16ea:	0e 94 32 0b 	call	0x1664	; 0x1664 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2, true);
    16ee:	41 e0       	ldi	r20, 0x01	; 1
    16f0:	62 e0       	ldi	r22, 0x02	; 2
    16f2:	81 e7       	ldi	r24, 0x71	; 113
    16f4:	9b e0       	ldi	r25, 0x0B	; 11
    16f6:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
    user_input_accepted = true;
    16fa:	81 e0       	ldi	r24, 0x01	; 1
    16fc:	80 93 e9 06 	sts	0x06E9, r24	; 0x8006e9 <user_input_accepted>
    1700:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    1702:	10 92 e9 06 	sts	0x06E9, r1	; 0x8006e9 <user_input_accepted>
    if (remote_user.isAdmin) {
    1706:	80 91 75 06 	lds	r24, 0x0675	; 0x800675 <remote_user>
    170a:	88 23       	and	r24, r24
    170c:	49 f1       	breq	.+82     	; 0x1760 <initial_options_menu+0x7e>
      u8 option = msg_buffer[0];
    170e:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <msg_buffer>
      if (option < '1' || option > '5') {
    1712:	9f ec       	ldi	r25, 0xCF	; 207
    1714:	98 0f       	add	r25, r24
    1716:	95 30       	cpi	r25, 0x05	; 5
    1718:	38 f0       	brcs	.+14     	; 0x1728 <initial_options_menu+0x46>
        println_msg("Invalid option!\t");
    171a:	8d e4       	ldi	r24, 0x4D	; 77
    171c:	92 e0       	ldi	r25, 0x02	; 2
    171e:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
        initial_options_menu();
    1722:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <initial_options_menu>
    1726:	08 95       	ret
        }
      else {
        switch (option) {
    1728:	83 33       	cpi	r24, 0x33	; 51
    172a:	89 f0       	breq	.+34     	; 0x174e <initial_options_menu+0x6c>
    172c:	28 f4       	brcc	.+10     	; 0x1738 <initial_options_menu+0x56>
    172e:	81 33       	cpi	r24, 0x31	; 49
    1730:	41 f0       	breq	.+16     	; 0x1742 <initial_options_menu+0x60>
    1732:	82 33       	cpi	r24, 0x32	; 50
    1734:	49 f0       	breq	.+18     	; 0x1748 <initial_options_menu+0x66>
    1736:	08 95       	ret
    1738:	84 33       	cpi	r24, 0x34	; 52
    173a:	61 f0       	breq	.+24     	; 0x1754 <initial_options_menu+0x72>
    173c:	85 33       	cpi	r24, 0x35	; 53
    173e:	69 f0       	breq	.+26     	; 0x175a <initial_options_menu+0x78>
    1740:	08 95       	ret
            case '1':
              add_user_prompt();
    1742:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <add_user_prompt>
              break;
    1746:	08 95       	ret
            case '2':
              delete_user_prompt();
    1748:	0e 94 c8 0b 	call	0x1790	; 0x1790 <delete_user_prompt>
              break;
    174c:	08 95       	ret
            case '3':
              remote_control();
    174e:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <remote_control>
              break;
    1752:	08 95       	ret
            case '4':
              logout();
    1754:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <logout>
              break;
    1758:	08 95       	ret
            case '5':
              grant_local_control_permission();
    175a:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <grant_local_control_permission>
              break;
    175e:	08 95       	ret
          }
        }
      }
    else {
      u8 option = msg_buffer[0];
    1760:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <msg_buffer>
      if (option < '1' || option > '2') {
    1764:	9f ec       	ldi	r25, 0xCF	; 207
    1766:	98 0f       	add	r25, r24
    1768:	92 30       	cpi	r25, 0x02	; 2
    176a:	38 f0       	brcs	.+14     	; 0x177a <initial_options_menu+0x98>
        println_msg("Invalid option!\t");
    176c:	8d e4       	ldi	r24, 0x4D	; 77
    176e:	92 e0       	ldi	r25, 0x02	; 2
    1770:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
        initial_options_menu();
    1774:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <initial_options_menu>
    1778:	08 95       	ret
        }
      else {
        switch (option) {
    177a:	81 33       	cpi	r24, 0x31	; 49
    177c:	19 f0       	breq	.+6      	; 0x1784 <initial_options_menu+0xa2>
    177e:	82 33       	cpi	r24, 0x32	; 50
    1780:	21 f0       	breq	.+8      	; 0x178a <initial_options_menu+0xa8>
    1782:	08 95       	ret
            case '1':
              remote_control();
    1784:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <remote_control>
              break;
    1788:	08 95       	ret
            case '2':
              logout();
    178a:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <logout>
    178e:	08 95       	ret

00001790 <delete_user_prompt>:
void get_lamp_state(u8 lamp, u8* state) {
  DIO_Read(lamp + 2, PORT_C, state);
  }

void delete_user_prompt(void) {
  if (!user_input_accepted) {
    1790:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <user_input_accepted>
    1794:	81 11       	cpse	r24, r1
    1796:	0e c0       	rjmp	.+28     	; 0x17b4 <delete_user_prompt+0x24>
    print_msg("Enter the user name of the user you want to delete: ");
    1798:	8e e5       	ldi	r24, 0x5E	; 94
    179a:	92 e0       	ldi	r25, 0x02	; 2
    179c:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <print_msg>
    request_user_input(delete_user_prompt, 13, false);
    17a0:	40 e0       	ldi	r20, 0x00	; 0
    17a2:	6d e0       	ldi	r22, 0x0D	; 13
    17a4:	88 ec       	ldi	r24, 0xC8	; 200
    17a6:	9b e0       	ldi	r25, 0x0B	; 11
    17a8:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
    user_input_accepted = true;
    17ac:	81 e0       	ldi	r24, 0x01	; 1
    17ae:	80 93 e9 06 	sts	0x06E9, r24	; 0x8006e9 <user_input_accepted>
    17b2:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    17b4:	10 92 e9 06 	sts	0x06E9, r1	; 0x8006e9 <user_input_accepted>
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    17b8:	65 e9       	ldi	r22, 0x95	; 149
    17ba:	76 e0       	ldi	r23, 0x06	; 6
    17bc:	85 eb       	ldi	r24, 0xB5	; 181
    17be:	96 e0       	ldi	r25, 0x06	; 6
    17c0:	0e 94 4c 0f 	call	0x1e98	; 0x1e98 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    17c4:	83 30       	cpi	r24, 0x03	; 3
    17c6:	29 f4       	brne	.+10     	; 0x17d2 <delete_user_prompt+0x42>
      println_msg("\rError! User not found. Returning to the main menu...");
    17c8:	83 e9       	ldi	r24, 0x93	; 147
    17ca:	92 e0       	ldi	r25, 0x02	; 2
    17cc:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    17d0:	08 c0       	rjmp	.+16     	; 0x17e2 <delete_user_prompt+0x52>
      }
    else {
      // Delete the user
      delete_user(&temp_user);
    17d2:	85 e9       	ldi	r24, 0x95	; 149
    17d4:	96 e0       	ldi	r25, 0x06	; 6
    17d6:	0e 94 1d 11 	call	0x223a	; 0x223a <delete_user>
      println_msg("The user has been deleted successfully!\t");
    17da:	89 ec       	ldi	r24, 0xC9	; 201
    17dc:	92 e0       	ldi	r25, 0x02	; 2
    17de:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
      }
    initial_options_menu();
    17e2:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <initial_options_menu>
    17e6:	08 95       	ret

000017e8 <remote_control>:
    }
  remote_control();
  }

// Prints the state of the device and prompts the user if he wants to change it.
void remote_control(void) {
    17e8:	0f 93       	push	r16
    17ea:	1f 93       	push	r17
    17ec:	cf 93       	push	r28
    17ee:	df 93       	push	r29
    17f0:	1f 92       	push	r1
    17f2:	cd b7       	in	r28, 0x3d	; 61
    17f4:	de b7       	in	r29, 0x3e	; 62
  if (!user_input_accepted) {
    17f6:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <user_input_accepted>
    17fa:	81 11       	cpse	r24, r1
    17fc:	0c c0       	rjmp	.+24     	; 0x1816 <remote_control+0x2e>
    print_remote_control_menu();
    17fe:	0e 94 04 0b 	call	0x1608	; 0x1608 <print_remote_control_menu>
    request_user_input(remote_control, 2, true);
    1802:	41 e0       	ldi	r20, 0x01	; 1
    1804:	62 e0       	ldi	r22, 0x02	; 2
    1806:	84 ef       	ldi	r24, 0xF4	; 244
    1808:	9b e0       	ldi	r25, 0x0B	; 11
    180a:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
    user_input_accepted = true;
    180e:	81 e0       	ldi	r24, 0x01	; 1
    1810:	80 93 e9 06 	sts	0x06E9, r24	; 0x8006e9 <user_input_accepted>
    1814:	63 c0       	rjmp	.+198    	; 0x18dc <remote_control+0xf4>
    }
  else {
    user_input_accepted = false;
    1816:	10 92 e9 06 	sts	0x06E9, r1	; 0x8006e9 <user_input_accepted>
    u8 option = msg_buffer[0];
    181a:	10 91 b5 06 	lds	r17, 0x06B5	; 0x8006b5 <msg_buffer>
    if ((!remote_user.isAdmin && option > '7') || option < '1' || option > '8') {
    181e:	80 91 75 06 	lds	r24, 0x0675	; 0x800675 <remote_user>
    1822:	81 11       	cpse	r24, r1
    1824:	02 c0       	rjmp	.+4      	; 0x182a <remote_control+0x42>
    1826:	18 33       	cpi	r17, 0x38	; 56
    1828:	20 f4       	brcc	.+8      	; 0x1832 <remote_control+0x4a>
    182a:	11 33       	cpi	r17, 0x31	; 49
    182c:	10 f0       	brcs	.+4      	; 0x1832 <remote_control+0x4a>
    182e:	19 33       	cpi	r17, 0x39	; 57
    1830:	38 f0       	brcs	.+14     	; 0x1840 <remote_control+0x58>
      println_msg("Invalid option!\t");
    1832:	8d e4       	ldi	r24, 0x4D	; 77
    1834:	92 e0       	ldi	r25, 0x02	; 2
    1836:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
      remote_control();
    183a:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <remote_control>
    183e:	4e c0       	rjmp	.+156    	; 0x18dc <remote_control+0xf4>
      }
    else {
      u8 state;
      get_lamp_state(option - 48, &state);
    1840:	be 01       	movw	r22, r28
    1842:	6f 5f       	subi	r22, 0xFF	; 255
    1844:	7f 4f       	sbci	r23, 0xFF	; 255
    1846:	00 ed       	ldi	r16, 0xD0	; 208
    1848:	01 0f       	add	r16, r17
    184a:	80 2f       	mov	r24, r16
    184c:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <get_lamp_state>
      device_number = option - 48;
    1850:	00 93 c6 06 	sts	0x06C6, r16	; 0x8006c6 <device_number>
      switch (option) {
    1854:	17 33       	cpi	r17, 0x37	; 55
    1856:	79 f0       	breq	.+30     	; 0x1876 <remote_control+0x8e>
    1858:	18 33       	cpi	r17, 0x38	; 56
    185a:	f9 f0       	breq	.+62     	; 0x189a <remote_control+0xb2>
    185c:	16 33       	cpi	r17, 0x36	; 54
    185e:	01 f5       	brne	.+64     	; 0x18a0 <remote_control+0xb8>
          case '6':
            print_msg("Enter the brightness level for the lamp(from 0(off) to 9(max)): ");
    1860:	82 ef       	ldi	r24, 0xF2	; 242
    1862:	92 e0       	ldi	r25, 0x02	; 2
    1864:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <print_msg>
            request_user_input(control_device, 2, true);
    1868:	41 e0       	ldi	r20, 0x01	; 1
    186a:	62 e0       	ldi	r22, 0x02	; 2
    186c:	84 e7       	ldi	r24, 0x74	; 116
    186e:	9c e0       	ldi	r25, 0x0C	; 12
    1870:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
            break;
    1874:	33 c0       	rjmp	.+102    	; 0x18dc <remote_control+0xf4>
          case '7':
            if (remote_user.isAdmin) {
    1876:	80 91 75 06 	lds	r24, 0x0675	; 0x800675 <remote_user>
    187a:	88 23       	and	r24, r24
    187c:	59 f0       	breq	.+22     	; 0x1894 <remote_control+0xac>
              println_msg("Enter 1 to open the door and 0 to close it: ");
    187e:	83 e3       	ldi	r24, 0x33	; 51
    1880:	93 e0       	ldi	r25, 0x03	; 3
    1882:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
              request_user_input(control_device, 2, true);
    1886:	41 e0       	ldi	r20, 0x01	; 1
    1888:	62 e0       	ldi	r22, 0x02	; 2
    188a:	84 e7       	ldi	r24, 0x74	; 116
    188c:	9c e0       	ldi	r25, 0x0C	; 12
    188e:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
    1892:	24 c0       	rjmp	.+72     	; 0x18dc <remote_control+0xf4>
              }
            else {
              initial_options_menu();
    1894:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <initial_options_menu>
    1898:	21 c0       	rjmp	.+66     	; 0x18dc <remote_control+0xf4>
              }
            break;
          case '8':
            initial_options_menu();
    189a:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <initial_options_menu>
            break;
    189e:	1e c0       	rjmp	.+60     	; 0x18dc <remote_control+0xf4>
          default:
            if (state) {
    18a0:	89 81       	ldd	r24, Y+1	; 0x01
    18a2:	88 23       	and	r24, r24
    18a4:	69 f0       	breq	.+26     	; 0x18c0 <remote_control+0xd8>
              print_msg("Lamp ");
    18a6:	80 e6       	ldi	r24, 0x60	; 96
    18a8:	93 e0       	ldi	r25, 0x03	; 3
    18aa:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <print_msg>
              BT_sendChar(device_number);
    18ae:	80 91 c6 06 	lds	r24, 0x06C6	; 0x8006c6 <device_number>
    18b2:	0e 94 16 02 	call	0x42c	; 0x42c <BT_sendChar>
              println_msg(" is on. Turn it off? (Y/N)");
    18b6:	86 e6       	ldi	r24, 0x66	; 102
    18b8:	93 e0       	ldi	r25, 0x03	; 3
    18ba:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    18be:	08 c0       	rjmp	.+16     	; 0x18d0 <remote_control+0xe8>
              }
            else {
              print_msg("Lamp ");
    18c0:	80 e6       	ldi	r24, 0x60	; 96
    18c2:	93 e0       	ldi	r25, 0x03	; 3
    18c4:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <print_msg>
              // BT_sendChar(device_number);
              println_msg(" is off. Turn it on? (Y/N)");
    18c8:	81 e8       	ldi	r24, 0x81	; 129
    18ca:	93 e0       	ldi	r25, 0x03	; 3
    18cc:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
              }
            request_user_input(control_device, 2, false);
    18d0:	40 e0       	ldi	r20, 0x00	; 0
    18d2:	62 e0       	ldi	r22, 0x02	; 2
    18d4:	84 e7       	ldi	r24, 0x74	; 116
    18d6:	9c e0       	ldi	r25, 0x0C	; 12
    18d8:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
            break;
        }
      }
    }
  }
    18dc:	0f 90       	pop	r0
    18de:	df 91       	pop	r29
    18e0:	cf 91       	pop	r28
    18e2:	1f 91       	pop	r17
    18e4:	0f 91       	pop	r16
    18e6:	08 95       	ret

000018e8 <control_device>:
  else {
    println_msg("[7] Go back to main menu");
    }
  }

void control_device(void) {
    18e8:	cf 93       	push	r28
  u8 option = msg_buffer[0];
    18ea:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <msg_buffer>
  switch (device_number) {
    18ee:	90 91 c6 06 	lds	r25, 0x06C6	; 0x8006c6 <device_number>
    18f2:	96 30       	cpi	r25, 0x06	; 6
    18f4:	19 f0       	breq	.+6      	; 0x18fc <control_device+0x14>
    18f6:	97 30       	cpi	r25, 0x07	; 7
    18f8:	e1 f0       	breq	.+56     	; 0x1932 <control_device+0x4a>
    18fa:	34 c0       	rjmp	.+104    	; 0x1964 <control_device+0x7c>
      case 6:
        if (option < '0' || option > '9') {
    18fc:	60 ed       	ldi	r22, 0xD0	; 208
    18fe:	68 0f       	add	r22, r24
    1900:	6a 30       	cpi	r22, 0x0A	; 10
    1902:	28 f0       	brcs	.+10     	; 0x190e <control_device+0x26>
          println_msg("\r\nInvalid input!!\t");
    1904:	8c e9       	ldi	r24, 0x9C	; 156
    1906:	93 e0       	ldi	r25, 0x03	; 3
    1908:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    190c:	4d c0       	rjmp	.+154    	; 0x19a8 <control_device+0xc0>
          }
        else {
          option -= 48; // Convert to int
          Lamp_dimmable_set_brightness((double)option / 9.0);
    190e:	70 e0       	ldi	r23, 0x00	; 0
    1910:	80 e0       	ldi	r24, 0x00	; 0
    1912:	90 e0       	ldi	r25, 0x00	; 0
    1914:	0e 94 9e 12 	call	0x253c	; 0x253c <__floatunsisf>
    1918:	20 e0       	ldi	r18, 0x00	; 0
    191a:	30 e0       	ldi	r19, 0x00	; 0
    191c:	40 e1       	ldi	r20, 0x10	; 16
    191e:	51 e4       	ldi	r21, 0x41	; 65
    1920:	0e 94 fd 11 	call	0x23fa	; 0x23fa <__divsf3>
    1924:	0e 94 c2 0a 	call	0x1584	; 0x1584 <Lamp_dimmable_set_brightness>
          println_msg("The brightness has been adjusted!");
    1928:	8f ea       	ldi	r24, 0xAF	; 175
    192a:	93 e0       	ldi	r25, 0x03	; 3
    192c:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    1930:	3b c0       	rjmp	.+118    	; 0x19a8 <control_device+0xc0>
          }
        break;
      case 7:
        if (option != '0' && option != '1') {
    1932:	90 ed       	ldi	r25, 0xD0	; 208
    1934:	98 0f       	add	r25, r24
    1936:	92 30       	cpi	r25, 0x02	; 2
    1938:	28 f0       	brcs	.+10     	; 0x1944 <control_device+0x5c>
          println_msg("\r\nInvalid input!!\t");
    193a:	8c e9       	ldi	r24, 0x9C	; 156
    193c:	93 e0       	ldi	r25, 0x03	; 3
    193e:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    1942:	32 c0       	rjmp	.+100    	; 0x19a8 <control_device+0xc0>
          }
        else {
          if (option == '0') {
    1944:	80 33       	cpi	r24, 0x30	; 48
    1946:	39 f4       	brne	.+14     	; 0x1956 <control_device+0x6e>
            Door_close();
    1948:	0e 94 11 0a 	call	0x1422	; 0x1422 <Door_close>
            println_msg("The Door is closed now.");
    194c:	81 ed       	ldi	r24, 0xD1	; 209
    194e:	93 e0       	ldi	r25, 0x03	; 3
    1950:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    1954:	29 c0       	rjmp	.+82     	; 0x19a8 <control_device+0xc0>
            }
          else {
            Door_open();
    1956:	0e 94 0d 0a 	call	0x141a	; 0x141a <Door_open>
            println_msg("The Door is open now.");
    195a:	89 ee       	ldi	r24, 0xE9	; 233
    195c:	93 e0       	ldi	r25, 0x03	; 3
    195e:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    1962:	22 c0       	rjmp	.+68     	; 0x19a8 <control_device+0xc0>
            }
          }
        break;
      default:
        if (option != 'Y' && option != 'y' && option != 'n' && option != 'N') {
    1964:	89 35       	cpi	r24, 0x59	; 89
    1966:	59 f0       	breq	.+22     	; 0x197e <control_device+0x96>
    1968:	89 37       	cpi	r24, 0x79	; 121
    196a:	49 f0       	breq	.+18     	; 0x197e <control_device+0x96>
    196c:	8e 36       	cpi	r24, 0x6E	; 110
    196e:	39 f0       	breq	.+14     	; 0x197e <control_device+0x96>
    1970:	8e 34       	cpi	r24, 0x4E	; 78
    1972:	29 f0       	breq	.+10     	; 0x197e <control_device+0x96>
          println_msg("\r\nInvalid input!!\t");
    1974:	8c e9       	ldi	r24, 0x9C	; 156
    1976:	93 e0       	ldi	r25, 0x03	; 3
    1978:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    197c:	15 c0       	rjmp	.+42     	; 0x19a8 <control_device+0xc0>
          }
        else {
          //! Disabled because the program used more than 99.5% of the data memory and can't be extended further.
          u8 state;
          get_lamp_state(option - 48, state);
    197e:	c0 e0       	ldi	r28, 0x00	; 0
    1980:	6c 2f       	mov	r22, r28
    1982:	70 e0       	ldi	r23, 0x00	; 0
    1984:	80 53       	subi	r24, 0x30	; 48
    1986:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <get_lamp_state>
          Lamp_toggle(device_number);
    198a:	80 91 c6 06 	lds	r24, 0x06C6	; 0x8006c6 <device_number>
    198e:	0e 94 90 0a 	call	0x1520	; 0x1520 <Lamp_toggle>
          if (state) {
    1992:	cc 23       	and	r28, r28
    1994:	29 f0       	breq	.+10     	; 0x19a0 <control_device+0xb8>
            println_msg("The Lamp is now on!");
    1996:	8f ef       	ldi	r24, 0xFF	; 255
    1998:	93 e0       	ldi	r25, 0x03	; 3
    199a:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    199e:	04 c0       	rjmp	.+8      	; 0x19a8 <control_device+0xc0>
            }
          else {
            println_msg("The Lamp is now off!");
    19a0:	83 e1       	ldi	r24, 0x13	; 19
    19a2:	94 e0       	ldi	r25, 0x04	; 4
    19a4:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
            }
          }
        break;
    }
  remote_control();
    19a8:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <remote_control>
  }
    19ac:	cf 91       	pop	r28
    19ae:	08 95       	ret

000019b0 <add_user_isAdmin_prompt>:
  println_msg("You have successfully logged out...");
  msg_length = 0;
  }

void add_user_isAdmin_prompt(void) {
  if (!user_input_accepted) {
    19b0:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <user_input_accepted>
    19b4:	81 11       	cpse	r24, r1
    19b6:	0e c0       	rjmp	.+28     	; 0x19d4 <add_user_isAdmin_prompt+0x24>
    println_msg("Do you want to make the new user an admin? (y/n) ");
    19b8:	88 e2       	ldi	r24, 0x28	; 40
    19ba:	94 e0       	ldi	r25, 0x04	; 4
    19bc:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    request_user_input(add_user_isAdmin_prompt, 2, false);
    19c0:	40 e0       	ldi	r20, 0x00	; 0
    19c2:	62 e0       	ldi	r22, 0x02	; 2
    19c4:	88 ed       	ldi	r24, 0xD8	; 216
    19c6:	9c e0       	ldi	r25, 0x0C	; 12
    19c8:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
    user_input_accepted = true;
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	80 93 e9 06 	sts	0x06E9, r24	; 0x8006e9 <user_input_accepted>
    19d2:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    19d4:	10 92 e9 06 	sts	0x06E9, r1	; 0x8006e9 <user_input_accepted>
    new_user.isAdmin = (msg_buffer[0] == 'y' || msg_buffer[0] == 'Y');
    19d8:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <msg_buffer>
    19dc:	89 37       	cpi	r24, 0x79	; 121
    19de:	21 f0       	breq	.+8      	; 0x19e8 <add_user_isAdmin_prompt+0x38>
    19e0:	89 35       	cpi	r24, 0x59	; 89
    19e2:	21 f4       	brne	.+8      	; 0x19ec <add_user_isAdmin_prompt+0x3c>
    19e4:	81 e0       	ldi	r24, 0x01	; 1
    19e6:	03 c0       	rjmp	.+6      	; 0x19ee <add_user_isAdmin_prompt+0x3e>
    19e8:	81 e0       	ldi	r24, 0x01	; 1
    19ea:	01 c0       	rjmp	.+2      	; 0x19ee <add_user_isAdmin_prompt+0x3e>
    19ec:	80 e0       	ldi	r24, 0x00	; 0
    19ee:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <new_user>
    add_user(&new_user);
    19f2:	87 ec       	ldi	r24, 0xC7	; 199
    19f4:	96 e0       	ldi	r25, 0x06	; 6
    19f6:	0e 94 e2 10 	call	0x21c4	; 0x21c4 <add_user>
    println_msg("User has been added successfully!");
    19fa:	8a e5       	ldi	r24, 0x5A	; 90
    19fc:	94 e0       	ldi	r25, 0x04	; 4
    19fe:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    // Return to the main menu
    initial_options_menu();
    1a02:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <initial_options_menu>
    1a06:	08 95       	ret

00001a08 <add_user_password_prompt>:
    }
  }

void add_user_password_prompt(void) {
  if (!user_input_accepted) {
    1a08:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <user_input_accepted>
    1a0c:	81 11       	cpse	r24, r1
    1a0e:	0e c0       	rjmp	.+28     	; 0x1a2c <add_user_password_prompt+0x24>
    println_msg("Enter the new user's password(The password can only consist of numbers and 4 digits at least, 10 at max): ");
    1a10:	8c e7       	ldi	r24, 0x7C	; 124
    1a12:	94 e0       	ldi	r25, 0x04	; 4
    1a14:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    request_user_input(add_user_password_prompt, 11, true);
    1a18:	41 e0       	ldi	r20, 0x01	; 1
    1a1a:	6b e0       	ldi	r22, 0x0B	; 11
    1a1c:	84 e0       	ldi	r24, 0x04	; 4
    1a1e:	9d e0       	ldi	r25, 0x0D	; 13
    1a20:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
    user_input_accepted = true;
    1a24:	81 e0       	ldi	r24, 0x01	; 1
    1a26:	80 93 e9 06 	sts	0x06E9, r24	; 0x8006e9 <user_input_accepted>
    1a2a:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    1a2c:	10 92 e9 06 	sts	0x06E9, r1	; 0x8006e9 <user_input_accepted>
    if (strlen(msg_buffer) < 4) {
    1a30:	e5 eb       	ldi	r30, 0xB5	; 181
    1a32:	f6 e0       	ldi	r31, 0x06	; 6
    1a34:	01 90       	ld	r0, Z+
    1a36:	00 20       	and	r0, r0
    1a38:	e9 f7       	brne	.-6      	; 0x1a34 <add_user_password_prompt+0x2c>
    1a3a:	31 97       	sbiw	r30, 0x01	; 1
    1a3c:	e5 5b       	subi	r30, 0xB5	; 181
    1a3e:	f6 40       	sbci	r31, 0x06	; 6
    1a40:	34 97       	sbiw	r30, 0x04	; 4
    1a42:	38 f4       	brcc	.+14     	; 0x1a52 <add_user_password_prompt+0x4a>
      println_msg("Password too short!!\t");
    1a44:	87 ee       	ldi	r24, 0xE7	; 231
    1a46:	94 e0       	ldi	r25, 0x04	; 4
    1a48:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
      add_user_password_prompt();
    1a4c:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <add_user_password_prompt>
    1a50:	08 95       	ret
      }
    else {
      strcpy(new_user.password, msg_buffer);
    1a52:	65 eb       	ldi	r22, 0xB5	; 181
    1a54:	76 e0       	ldi	r23, 0x06	; 6
    1a56:	8c ed       	ldi	r24, 0xDC	; 220
    1a58:	96 e0       	ldi	r25, 0x06	; 6
    1a5a:	0e 94 a8 13 	call	0x2750	; 0x2750 <strcpy>
      add_user_isAdmin_prompt();
    1a5e:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <add_user_isAdmin_prompt>
    1a62:	08 95       	ret

00001a64 <add_user_code_prompt>:
      }
    }
  }

void add_user_code_prompt(void) {
  if (!user_input_accepted) {
    1a64:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <user_input_accepted>
    1a68:	81 11       	cpse	r24, r1
    1a6a:	0e c0       	rjmp	.+28     	; 0x1a88 <add_user_code_prompt+0x24>
    print_msg("Enter the new user's code(must be a unique six digit code): ");
    1a6c:	8d ef       	ldi	r24, 0xFD	; 253
    1a6e:	94 e0       	ldi	r25, 0x04	; 4
    1a70:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <print_msg>
    request_user_input(add_user_code_prompt, 7, true);
    1a74:	41 e0       	ldi	r20, 0x01	; 1
    1a76:	67 e0       	ldi	r22, 0x07	; 7
    1a78:	82 e3       	ldi	r24, 0x32	; 50
    1a7a:	9d e0       	ldi	r25, 0x0D	; 13
    1a7c:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
    user_input_accepted = true;
    1a80:	81 e0       	ldi	r24, 0x01	; 1
    1a82:	80 93 e9 06 	sts	0x06E9, r24	; 0x8006e9 <user_input_accepted>
    1a86:	08 95       	ret
    }
  else {// Validating the length of the user code. It can't be more than 6 digits by the input limitations. But the input can be smaller
    user_input_accepted = false;
    1a88:	10 92 e9 06 	sts	0x06E9, r1	; 0x8006e9 <user_input_accepted>
    if (strlen(msg_buffer) != 6) {
    1a8c:	e5 eb       	ldi	r30, 0xB5	; 181
    1a8e:	f6 e0       	ldi	r31, 0x06	; 6
    1a90:	01 90       	ld	r0, Z+
    1a92:	00 20       	and	r0, r0
    1a94:	e9 f7       	brne	.-6      	; 0x1a90 <add_user_code_prompt+0x2c>
    1a96:	ec 5b       	subi	r30, 0xBC	; 188
    1a98:	f6 40       	sbci	r31, 0x06	; 6
    1a9a:	39 f0       	breq	.+14     	; 0x1aaa <add_user_code_prompt+0x46>
      println_msg("User code too short!");
    1a9c:	8a e3       	ldi	r24, 0x3A	; 58
    1a9e:	95 e0       	ldi	r25, 0x05	; 5
    1aa0:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
      add_user_code_prompt();
    1aa4:	0e 94 32 0d 	call	0x1a64	; 0x1a64 <add_user_code_prompt>
    1aa8:	08 95       	ret
      }
    else {
      EN_UserStatusCode_t userExists = getUserByCode(msg_buffer, &temp_user);
    1aaa:	65 e9       	ldi	r22, 0x95	; 149
    1aac:	76 e0       	ldi	r23, 0x06	; 6
    1aae:	85 eb       	ldi	r24, 0xB5	; 181
    1ab0:	96 e0       	ldi	r25, 0x06	; 6
    1ab2:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <getUserByCode>
      if (userExists == USER_NOT_FOUND) {
    1ab6:	83 30       	cpi	r24, 0x03	; 3
    1ab8:	49 f4       	brne	.+18     	; 0x1acc <add_user_code_prompt+0x68>
        strcpy(new_user.code, msg_buffer);
    1aba:	65 eb       	ldi	r22, 0xB5	; 181
    1abc:	76 e0       	ldi	r23, 0x06	; 6
    1abe:	85 ed       	ldi	r24, 0xD5	; 213
    1ac0:	96 e0       	ldi	r25, 0x06	; 6
    1ac2:	0e 94 a8 13 	call	0x2750	; 0x2750 <strcpy>
        add_user_password_prompt();
    1ac6:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <add_user_password_prompt>
    1aca:	08 95       	ret
        }
      else {
        println_msg("\rThe user code already exists!\t");
    1acc:	8f e4       	ldi	r24, 0x4F	; 79
    1ace:	95 e0       	ldi	r25, 0x05	; 5
    1ad0:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
        add_user_code_prompt();
    1ad4:	0e 94 32 0d 	call	0x1a64	; 0x1a64 <add_user_code_prompt>
    1ad8:	08 95       	ret

00001ada <add_user_prompt>:
      }
    }
  }

void add_user_prompt(void) {
  if (!user_input_accepted) {
    1ada:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <user_input_accepted>
    1ade:	81 11       	cpse	r24, r1
    1ae0:	0e c0       	rjmp	.+28     	; 0x1afe <add_user_prompt+0x24>
    print_msg("Enter the new user's name: ");
    1ae2:	8f e6       	ldi	r24, 0x6F	; 111
    1ae4:	95 e0       	ldi	r25, 0x05	; 5
    1ae6:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <print_msg>
    request_user_input(add_user_prompt, 13, false);
    1aea:	40 e0       	ldi	r20, 0x00	; 0
    1aec:	6d e0       	ldi	r22, 0x0D	; 13
    1aee:	8d e6       	ldi	r24, 0x6D	; 109
    1af0:	9d e0       	ldi	r25, 0x0D	; 13
    1af2:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
    user_input_accepted = true;
    1af6:	81 e0       	ldi	r24, 0x01	; 1
    1af8:	80 93 e9 06 	sts	0x06E9, r24	; 0x8006e9 <user_input_accepted>
    1afc:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    1afe:	10 92 e9 06 	sts	0x06E9, r1	; 0x8006e9 <user_input_accepted>
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    1b02:	65 e9       	ldi	r22, 0x95	; 149
    1b04:	76 e0       	ldi	r23, 0x06	; 6
    1b06:	85 eb       	ldi	r24, 0xB5	; 181
    1b08:	96 e0       	ldi	r25, 0x06	; 6
    1b0a:	0e 94 4c 0f 	call	0x1e98	; 0x1e98 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    1b0e:	83 30       	cpi	r24, 0x03	; 3
    1b10:	49 f4       	brne	.+18     	; 0x1b24 <add_user_prompt+0x4a>
      strcpy(new_user.name, msg_buffer);
    1b12:	65 eb       	ldi	r22, 0xB5	; 181
    1b14:	76 e0       	ldi	r23, 0x06	; 6
    1b16:	88 ec       	ldi	r24, 0xC8	; 200
    1b18:	96 e0       	ldi	r25, 0x06	; 6
    1b1a:	0e 94 a8 13 	call	0x2750	; 0x2750 <strcpy>
      add_user_code_prompt();
    1b1e:	0e 94 32 0d 	call	0x1a64	; 0x1a64 <add_user_code_prompt>
    1b22:	08 95       	ret
      }
    else {
      // Prompt the user to enter the user code
      println_msg("\rThe user already exists!\t");
    1b24:	8b e8       	ldi	r24, 0x8B	; 139
    1b26:	95 e0       	ldi	r25, 0x05	; 5
    1b28:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
      //! Return to the main menu
      initial_options_menu();
    1b2c:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <initial_options_menu>
    1b30:	08 95       	ret

00001b32 <invalid_remote_login_attempt>:
  // // Show the options menu
  // initial_options_menu();
  // }
  }

void invalid_remote_login_attempt(void) {
    1b32:	0f 93       	push	r16
    1b34:	1f 93       	push	r17
    1b36:	cf 93       	push	r28
    1b38:	df 93       	push	r29
    1b3a:	cd b7       	in	r28, 0x3d	; 61
    1b3c:	de b7       	in	r29, 0x3e	; 62
    1b3e:	e2 97       	sbiw	r28, 0x32	; 50
    1b40:	0f b6       	in	r0, 0x3f	; 63
    1b42:	f8 94       	cli
    1b44:	de bf       	out	0x3e, r29	; 62
    1b46:	0f be       	out	0x3f, r0	; 63
    1b48:	cd bf       	out	0x3d, r28	; 61
  invalid_trails++;
    1b4a:	80 91 72 06 	lds	r24, 0x0672	; 0x800672 <invalid_trails>
    1b4e:	8f 5f       	subi	r24, 0xFF	; 255
    1b50:	80 93 72 06 	sts	0x0672, r24	; 0x800672 <invalid_trails>
  s8 msg[50];
  if (invalid_trails < 3) {
    1b54:	83 30       	cpi	r24, 0x03	; 3
    1b56:	e8 f4       	brcc	.+58     	; 0x1b92 <invalid_remote_login_attempt+0x60>
    sprintf(msg, "Invalid login attempt! \r\n%d attempts remaining.", 3 - invalid_trails);
    1b58:	23 e0       	ldi	r18, 0x03	; 3
    1b5a:	30 e0       	ldi	r19, 0x00	; 0
    1b5c:	a9 01       	movw	r20, r18
    1b5e:	48 1b       	sub	r20, r24
    1b60:	51 09       	sbc	r21, r1
    1b62:	ca 01       	movw	r24, r20
    1b64:	9f 93       	push	r25
    1b66:	4f 93       	push	r20
    1b68:	86 ea       	ldi	r24, 0xA6	; 166
    1b6a:	95 e0       	ldi	r25, 0x05	; 5
    1b6c:	9f 93       	push	r25
    1b6e:	8f 93       	push	r24
    1b70:	8e 01       	movw	r16, r28
    1b72:	0f 5f       	subi	r16, 0xFF	; 255
    1b74:	1f 4f       	sbci	r17, 0xFF	; 255
    1b76:	1f 93       	push	r17
    1b78:	0f 93       	push	r16
    1b7a:	0e 94 af 13 	call	0x275e	; 0x275e <sprintf>
    println_msg(msg);
    1b7e:	c8 01       	movw	r24, r16
    1b80:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
    return;
    1b84:	0f 90       	pop	r0
    1b86:	0f 90       	pop	r0
    1b88:	0f 90       	pop	r0
    1b8a:	0f 90       	pop	r0
    1b8c:	0f 90       	pop	r0
    1b8e:	0f 90       	pop	r0
    1b90:	0f c0       	rjmp	.+30     	; 0x1bb0 <invalid_remote_login_attempt+0x7e>
    }
  strcpy(msg, "Too many login attempts! \r--- System Suspended! ---");
    1b92:	84 e3       	ldi	r24, 0x34	; 52
    1b94:	e6 ed       	ldi	r30, 0xD6	; 214
    1b96:	f5 e0       	ldi	r31, 0x05	; 5
    1b98:	de 01       	movw	r26, r28
    1b9a:	11 96       	adiw	r26, 0x01	; 1
    1b9c:	01 90       	ld	r0, Z+
    1b9e:	0d 92       	st	X+, r0
    1ba0:	8a 95       	dec	r24
    1ba2:	e1 f7       	brne	.-8      	; 0x1b9c <invalid_remote_login_attempt+0x6a>
  println_msg(msg);
    1ba4:	ce 01       	movw	r24, r28
    1ba6:	01 96       	adiw	r24, 0x01	; 1
    1ba8:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
  run_system = false;
    1bac:	10 92 71 06 	sts	0x0671, r1	; 0x800671 <run_system>
  }
    1bb0:	e2 96       	adiw	r28, 0x32	; 50
    1bb2:	0f b6       	in	r0, 0x3f	; 63
    1bb4:	f8 94       	cli
    1bb6:	de bf       	out	0x3e, r29	; 62
    1bb8:	0f be       	out	0x3f, r0	; 63
    1bba:	cd bf       	out	0x3d, r28	; 61
    1bbc:	df 91       	pop	r29
    1bbe:	cf 91       	pop	r28
    1bc0:	1f 91       	pop	r17
    1bc2:	0f 91       	pop	r16
    1bc4:	08 95       	ret

00001bc6 <userPassword_prompt_handler>:
      }
    }
  }

void userPassword_prompt_handler(void) {
  if (!user_input_accepted) {
    1bc6:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <user_input_accepted>
    1bca:	81 11       	cpse	r24, r1
    1bcc:	0e c0       	rjmp	.+28     	; 0x1bea <userPassword_prompt_handler+0x24>
    print_msg("Enter your password:\t");
    1bce:	8a e0       	ldi	r24, 0x0A	; 10
    1bd0:	96 e0       	ldi	r25, 0x06	; 6
    1bd2:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <print_msg>
    request_user_input(userPassword_prompt_handler, 11, true);
    1bd6:	41 e0       	ldi	r20, 0x01	; 1
    1bd8:	6b e0       	ldi	r22, 0x0B	; 11
    1bda:	83 ee       	ldi	r24, 0xE3	; 227
    1bdc:	9d e0       	ldi	r25, 0x0D	; 13
    1bde:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
    user_input_accepted = true;
    1be2:	81 e0       	ldi	r24, 0x01	; 1
    1be4:	80 93 e9 06 	sts	0x06E9, r24	; 0x8006e9 <user_input_accepted>
    1be8:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    1bea:	10 92 e9 06 	sts	0x06E9, r1	; 0x8006e9 <user_input_accepted>
    if (strcmp(remote_user.password, msg_buffer)) { // Wrong password
    1bee:	65 eb       	ldi	r22, 0xB5	; 181
    1bf0:	76 e0       	ldi	r23, 0x06	; 6
    1bf2:	8a e8       	ldi	r24, 0x8A	; 138
    1bf4:	96 e0       	ldi	r25, 0x06	; 6
    1bf6:	0e 94 9f 13 	call	0x273e	; 0x273e <strcmp>
    1bfa:	89 2b       	or	r24, r25
    1bfc:	49 f0       	breq	.+18     	; 0x1c10 <userPassword_prompt_handler+0x4a>
      println_msg("Wrong password!");
    1bfe:	80 e2       	ldi	r24, 0x20	; 32
    1c00:	96 e0       	ldi	r25, 0x06	; 6
    1c02:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
      invalid_remote_login_attempt();
    1c06:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <invalid_remote_login_attempt>
      userPassword_prompt_handler();
    1c0a:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <userPassword_prompt_handler>
    1c0e:	08 95       	ret
      }
    else {
      remote_user_loggedin = true;
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	80 93 70 06 	sts	0x0670, r24	; 0x800670 <remote_user_loggedin>
      print_msg("Welcome ");
    1c16:	80 e3       	ldi	r24, 0x30	; 48
    1c18:	96 e0       	ldi	r25, 0x06	; 6
    1c1a:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <print_msg>
      print_msg(remote_user.name);
    1c1e:	86 e7       	ldi	r24, 0x76	; 118
    1c20:	96 e0       	ldi	r25, 0x06	; 6
    1c22:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <print_msg>
      println_msg("!");
    1c26:	8f ec       	ldi	r24, 0xCF	; 207
    1c28:	93 e0       	ldi	r25, 0x03	; 3
    1c2a:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
      // Show the options menu
      initial_options_menu();
    1c2e:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <initial_options_menu>
    1c32:	08 95       	ret

00001c34 <userName_prompt_handler>:
    }
  }

void userName_prompt_handler(void) {
  // Request user input for the first time and in case of wrong input
  if (!user_input_accepted) {
    1c34:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <user_input_accepted>
    1c38:	81 11       	cpse	r24, r1
    1c3a:	0e c0       	rjmp	.+28     	; 0x1c58 <userName_prompt_handler+0x24>
    print_msg("Enter your user name:\t");
    1c3c:	89 e3       	ldi	r24, 0x39	; 57
    1c3e:	96 e0       	ldi	r25, 0x06	; 6
    1c40:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <print_msg>
    request_user_input(userName_prompt_handler, 13, false);
    1c44:	40 e0       	ldi	r20, 0x00	; 0
    1c46:	6d e0       	ldi	r22, 0x0D	; 13
    1c48:	8a e1       	ldi	r24, 0x1A	; 26
    1c4a:	9e e0       	ldi	r25, 0x0E	; 14
    1c4c:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <request_user_input>
    user_input_accepted = true;
    1c50:	81 e0       	ldi	r24, 0x01	; 1
    1c52:	80 93 e9 06 	sts	0x06E9, r24	; 0x8006e9 <user_input_accepted>
    1c56:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &remote_user);
    1c58:	65 e7       	ldi	r22, 0x75	; 117
    1c5a:	76 e0       	ldi	r23, 0x06	; 6
    1c5c:	85 eb       	ldi	r24, 0xB5	; 181
    1c5e:	96 e0       	ldi	r25, 0x06	; 6
    1c60:	0e 94 4c 0f 	call	0x1e98	; 0x1e98 <getUserByName>
    user_input_accepted = false;
    1c64:	10 92 e9 06 	sts	0x06E9, r1	; 0x8006e9 <user_input_accepted>
    if (userExists == USER_NOT_FOUND) {
    1c68:	83 30       	cpi	r24, 0x03	; 3
    1c6a:	49 f4       	brne	.+18     	; 0x1c7e <userName_prompt_handler+0x4a>
      println_msg("User doesn't exist!");
    1c6c:	80 e5       	ldi	r24, 0x50	; 80
    1c6e:	96 e0       	ldi	r25, 0x06	; 6
    1c70:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
      invalid_remote_login_attempt();
    1c74:	0e 94 99 0d 	call	0x1b32	; 0x1b32 <invalid_remote_login_attempt>
      userName_prompt_handler();
    1c78:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <userName_prompt_handler>
    1c7c:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      userPassword_prompt_handler();
    1c7e:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <userPassword_prompt_handler>
    1c82:	08 95       	ret

00001c84 <remote_login_prompt>:
  }

void remote_login_prompt(void) {
  //! for some reason this part causes a compilation error related to .bss section in memory!!!! 
  // if (!remote_user_loggedin) {
  println_msg("Welcome!");
    1c84:	84 e6       	ldi	r24, 0x64	; 100
    1c86:	96 e0       	ldi	r25, 0x06	; 6
    1c88:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <println_msg>
  // println_msg("Welcome to the Smart Home System!");
  // println_msg("To proceed, please login.");
  userName_prompt_handler();
    1c8c:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <userName_prompt_handler>
    1c90:	08 95       	ret

00001c92 <__vector_13>:
  println_msg(msg);
  run_system = false;
  }

// Handles the user input asynchronously.
ISR(USART_RXC_vect) {
    1c92:	1f 92       	push	r1
    1c94:	0f 92       	push	r0
    1c96:	0f b6       	in	r0, 0x3f	; 63
    1c98:	0f 92       	push	r0
    1c9a:	11 24       	eor	r1, r1
    1c9c:	2f 93       	push	r18
    1c9e:	3f 93       	push	r19
    1ca0:	4f 93       	push	r20
    1ca2:	5f 93       	push	r21
    1ca4:	6f 93       	push	r22
    1ca6:	7f 93       	push	r23
    1ca8:	8f 93       	push	r24
    1caa:	9f 93       	push	r25
    1cac:	af 93       	push	r26
    1cae:	bf 93       	push	r27
    1cb0:	ef 93       	push	r30
    1cb2:	ff 93       	push	r31
#if UART_COMMUNICATION_INTERFACE ==  PROTEUS_VIRTUAL_TERMINAL
  // Read the UDR to clear the RXC bit
  udr_temp = UDR;
    1cb4:	8c b1       	in	r24, 0x0c	; 12
    1cb6:	80 93 c5 06 	sts	0x06C5, r24	; 0x8006c5 <udr_temp>

  // If no input requested, ignore the input. No input requested is indicated by msg length of zero
  if (msg_length == 0) return;
    1cba:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <msg_length>
    1cbe:	99 23       	and	r25, r25
    1cc0:	09 f4       	brne	.+2      	; 0x1cc4 <__vector_13+0x32>
    1cc2:	5b c0       	rjmp	.+182    	; 0x1d7a <__vector_13+0xe8>

  // Accept numbers only in the numerical input mode
  if (numerical_input_mode) {
    1cc4:	90 91 74 06 	lds	r25, 0x0674	; 0x800674 <numerical_input_mode>
    1cc8:	99 23       	and	r25, r25
    1cca:	59 f0       	breq	.+22     	; 0x1ce2 <__vector_13+0x50>
    if (!((udr_temp >= '0' && udr_temp <= '9') || udr_temp == '\b' || udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER || udr_temp == '\n')) {
    1ccc:	90 ed       	ldi	r25, 0xD0	; 208
    1cce:	98 0f       	add	r25, r24
    1cd0:	9a 30       	cpi	r25, 0x0A	; 10
    1cd2:	38 f0       	brcs	.+14     	; 0x1ce2 <__vector_13+0x50>
    1cd4:	88 30       	cpi	r24, 0x08	; 8
    1cd6:	29 f0       	breq	.+10     	; 0x1ce2 <__vector_13+0x50>
    1cd8:	8d 30       	cpi	r24, 0x0D	; 13
    1cda:	19 f0       	breq	.+6      	; 0x1ce2 <__vector_13+0x50>
    1cdc:	8a 30       	cpi	r24, 0x0A	; 10
    1cde:	09 f0       	breq	.+2      	; 0x1ce2 <__vector_13+0x50>
    1ce0:	4c c0       	rjmp	.+152    	; 0x1d7a <__vector_13+0xe8>
      return;
      }
    }

  // Handling backspaces
  if (udr_temp == '\b') {
    1ce2:	88 30       	cpi	r24, 0x08	; 8
    1ce4:	59 f4       	brne	.+22     	; 0x1cfc <__vector_13+0x6a>
    if (msg_buffer_pointer > 0) {
    1ce6:	90 91 73 06 	lds	r25, 0x0673	; 0x800673 <msg_buffer_pointer>
    1cea:	99 23       	and	r25, r25
    1cec:	09 f4       	brne	.+2      	; 0x1cf0 <__vector_13+0x5e>
    1cee:	45 c0       	rjmp	.+138    	; 0x1d7a <__vector_13+0xe8>
      msg_buffer_pointer--;
    1cf0:	91 50       	subi	r25, 0x01	; 1
    1cf2:	90 93 73 06 	sts	0x0673, r25	; 0x800673 <msg_buffer_pointer>
      BT_sendChar(udr_temp);
    1cf6:	0e 94 16 02 	call	0x42c	; 0x42c <BT_sendChar>
    1cfa:	3f c0       	rjmp	.+126    	; 0x1d7a <__vector_13+0xe8>
      }
    return;
    }

  msg_buffer[msg_buffer_pointer] = udr_temp;
    1cfc:	90 91 73 06 	lds	r25, 0x0673	; 0x800673 <msg_buffer_pointer>
    1d00:	e9 2f       	mov	r30, r25
    1d02:	f0 e0       	ldi	r31, 0x00	; 0
    1d04:	eb 54       	subi	r30, 0x4B	; 75
    1d06:	f9 4f       	sbci	r31, 0xF9	; 249
    1d08:	80 83       	st	Z, r24
  msg_buffer_pointer++;
    1d0a:	9f 5f       	subi	r25, 0xFF	; 255
    1d0c:	90 93 73 06 	sts	0x0673, r25	; 0x800673 <msg_buffer_pointer>

  // Msg is empty
  // Ignore null msgs
  if (msg_buffer_pointer == 1) {
    1d10:	91 30       	cpi	r25, 0x01	; 1
    1d12:	39 f4       	brne	.+14     	; 0x1d22 <__vector_13+0x90>
    if (msg_buffer[0] == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1d14:	90 91 b5 06 	lds	r25, 0x06B5	; 0x8006b5 <msg_buffer>
    1d18:	9d 30       	cpi	r25, 0x0D	; 13
    1d1a:	19 f4       	brne	.+6      	; 0x1d22 <__vector_13+0x90>
      msg_buffer_pointer = 0;
    1d1c:	10 92 73 06 	sts	0x0673, r1	; 0x800673 <msg_buffer_pointer>
      return;
    1d20:	2c c0       	rjmp	.+88     	; 0x1d7a <__vector_13+0xe8>
      }
    }

  // Echo the sent char on the terminal
  //! Proteus virtual terminal doesn't send a line feed char (ASCII code: 10). Instead it sends a carriage return (ASCII code: 13).
  if (udr_temp != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER)
    1d22:	8d 30       	cpi	r24, 0x0D	; 13
    1d24:	11 f0       	breq	.+4      	; 0x1d2a <__vector_13+0x98>
    BT_sendChar(udr_temp);
    1d26:	0e 94 16 02 	call	0x42c	; 0x42c <BT_sendChar>

  // Msg is longer than required
  // Delete the last input char. Don't allow the user to enter longer input than the maximum required
  if (msg_buffer_pointer == msg_length) {
    1d2a:	80 91 73 06 	lds	r24, 0x0673	; 0x800673 <msg_buffer_pointer>
    1d2e:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <msg_length>
    1d32:	89 13       	cpse	r24, r25
    1d34:	0d c0       	rjmp	.+26     	; 0x1d50 <__vector_13+0xbe>
    if (msg_buffer[msg_buffer_pointer - 1] != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1d36:	e8 2f       	mov	r30, r24
    1d38:	f0 e0       	ldi	r31, 0x00	; 0
    1d3a:	ec 54       	subi	r30, 0x4C	; 76
    1d3c:	f9 4f       	sbci	r31, 0xF9	; 249
    1d3e:	90 81       	ld	r25, Z
    1d40:	9d 30       	cpi	r25, 0x0D	; 13
    1d42:	31 f0       	breq	.+12     	; 0x1d50 <__vector_13+0xbe>
      msg_buffer_pointer--;
    1d44:	81 50       	subi	r24, 0x01	; 1
    1d46:	80 93 73 06 	sts	0x0673, r24	; 0x800673 <msg_buffer_pointer>
      BT_sendChar('\b');
    1d4a:	88 e0       	ldi	r24, 0x08	; 8
    1d4c:	0e 94 16 02 	call	0x42c	; 0x42c <BT_sendChar>
      }
    }

  // Msg has ended and is within the required length
  if (udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1d50:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <udr_temp>
    1d54:	8d 30       	cpi	r24, 0x0D	; 13
    1d56:	89 f4       	brne	.+34     	; 0x1d7a <__vector_13+0xe8>
    if (msg_buffer_pointer <= msg_length) {
    1d58:	e0 91 73 06 	lds	r30, 0x0673	; 0x800673 <msg_buffer_pointer>
    1d5c:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <msg_length>
    1d60:	8e 17       	cp	r24, r30
    1d62:	58 f0       	brcs	.+22     	; 0x1d7a <__vector_13+0xe8>
      // Replace the carriage return with null to terminate the string correctly
      msg_buffer[msg_buffer_pointer - 1] = '\0';
    1d64:	f0 e0       	ldi	r31, 0x00	; 0
    1d66:	ec 54       	subi	r30, 0x4C	; 76
    1d68:	f9 4f       	sbci	r31, 0xF9	; 249
    1d6a:	10 82       	st	Z, r1
      BT_sendChar('\r');
    1d6c:	8d e0       	ldi	r24, 0x0D	; 13
    1d6e:	0e 94 16 02 	call	0x42c	; 0x42c <BT_sendChar>
      callFunWhenBufferReady();
    1d72:	0e 94 ef 0a 	call	0x15de	; 0x15de <callFunWhenBufferReady>
      msg_buffer_pointer = 0;
    1d76:	10 92 73 06 	sts	0x0673, r1	; 0x800673 <msg_buffer_pointer>
      callFunWhenBufferReady();
      msg_buffer_pointer = 0;
      }
    }
#endif
  }
    1d7a:	ff 91       	pop	r31
    1d7c:	ef 91       	pop	r30
    1d7e:	bf 91       	pop	r27
    1d80:	af 91       	pop	r26
    1d82:	9f 91       	pop	r25
    1d84:	8f 91       	pop	r24
    1d86:	7f 91       	pop	r23
    1d88:	6f 91       	pop	r22
    1d8a:	5f 91       	pop	r21
    1d8c:	4f 91       	pop	r20
    1d8e:	3f 91       	pop	r19
    1d90:	2f 91       	pop	r18
    1d92:	0f 90       	pop	r0
    1d94:	0f be       	out	0x3f, r0	; 63
    1d96:	0f 90       	pop	r0
    1d98:	1f 90       	pop	r1
    1d9a:	18 95       	reti

00001d9c <__vector_1>:

ISR(INT0_vect) {
    1d9c:	1f 92       	push	r1
    1d9e:	0f 92       	push	r0
    1da0:	0f b6       	in	r0, 0x3f	; 63
    1da2:	0f 92       	push	r0
    1da4:	11 24       	eor	r1, r1
    1da6:	2f 93       	push	r18
    1da8:	3f 93       	push	r19
    1daa:	4f 93       	push	r20
    1dac:	5f 93       	push	r21
    1dae:	6f 93       	push	r22
    1db0:	7f 93       	push	r23
    1db2:	8f 93       	push	r24
    1db4:	9f 93       	push	r25
    1db6:	af 93       	push	r26
    1db8:	bf 93       	push	r27
    1dba:	ef 93       	push	r30
    1dbc:	ff 93       	push	r31
  // Initialize communication with the user
  // Request user login credentials
  remote_login_prompt();
    1dbe:	0e 94 42 0e 	call	0x1c84	; 0x1c84 <remote_login_prompt>
  }
    1dc2:	ff 91       	pop	r31
    1dc4:	ef 91       	pop	r30
    1dc6:	bf 91       	pop	r27
    1dc8:	af 91       	pop	r26
    1dca:	9f 91       	pop	r25
    1dcc:	8f 91       	pop	r24
    1dce:	7f 91       	pop	r23
    1dd0:	6f 91       	pop	r22
    1dd2:	5f 91       	pop	r21
    1dd4:	4f 91       	pop	r20
    1dd6:	3f 91       	pop	r19
    1dd8:	2f 91       	pop	r18
    1dda:	0f 90       	pop	r0
    1ddc:	0f be       	out	0x3f, r0	; 63
    1dde:	0f 90       	pop	r0
    1de0:	1f 90       	pop	r1
    1de2:	18 95       	reti

00001de4 <AC_auto_control_service_start>:
  DIO_write(AC_PIN, AC_PORT, LOW);
  // Turn off the timer
#if AC_ADC_TRIGGER == TIMER_0_COMPARE_MATCH_TRIGGER
  Timer_stop(TIMER_0);
#elif AC_ADC_TRIGGER == TIMER_0_OVF_TRIGGER
  Timer_stop(TIMER_0);
    1de4:	64 e0       	ldi	r22, 0x04	; 4
    1de6:	87 e0       	ldi	r24, 0x07	; 7
    1de8:	0e 94 1d 03 	call	0x63a	; 0x63a <LM35_init_INT>
    1dec:	41 e0       	ldi	r20, 0x01	; 1
    1dee:	63 e4       	ldi	r22, 0x43	; 67
    1df0:	87 e0       	ldi	r24, 0x07	; 7
    1df2:	0e 94 c0 03 	call	0x780	; 0x780 <DIO_init>
    1df6:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADC_INT_init>
    1dfa:	60 e0       	ldi	r22, 0x00	; 0
    1dfc:	70 e0       	ldi	r23, 0x00	; 0
    1dfe:	80 e0       	ldi	r24, 0x00	; 0
    1e00:	0e 94 a6 07 	call	0xf4c	; 0xf4c <Timer_normal_init>
    1e04:	60 e0       	ldi	r22, 0x00	; 0
    1e06:	74 e0       	ldi	r23, 0x04	; 4
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <Timer_start>
    1e0e:	08 95       	ret

00001e10 <__vector_16>:
#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_BY_ACTIVATING_TIMER0_OVF_INT
// To reset the TOV0 flag. Alternatively, it can be reset in the ADC complete interrupt.
ISR(TIMER0_OVF_vect) {}
#endif

ISR(ADC_vect) {
    1e10:	1f 92       	push	r1
    1e12:	0f 92       	push	r0
    1e14:	0f b6       	in	r0, 0x3f	; 63
    1e16:	0f 92       	push	r0
    1e18:	11 24       	eor	r1, r1
    1e1a:	2f 93       	push	r18
    1e1c:	3f 93       	push	r19
    1e1e:	4f 93       	push	r20
    1e20:	5f 93       	push	r21
    1e22:	6f 93       	push	r22
    1e24:	7f 93       	push	r23
    1e26:	8f 93       	push	r24
    1e28:	9f 93       	push	r25
    1e2a:	af 93       	push	r26
    1e2c:	bf 93       	push	r27
    1e2e:	cf 93       	push	r28
    1e30:	df 93       	push	r29
    1e32:	ef 93       	push	r30
    1e34:	ff 93       	push	r31
  u16 temperature;
  temperature = ADCL + (ADCH << 8);
    1e36:	84 b1       	in	r24, 0x04	; 4
    1e38:	c5 b1       	in	r28, 0x05	; 5
    1e3a:	d0 e0       	ldi	r29, 0x00	; 0
    1e3c:	dc 2f       	mov	r29, r28
    1e3e:	cc 27       	eor	r28, r28
    1e40:	c8 0f       	add	r28, r24
    1e42:	d1 1d       	adc	r29, r1
  // Since the ADC is set to use the internal VREF of 2.56 V, the resolution of the ADC is 2.5 mV. This resolution allows to measure the temperature
  // out of the LM35 with a resolution of 0.25 degree celsius, since each 10mV  increment on the LM35 output is 1 degree C.
  // If the temperature is higher than the maximum specified temperature, turn on the AC.
  if (temperature > AMBIENT_HIGH_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, HIGH);
    1e44:	c1 37       	cpi	r28, 0x71	; 113
    1e46:	d1 05       	cpc	r29, r1
    1e48:	28 f0       	brcs	.+10     	; 0x1e54 <__vector_16+0x44>
    1e4a:	41 e0       	ldi	r20, 0x01	; 1
    1e4c:	63 e4       	ldi	r22, 0x43	; 67
    1e4e:	87 e0       	ldi	r24, 0x07	; 7
    1e50:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>
  // If the temperature became below the minimum specified temperature turn off the AC.
  if (temperature < AMBIENT_LOW_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, LOW);
    1e54:	c4 35       	cpi	r28, 0x54	; 84
    1e56:	d1 05       	cpc	r29, r1
    1e58:	28 f4       	brcc	.+10     	; 0x1e64 <__vector_16+0x54>
    1e5a:	40 e0       	ldi	r20, 0x00	; 0
    1e5c:	63 e4       	ldi	r22, 0x43	; 67
    1e5e:	87 e0       	ldi	r24, 0x07	; 7
    1e60:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <DIO_write>

#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_VIA_ADC_COMPLETE_INTERRUPT
  // Since the ADC is configured in auto trigger mode with timer 0 overflow as the trigger, 
  // The overflow interrupt flag bit must be cleared by software if timer 0 overflow interrupt isn't used. 
  // Otherwise the triggering won't work and the ADC will halt.
  set_bit(TIFR, TOV0);
    1e64:	88 b7       	in	r24, 0x38	; 56
    1e66:	81 60       	ori	r24, 0x01	; 1
    1e68:	88 bf       	out	0x38, r24	; 56
#endif
    1e6a:	ff 91       	pop	r31
    1e6c:	ef 91       	pop	r30
    1e6e:	df 91       	pop	r29
    1e70:	cf 91       	pop	r28
    1e72:	bf 91       	pop	r27
    1e74:	af 91       	pop	r26
    1e76:	9f 91       	pop	r25
    1e78:	8f 91       	pop	r24
    1e7a:	7f 91       	pop	r23
    1e7c:	6f 91       	pop	r22
    1e7e:	5f 91       	pop	r21
    1e80:	4f 91       	pop	r20
    1e82:	3f 91       	pop	r19
    1e84:	2f 91       	pop	r18
    1e86:	0f 90       	pop	r0
    1e88:	0f be       	out	0x3f, r0	; 63
    1e8a:	0f 90       	pop	r0
    1e8c:	1f 90       	pop	r1
    1e8e:	18 95       	reti

00001e90 <User_DB_init>:
    return getUserByName(user_code_or_name, user);
    }
  else {
    return getUserByCode(user_code_or_name, user);
    }
  }
    1e90:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <EEPROM_init>
    1e94:	88 e0       	ldi	r24, 0x08	; 8
    1e96:	08 95       	ret

00001e98 <getUserByName>:
    1e98:	9f 92       	push	r9
    1e9a:	af 92       	push	r10
    1e9c:	bf 92       	push	r11
    1e9e:	cf 92       	push	r12
    1ea0:	df 92       	push	r13
    1ea2:	ef 92       	push	r14
    1ea4:	ff 92       	push	r15
    1ea6:	0f 93       	push	r16
    1ea8:	1f 93       	push	r17
    1eaa:	cf 93       	push	r28
    1eac:	df 93       	push	r29
    1eae:	cd b7       	in	r28, 0x3d	; 61
    1eb0:	de b7       	in	r29, 0x3e	; 62
    1eb2:	6d 97       	sbiw	r28, 0x1d	; 29
    1eb4:	0f b6       	in	r0, 0x3f	; 63
    1eb6:	f8 94       	cli
    1eb8:	de bf       	out	0x3e, r29	; 62
    1eba:	0f be       	out	0x3f, r0	; 63
    1ebc:	cd bf       	out	0x3d, r28	; 61
    1ebe:	7c 01       	movw	r14, r24
    1ec0:	6b 01       	movw	r12, r22
    1ec2:	91 2c       	mov	r9, r1
    1ec4:	6b c0       	rjmp	.+214    	; 0x1f9c <getUserByName+0x104>
    1ec6:	ae 01       	movw	r20, r28
    1ec8:	4f 5f       	subi	r20, 0xFF	; 255
    1eca:	5f 4f       	sbci	r21, 0xFF	; 255
    1ecc:	60 e0       	ldi	r22, 0x00	; 0
    1ece:	89 2d       	mov	r24, r9
    1ed0:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    1ed4:	ae 01       	movw	r20, r28
    1ed6:	4e 5f       	subi	r20, 0xFE	; 254
    1ed8:	5f 4f       	sbci	r21, 0xFF	; 255
    1eda:	61 e0       	ldi	r22, 0x01	; 1
    1edc:	89 2d       	mov	r24, r9
    1ede:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    1ee2:	b1 2c       	mov	r11, r1
    1ee4:	56 c0       	rjmp	.+172    	; 0x1f92 <getUserByName+0xfa>
    1ee6:	89 81       	ldd	r24, Y+1	; 0x01
    1ee8:	90 e0       	ldi	r25, 0x00	; 0
    1eea:	0b 2c       	mov	r0, r11
    1eec:	02 c0       	rjmp	.+4      	; 0x1ef2 <getUserByName+0x5a>
    1eee:	95 95       	asr	r25
    1ef0:	87 95       	ror	r24
    1ef2:	0a 94       	dec	r0
    1ef4:	e2 f7       	brpl	.-8      	; 0x1eee <getUserByName+0x56>
    1ef6:	80 ff       	sbrs	r24, 0
    1ef8:	4b c0       	rjmp	.+150    	; 0x1f90 <getUserByName+0xf8>
    1efa:	6f e1       	ldi	r22, 0x1F	; 31
    1efc:	b6 9e       	mul	r11, r22
    1efe:	a0 2c       	mov	r10, r0
    1f00:	11 24       	eor	r1, r1
    1f02:	68 e0       	ldi	r22, 0x08	; 8
    1f04:	6a 0d       	add	r22, r10
    1f06:	9e 01       	movw	r18, r28
    1f08:	2d 5f       	subi	r18, 0xFD	; 253
    1f0a:	3f 4f       	sbci	r19, 0xFF	; 255
    1f0c:	4d e0       	ldi	r20, 0x0D	; 13
    1f0e:	50 e0       	ldi	r21, 0x00	; 0
    1f10:	89 2d       	mov	r24, r9
    1f12:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    1f16:	be 01       	movw	r22, r28
    1f18:	6d 5f       	subi	r22, 0xFD	; 253
    1f1a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f1c:	c7 01       	movw	r24, r14
    1f1e:	0e 94 9f 13 	call	0x273e	; 0x273e <strcmp>
    1f22:	89 2b       	or	r24, r25
    1f24:	a9 f5       	brne	.+106    	; 0x1f90 <getUserByName+0xf8>
    1f26:	65 e1       	ldi	r22, 0x15	; 21
    1f28:	6a 0d       	add	r22, r10
    1f2a:	9e 01       	movw	r18, r28
    1f2c:	20 5f       	subi	r18, 0xF0	; 240
    1f2e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f30:	47 e0       	ldi	r20, 0x07	; 7
    1f32:	50 e0       	ldi	r21, 0x00	; 0
    1f34:	89 2d       	mov	r24, r9
    1f36:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    1f3a:	6c e1       	ldi	r22, 0x1C	; 28
    1f3c:	6a 0d       	add	r22, r10
    1f3e:	9e 01       	movw	r18, r28
    1f40:	29 5e       	subi	r18, 0xE9	; 233
    1f42:	3f 4f       	sbci	r19, 0xFF	; 255
    1f44:	47 e0       	ldi	r20, 0x07	; 7
    1f46:	50 e0       	ldi	r21, 0x00	; 0
    1f48:	89 2d       	mov	r24, r9
    1f4a:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    1f4e:	8a 81       	ldd	r24, Y+2	; 0x02
    1f50:	90 e0       	ldi	r25, 0x00	; 0
    1f52:	02 c0       	rjmp	.+4      	; 0x1f58 <getUserByName+0xc0>
    1f54:	95 95       	asr	r25
    1f56:	87 95       	ror	r24
    1f58:	ba 94       	dec	r11
    1f5a:	e2 f7       	brpl	.-8      	; 0x1f54 <getUserByName+0xbc>
    1f5c:	98 2f       	mov	r25, r24
    1f5e:	91 70       	andi	r25, 0x01	; 1
    1f60:	f6 01       	movw	r30, r12
    1f62:	91 93       	st	Z+, r25
    1f64:	be 01       	movw	r22, r28
    1f66:	6d 5f       	subi	r22, 0xFD	; 253
    1f68:	7f 4f       	sbci	r23, 0xFF	; 255
    1f6a:	cf 01       	movw	r24, r30
    1f6c:	0e 94 a8 13 	call	0x2750	; 0x2750 <strcpy>
    1f70:	be 01       	movw	r22, r28
    1f72:	60 5f       	subi	r22, 0xF0	; 240
    1f74:	7f 4f       	sbci	r23, 0xFF	; 255
    1f76:	c6 01       	movw	r24, r12
    1f78:	0e 96       	adiw	r24, 0x0e	; 14
    1f7a:	0e 94 a8 13 	call	0x2750	; 0x2750 <strcpy>
    1f7e:	be 01       	movw	r22, r28
    1f80:	69 5e       	subi	r22, 0xE9	; 233
    1f82:	7f 4f       	sbci	r23, 0xFF	; 255
    1f84:	c6 01       	movw	r24, r12
    1f86:	45 96       	adiw	r24, 0x15	; 21
    1f88:	0e 94 a8 13 	call	0x2750	; 0x2750 <strcpy>
    1f8c:	82 e0       	ldi	r24, 0x02	; 2
    1f8e:	0b c0       	rjmp	.+22     	; 0x1fa6 <getUserByName+0x10e>
    1f90:	b3 94       	inc	r11
    1f92:	87 e0       	ldi	r24, 0x07	; 7
    1f94:	8b 15       	cp	r24, r11
    1f96:	08 f0       	brcs	.+2      	; 0x1f9a <getUserByName+0x102>
    1f98:	a6 cf       	rjmp	.-180    	; 0x1ee6 <getUserByName+0x4e>
    1f9a:	93 94       	inc	r9
    1f9c:	87 e0       	ldi	r24, 0x07	; 7
    1f9e:	89 15       	cp	r24, r9
    1fa0:	08 f0       	brcs	.+2      	; 0x1fa4 <getUserByName+0x10c>
    1fa2:	91 cf       	rjmp	.-222    	; 0x1ec6 <getUserByName+0x2e>
    1fa4:	83 e0       	ldi	r24, 0x03	; 3
    1fa6:	6d 96       	adiw	r28, 0x1d	; 29
    1fa8:	0f b6       	in	r0, 0x3f	; 63
    1faa:	f8 94       	cli
    1fac:	de bf       	out	0x3e, r29	; 62
    1fae:	0f be       	out	0x3f, r0	; 63
    1fb0:	cd bf       	out	0x3d, r28	; 61
    1fb2:	df 91       	pop	r29
    1fb4:	cf 91       	pop	r28
    1fb6:	1f 91       	pop	r17
    1fb8:	0f 91       	pop	r16
    1fba:	ff 90       	pop	r15
    1fbc:	ef 90       	pop	r14
    1fbe:	df 90       	pop	r13
    1fc0:	cf 90       	pop	r12
    1fc2:	bf 90       	pop	r11
    1fc4:	af 90       	pop	r10
    1fc6:	9f 90       	pop	r9
    1fc8:	08 95       	ret

00001fca <getUserByCode>:
    1fca:	9f 92       	push	r9
    1fcc:	af 92       	push	r10
    1fce:	bf 92       	push	r11
    1fd0:	cf 92       	push	r12
    1fd2:	df 92       	push	r13
    1fd4:	ef 92       	push	r14
    1fd6:	ff 92       	push	r15
    1fd8:	0f 93       	push	r16
    1fda:	1f 93       	push	r17
    1fdc:	cf 93       	push	r28
    1fde:	df 93       	push	r29
    1fe0:	cd b7       	in	r28, 0x3d	; 61
    1fe2:	de b7       	in	r29, 0x3e	; 62
    1fe4:	6d 97       	sbiw	r28, 0x1d	; 29
    1fe6:	0f b6       	in	r0, 0x3f	; 63
    1fe8:	f8 94       	cli
    1fea:	de bf       	out	0x3e, r29	; 62
    1fec:	0f be       	out	0x3f, r0	; 63
    1fee:	cd bf       	out	0x3d, r28	; 61
    1ff0:	7c 01       	movw	r14, r24
    1ff2:	6b 01       	movw	r12, r22
    1ff4:	91 2c       	mov	r9, r1
    1ff6:	6b c0       	rjmp	.+214    	; 0x20ce <getUserByCode+0x104>
    1ff8:	ae 01       	movw	r20, r28
    1ffa:	4f 5f       	subi	r20, 0xFF	; 255
    1ffc:	5f 4f       	sbci	r21, 0xFF	; 255
    1ffe:	60 e0       	ldi	r22, 0x00	; 0
    2000:	89 2d       	mov	r24, r9
    2002:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    2006:	ae 01       	movw	r20, r28
    2008:	4e 5f       	subi	r20, 0xFE	; 254
    200a:	5f 4f       	sbci	r21, 0xFF	; 255
    200c:	61 e0       	ldi	r22, 0x01	; 1
    200e:	89 2d       	mov	r24, r9
    2010:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    2014:	b1 2c       	mov	r11, r1
    2016:	56 c0       	rjmp	.+172    	; 0x20c4 <getUserByCode+0xfa>
    2018:	89 81       	ldd	r24, Y+1	; 0x01
    201a:	90 e0       	ldi	r25, 0x00	; 0
    201c:	0b 2c       	mov	r0, r11
    201e:	02 c0       	rjmp	.+4      	; 0x2024 <getUserByCode+0x5a>
    2020:	95 95       	asr	r25
    2022:	87 95       	ror	r24
    2024:	0a 94       	dec	r0
    2026:	e2 f7       	brpl	.-8      	; 0x2020 <getUserByCode+0x56>
    2028:	80 ff       	sbrs	r24, 0
    202a:	4b c0       	rjmp	.+150    	; 0x20c2 <getUserByCode+0xf8>
    202c:	6f e1       	ldi	r22, 0x1F	; 31
    202e:	b6 9e       	mul	r11, r22
    2030:	a0 2c       	mov	r10, r0
    2032:	11 24       	eor	r1, r1
    2034:	65 e1       	ldi	r22, 0x15	; 21
    2036:	6a 0d       	add	r22, r10
    2038:	9e 01       	movw	r18, r28
    203a:	20 5f       	subi	r18, 0xF0	; 240
    203c:	3f 4f       	sbci	r19, 0xFF	; 255
    203e:	47 e0       	ldi	r20, 0x07	; 7
    2040:	50 e0       	ldi	r21, 0x00	; 0
    2042:	89 2d       	mov	r24, r9
    2044:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    2048:	be 01       	movw	r22, r28
    204a:	60 5f       	subi	r22, 0xF0	; 240
    204c:	7f 4f       	sbci	r23, 0xFF	; 255
    204e:	c7 01       	movw	r24, r14
    2050:	0e 94 9f 13 	call	0x273e	; 0x273e <strcmp>
    2054:	89 2b       	or	r24, r25
    2056:	a9 f5       	brne	.+106    	; 0x20c2 <getUserByCode+0xf8>
    2058:	68 e0       	ldi	r22, 0x08	; 8
    205a:	6a 0d       	add	r22, r10
    205c:	9e 01       	movw	r18, r28
    205e:	2d 5f       	subi	r18, 0xFD	; 253
    2060:	3f 4f       	sbci	r19, 0xFF	; 255
    2062:	4d e0       	ldi	r20, 0x0D	; 13
    2064:	50 e0       	ldi	r21, 0x00	; 0
    2066:	89 2d       	mov	r24, r9
    2068:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    206c:	6c e1       	ldi	r22, 0x1C	; 28
    206e:	6a 0d       	add	r22, r10
    2070:	9e 01       	movw	r18, r28
    2072:	29 5e       	subi	r18, 0xE9	; 233
    2074:	3f 4f       	sbci	r19, 0xFF	; 255
    2076:	47 e0       	ldi	r20, 0x07	; 7
    2078:	50 e0       	ldi	r21, 0x00	; 0
    207a:	89 2d       	mov	r24, r9
    207c:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    2080:	8a 81       	ldd	r24, Y+2	; 0x02
    2082:	90 e0       	ldi	r25, 0x00	; 0
    2084:	02 c0       	rjmp	.+4      	; 0x208a <getUserByCode+0xc0>
    2086:	95 95       	asr	r25
    2088:	87 95       	ror	r24
    208a:	ba 94       	dec	r11
    208c:	e2 f7       	brpl	.-8      	; 0x2086 <getUserByCode+0xbc>
    208e:	98 2f       	mov	r25, r24
    2090:	91 70       	andi	r25, 0x01	; 1
    2092:	f6 01       	movw	r30, r12
    2094:	91 93       	st	Z+, r25
    2096:	be 01       	movw	r22, r28
    2098:	6d 5f       	subi	r22, 0xFD	; 253
    209a:	7f 4f       	sbci	r23, 0xFF	; 255
    209c:	cf 01       	movw	r24, r30
    209e:	0e 94 a8 13 	call	0x2750	; 0x2750 <strcpy>
    20a2:	be 01       	movw	r22, r28
    20a4:	60 5f       	subi	r22, 0xF0	; 240
    20a6:	7f 4f       	sbci	r23, 0xFF	; 255
    20a8:	c6 01       	movw	r24, r12
    20aa:	0e 96       	adiw	r24, 0x0e	; 14
    20ac:	0e 94 a8 13 	call	0x2750	; 0x2750 <strcpy>
    20b0:	be 01       	movw	r22, r28
    20b2:	69 5e       	subi	r22, 0xE9	; 233
    20b4:	7f 4f       	sbci	r23, 0xFF	; 255
    20b6:	c6 01       	movw	r24, r12
    20b8:	45 96       	adiw	r24, 0x15	; 21
    20ba:	0e 94 a8 13 	call	0x2750	; 0x2750 <strcpy>
    20be:	82 e0       	ldi	r24, 0x02	; 2
    20c0:	0b c0       	rjmp	.+22     	; 0x20d8 <getUserByCode+0x10e>
    20c2:	b3 94       	inc	r11
    20c4:	87 e0       	ldi	r24, 0x07	; 7
    20c6:	8b 15       	cp	r24, r11
    20c8:	08 f0       	brcs	.+2      	; 0x20cc <getUserByCode+0x102>
    20ca:	a6 cf       	rjmp	.-180    	; 0x2018 <getUserByCode+0x4e>
    20cc:	93 94       	inc	r9
    20ce:	87 e0       	ldi	r24, 0x07	; 7
    20d0:	89 15       	cp	r24, r9
    20d2:	08 f0       	brcs	.+2      	; 0x20d6 <getUserByCode+0x10c>
    20d4:	91 cf       	rjmp	.-222    	; 0x1ff8 <getUserByCode+0x2e>
    20d6:	83 e0       	ldi	r24, 0x03	; 3
    20d8:	6d 96       	adiw	r28, 0x1d	; 29
    20da:	0f b6       	in	r0, 0x3f	; 63
    20dc:	f8 94       	cli
    20de:	de bf       	out	0x3e, r29	; 62
    20e0:	0f be       	out	0x3f, r0	; 63
    20e2:	cd bf       	out	0x3d, r28	; 61
    20e4:	df 91       	pop	r29
    20e6:	cf 91       	pop	r28
    20e8:	1f 91       	pop	r17
    20ea:	0f 91       	pop	r16
    20ec:	ff 90       	pop	r15
    20ee:	ef 90       	pop	r14
    20f0:	df 90       	pop	r13
    20f2:	cf 90       	pop	r12
    20f4:	bf 90       	pop	r11
    20f6:	af 90       	pop	r10
    20f8:	9f 90       	pop	r9
    20fa:	08 95       	ret

000020fc <write_user>:

void write_user(u8 userBlockIndex, ST_User_t* user) {
    20fc:	ef 92       	push	r14
    20fe:	ff 92       	push	r15
    2100:	0f 93       	push	r16
    2102:	1f 93       	push	r17
    2104:	cf 93       	push	r28
    2106:	df 93       	push	r29
    2108:	00 d0       	rcall	.+0      	; 0x210a <write_user+0xe>
    210a:	cd b7       	in	r28, 0x3d	; 61
    210c:	de b7       	in	r29, 0x3e	; 62
    210e:	7b 01       	movw	r14, r22
  // Get the user block location (page - index)
  u8 page = userBlockIndex / 8;
    2110:	08 2f       	mov	r16, r24
    2112:	06 95       	lsr	r16
    2114:	06 95       	lsr	r16
    2116:	06 95       	lsr	r16
  u8 blockNumber = userBlockIndex % 8;
    2118:	18 2f       	mov	r17, r24
    211a:	17 70       	andi	r17, 0x07	; 7
  // Read and update the block status (reserve the block). And update the user authority level flag if the user is admin
  u8 usersBlockStatus, usersAuthorityLevel;
  EEPROM_read_byte(page, 0, &usersBlockStatus);
    211c:	ae 01       	movw	r20, r28
    211e:	4f 5f       	subi	r20, 0xFF	; 255
    2120:	5f 4f       	sbci	r21, 0xFF	; 255
    2122:	60 e0       	ldi	r22, 0x00	; 0
    2124:	80 2f       	mov	r24, r16
    2126:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
  EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    212a:	ae 01       	movw	r20, r28
    212c:	4e 5f       	subi	r20, 0xFE	; 254
    212e:	5f 4f       	sbci	r21, 0xFF	; 255
    2130:	61 e0       	ldi	r22, 0x01	; 1
    2132:	80 2f       	mov	r24, r16
    2134:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
  set_bit(usersBlockStatus, blockNumber);
    2138:	81 e0       	ldi	r24, 0x01	; 1
    213a:	90 e0       	ldi	r25, 0x00	; 0
    213c:	01 2e       	mov	r0, r17
    213e:	02 c0       	rjmp	.+4      	; 0x2144 <write_user+0x48>
    2140:	88 0f       	add	r24, r24
    2142:	99 1f       	adc	r25, r25
    2144:	0a 94       	dec	r0
    2146:	e2 f7       	brpl	.-8      	; 0x2140 <write_user+0x44>
    2148:	49 81       	ldd	r20, Y+1	; 0x01
    214a:	48 2b       	or	r20, r24
    214c:	49 83       	std	Y+1, r20	; 0x01
  if (user->isAdmin) set_bit(usersAuthorityLevel, blockNumber);
    214e:	f7 01       	movw	r30, r14
    2150:	20 81       	ld	r18, Z
    2152:	22 23       	and	r18, r18
    2154:	19 f0       	breq	.+6      	; 0x215c <write_user+0x60>
    2156:	9a 81       	ldd	r25, Y+2	; 0x02
    2158:	89 2b       	or	r24, r25
    215a:	8a 83       	std	Y+2, r24	; 0x02
  EEPROM_write_byte(page, 0, usersBlockStatus);
    215c:	60 e0       	ldi	r22, 0x00	; 0
    215e:	80 2f       	mov	r24, r16
    2160:	0e 94 2e 01 	call	0x25c	; 0x25c <EEPROM_write_byte>
  EEPROM_write_byte(page, 1, usersAuthorityLevel);
    2164:	4a 81       	ldd	r20, Y+2	; 0x02
    2166:	61 e0       	ldi	r22, 0x01	; 1
    2168:	80 2f       	mov	r24, r16
    216a:	0e 94 2e 01 	call	0x25c	; 0x25c <EEPROM_write_byte>
  // Write the user data
  EEPROM_write_block(page, 8 + 31 * blockNumber, 13, user->name);
    216e:	97 01       	movw	r18, r14
    2170:	2f 5f       	subi	r18, 0xFF	; 255
    2172:	3f 4f       	sbci	r19, 0xFF	; 255
    2174:	6f e1       	ldi	r22, 0x1F	; 31
    2176:	16 9f       	mul	r17, r22
    2178:	10 2d       	mov	r17, r0
    217a:	11 24       	eor	r1, r1
    217c:	68 e0       	ldi	r22, 0x08	; 8
    217e:	61 0f       	add	r22, r17
    2180:	4d e0       	ldi	r20, 0x0D	; 13
    2182:	50 e0       	ldi	r21, 0x00	; 0
    2184:	80 2f       	mov	r24, r16
    2186:	0e 94 4d 01 	call	0x29a	; 0x29a <EEPROM_write_block>
  EEPROM_write_block(page, 21 + 31 * blockNumber, 7, user->code);
    218a:	97 01       	movw	r18, r14
    218c:	22 5f       	subi	r18, 0xF2	; 242
    218e:	3f 4f       	sbci	r19, 0xFF	; 255
    2190:	65 e1       	ldi	r22, 0x15	; 21
    2192:	61 0f       	add	r22, r17
    2194:	47 e0       	ldi	r20, 0x07	; 7
    2196:	50 e0       	ldi	r21, 0x00	; 0
    2198:	80 2f       	mov	r24, r16
    219a:	0e 94 4d 01 	call	0x29a	; 0x29a <EEPROM_write_block>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
    219e:	97 01       	movw	r18, r14
    21a0:	2b 5e       	subi	r18, 0xEB	; 235
    21a2:	3f 4f       	sbci	r19, 0xFF	; 255
    21a4:	6c e1       	ldi	r22, 0x1C	; 28
    21a6:	61 0f       	add	r22, r17
    21a8:	4b e0       	ldi	r20, 0x0B	; 11
    21aa:	50 e0       	ldi	r21, 0x00	; 0
    21ac:	80 2f       	mov	r24, r16
    21ae:	0e 94 4d 01 	call	0x29a	; 0x29a <EEPROM_write_block>
  }
    21b2:	0f 90       	pop	r0
    21b4:	0f 90       	pop	r0
    21b6:	df 91       	pop	r29
    21b8:	cf 91       	pop	r28
    21ba:	1f 91       	pop	r17
    21bc:	0f 91       	pop	r16
    21be:	ff 90       	pop	r15
    21c0:	ef 90       	pop	r14
    21c2:	08 95       	ret

000021c4 <add_user>:

EN_UserStatusCode_t add_user(ST_User_t* user) {
    21c4:	ef 92       	push	r14
    21c6:	ff 92       	push	r15
    21c8:	1f 93       	push	r17
    21ca:	cf 93       	push	r28
    21cc:	df 93       	push	r29
    21ce:	1f 92       	push	r1
    21d0:	cd b7       	in	r28, 0x3d	; 61
    21d2:	de b7       	in	r29, 0x3e	; 62
    21d4:	7c 01       	movw	r14, r24
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    21d6:	10 e0       	ldi	r17, 0x00	; 0
    21d8:	1a c0       	rjmp	.+52     	; 0x220e <add_user+0x4a>
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    21da:	ae 01       	movw	r20, r28
    21dc:	4f 5f       	subi	r20, 0xFF	; 255
    21de:	5f 4f       	sbci	r21, 0xFF	; 255
    21e0:	60 e0       	ldi	r22, 0x00	; 0
    21e2:	81 2f       	mov	r24, r17
    21e4:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    if (usersBlockStatus != 0xFF) {
    21e8:	99 81       	ldd	r25, Y+1	; 0x01
    21ea:	9f 3f       	cpi	r25, 0xFF	; 255
    21ec:	79 f0       	breq	.+30     	; 0x220c <add_user+0x48>
    21ee:	02 c0       	rjmp	.+4      	; 0x21f4 <add_user+0x30>
      // Find the block number in the page
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
    21f0:	8f 5f       	subi	r24, 0xFF	; 255
    21f2:	01 c0       	rjmp	.+2      	; 0x21f6 <add_user+0x32>
    21f4:	80 e0       	ldi	r24, 0x00	; 0
    21f6:	29 2f       	mov	r18, r25
    21f8:	30 e0       	ldi	r19, 0x00	; 0
    21fa:	08 2e       	mov	r0, r24
    21fc:	02 c0       	rjmp	.+4      	; 0x2202 <add_user+0x3e>
    21fe:	35 95       	asr	r19
    2200:	27 95       	ror	r18
    2202:	0a 94       	dec	r0
    2204:	e2 f7       	brpl	.-8      	; 0x21fe <add_user+0x3a>
    2206:	20 fd       	sbrc	r18, 0
    2208:	f3 cf       	rjmp	.-26     	; 0x21f0 <add_user+0x2c>
    220a:	04 c0       	rjmp	.+8      	; 0x2214 <add_user+0x50>
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    220c:	1f 5f       	subi	r17, 0xFF	; 255
    220e:	18 30       	cpi	r17, 0x08	; 8
    2210:	20 f3       	brcs	.-56     	; 0x21da <add_user+0x16>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
    2212:	80 e0       	ldi	r24, 0x00	; 0
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    2214:	18 30       	cpi	r17, 0x08	; 8
    2216:	49 f0       	breq	.+18     	; 0x222a <add_user+0x66>
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
    2218:	11 0f       	add	r17, r17
    221a:	11 0f       	add	r17, r17
    221c:	11 0f       	add	r17, r17
  write_user(availableUserBlockIndex, user);
    221e:	b7 01       	movw	r22, r14
    2220:	81 0f       	add	r24, r17
    2222:	0e 94 7e 10 	call	0x20fc	; 0x20fc <write_user>
  return USER_ADDED_SUCCESSFULLY;
    2226:	8a e0       	ldi	r24, 0x0A	; 10
    2228:	01 c0       	rjmp	.+2      	; 0x222c <add_user+0x68>
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    222a:	8c e0       	ldi	r24, 0x0C	; 12
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
  write_user(availableUserBlockIndex, user);
  return USER_ADDED_SUCCESSFULLY;
  }
    222c:	0f 90       	pop	r0
    222e:	df 91       	pop	r29
    2230:	cf 91       	pop	r28
    2232:	1f 91       	pop	r17
    2234:	ff 90       	pop	r15
    2236:	ef 90       	pop	r14
    2238:	08 95       	ret

0000223a <delete_user>:

EN_UserStatusCode_t delete_user(ST_User_t* user) {
    223a:	cf 92       	push	r12
    223c:	df 92       	push	r13
    223e:	ef 92       	push	r14
    2240:	ff 92       	push	r15
    2242:	0f 93       	push	r16
    2244:	1f 93       	push	r17
    2246:	cf 93       	push	r28
    2248:	df 93       	push	r29
    224a:	cd b7       	in	r28, 0x3d	; 61
    224c:	de b7       	in	r29, 0x3e	; 62
    224e:	29 97       	sbiw	r28, 0x09	; 9
    2250:	0f b6       	in	r0, 0x3f	; 63
    2252:	f8 94       	cli
    2254:	de bf       	out	0x3e, r29	; 62
    2256:	0f be       	out	0x3f, r0	; 63
    2258:	cd bf       	out	0x3d, r28	; 61
    225a:	6c 01       	movw	r12, r24
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    225c:	00 e0       	ldi	r16, 0x00	; 0
    225e:	4d c0       	rjmp	.+154    	; 0x22fa <delete_user+0xc0>
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    2260:	ae 01       	movw	r20, r28
    2262:	4f 5f       	subi	r20, 0xFF	; 255
    2264:	5f 4f       	sbci	r21, 0xFF	; 255
    2266:	60 e0       	ldi	r22, 0x00	; 0
    2268:	80 2f       	mov	r24, r16
    226a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    226e:	ae 01       	movw	r20, r28
    2270:	4e 5f       	subi	r20, 0xFE	; 254
    2272:	5f 4f       	sbci	r21, 0xFF	; 255
    2274:	61 e0       	ldi	r22, 0x01	; 1
    2276:	80 2f       	mov	r24, r16
    2278:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    for (userIndex = 0; userIndex < 8;userIndex++) {
    227c:	10 e0       	ldi	r17, 0x00	; 0
    227e:	3a c0       	rjmp	.+116    	; 0x22f4 <delete_user+0xba>
      if (read_bit(usersBlockStatus, userIndex)) {  // If the user isn't deleted
    2280:	89 81       	ldd	r24, Y+1	; 0x01
    2282:	90 e0       	ldi	r25, 0x00	; 0
    2284:	01 2e       	mov	r0, r17
    2286:	02 c0       	rjmp	.+4      	; 0x228c <delete_user+0x52>
    2288:	95 95       	asr	r25
    228a:	87 95       	ror	r24
    228c:	0a 94       	dec	r0
    228e:	e2 f7       	brpl	.-8      	; 0x2288 <delete_user+0x4e>
    2290:	80 ff       	sbrs	r24, 0
    2292:	2f c0       	rjmp	.+94     	; 0x22f2 <delete_user+0xb8>
        EEPROM_read_block(page, 21 + 31 * userIndex, 7, tempUserCode);
    2294:	6f e1       	ldi	r22, 0x1F	; 31
    2296:	16 9f       	mul	r17, r22
    2298:	60 2d       	mov	r22, r0
    229a:	11 24       	eor	r1, r1
    229c:	6b 5e       	subi	r22, 0xEB	; 235
    229e:	9e 01       	movw	r18, r28
    22a0:	2d 5f       	subi	r18, 0xFD	; 253
    22a2:	3f 4f       	sbci	r19, 0xFF	; 255
    22a4:	47 e0       	ldi	r20, 0x07	; 7
    22a6:	50 e0       	ldi	r21, 0x00	; 0
    22a8:	80 2f       	mov	r24, r16
    22aa:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
        if (strcmp(user->code, tempUserCode) == 0) { // User has been found
    22ae:	be 01       	movw	r22, r28
    22b0:	6d 5f       	subi	r22, 0xFD	; 253
    22b2:	7f 4f       	sbci	r23, 0xFF	; 255
    22b4:	c6 01       	movw	r24, r12
    22b6:	0e 96       	adiw	r24, 0x0e	; 14
    22b8:	0e 94 9f 13 	call	0x273e	; 0x273e <strcmp>
    22bc:	89 2b       	or	r24, r25
    22be:	c9 f4       	brne	.+50     	; 0x22f2 <delete_user+0xb8>
          // Mark it as deleted
          clear_bit(usersBlockStatus, userIndex);
    22c0:	81 e0       	ldi	r24, 0x01	; 1
    22c2:	90 e0       	ldi	r25, 0x00	; 0
    22c4:	02 c0       	rjmp	.+4      	; 0x22ca <delete_user+0x90>
    22c6:	88 0f       	add	r24, r24
    22c8:	99 1f       	adc	r25, r25
    22ca:	1a 95       	dec	r17
    22cc:	e2 f7       	brpl	.-8      	; 0x22c6 <delete_user+0x8c>
    22ce:	80 95       	com	r24
    22d0:	49 81       	ldd	r20, Y+1	; 0x01
    22d2:	48 23       	and	r20, r24
    22d4:	49 83       	std	Y+1, r20	; 0x01
          clear_bit(usersAuthorityLevel, userIndex);
    22d6:	9a 81       	ldd	r25, Y+2	; 0x02
    22d8:	89 23       	and	r24, r25
    22da:	8a 83       	std	Y+2, r24	; 0x02
          EEPROM_write_byte(page, 0, usersBlockStatus);
    22dc:	60 e0       	ldi	r22, 0x00	; 0
    22de:	80 2f       	mov	r24, r16
    22e0:	0e 94 2e 01 	call	0x25c	; 0x25c <EEPROM_write_byte>
          EEPROM_write_byte(page, 1, usersAuthorityLevel);
    22e4:	4a 81       	ldd	r20, Y+2	; 0x02
    22e6:	61 e0       	ldi	r22, 0x01	; 1
    22e8:	80 2f       	mov	r24, r16
    22ea:	0e 94 2e 01 	call	0x25c	; 0x25c <EEPROM_write_byte>
          return USER_DELETED_SUCCESSFULLY;
    22ee:	8b e0       	ldi	r24, 0x0B	; 11
    22f0:	08 c0       	rjmp	.+16     	; 0x2302 <delete_user+0xc8>
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    for (userIndex = 0; userIndex < 8;userIndex++) {
    22f2:	1f 5f       	subi	r17, 0xFF	; 255
    22f4:	18 30       	cpi	r17, 0x08	; 8
    22f6:	20 f2       	brcs	.-120    	; 0x2280 <delete_user+0x46>
EN_UserStatusCode_t delete_user(ST_User_t* user) {
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    22f8:	0f 5f       	subi	r16, 0xFF	; 255
    22fa:	08 30       	cpi	r16, 0x08	; 8
    22fc:	08 f4       	brcc	.+2      	; 0x2300 <delete_user+0xc6>
    22fe:	b0 cf       	rjmp	.-160    	; 0x2260 <delete_user+0x26>
          return USER_DELETED_SUCCESSFULLY;
          }
        }
      }
    }
  return USER_NOT_FOUND;
    2300:	83 e0       	ldi	r24, 0x03	; 3
  }
    2302:	29 96       	adiw	r28, 0x09	; 9
    2304:	0f b6       	in	r0, 0x3f	; 63
    2306:	f8 94       	cli
    2308:	de bf       	out	0x3e, r29	; 62
    230a:	0f be       	out	0x3f, r0	; 63
    230c:	cd bf       	out	0x3d, r28	; 61
    230e:	df 91       	pop	r29
    2310:	cf 91       	pop	r28
    2312:	1f 91       	pop	r17
    2314:	0f 91       	pop	r16
    2316:	ff 90       	pop	r15
    2318:	ef 90       	pop	r14
    231a:	df 90       	pop	r13
    231c:	cf 90       	pop	r12
    231e:	08 95       	ret

00002320 <__subsf3>:
    2320:	50 58       	subi	r21, 0x80	; 128

00002322 <__addsf3>:
    2322:	bb 27       	eor	r27, r27
    2324:	aa 27       	eor	r26, r26
    2326:	0e 94 a8 11 	call	0x2350	; 0x2350 <__addsf3x>
    232a:	0c 94 f2 12 	jmp	0x25e4	; 0x25e4 <__fp_round>
    232e:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <__fp_pscA>
    2332:	38 f0       	brcs	.+14     	; 0x2342 <__addsf3+0x20>
    2334:	0e 94 eb 12 	call	0x25d6	; 0x25d6 <__fp_pscB>
    2338:	20 f0       	brcs	.+8      	; 0x2342 <__addsf3+0x20>
    233a:	39 f4       	brne	.+14     	; 0x234a <__addsf3+0x28>
    233c:	9f 3f       	cpi	r25, 0xFF	; 255
    233e:	19 f4       	brne	.+6      	; 0x2346 <__addsf3+0x24>
    2340:	26 f4       	brtc	.+8      	; 0x234a <__addsf3+0x28>
    2342:	0c 94 e1 12 	jmp	0x25c2	; 0x25c2 <__fp_nan>
    2346:	0e f4       	brtc	.+2      	; 0x234a <__addsf3+0x28>
    2348:	e0 95       	com	r30
    234a:	e7 fb       	bst	r30, 7
    234c:	0c 94 db 12 	jmp	0x25b6	; 0x25b6 <__fp_inf>

00002350 <__addsf3x>:
    2350:	e9 2f       	mov	r30, r25
    2352:	0e 94 03 13 	call	0x2606	; 0x2606 <__fp_split3>
    2356:	58 f3       	brcs	.-42     	; 0x232e <__addsf3+0xc>
    2358:	ba 17       	cp	r27, r26
    235a:	62 07       	cpc	r22, r18
    235c:	73 07       	cpc	r23, r19
    235e:	84 07       	cpc	r24, r20
    2360:	95 07       	cpc	r25, r21
    2362:	20 f0       	brcs	.+8      	; 0x236c <__addsf3x+0x1c>
    2364:	79 f4       	brne	.+30     	; 0x2384 <__addsf3x+0x34>
    2366:	a6 f5       	brtc	.+104    	; 0x23d0 <__addsf3x+0x80>
    2368:	0c 94 25 13 	jmp	0x264a	; 0x264a <__fp_zero>
    236c:	0e f4       	brtc	.+2      	; 0x2370 <__addsf3x+0x20>
    236e:	e0 95       	com	r30
    2370:	0b 2e       	mov	r0, r27
    2372:	ba 2f       	mov	r27, r26
    2374:	a0 2d       	mov	r26, r0
    2376:	0b 01       	movw	r0, r22
    2378:	b9 01       	movw	r22, r18
    237a:	90 01       	movw	r18, r0
    237c:	0c 01       	movw	r0, r24
    237e:	ca 01       	movw	r24, r20
    2380:	a0 01       	movw	r20, r0
    2382:	11 24       	eor	r1, r1
    2384:	ff 27       	eor	r31, r31
    2386:	59 1b       	sub	r21, r25
    2388:	99 f0       	breq	.+38     	; 0x23b0 <__addsf3x+0x60>
    238a:	59 3f       	cpi	r21, 0xF9	; 249
    238c:	50 f4       	brcc	.+20     	; 0x23a2 <__addsf3x+0x52>
    238e:	50 3e       	cpi	r21, 0xE0	; 224
    2390:	68 f1       	brcs	.+90     	; 0x23ec <__addsf3x+0x9c>
    2392:	1a 16       	cp	r1, r26
    2394:	f0 40       	sbci	r31, 0x00	; 0
    2396:	a2 2f       	mov	r26, r18
    2398:	23 2f       	mov	r18, r19
    239a:	34 2f       	mov	r19, r20
    239c:	44 27       	eor	r20, r20
    239e:	58 5f       	subi	r21, 0xF8	; 248
    23a0:	f3 cf       	rjmp	.-26     	; 0x2388 <__addsf3x+0x38>
    23a2:	46 95       	lsr	r20
    23a4:	37 95       	ror	r19
    23a6:	27 95       	ror	r18
    23a8:	a7 95       	ror	r26
    23aa:	f0 40       	sbci	r31, 0x00	; 0
    23ac:	53 95       	inc	r21
    23ae:	c9 f7       	brne	.-14     	; 0x23a2 <__addsf3x+0x52>
    23b0:	7e f4       	brtc	.+30     	; 0x23d0 <__addsf3x+0x80>
    23b2:	1f 16       	cp	r1, r31
    23b4:	ba 0b       	sbc	r27, r26
    23b6:	62 0b       	sbc	r22, r18
    23b8:	73 0b       	sbc	r23, r19
    23ba:	84 0b       	sbc	r24, r20
    23bc:	ba f0       	brmi	.+46     	; 0x23ec <__addsf3x+0x9c>
    23be:	91 50       	subi	r25, 0x01	; 1
    23c0:	a1 f0       	breq	.+40     	; 0x23ea <__addsf3x+0x9a>
    23c2:	ff 0f       	add	r31, r31
    23c4:	bb 1f       	adc	r27, r27
    23c6:	66 1f       	adc	r22, r22
    23c8:	77 1f       	adc	r23, r23
    23ca:	88 1f       	adc	r24, r24
    23cc:	c2 f7       	brpl	.-16     	; 0x23be <__addsf3x+0x6e>
    23ce:	0e c0       	rjmp	.+28     	; 0x23ec <__addsf3x+0x9c>
    23d0:	ba 0f       	add	r27, r26
    23d2:	62 1f       	adc	r22, r18
    23d4:	73 1f       	adc	r23, r19
    23d6:	84 1f       	adc	r24, r20
    23d8:	48 f4       	brcc	.+18     	; 0x23ec <__addsf3x+0x9c>
    23da:	87 95       	ror	r24
    23dc:	77 95       	ror	r23
    23de:	67 95       	ror	r22
    23e0:	b7 95       	ror	r27
    23e2:	f7 95       	ror	r31
    23e4:	9e 3f       	cpi	r25, 0xFE	; 254
    23e6:	08 f0       	brcs	.+2      	; 0x23ea <__addsf3x+0x9a>
    23e8:	b0 cf       	rjmp	.-160    	; 0x234a <__addsf3+0x28>
    23ea:	93 95       	inc	r25
    23ec:	88 0f       	add	r24, r24
    23ee:	08 f0       	brcs	.+2      	; 0x23f2 <__addsf3x+0xa2>
    23f0:	99 27       	eor	r25, r25
    23f2:	ee 0f       	add	r30, r30
    23f4:	97 95       	ror	r25
    23f6:	87 95       	ror	r24
    23f8:	08 95       	ret

000023fa <__divsf3>:
    23fa:	0e 94 11 12 	call	0x2422	; 0x2422 <__divsf3x>
    23fe:	0c 94 f2 12 	jmp	0x25e4	; 0x25e4 <__fp_round>
    2402:	0e 94 eb 12 	call	0x25d6	; 0x25d6 <__fp_pscB>
    2406:	58 f0       	brcs	.+22     	; 0x241e <__divsf3+0x24>
    2408:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <__fp_pscA>
    240c:	40 f0       	brcs	.+16     	; 0x241e <__divsf3+0x24>
    240e:	29 f4       	brne	.+10     	; 0x241a <__divsf3+0x20>
    2410:	5f 3f       	cpi	r21, 0xFF	; 255
    2412:	29 f0       	breq	.+10     	; 0x241e <__divsf3+0x24>
    2414:	0c 94 db 12 	jmp	0x25b6	; 0x25b6 <__fp_inf>
    2418:	51 11       	cpse	r21, r1
    241a:	0c 94 26 13 	jmp	0x264c	; 0x264c <__fp_szero>
    241e:	0c 94 e1 12 	jmp	0x25c2	; 0x25c2 <__fp_nan>

00002422 <__divsf3x>:
    2422:	0e 94 03 13 	call	0x2606	; 0x2606 <__fp_split3>
    2426:	68 f3       	brcs	.-38     	; 0x2402 <__divsf3+0x8>

00002428 <__divsf3_pse>:
    2428:	99 23       	and	r25, r25
    242a:	b1 f3       	breq	.-20     	; 0x2418 <__divsf3+0x1e>
    242c:	55 23       	and	r21, r21
    242e:	91 f3       	breq	.-28     	; 0x2414 <__divsf3+0x1a>
    2430:	95 1b       	sub	r25, r21
    2432:	55 0b       	sbc	r21, r21
    2434:	bb 27       	eor	r27, r27
    2436:	aa 27       	eor	r26, r26
    2438:	62 17       	cp	r22, r18
    243a:	73 07       	cpc	r23, r19
    243c:	84 07       	cpc	r24, r20
    243e:	38 f0       	brcs	.+14     	; 0x244e <__divsf3_pse+0x26>
    2440:	9f 5f       	subi	r25, 0xFF	; 255
    2442:	5f 4f       	sbci	r21, 0xFF	; 255
    2444:	22 0f       	add	r18, r18
    2446:	33 1f       	adc	r19, r19
    2448:	44 1f       	adc	r20, r20
    244a:	aa 1f       	adc	r26, r26
    244c:	a9 f3       	breq	.-22     	; 0x2438 <__divsf3_pse+0x10>
    244e:	35 d0       	rcall	.+106    	; 0x24ba <__divsf3_pse+0x92>
    2450:	0e 2e       	mov	r0, r30
    2452:	3a f0       	brmi	.+14     	; 0x2462 <__divsf3_pse+0x3a>
    2454:	e0 e8       	ldi	r30, 0x80	; 128
    2456:	32 d0       	rcall	.+100    	; 0x24bc <__divsf3_pse+0x94>
    2458:	91 50       	subi	r25, 0x01	; 1
    245a:	50 40       	sbci	r21, 0x00	; 0
    245c:	e6 95       	lsr	r30
    245e:	00 1c       	adc	r0, r0
    2460:	ca f7       	brpl	.-14     	; 0x2454 <__divsf3_pse+0x2c>
    2462:	2b d0       	rcall	.+86     	; 0x24ba <__divsf3_pse+0x92>
    2464:	fe 2f       	mov	r31, r30
    2466:	29 d0       	rcall	.+82     	; 0x24ba <__divsf3_pse+0x92>
    2468:	66 0f       	add	r22, r22
    246a:	77 1f       	adc	r23, r23
    246c:	88 1f       	adc	r24, r24
    246e:	bb 1f       	adc	r27, r27
    2470:	26 17       	cp	r18, r22
    2472:	37 07       	cpc	r19, r23
    2474:	48 07       	cpc	r20, r24
    2476:	ab 07       	cpc	r26, r27
    2478:	b0 e8       	ldi	r27, 0x80	; 128
    247a:	09 f0       	breq	.+2      	; 0x247e <__divsf3_pse+0x56>
    247c:	bb 0b       	sbc	r27, r27
    247e:	80 2d       	mov	r24, r0
    2480:	bf 01       	movw	r22, r30
    2482:	ff 27       	eor	r31, r31
    2484:	93 58       	subi	r25, 0x83	; 131
    2486:	5f 4f       	sbci	r21, 0xFF	; 255
    2488:	3a f0       	brmi	.+14     	; 0x2498 <__divsf3_pse+0x70>
    248a:	9e 3f       	cpi	r25, 0xFE	; 254
    248c:	51 05       	cpc	r21, r1
    248e:	78 f0       	brcs	.+30     	; 0x24ae <__divsf3_pse+0x86>
    2490:	0c 94 db 12 	jmp	0x25b6	; 0x25b6 <__fp_inf>
    2494:	0c 94 26 13 	jmp	0x264c	; 0x264c <__fp_szero>
    2498:	5f 3f       	cpi	r21, 0xFF	; 255
    249a:	e4 f3       	brlt	.-8      	; 0x2494 <__divsf3_pse+0x6c>
    249c:	98 3e       	cpi	r25, 0xE8	; 232
    249e:	d4 f3       	brlt	.-12     	; 0x2494 <__divsf3_pse+0x6c>
    24a0:	86 95       	lsr	r24
    24a2:	77 95       	ror	r23
    24a4:	67 95       	ror	r22
    24a6:	b7 95       	ror	r27
    24a8:	f7 95       	ror	r31
    24aa:	9f 5f       	subi	r25, 0xFF	; 255
    24ac:	c9 f7       	brne	.-14     	; 0x24a0 <__divsf3_pse+0x78>
    24ae:	88 0f       	add	r24, r24
    24b0:	91 1d       	adc	r25, r1
    24b2:	96 95       	lsr	r25
    24b4:	87 95       	ror	r24
    24b6:	97 f9       	bld	r25, 7
    24b8:	08 95       	ret
    24ba:	e1 e0       	ldi	r30, 0x01	; 1
    24bc:	66 0f       	add	r22, r22
    24be:	77 1f       	adc	r23, r23
    24c0:	88 1f       	adc	r24, r24
    24c2:	bb 1f       	adc	r27, r27
    24c4:	62 17       	cp	r22, r18
    24c6:	73 07       	cpc	r23, r19
    24c8:	84 07       	cpc	r24, r20
    24ca:	ba 07       	cpc	r27, r26
    24cc:	20 f0       	brcs	.+8      	; 0x24d6 <__divsf3_pse+0xae>
    24ce:	62 1b       	sub	r22, r18
    24d0:	73 0b       	sbc	r23, r19
    24d2:	84 0b       	sbc	r24, r20
    24d4:	ba 0b       	sbc	r27, r26
    24d6:	ee 1f       	adc	r30, r30
    24d8:	88 f7       	brcc	.-30     	; 0x24bc <__divsf3_pse+0x94>
    24da:	e0 95       	com	r30
    24dc:	08 95       	ret

000024de <__fixunssfsi>:
    24de:	0e 94 0b 13 	call	0x2616	; 0x2616 <__fp_splitA>
    24e2:	88 f0       	brcs	.+34     	; 0x2506 <__fixunssfsi+0x28>
    24e4:	9f 57       	subi	r25, 0x7F	; 127
    24e6:	98 f0       	brcs	.+38     	; 0x250e <__fixunssfsi+0x30>
    24e8:	b9 2f       	mov	r27, r25
    24ea:	99 27       	eor	r25, r25
    24ec:	b7 51       	subi	r27, 0x17	; 23
    24ee:	b0 f0       	brcs	.+44     	; 0x251c <__fixunssfsi+0x3e>
    24f0:	e1 f0       	breq	.+56     	; 0x252a <__fixunssfsi+0x4c>
    24f2:	66 0f       	add	r22, r22
    24f4:	77 1f       	adc	r23, r23
    24f6:	88 1f       	adc	r24, r24
    24f8:	99 1f       	adc	r25, r25
    24fa:	1a f0       	brmi	.+6      	; 0x2502 <__fixunssfsi+0x24>
    24fc:	ba 95       	dec	r27
    24fe:	c9 f7       	brne	.-14     	; 0x24f2 <__fixunssfsi+0x14>
    2500:	14 c0       	rjmp	.+40     	; 0x252a <__fixunssfsi+0x4c>
    2502:	b1 30       	cpi	r27, 0x01	; 1
    2504:	91 f0       	breq	.+36     	; 0x252a <__fixunssfsi+0x4c>
    2506:	0e 94 25 13 	call	0x264a	; 0x264a <__fp_zero>
    250a:	b1 e0       	ldi	r27, 0x01	; 1
    250c:	08 95       	ret
    250e:	0c 94 25 13 	jmp	0x264a	; 0x264a <__fp_zero>
    2512:	67 2f       	mov	r22, r23
    2514:	78 2f       	mov	r23, r24
    2516:	88 27       	eor	r24, r24
    2518:	b8 5f       	subi	r27, 0xF8	; 248
    251a:	39 f0       	breq	.+14     	; 0x252a <__fixunssfsi+0x4c>
    251c:	b9 3f       	cpi	r27, 0xF9	; 249
    251e:	cc f3       	brlt	.-14     	; 0x2512 <__fixunssfsi+0x34>
    2520:	86 95       	lsr	r24
    2522:	77 95       	ror	r23
    2524:	67 95       	ror	r22
    2526:	b3 95       	inc	r27
    2528:	d9 f7       	brne	.-10     	; 0x2520 <__fixunssfsi+0x42>
    252a:	3e f4       	brtc	.+14     	; 0x253a <__fixunssfsi+0x5c>
    252c:	90 95       	com	r25
    252e:	80 95       	com	r24
    2530:	70 95       	com	r23
    2532:	61 95       	neg	r22
    2534:	7f 4f       	sbci	r23, 0xFF	; 255
    2536:	8f 4f       	sbci	r24, 0xFF	; 255
    2538:	9f 4f       	sbci	r25, 0xFF	; 255
    253a:	08 95       	ret

0000253c <__floatunsisf>:
    253c:	e8 94       	clt
    253e:	09 c0       	rjmp	.+18     	; 0x2552 <__floatsisf+0x12>

00002540 <__floatsisf>:
    2540:	97 fb       	bst	r25, 7
    2542:	3e f4       	brtc	.+14     	; 0x2552 <__floatsisf+0x12>
    2544:	90 95       	com	r25
    2546:	80 95       	com	r24
    2548:	70 95       	com	r23
    254a:	61 95       	neg	r22
    254c:	7f 4f       	sbci	r23, 0xFF	; 255
    254e:	8f 4f       	sbci	r24, 0xFF	; 255
    2550:	9f 4f       	sbci	r25, 0xFF	; 255
    2552:	99 23       	and	r25, r25
    2554:	a9 f0       	breq	.+42     	; 0x2580 <__floatsisf+0x40>
    2556:	f9 2f       	mov	r31, r25
    2558:	96 e9       	ldi	r25, 0x96	; 150
    255a:	bb 27       	eor	r27, r27
    255c:	93 95       	inc	r25
    255e:	f6 95       	lsr	r31
    2560:	87 95       	ror	r24
    2562:	77 95       	ror	r23
    2564:	67 95       	ror	r22
    2566:	b7 95       	ror	r27
    2568:	f1 11       	cpse	r31, r1
    256a:	f8 cf       	rjmp	.-16     	; 0x255c <__floatsisf+0x1c>
    256c:	fa f4       	brpl	.+62     	; 0x25ac <__floatsisf+0x6c>
    256e:	bb 0f       	add	r27, r27
    2570:	11 f4       	brne	.+4      	; 0x2576 <__floatsisf+0x36>
    2572:	60 ff       	sbrs	r22, 0
    2574:	1b c0       	rjmp	.+54     	; 0x25ac <__floatsisf+0x6c>
    2576:	6f 5f       	subi	r22, 0xFF	; 255
    2578:	7f 4f       	sbci	r23, 0xFF	; 255
    257a:	8f 4f       	sbci	r24, 0xFF	; 255
    257c:	9f 4f       	sbci	r25, 0xFF	; 255
    257e:	16 c0       	rjmp	.+44     	; 0x25ac <__floatsisf+0x6c>
    2580:	88 23       	and	r24, r24
    2582:	11 f0       	breq	.+4      	; 0x2588 <__floatsisf+0x48>
    2584:	96 e9       	ldi	r25, 0x96	; 150
    2586:	11 c0       	rjmp	.+34     	; 0x25aa <__floatsisf+0x6a>
    2588:	77 23       	and	r23, r23
    258a:	21 f0       	breq	.+8      	; 0x2594 <__floatsisf+0x54>
    258c:	9e e8       	ldi	r25, 0x8E	; 142
    258e:	87 2f       	mov	r24, r23
    2590:	76 2f       	mov	r23, r22
    2592:	05 c0       	rjmp	.+10     	; 0x259e <__floatsisf+0x5e>
    2594:	66 23       	and	r22, r22
    2596:	71 f0       	breq	.+28     	; 0x25b4 <__floatsisf+0x74>
    2598:	96 e8       	ldi	r25, 0x86	; 134
    259a:	86 2f       	mov	r24, r22
    259c:	70 e0       	ldi	r23, 0x00	; 0
    259e:	60 e0       	ldi	r22, 0x00	; 0
    25a0:	2a f0       	brmi	.+10     	; 0x25ac <__floatsisf+0x6c>
    25a2:	9a 95       	dec	r25
    25a4:	66 0f       	add	r22, r22
    25a6:	77 1f       	adc	r23, r23
    25a8:	88 1f       	adc	r24, r24
    25aa:	da f7       	brpl	.-10     	; 0x25a2 <__floatsisf+0x62>
    25ac:	88 0f       	add	r24, r24
    25ae:	96 95       	lsr	r25
    25b0:	87 95       	ror	r24
    25b2:	97 f9       	bld	r25, 7
    25b4:	08 95       	ret

000025b6 <__fp_inf>:
    25b6:	97 f9       	bld	r25, 7
    25b8:	9f 67       	ori	r25, 0x7F	; 127
    25ba:	80 e8       	ldi	r24, 0x80	; 128
    25bc:	70 e0       	ldi	r23, 0x00	; 0
    25be:	60 e0       	ldi	r22, 0x00	; 0
    25c0:	08 95       	ret

000025c2 <__fp_nan>:
    25c2:	9f ef       	ldi	r25, 0xFF	; 255
    25c4:	80 ec       	ldi	r24, 0xC0	; 192
    25c6:	08 95       	ret

000025c8 <__fp_pscA>:
    25c8:	00 24       	eor	r0, r0
    25ca:	0a 94       	dec	r0
    25cc:	16 16       	cp	r1, r22
    25ce:	17 06       	cpc	r1, r23
    25d0:	18 06       	cpc	r1, r24
    25d2:	09 06       	cpc	r0, r25
    25d4:	08 95       	ret

000025d6 <__fp_pscB>:
    25d6:	00 24       	eor	r0, r0
    25d8:	0a 94       	dec	r0
    25da:	12 16       	cp	r1, r18
    25dc:	13 06       	cpc	r1, r19
    25de:	14 06       	cpc	r1, r20
    25e0:	05 06       	cpc	r0, r21
    25e2:	08 95       	ret

000025e4 <__fp_round>:
    25e4:	09 2e       	mov	r0, r25
    25e6:	03 94       	inc	r0
    25e8:	00 0c       	add	r0, r0
    25ea:	11 f4       	brne	.+4      	; 0x25f0 <__fp_round+0xc>
    25ec:	88 23       	and	r24, r24
    25ee:	52 f0       	brmi	.+20     	; 0x2604 <__fp_round+0x20>
    25f0:	bb 0f       	add	r27, r27
    25f2:	40 f4       	brcc	.+16     	; 0x2604 <__fp_round+0x20>
    25f4:	bf 2b       	or	r27, r31
    25f6:	11 f4       	brne	.+4      	; 0x25fc <__fp_round+0x18>
    25f8:	60 ff       	sbrs	r22, 0
    25fa:	04 c0       	rjmp	.+8      	; 0x2604 <__fp_round+0x20>
    25fc:	6f 5f       	subi	r22, 0xFF	; 255
    25fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2600:	8f 4f       	sbci	r24, 0xFF	; 255
    2602:	9f 4f       	sbci	r25, 0xFF	; 255
    2604:	08 95       	ret

00002606 <__fp_split3>:
    2606:	57 fd       	sbrc	r21, 7
    2608:	90 58       	subi	r25, 0x80	; 128
    260a:	44 0f       	add	r20, r20
    260c:	55 1f       	adc	r21, r21
    260e:	59 f0       	breq	.+22     	; 0x2626 <__fp_splitA+0x10>
    2610:	5f 3f       	cpi	r21, 0xFF	; 255
    2612:	71 f0       	breq	.+28     	; 0x2630 <__fp_splitA+0x1a>
    2614:	47 95       	ror	r20

00002616 <__fp_splitA>:
    2616:	88 0f       	add	r24, r24
    2618:	97 fb       	bst	r25, 7
    261a:	99 1f       	adc	r25, r25
    261c:	61 f0       	breq	.+24     	; 0x2636 <__fp_splitA+0x20>
    261e:	9f 3f       	cpi	r25, 0xFF	; 255
    2620:	79 f0       	breq	.+30     	; 0x2640 <__fp_splitA+0x2a>
    2622:	87 95       	ror	r24
    2624:	08 95       	ret
    2626:	12 16       	cp	r1, r18
    2628:	13 06       	cpc	r1, r19
    262a:	14 06       	cpc	r1, r20
    262c:	55 1f       	adc	r21, r21
    262e:	f2 cf       	rjmp	.-28     	; 0x2614 <__fp_split3+0xe>
    2630:	46 95       	lsr	r20
    2632:	f1 df       	rcall	.-30     	; 0x2616 <__fp_splitA>
    2634:	08 c0       	rjmp	.+16     	; 0x2646 <__fp_splitA+0x30>
    2636:	16 16       	cp	r1, r22
    2638:	17 06       	cpc	r1, r23
    263a:	18 06       	cpc	r1, r24
    263c:	99 1f       	adc	r25, r25
    263e:	f1 cf       	rjmp	.-30     	; 0x2622 <__fp_splitA+0xc>
    2640:	86 95       	lsr	r24
    2642:	71 05       	cpc	r23, r1
    2644:	61 05       	cpc	r22, r1
    2646:	08 94       	sec
    2648:	08 95       	ret

0000264a <__fp_zero>:
    264a:	e8 94       	clt

0000264c <__fp_szero>:
    264c:	bb 27       	eor	r27, r27
    264e:	66 27       	eor	r22, r22
    2650:	77 27       	eor	r23, r23
    2652:	cb 01       	movw	r24, r22
    2654:	97 f9       	bld	r25, 7
    2656:	08 95       	ret

00002658 <__mulsf3>:
    2658:	0e 94 3f 13 	call	0x267e	; 0x267e <__mulsf3x>
    265c:	0c 94 f2 12 	jmp	0x25e4	; 0x25e4 <__fp_round>
    2660:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <__fp_pscA>
    2664:	38 f0       	brcs	.+14     	; 0x2674 <__mulsf3+0x1c>
    2666:	0e 94 eb 12 	call	0x25d6	; 0x25d6 <__fp_pscB>
    266a:	20 f0       	brcs	.+8      	; 0x2674 <__mulsf3+0x1c>
    266c:	95 23       	and	r25, r21
    266e:	11 f0       	breq	.+4      	; 0x2674 <__mulsf3+0x1c>
    2670:	0c 94 db 12 	jmp	0x25b6	; 0x25b6 <__fp_inf>
    2674:	0c 94 e1 12 	jmp	0x25c2	; 0x25c2 <__fp_nan>
    2678:	11 24       	eor	r1, r1
    267a:	0c 94 26 13 	jmp	0x264c	; 0x264c <__fp_szero>

0000267e <__mulsf3x>:
    267e:	0e 94 03 13 	call	0x2606	; 0x2606 <__fp_split3>
    2682:	70 f3       	brcs	.-36     	; 0x2660 <__mulsf3+0x8>

00002684 <__mulsf3_pse>:
    2684:	95 9f       	mul	r25, r21
    2686:	c1 f3       	breq	.-16     	; 0x2678 <__mulsf3+0x20>
    2688:	95 0f       	add	r25, r21
    268a:	50 e0       	ldi	r21, 0x00	; 0
    268c:	55 1f       	adc	r21, r21
    268e:	62 9f       	mul	r22, r18
    2690:	f0 01       	movw	r30, r0
    2692:	72 9f       	mul	r23, r18
    2694:	bb 27       	eor	r27, r27
    2696:	f0 0d       	add	r31, r0
    2698:	b1 1d       	adc	r27, r1
    269a:	63 9f       	mul	r22, r19
    269c:	aa 27       	eor	r26, r26
    269e:	f0 0d       	add	r31, r0
    26a0:	b1 1d       	adc	r27, r1
    26a2:	aa 1f       	adc	r26, r26
    26a4:	64 9f       	mul	r22, r20
    26a6:	66 27       	eor	r22, r22
    26a8:	b0 0d       	add	r27, r0
    26aa:	a1 1d       	adc	r26, r1
    26ac:	66 1f       	adc	r22, r22
    26ae:	82 9f       	mul	r24, r18
    26b0:	22 27       	eor	r18, r18
    26b2:	b0 0d       	add	r27, r0
    26b4:	a1 1d       	adc	r26, r1
    26b6:	62 1f       	adc	r22, r18
    26b8:	73 9f       	mul	r23, r19
    26ba:	b0 0d       	add	r27, r0
    26bc:	a1 1d       	adc	r26, r1
    26be:	62 1f       	adc	r22, r18
    26c0:	83 9f       	mul	r24, r19
    26c2:	a0 0d       	add	r26, r0
    26c4:	61 1d       	adc	r22, r1
    26c6:	22 1f       	adc	r18, r18
    26c8:	74 9f       	mul	r23, r20
    26ca:	33 27       	eor	r19, r19
    26cc:	a0 0d       	add	r26, r0
    26ce:	61 1d       	adc	r22, r1
    26d0:	23 1f       	adc	r18, r19
    26d2:	84 9f       	mul	r24, r20
    26d4:	60 0d       	add	r22, r0
    26d6:	21 1d       	adc	r18, r1
    26d8:	82 2f       	mov	r24, r18
    26da:	76 2f       	mov	r23, r22
    26dc:	6a 2f       	mov	r22, r26
    26de:	11 24       	eor	r1, r1
    26e0:	9f 57       	subi	r25, 0x7F	; 127
    26e2:	50 40       	sbci	r21, 0x00	; 0
    26e4:	9a f0       	brmi	.+38     	; 0x270c <__mulsf3_pse+0x88>
    26e6:	f1 f0       	breq	.+60     	; 0x2724 <__mulsf3_pse+0xa0>
    26e8:	88 23       	and	r24, r24
    26ea:	4a f0       	brmi	.+18     	; 0x26fe <__mulsf3_pse+0x7a>
    26ec:	ee 0f       	add	r30, r30
    26ee:	ff 1f       	adc	r31, r31
    26f0:	bb 1f       	adc	r27, r27
    26f2:	66 1f       	adc	r22, r22
    26f4:	77 1f       	adc	r23, r23
    26f6:	88 1f       	adc	r24, r24
    26f8:	91 50       	subi	r25, 0x01	; 1
    26fa:	50 40       	sbci	r21, 0x00	; 0
    26fc:	a9 f7       	brne	.-22     	; 0x26e8 <__mulsf3_pse+0x64>
    26fe:	9e 3f       	cpi	r25, 0xFE	; 254
    2700:	51 05       	cpc	r21, r1
    2702:	80 f0       	brcs	.+32     	; 0x2724 <__mulsf3_pse+0xa0>
    2704:	0c 94 db 12 	jmp	0x25b6	; 0x25b6 <__fp_inf>
    2708:	0c 94 26 13 	jmp	0x264c	; 0x264c <__fp_szero>
    270c:	5f 3f       	cpi	r21, 0xFF	; 255
    270e:	e4 f3       	brlt	.-8      	; 0x2708 <__mulsf3_pse+0x84>
    2710:	98 3e       	cpi	r25, 0xE8	; 232
    2712:	d4 f3       	brlt	.-12     	; 0x2708 <__mulsf3_pse+0x84>
    2714:	86 95       	lsr	r24
    2716:	77 95       	ror	r23
    2718:	67 95       	ror	r22
    271a:	b7 95       	ror	r27
    271c:	f7 95       	ror	r31
    271e:	e7 95       	ror	r30
    2720:	9f 5f       	subi	r25, 0xFF	; 255
    2722:	c1 f7       	brne	.-16     	; 0x2714 <__mulsf3_pse+0x90>
    2724:	fe 2b       	or	r31, r30
    2726:	88 0f       	add	r24, r24
    2728:	91 1d       	adc	r25, r1
    272a:	96 95       	lsr	r25
    272c:	87 95       	ror	r24
    272e:	97 f9       	bld	r25, 7
    2730:	08 95       	ret

00002732 <__tablejump2__>:
    2732:	ee 0f       	add	r30, r30
    2734:	ff 1f       	adc	r31, r31
    2736:	05 90       	lpm	r0, Z+
    2738:	f4 91       	lpm	r31, Z
    273a:	e0 2d       	mov	r30, r0
    273c:	09 94       	ijmp

0000273e <strcmp>:
    273e:	fb 01       	movw	r30, r22
    2740:	dc 01       	movw	r26, r24
    2742:	8d 91       	ld	r24, X+
    2744:	01 90       	ld	r0, Z+
    2746:	80 19       	sub	r24, r0
    2748:	01 10       	cpse	r0, r1
    274a:	d9 f3       	breq	.-10     	; 0x2742 <strcmp+0x4>
    274c:	99 0b       	sbc	r25, r25
    274e:	08 95       	ret

00002750 <strcpy>:
    2750:	fb 01       	movw	r30, r22
    2752:	dc 01       	movw	r26, r24
    2754:	01 90       	ld	r0, Z+
    2756:	0d 92       	st	X+, r0
    2758:	00 20       	and	r0, r0
    275a:	e1 f7       	brne	.-8      	; 0x2754 <strcpy+0x4>
    275c:	08 95       	ret

0000275e <sprintf>:
    275e:	ae e0       	ldi	r26, 0x0E	; 14
    2760:	b0 e0       	ldi	r27, 0x00	; 0
    2762:	e5 eb       	ldi	r30, 0xB5	; 181
    2764:	f3 e1       	ldi	r31, 0x13	; 19
    2766:	0c 94 70 16 	jmp	0x2ce0	; 0x2ce0 <__prologue_saves__+0x1c>
    276a:	0d 89       	ldd	r16, Y+21	; 0x15
    276c:	1e 89       	ldd	r17, Y+22	; 0x16
    276e:	86 e0       	ldi	r24, 0x06	; 6
    2770:	8c 83       	std	Y+4, r24	; 0x04
    2772:	1a 83       	std	Y+2, r17	; 0x02
    2774:	09 83       	std	Y+1, r16	; 0x01
    2776:	8f ef       	ldi	r24, 0xFF	; 255
    2778:	9f e7       	ldi	r25, 0x7F	; 127
    277a:	9e 83       	std	Y+6, r25	; 0x06
    277c:	8d 83       	std	Y+5, r24	; 0x05
    277e:	ae 01       	movw	r20, r28
    2780:	47 5e       	subi	r20, 0xE7	; 231
    2782:	5f 4f       	sbci	r21, 0xFF	; 255
    2784:	6f 89       	ldd	r22, Y+23	; 0x17
    2786:	78 8d       	ldd	r23, Y+24	; 0x18
    2788:	ce 01       	movw	r24, r28
    278a:	01 96       	adiw	r24, 0x01	; 1
    278c:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vfprintf>
    2790:	ef 81       	ldd	r30, Y+7	; 0x07
    2792:	f8 85       	ldd	r31, Y+8	; 0x08
    2794:	e0 0f       	add	r30, r16
    2796:	f1 1f       	adc	r31, r17
    2798:	10 82       	st	Z, r1
    279a:	2e 96       	adiw	r28, 0x0e	; 14
    279c:	e4 e0       	ldi	r30, 0x04	; 4
    279e:	0c 94 8c 16 	jmp	0x2d18	; 0x2d18 <__epilogue_restores__+0x1c>

000027a2 <vfprintf>:
    27a2:	ab e0       	ldi	r26, 0x0B	; 11
    27a4:	b0 e0       	ldi	r27, 0x00	; 0
    27a6:	e7 ed       	ldi	r30, 0xD7	; 215
    27a8:	f3 e1       	ldi	r31, 0x13	; 19
    27aa:	0c 94 62 16 	jmp	0x2cc4	; 0x2cc4 <__prologue_saves__>
    27ae:	6c 01       	movw	r12, r24
    27b0:	7b 01       	movw	r14, r22
    27b2:	8a 01       	movw	r16, r20
    27b4:	fc 01       	movw	r30, r24
    27b6:	17 82       	std	Z+7, r1	; 0x07
    27b8:	16 82       	std	Z+6, r1	; 0x06
    27ba:	83 81       	ldd	r24, Z+3	; 0x03
    27bc:	81 ff       	sbrs	r24, 1
    27be:	cc c1       	rjmp	.+920    	; 0x2b58 <vfprintf+0x3b6>
    27c0:	ce 01       	movw	r24, r28
    27c2:	01 96       	adiw	r24, 0x01	; 1
    27c4:	3c 01       	movw	r6, r24
    27c6:	f6 01       	movw	r30, r12
    27c8:	93 81       	ldd	r25, Z+3	; 0x03
    27ca:	f7 01       	movw	r30, r14
    27cc:	93 fd       	sbrc	r25, 3
    27ce:	85 91       	lpm	r24, Z+
    27d0:	93 ff       	sbrs	r25, 3
    27d2:	81 91       	ld	r24, Z+
    27d4:	7f 01       	movw	r14, r30
    27d6:	88 23       	and	r24, r24
    27d8:	09 f4       	brne	.+2      	; 0x27dc <vfprintf+0x3a>
    27da:	ba c1       	rjmp	.+884    	; 0x2b50 <vfprintf+0x3ae>
    27dc:	85 32       	cpi	r24, 0x25	; 37
    27de:	39 f4       	brne	.+14     	; 0x27ee <vfprintf+0x4c>
    27e0:	93 fd       	sbrc	r25, 3
    27e2:	85 91       	lpm	r24, Z+
    27e4:	93 ff       	sbrs	r25, 3
    27e6:	81 91       	ld	r24, Z+
    27e8:	7f 01       	movw	r14, r30
    27ea:	85 32       	cpi	r24, 0x25	; 37
    27ec:	29 f4       	brne	.+10     	; 0x27f8 <vfprintf+0x56>
    27ee:	b6 01       	movw	r22, r12
    27f0:	90 e0       	ldi	r25, 0x00	; 0
    27f2:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <fputc>
    27f6:	e7 cf       	rjmp	.-50     	; 0x27c6 <vfprintf+0x24>
    27f8:	91 2c       	mov	r9, r1
    27fa:	21 2c       	mov	r2, r1
    27fc:	31 2c       	mov	r3, r1
    27fe:	ff e1       	ldi	r31, 0x1F	; 31
    2800:	f3 15       	cp	r31, r3
    2802:	d8 f0       	brcs	.+54     	; 0x283a <vfprintf+0x98>
    2804:	8b 32       	cpi	r24, 0x2B	; 43
    2806:	79 f0       	breq	.+30     	; 0x2826 <vfprintf+0x84>
    2808:	38 f4       	brcc	.+14     	; 0x2818 <vfprintf+0x76>
    280a:	80 32       	cpi	r24, 0x20	; 32
    280c:	79 f0       	breq	.+30     	; 0x282c <vfprintf+0x8a>
    280e:	83 32       	cpi	r24, 0x23	; 35
    2810:	a1 f4       	brne	.+40     	; 0x283a <vfprintf+0x98>
    2812:	23 2d       	mov	r18, r3
    2814:	20 61       	ori	r18, 0x10	; 16
    2816:	1d c0       	rjmp	.+58     	; 0x2852 <vfprintf+0xb0>
    2818:	8d 32       	cpi	r24, 0x2D	; 45
    281a:	61 f0       	breq	.+24     	; 0x2834 <vfprintf+0x92>
    281c:	80 33       	cpi	r24, 0x30	; 48
    281e:	69 f4       	brne	.+26     	; 0x283a <vfprintf+0x98>
    2820:	23 2d       	mov	r18, r3
    2822:	21 60       	ori	r18, 0x01	; 1
    2824:	16 c0       	rjmp	.+44     	; 0x2852 <vfprintf+0xb0>
    2826:	83 2d       	mov	r24, r3
    2828:	82 60       	ori	r24, 0x02	; 2
    282a:	38 2e       	mov	r3, r24
    282c:	e3 2d       	mov	r30, r3
    282e:	e4 60       	ori	r30, 0x04	; 4
    2830:	3e 2e       	mov	r3, r30
    2832:	2a c0       	rjmp	.+84     	; 0x2888 <vfprintf+0xe6>
    2834:	f3 2d       	mov	r31, r3
    2836:	f8 60       	ori	r31, 0x08	; 8
    2838:	1d c0       	rjmp	.+58     	; 0x2874 <vfprintf+0xd2>
    283a:	37 fc       	sbrc	r3, 7
    283c:	2d c0       	rjmp	.+90     	; 0x2898 <vfprintf+0xf6>
    283e:	20 ed       	ldi	r18, 0xD0	; 208
    2840:	28 0f       	add	r18, r24
    2842:	2a 30       	cpi	r18, 0x0A	; 10
    2844:	40 f0       	brcs	.+16     	; 0x2856 <vfprintf+0xb4>
    2846:	8e 32       	cpi	r24, 0x2E	; 46
    2848:	b9 f4       	brne	.+46     	; 0x2878 <vfprintf+0xd6>
    284a:	36 fc       	sbrc	r3, 6
    284c:	81 c1       	rjmp	.+770    	; 0x2b50 <vfprintf+0x3ae>
    284e:	23 2d       	mov	r18, r3
    2850:	20 64       	ori	r18, 0x40	; 64
    2852:	32 2e       	mov	r3, r18
    2854:	19 c0       	rjmp	.+50     	; 0x2888 <vfprintf+0xe6>
    2856:	36 fe       	sbrs	r3, 6
    2858:	06 c0       	rjmp	.+12     	; 0x2866 <vfprintf+0xc4>
    285a:	8a e0       	ldi	r24, 0x0A	; 10
    285c:	98 9e       	mul	r9, r24
    285e:	20 0d       	add	r18, r0
    2860:	11 24       	eor	r1, r1
    2862:	92 2e       	mov	r9, r18
    2864:	11 c0       	rjmp	.+34     	; 0x2888 <vfprintf+0xe6>
    2866:	ea e0       	ldi	r30, 0x0A	; 10
    2868:	2e 9e       	mul	r2, r30
    286a:	20 0d       	add	r18, r0
    286c:	11 24       	eor	r1, r1
    286e:	22 2e       	mov	r2, r18
    2870:	f3 2d       	mov	r31, r3
    2872:	f0 62       	ori	r31, 0x20	; 32
    2874:	3f 2e       	mov	r3, r31
    2876:	08 c0       	rjmp	.+16     	; 0x2888 <vfprintf+0xe6>
    2878:	8c 36       	cpi	r24, 0x6C	; 108
    287a:	21 f4       	brne	.+8      	; 0x2884 <vfprintf+0xe2>
    287c:	83 2d       	mov	r24, r3
    287e:	80 68       	ori	r24, 0x80	; 128
    2880:	38 2e       	mov	r3, r24
    2882:	02 c0       	rjmp	.+4      	; 0x2888 <vfprintf+0xe6>
    2884:	88 36       	cpi	r24, 0x68	; 104
    2886:	41 f4       	brne	.+16     	; 0x2898 <vfprintf+0xf6>
    2888:	f7 01       	movw	r30, r14
    288a:	93 fd       	sbrc	r25, 3
    288c:	85 91       	lpm	r24, Z+
    288e:	93 ff       	sbrs	r25, 3
    2890:	81 91       	ld	r24, Z+
    2892:	7f 01       	movw	r14, r30
    2894:	81 11       	cpse	r24, r1
    2896:	b3 cf       	rjmp	.-154    	; 0x27fe <vfprintf+0x5c>
    2898:	98 2f       	mov	r25, r24
    289a:	9f 7d       	andi	r25, 0xDF	; 223
    289c:	95 54       	subi	r25, 0x45	; 69
    289e:	93 30       	cpi	r25, 0x03	; 3
    28a0:	28 f4       	brcc	.+10     	; 0x28ac <vfprintf+0x10a>
    28a2:	0c 5f       	subi	r16, 0xFC	; 252
    28a4:	1f 4f       	sbci	r17, 0xFF	; 255
    28a6:	9f e3       	ldi	r25, 0x3F	; 63
    28a8:	99 83       	std	Y+1, r25	; 0x01
    28aa:	0d c0       	rjmp	.+26     	; 0x28c6 <vfprintf+0x124>
    28ac:	83 36       	cpi	r24, 0x63	; 99
    28ae:	31 f0       	breq	.+12     	; 0x28bc <vfprintf+0x11a>
    28b0:	83 37       	cpi	r24, 0x73	; 115
    28b2:	71 f0       	breq	.+28     	; 0x28d0 <vfprintf+0x12e>
    28b4:	83 35       	cpi	r24, 0x53	; 83
    28b6:	09 f0       	breq	.+2      	; 0x28ba <vfprintf+0x118>
    28b8:	59 c0       	rjmp	.+178    	; 0x296c <vfprintf+0x1ca>
    28ba:	21 c0       	rjmp	.+66     	; 0x28fe <vfprintf+0x15c>
    28bc:	f8 01       	movw	r30, r16
    28be:	80 81       	ld	r24, Z
    28c0:	89 83       	std	Y+1, r24	; 0x01
    28c2:	0e 5f       	subi	r16, 0xFE	; 254
    28c4:	1f 4f       	sbci	r17, 0xFF	; 255
    28c6:	88 24       	eor	r8, r8
    28c8:	83 94       	inc	r8
    28ca:	91 2c       	mov	r9, r1
    28cc:	53 01       	movw	r10, r6
    28ce:	13 c0       	rjmp	.+38     	; 0x28f6 <vfprintf+0x154>
    28d0:	28 01       	movw	r4, r16
    28d2:	f2 e0       	ldi	r31, 0x02	; 2
    28d4:	4f 0e       	add	r4, r31
    28d6:	51 1c       	adc	r5, r1
    28d8:	f8 01       	movw	r30, r16
    28da:	a0 80       	ld	r10, Z
    28dc:	b1 80       	ldd	r11, Z+1	; 0x01
    28de:	36 fe       	sbrs	r3, 6
    28e0:	03 c0       	rjmp	.+6      	; 0x28e8 <vfprintf+0x146>
    28e2:	69 2d       	mov	r22, r9
    28e4:	70 e0       	ldi	r23, 0x00	; 0
    28e6:	02 c0       	rjmp	.+4      	; 0x28ec <vfprintf+0x14a>
    28e8:	6f ef       	ldi	r22, 0xFF	; 255
    28ea:	7f ef       	ldi	r23, 0xFF	; 255
    28ec:	c5 01       	movw	r24, r10
    28ee:	0e 94 bd 15 	call	0x2b7a	; 0x2b7a <strnlen>
    28f2:	4c 01       	movw	r8, r24
    28f4:	82 01       	movw	r16, r4
    28f6:	f3 2d       	mov	r31, r3
    28f8:	ff 77       	andi	r31, 0x7F	; 127
    28fa:	3f 2e       	mov	r3, r31
    28fc:	16 c0       	rjmp	.+44     	; 0x292a <vfprintf+0x188>
    28fe:	28 01       	movw	r4, r16
    2900:	22 e0       	ldi	r18, 0x02	; 2
    2902:	42 0e       	add	r4, r18
    2904:	51 1c       	adc	r5, r1
    2906:	f8 01       	movw	r30, r16
    2908:	a0 80       	ld	r10, Z
    290a:	b1 80       	ldd	r11, Z+1	; 0x01
    290c:	36 fe       	sbrs	r3, 6
    290e:	03 c0       	rjmp	.+6      	; 0x2916 <vfprintf+0x174>
    2910:	69 2d       	mov	r22, r9
    2912:	70 e0       	ldi	r23, 0x00	; 0
    2914:	02 c0       	rjmp	.+4      	; 0x291a <vfprintf+0x178>
    2916:	6f ef       	ldi	r22, 0xFF	; 255
    2918:	7f ef       	ldi	r23, 0xFF	; 255
    291a:	c5 01       	movw	r24, r10
    291c:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <strnlen_P>
    2920:	4c 01       	movw	r8, r24
    2922:	f3 2d       	mov	r31, r3
    2924:	f0 68       	ori	r31, 0x80	; 128
    2926:	3f 2e       	mov	r3, r31
    2928:	82 01       	movw	r16, r4
    292a:	33 fc       	sbrc	r3, 3
    292c:	1b c0       	rjmp	.+54     	; 0x2964 <vfprintf+0x1c2>
    292e:	82 2d       	mov	r24, r2
    2930:	90 e0       	ldi	r25, 0x00	; 0
    2932:	88 16       	cp	r8, r24
    2934:	99 06       	cpc	r9, r25
    2936:	b0 f4       	brcc	.+44     	; 0x2964 <vfprintf+0x1c2>
    2938:	b6 01       	movw	r22, r12
    293a:	80 e2       	ldi	r24, 0x20	; 32
    293c:	90 e0       	ldi	r25, 0x00	; 0
    293e:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <fputc>
    2942:	2a 94       	dec	r2
    2944:	f4 cf       	rjmp	.-24     	; 0x292e <vfprintf+0x18c>
    2946:	f5 01       	movw	r30, r10
    2948:	37 fc       	sbrc	r3, 7
    294a:	85 91       	lpm	r24, Z+
    294c:	37 fe       	sbrs	r3, 7
    294e:	81 91       	ld	r24, Z+
    2950:	5f 01       	movw	r10, r30
    2952:	b6 01       	movw	r22, r12
    2954:	90 e0       	ldi	r25, 0x00	; 0
    2956:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <fputc>
    295a:	21 10       	cpse	r2, r1
    295c:	2a 94       	dec	r2
    295e:	21 e0       	ldi	r18, 0x01	; 1
    2960:	82 1a       	sub	r8, r18
    2962:	91 08       	sbc	r9, r1
    2964:	81 14       	cp	r8, r1
    2966:	91 04       	cpc	r9, r1
    2968:	71 f7       	brne	.-36     	; 0x2946 <vfprintf+0x1a4>
    296a:	e8 c0       	rjmp	.+464    	; 0x2b3c <vfprintf+0x39a>
    296c:	84 36       	cpi	r24, 0x64	; 100
    296e:	11 f0       	breq	.+4      	; 0x2974 <vfprintf+0x1d2>
    2970:	89 36       	cpi	r24, 0x69	; 105
    2972:	41 f5       	brne	.+80     	; 0x29c4 <vfprintf+0x222>
    2974:	f8 01       	movw	r30, r16
    2976:	37 fe       	sbrs	r3, 7
    2978:	07 c0       	rjmp	.+14     	; 0x2988 <vfprintf+0x1e6>
    297a:	60 81       	ld	r22, Z
    297c:	71 81       	ldd	r23, Z+1	; 0x01
    297e:	82 81       	ldd	r24, Z+2	; 0x02
    2980:	93 81       	ldd	r25, Z+3	; 0x03
    2982:	0c 5f       	subi	r16, 0xFC	; 252
    2984:	1f 4f       	sbci	r17, 0xFF	; 255
    2986:	08 c0       	rjmp	.+16     	; 0x2998 <vfprintf+0x1f6>
    2988:	60 81       	ld	r22, Z
    298a:	71 81       	ldd	r23, Z+1	; 0x01
    298c:	07 2e       	mov	r0, r23
    298e:	00 0c       	add	r0, r0
    2990:	88 0b       	sbc	r24, r24
    2992:	99 0b       	sbc	r25, r25
    2994:	0e 5f       	subi	r16, 0xFE	; 254
    2996:	1f 4f       	sbci	r17, 0xFF	; 255
    2998:	f3 2d       	mov	r31, r3
    299a:	ff 76       	andi	r31, 0x6F	; 111
    299c:	3f 2e       	mov	r3, r31
    299e:	97 ff       	sbrs	r25, 7
    29a0:	09 c0       	rjmp	.+18     	; 0x29b4 <vfprintf+0x212>
    29a2:	90 95       	com	r25
    29a4:	80 95       	com	r24
    29a6:	70 95       	com	r23
    29a8:	61 95       	neg	r22
    29aa:	7f 4f       	sbci	r23, 0xFF	; 255
    29ac:	8f 4f       	sbci	r24, 0xFF	; 255
    29ae:	9f 4f       	sbci	r25, 0xFF	; 255
    29b0:	f0 68       	ori	r31, 0x80	; 128
    29b2:	3f 2e       	mov	r3, r31
    29b4:	2a e0       	ldi	r18, 0x0A	; 10
    29b6:	30 e0       	ldi	r19, 0x00	; 0
    29b8:	a3 01       	movw	r20, r6
    29ba:	0e 94 04 16 	call	0x2c08	; 0x2c08 <__ultoa_invert>
    29be:	88 2e       	mov	r8, r24
    29c0:	86 18       	sub	r8, r6
    29c2:	45 c0       	rjmp	.+138    	; 0x2a4e <vfprintf+0x2ac>
    29c4:	85 37       	cpi	r24, 0x75	; 117
    29c6:	31 f4       	brne	.+12     	; 0x29d4 <vfprintf+0x232>
    29c8:	23 2d       	mov	r18, r3
    29ca:	2f 7e       	andi	r18, 0xEF	; 239
    29cc:	b2 2e       	mov	r11, r18
    29ce:	2a e0       	ldi	r18, 0x0A	; 10
    29d0:	30 e0       	ldi	r19, 0x00	; 0
    29d2:	25 c0       	rjmp	.+74     	; 0x2a1e <vfprintf+0x27c>
    29d4:	93 2d       	mov	r25, r3
    29d6:	99 7f       	andi	r25, 0xF9	; 249
    29d8:	b9 2e       	mov	r11, r25
    29da:	8f 36       	cpi	r24, 0x6F	; 111
    29dc:	c1 f0       	breq	.+48     	; 0x2a0e <vfprintf+0x26c>
    29de:	18 f4       	brcc	.+6      	; 0x29e6 <vfprintf+0x244>
    29e0:	88 35       	cpi	r24, 0x58	; 88
    29e2:	79 f0       	breq	.+30     	; 0x2a02 <vfprintf+0x260>
    29e4:	b5 c0       	rjmp	.+362    	; 0x2b50 <vfprintf+0x3ae>
    29e6:	80 37       	cpi	r24, 0x70	; 112
    29e8:	19 f0       	breq	.+6      	; 0x29f0 <vfprintf+0x24e>
    29ea:	88 37       	cpi	r24, 0x78	; 120
    29ec:	21 f0       	breq	.+8      	; 0x29f6 <vfprintf+0x254>
    29ee:	b0 c0       	rjmp	.+352    	; 0x2b50 <vfprintf+0x3ae>
    29f0:	e9 2f       	mov	r30, r25
    29f2:	e0 61       	ori	r30, 0x10	; 16
    29f4:	be 2e       	mov	r11, r30
    29f6:	b4 fe       	sbrs	r11, 4
    29f8:	0d c0       	rjmp	.+26     	; 0x2a14 <vfprintf+0x272>
    29fa:	fb 2d       	mov	r31, r11
    29fc:	f4 60       	ori	r31, 0x04	; 4
    29fe:	bf 2e       	mov	r11, r31
    2a00:	09 c0       	rjmp	.+18     	; 0x2a14 <vfprintf+0x272>
    2a02:	34 fe       	sbrs	r3, 4
    2a04:	0a c0       	rjmp	.+20     	; 0x2a1a <vfprintf+0x278>
    2a06:	29 2f       	mov	r18, r25
    2a08:	26 60       	ori	r18, 0x06	; 6
    2a0a:	b2 2e       	mov	r11, r18
    2a0c:	06 c0       	rjmp	.+12     	; 0x2a1a <vfprintf+0x278>
    2a0e:	28 e0       	ldi	r18, 0x08	; 8
    2a10:	30 e0       	ldi	r19, 0x00	; 0
    2a12:	05 c0       	rjmp	.+10     	; 0x2a1e <vfprintf+0x27c>
    2a14:	20 e1       	ldi	r18, 0x10	; 16
    2a16:	30 e0       	ldi	r19, 0x00	; 0
    2a18:	02 c0       	rjmp	.+4      	; 0x2a1e <vfprintf+0x27c>
    2a1a:	20 e1       	ldi	r18, 0x10	; 16
    2a1c:	32 e0       	ldi	r19, 0x02	; 2
    2a1e:	f8 01       	movw	r30, r16
    2a20:	b7 fe       	sbrs	r11, 7
    2a22:	07 c0       	rjmp	.+14     	; 0x2a32 <vfprintf+0x290>
    2a24:	60 81       	ld	r22, Z
    2a26:	71 81       	ldd	r23, Z+1	; 0x01
    2a28:	82 81       	ldd	r24, Z+2	; 0x02
    2a2a:	93 81       	ldd	r25, Z+3	; 0x03
    2a2c:	0c 5f       	subi	r16, 0xFC	; 252
    2a2e:	1f 4f       	sbci	r17, 0xFF	; 255
    2a30:	06 c0       	rjmp	.+12     	; 0x2a3e <vfprintf+0x29c>
    2a32:	60 81       	ld	r22, Z
    2a34:	71 81       	ldd	r23, Z+1	; 0x01
    2a36:	80 e0       	ldi	r24, 0x00	; 0
    2a38:	90 e0       	ldi	r25, 0x00	; 0
    2a3a:	0e 5f       	subi	r16, 0xFE	; 254
    2a3c:	1f 4f       	sbci	r17, 0xFF	; 255
    2a3e:	a3 01       	movw	r20, r6
    2a40:	0e 94 04 16 	call	0x2c08	; 0x2c08 <__ultoa_invert>
    2a44:	88 2e       	mov	r8, r24
    2a46:	86 18       	sub	r8, r6
    2a48:	fb 2d       	mov	r31, r11
    2a4a:	ff 77       	andi	r31, 0x7F	; 127
    2a4c:	3f 2e       	mov	r3, r31
    2a4e:	36 fe       	sbrs	r3, 6
    2a50:	0d c0       	rjmp	.+26     	; 0x2a6c <vfprintf+0x2ca>
    2a52:	23 2d       	mov	r18, r3
    2a54:	2e 7f       	andi	r18, 0xFE	; 254
    2a56:	a2 2e       	mov	r10, r18
    2a58:	89 14       	cp	r8, r9
    2a5a:	58 f4       	brcc	.+22     	; 0x2a72 <vfprintf+0x2d0>
    2a5c:	34 fe       	sbrs	r3, 4
    2a5e:	0b c0       	rjmp	.+22     	; 0x2a76 <vfprintf+0x2d4>
    2a60:	32 fc       	sbrc	r3, 2
    2a62:	09 c0       	rjmp	.+18     	; 0x2a76 <vfprintf+0x2d4>
    2a64:	83 2d       	mov	r24, r3
    2a66:	8e 7e       	andi	r24, 0xEE	; 238
    2a68:	a8 2e       	mov	r10, r24
    2a6a:	05 c0       	rjmp	.+10     	; 0x2a76 <vfprintf+0x2d4>
    2a6c:	b8 2c       	mov	r11, r8
    2a6e:	a3 2c       	mov	r10, r3
    2a70:	03 c0       	rjmp	.+6      	; 0x2a78 <vfprintf+0x2d6>
    2a72:	b8 2c       	mov	r11, r8
    2a74:	01 c0       	rjmp	.+2      	; 0x2a78 <vfprintf+0x2d6>
    2a76:	b9 2c       	mov	r11, r9
    2a78:	a4 fe       	sbrs	r10, 4
    2a7a:	0f c0       	rjmp	.+30     	; 0x2a9a <vfprintf+0x2f8>
    2a7c:	fe 01       	movw	r30, r28
    2a7e:	e8 0d       	add	r30, r8
    2a80:	f1 1d       	adc	r31, r1
    2a82:	80 81       	ld	r24, Z
    2a84:	80 33       	cpi	r24, 0x30	; 48
    2a86:	21 f4       	brne	.+8      	; 0x2a90 <vfprintf+0x2ee>
    2a88:	9a 2d       	mov	r25, r10
    2a8a:	99 7e       	andi	r25, 0xE9	; 233
    2a8c:	a9 2e       	mov	r10, r25
    2a8e:	09 c0       	rjmp	.+18     	; 0x2aa2 <vfprintf+0x300>
    2a90:	a2 fe       	sbrs	r10, 2
    2a92:	06 c0       	rjmp	.+12     	; 0x2aa0 <vfprintf+0x2fe>
    2a94:	b3 94       	inc	r11
    2a96:	b3 94       	inc	r11
    2a98:	04 c0       	rjmp	.+8      	; 0x2aa2 <vfprintf+0x300>
    2a9a:	8a 2d       	mov	r24, r10
    2a9c:	86 78       	andi	r24, 0x86	; 134
    2a9e:	09 f0       	breq	.+2      	; 0x2aa2 <vfprintf+0x300>
    2aa0:	b3 94       	inc	r11
    2aa2:	a3 fc       	sbrc	r10, 3
    2aa4:	11 c0       	rjmp	.+34     	; 0x2ac8 <vfprintf+0x326>
    2aa6:	a0 fe       	sbrs	r10, 0
    2aa8:	06 c0       	rjmp	.+12     	; 0x2ab6 <vfprintf+0x314>
    2aaa:	b2 14       	cp	r11, r2
    2aac:	88 f4       	brcc	.+34     	; 0x2ad0 <vfprintf+0x32e>
    2aae:	28 0c       	add	r2, r8
    2ab0:	92 2c       	mov	r9, r2
    2ab2:	9b 18       	sub	r9, r11
    2ab4:	0e c0       	rjmp	.+28     	; 0x2ad2 <vfprintf+0x330>
    2ab6:	b2 14       	cp	r11, r2
    2ab8:	60 f4       	brcc	.+24     	; 0x2ad2 <vfprintf+0x330>
    2aba:	b6 01       	movw	r22, r12
    2abc:	80 e2       	ldi	r24, 0x20	; 32
    2abe:	90 e0       	ldi	r25, 0x00	; 0
    2ac0:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <fputc>
    2ac4:	b3 94       	inc	r11
    2ac6:	f7 cf       	rjmp	.-18     	; 0x2ab6 <vfprintf+0x314>
    2ac8:	b2 14       	cp	r11, r2
    2aca:	18 f4       	brcc	.+6      	; 0x2ad2 <vfprintf+0x330>
    2acc:	2b 18       	sub	r2, r11
    2ace:	02 c0       	rjmp	.+4      	; 0x2ad4 <vfprintf+0x332>
    2ad0:	98 2c       	mov	r9, r8
    2ad2:	21 2c       	mov	r2, r1
    2ad4:	a4 fe       	sbrs	r10, 4
    2ad6:	10 c0       	rjmp	.+32     	; 0x2af8 <vfprintf+0x356>
    2ad8:	b6 01       	movw	r22, r12
    2ada:	80 e3       	ldi	r24, 0x30	; 48
    2adc:	90 e0       	ldi	r25, 0x00	; 0
    2ade:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <fputc>
    2ae2:	a2 fe       	sbrs	r10, 2
    2ae4:	17 c0       	rjmp	.+46     	; 0x2b14 <vfprintf+0x372>
    2ae6:	a1 fc       	sbrc	r10, 1
    2ae8:	03 c0       	rjmp	.+6      	; 0x2af0 <vfprintf+0x34e>
    2aea:	88 e7       	ldi	r24, 0x78	; 120
    2aec:	90 e0       	ldi	r25, 0x00	; 0
    2aee:	02 c0       	rjmp	.+4      	; 0x2af4 <vfprintf+0x352>
    2af0:	88 e5       	ldi	r24, 0x58	; 88
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	b6 01       	movw	r22, r12
    2af6:	0c c0       	rjmp	.+24     	; 0x2b10 <vfprintf+0x36e>
    2af8:	8a 2d       	mov	r24, r10
    2afa:	86 78       	andi	r24, 0x86	; 134
    2afc:	59 f0       	breq	.+22     	; 0x2b14 <vfprintf+0x372>
    2afe:	a1 fe       	sbrs	r10, 1
    2b00:	02 c0       	rjmp	.+4      	; 0x2b06 <vfprintf+0x364>
    2b02:	8b e2       	ldi	r24, 0x2B	; 43
    2b04:	01 c0       	rjmp	.+2      	; 0x2b08 <vfprintf+0x366>
    2b06:	80 e2       	ldi	r24, 0x20	; 32
    2b08:	a7 fc       	sbrc	r10, 7
    2b0a:	8d e2       	ldi	r24, 0x2D	; 45
    2b0c:	b6 01       	movw	r22, r12
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <fputc>
    2b14:	89 14       	cp	r8, r9
    2b16:	38 f4       	brcc	.+14     	; 0x2b26 <vfprintf+0x384>
    2b18:	b6 01       	movw	r22, r12
    2b1a:	80 e3       	ldi	r24, 0x30	; 48
    2b1c:	90 e0       	ldi	r25, 0x00	; 0
    2b1e:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <fputc>
    2b22:	9a 94       	dec	r9
    2b24:	f7 cf       	rjmp	.-18     	; 0x2b14 <vfprintf+0x372>
    2b26:	8a 94       	dec	r8
    2b28:	f3 01       	movw	r30, r6
    2b2a:	e8 0d       	add	r30, r8
    2b2c:	f1 1d       	adc	r31, r1
    2b2e:	80 81       	ld	r24, Z
    2b30:	b6 01       	movw	r22, r12
    2b32:	90 e0       	ldi	r25, 0x00	; 0
    2b34:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <fputc>
    2b38:	81 10       	cpse	r8, r1
    2b3a:	f5 cf       	rjmp	.-22     	; 0x2b26 <vfprintf+0x384>
    2b3c:	22 20       	and	r2, r2
    2b3e:	09 f4       	brne	.+2      	; 0x2b42 <vfprintf+0x3a0>
    2b40:	42 ce       	rjmp	.-892    	; 0x27c6 <vfprintf+0x24>
    2b42:	b6 01       	movw	r22, r12
    2b44:	80 e2       	ldi	r24, 0x20	; 32
    2b46:	90 e0       	ldi	r25, 0x00	; 0
    2b48:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <fputc>
    2b4c:	2a 94       	dec	r2
    2b4e:	f6 cf       	rjmp	.-20     	; 0x2b3c <vfprintf+0x39a>
    2b50:	f6 01       	movw	r30, r12
    2b52:	86 81       	ldd	r24, Z+6	; 0x06
    2b54:	97 81       	ldd	r25, Z+7	; 0x07
    2b56:	02 c0       	rjmp	.+4      	; 0x2b5c <vfprintf+0x3ba>
    2b58:	8f ef       	ldi	r24, 0xFF	; 255
    2b5a:	9f ef       	ldi	r25, 0xFF	; 255
    2b5c:	2b 96       	adiw	r28, 0x0b	; 11
    2b5e:	e2 e1       	ldi	r30, 0x12	; 18
    2b60:	0c 94 7e 16 	jmp	0x2cfc	; 0x2cfc <__epilogue_restores__>

00002b64 <strnlen_P>:
    2b64:	fc 01       	movw	r30, r24
    2b66:	05 90       	lpm	r0, Z+
    2b68:	61 50       	subi	r22, 0x01	; 1
    2b6a:	70 40       	sbci	r23, 0x00	; 0
    2b6c:	01 10       	cpse	r0, r1
    2b6e:	d8 f7       	brcc	.-10     	; 0x2b66 <strnlen_P+0x2>
    2b70:	80 95       	com	r24
    2b72:	90 95       	com	r25
    2b74:	8e 0f       	add	r24, r30
    2b76:	9f 1f       	adc	r25, r31
    2b78:	08 95       	ret

00002b7a <strnlen>:
    2b7a:	fc 01       	movw	r30, r24
    2b7c:	61 50       	subi	r22, 0x01	; 1
    2b7e:	70 40       	sbci	r23, 0x00	; 0
    2b80:	01 90       	ld	r0, Z+
    2b82:	01 10       	cpse	r0, r1
    2b84:	d8 f7       	brcc	.-10     	; 0x2b7c <strnlen+0x2>
    2b86:	80 95       	com	r24
    2b88:	90 95       	com	r25
    2b8a:	8e 0f       	add	r24, r30
    2b8c:	9f 1f       	adc	r25, r31
    2b8e:	08 95       	ret

00002b90 <fputc>:
    2b90:	0f 93       	push	r16
    2b92:	1f 93       	push	r17
    2b94:	cf 93       	push	r28
    2b96:	df 93       	push	r29
    2b98:	fb 01       	movw	r30, r22
    2b9a:	23 81       	ldd	r18, Z+3	; 0x03
    2b9c:	21 fd       	sbrc	r18, 1
    2b9e:	03 c0       	rjmp	.+6      	; 0x2ba6 <fputc+0x16>
    2ba0:	8f ef       	ldi	r24, 0xFF	; 255
    2ba2:	9f ef       	ldi	r25, 0xFF	; 255
    2ba4:	2c c0       	rjmp	.+88     	; 0x2bfe <fputc+0x6e>
    2ba6:	22 ff       	sbrs	r18, 2
    2ba8:	16 c0       	rjmp	.+44     	; 0x2bd6 <fputc+0x46>
    2baa:	46 81       	ldd	r20, Z+6	; 0x06
    2bac:	57 81       	ldd	r21, Z+7	; 0x07
    2bae:	24 81       	ldd	r18, Z+4	; 0x04
    2bb0:	35 81       	ldd	r19, Z+5	; 0x05
    2bb2:	42 17       	cp	r20, r18
    2bb4:	53 07       	cpc	r21, r19
    2bb6:	44 f4       	brge	.+16     	; 0x2bc8 <fputc+0x38>
    2bb8:	a0 81       	ld	r26, Z
    2bba:	b1 81       	ldd	r27, Z+1	; 0x01
    2bbc:	9d 01       	movw	r18, r26
    2bbe:	2f 5f       	subi	r18, 0xFF	; 255
    2bc0:	3f 4f       	sbci	r19, 0xFF	; 255
    2bc2:	31 83       	std	Z+1, r19	; 0x01
    2bc4:	20 83       	st	Z, r18
    2bc6:	8c 93       	st	X, r24
    2bc8:	26 81       	ldd	r18, Z+6	; 0x06
    2bca:	37 81       	ldd	r19, Z+7	; 0x07
    2bcc:	2f 5f       	subi	r18, 0xFF	; 255
    2bce:	3f 4f       	sbci	r19, 0xFF	; 255
    2bd0:	37 83       	std	Z+7, r19	; 0x07
    2bd2:	26 83       	std	Z+6, r18	; 0x06
    2bd4:	14 c0       	rjmp	.+40     	; 0x2bfe <fputc+0x6e>
    2bd6:	8b 01       	movw	r16, r22
    2bd8:	ec 01       	movw	r28, r24
    2bda:	fb 01       	movw	r30, r22
    2bdc:	00 84       	ldd	r0, Z+8	; 0x08
    2bde:	f1 85       	ldd	r31, Z+9	; 0x09
    2be0:	e0 2d       	mov	r30, r0
    2be2:	09 95       	icall
    2be4:	89 2b       	or	r24, r25
    2be6:	e1 f6       	brne	.-72     	; 0x2ba0 <fputc+0x10>
    2be8:	d8 01       	movw	r26, r16
    2bea:	16 96       	adiw	r26, 0x06	; 6
    2bec:	8d 91       	ld	r24, X+
    2bee:	9c 91       	ld	r25, X
    2bf0:	17 97       	sbiw	r26, 0x07	; 7
    2bf2:	01 96       	adiw	r24, 0x01	; 1
    2bf4:	17 96       	adiw	r26, 0x07	; 7
    2bf6:	9c 93       	st	X, r25
    2bf8:	8e 93       	st	-X, r24
    2bfa:	16 97       	sbiw	r26, 0x06	; 6
    2bfc:	ce 01       	movw	r24, r28
    2bfe:	df 91       	pop	r29
    2c00:	cf 91       	pop	r28
    2c02:	1f 91       	pop	r17
    2c04:	0f 91       	pop	r16
    2c06:	08 95       	ret

00002c08 <__ultoa_invert>:
    2c08:	fa 01       	movw	r30, r20
    2c0a:	aa 27       	eor	r26, r26
    2c0c:	28 30       	cpi	r18, 0x08	; 8
    2c0e:	51 f1       	breq	.+84     	; 0x2c64 <__ultoa_invert+0x5c>
    2c10:	20 31       	cpi	r18, 0x10	; 16
    2c12:	81 f1       	breq	.+96     	; 0x2c74 <__ultoa_invert+0x6c>
    2c14:	e8 94       	clt
    2c16:	6f 93       	push	r22
    2c18:	6e 7f       	andi	r22, 0xFE	; 254
    2c1a:	6e 5f       	subi	r22, 0xFE	; 254
    2c1c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c1e:	8f 4f       	sbci	r24, 0xFF	; 255
    2c20:	9f 4f       	sbci	r25, 0xFF	; 255
    2c22:	af 4f       	sbci	r26, 0xFF	; 255
    2c24:	b1 e0       	ldi	r27, 0x01	; 1
    2c26:	3e d0       	rcall	.+124    	; 0x2ca4 <__ultoa_invert+0x9c>
    2c28:	b4 e0       	ldi	r27, 0x04	; 4
    2c2a:	3c d0       	rcall	.+120    	; 0x2ca4 <__ultoa_invert+0x9c>
    2c2c:	67 0f       	add	r22, r23
    2c2e:	78 1f       	adc	r23, r24
    2c30:	89 1f       	adc	r24, r25
    2c32:	9a 1f       	adc	r25, r26
    2c34:	a1 1d       	adc	r26, r1
    2c36:	68 0f       	add	r22, r24
    2c38:	79 1f       	adc	r23, r25
    2c3a:	8a 1f       	adc	r24, r26
    2c3c:	91 1d       	adc	r25, r1
    2c3e:	a1 1d       	adc	r26, r1
    2c40:	6a 0f       	add	r22, r26
    2c42:	71 1d       	adc	r23, r1
    2c44:	81 1d       	adc	r24, r1
    2c46:	91 1d       	adc	r25, r1
    2c48:	a1 1d       	adc	r26, r1
    2c4a:	20 d0       	rcall	.+64     	; 0x2c8c <__ultoa_invert+0x84>
    2c4c:	09 f4       	brne	.+2      	; 0x2c50 <__ultoa_invert+0x48>
    2c4e:	68 94       	set
    2c50:	3f 91       	pop	r19
    2c52:	2a e0       	ldi	r18, 0x0A	; 10
    2c54:	26 9f       	mul	r18, r22
    2c56:	11 24       	eor	r1, r1
    2c58:	30 19       	sub	r19, r0
    2c5a:	30 5d       	subi	r19, 0xD0	; 208
    2c5c:	31 93       	st	Z+, r19
    2c5e:	de f6       	brtc	.-74     	; 0x2c16 <__ultoa_invert+0xe>
    2c60:	cf 01       	movw	r24, r30
    2c62:	08 95       	ret
    2c64:	46 2f       	mov	r20, r22
    2c66:	47 70       	andi	r20, 0x07	; 7
    2c68:	40 5d       	subi	r20, 0xD0	; 208
    2c6a:	41 93       	st	Z+, r20
    2c6c:	b3 e0       	ldi	r27, 0x03	; 3
    2c6e:	0f d0       	rcall	.+30     	; 0x2c8e <__ultoa_invert+0x86>
    2c70:	c9 f7       	brne	.-14     	; 0x2c64 <__ultoa_invert+0x5c>
    2c72:	f6 cf       	rjmp	.-20     	; 0x2c60 <__ultoa_invert+0x58>
    2c74:	46 2f       	mov	r20, r22
    2c76:	4f 70       	andi	r20, 0x0F	; 15
    2c78:	40 5d       	subi	r20, 0xD0	; 208
    2c7a:	4a 33       	cpi	r20, 0x3A	; 58
    2c7c:	18 f0       	brcs	.+6      	; 0x2c84 <__ultoa_invert+0x7c>
    2c7e:	49 5d       	subi	r20, 0xD9	; 217
    2c80:	31 fd       	sbrc	r19, 1
    2c82:	40 52       	subi	r20, 0x20	; 32
    2c84:	41 93       	st	Z+, r20
    2c86:	02 d0       	rcall	.+4      	; 0x2c8c <__ultoa_invert+0x84>
    2c88:	a9 f7       	brne	.-22     	; 0x2c74 <__ultoa_invert+0x6c>
    2c8a:	ea cf       	rjmp	.-44     	; 0x2c60 <__ultoa_invert+0x58>
    2c8c:	b4 e0       	ldi	r27, 0x04	; 4
    2c8e:	a6 95       	lsr	r26
    2c90:	97 95       	ror	r25
    2c92:	87 95       	ror	r24
    2c94:	77 95       	ror	r23
    2c96:	67 95       	ror	r22
    2c98:	ba 95       	dec	r27
    2c9a:	c9 f7       	brne	.-14     	; 0x2c8e <__ultoa_invert+0x86>
    2c9c:	00 97       	sbiw	r24, 0x00	; 0
    2c9e:	61 05       	cpc	r22, r1
    2ca0:	71 05       	cpc	r23, r1
    2ca2:	08 95       	ret
    2ca4:	9b 01       	movw	r18, r22
    2ca6:	ac 01       	movw	r20, r24
    2ca8:	0a 2e       	mov	r0, r26
    2caa:	06 94       	lsr	r0
    2cac:	57 95       	ror	r21
    2cae:	47 95       	ror	r20
    2cb0:	37 95       	ror	r19
    2cb2:	27 95       	ror	r18
    2cb4:	ba 95       	dec	r27
    2cb6:	c9 f7       	brne	.-14     	; 0x2caa <__ultoa_invert+0xa2>
    2cb8:	62 0f       	add	r22, r18
    2cba:	73 1f       	adc	r23, r19
    2cbc:	84 1f       	adc	r24, r20
    2cbe:	95 1f       	adc	r25, r21
    2cc0:	a0 1d       	adc	r26, r0
    2cc2:	08 95       	ret

00002cc4 <__prologue_saves__>:
    2cc4:	2f 92       	push	r2
    2cc6:	3f 92       	push	r3
    2cc8:	4f 92       	push	r4
    2cca:	5f 92       	push	r5
    2ccc:	6f 92       	push	r6
    2cce:	7f 92       	push	r7
    2cd0:	8f 92       	push	r8
    2cd2:	9f 92       	push	r9
    2cd4:	af 92       	push	r10
    2cd6:	bf 92       	push	r11
    2cd8:	cf 92       	push	r12
    2cda:	df 92       	push	r13
    2cdc:	ef 92       	push	r14
    2cde:	ff 92       	push	r15
    2ce0:	0f 93       	push	r16
    2ce2:	1f 93       	push	r17
    2ce4:	cf 93       	push	r28
    2ce6:	df 93       	push	r29
    2ce8:	cd b7       	in	r28, 0x3d	; 61
    2cea:	de b7       	in	r29, 0x3e	; 62
    2cec:	ca 1b       	sub	r28, r26
    2cee:	db 0b       	sbc	r29, r27
    2cf0:	0f b6       	in	r0, 0x3f	; 63
    2cf2:	f8 94       	cli
    2cf4:	de bf       	out	0x3e, r29	; 62
    2cf6:	0f be       	out	0x3f, r0	; 63
    2cf8:	cd bf       	out	0x3d, r28	; 61
    2cfa:	09 94       	ijmp

00002cfc <__epilogue_restores__>:
    2cfc:	2a 88       	ldd	r2, Y+18	; 0x12
    2cfe:	39 88       	ldd	r3, Y+17	; 0x11
    2d00:	48 88       	ldd	r4, Y+16	; 0x10
    2d02:	5f 84       	ldd	r5, Y+15	; 0x0f
    2d04:	6e 84       	ldd	r6, Y+14	; 0x0e
    2d06:	7d 84       	ldd	r7, Y+13	; 0x0d
    2d08:	8c 84       	ldd	r8, Y+12	; 0x0c
    2d0a:	9b 84       	ldd	r9, Y+11	; 0x0b
    2d0c:	aa 84       	ldd	r10, Y+10	; 0x0a
    2d0e:	b9 84       	ldd	r11, Y+9	; 0x09
    2d10:	c8 84       	ldd	r12, Y+8	; 0x08
    2d12:	df 80       	ldd	r13, Y+7	; 0x07
    2d14:	ee 80       	ldd	r14, Y+6	; 0x06
    2d16:	fd 80       	ldd	r15, Y+5	; 0x05
    2d18:	0c 81       	ldd	r16, Y+4	; 0x04
    2d1a:	1b 81       	ldd	r17, Y+3	; 0x03
    2d1c:	aa 81       	ldd	r26, Y+2	; 0x02
    2d1e:	b9 81       	ldd	r27, Y+1	; 0x01
    2d20:	ce 0f       	add	r28, r30
    2d22:	d1 1d       	adc	r29, r1
    2d24:	0f b6       	in	r0, 0x3f	; 63
    2d26:	f8 94       	cli
    2d28:	de bf       	out	0x3e, r29	; 62
    2d2a:	0f be       	out	0x3f, r0	; 63
    2d2c:	cd bf       	out	0x3d, r28	; 61
    2d2e:	ed 01       	movw	r28, r26
    2d30:	08 95       	ret

00002d32 <_exit>:
    2d32:	f8 94       	cli

00002d34 <__stop_program>:
    2d34:	ff cf       	rjmp	.-2      	; 0x2d34 <__stop_program>
