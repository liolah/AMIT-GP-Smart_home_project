
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000358a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000746  00800060  0000358a  0000361e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000b6  008007a6  008007a6  00003d64  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003d64  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00003dc0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000640  00000000  00000000  00003dfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000068d0  00000000  00000000  0000443c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001a9a  00000000  00000000  0000ad0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000043b8  00000000  00000000  0000c7a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000eec  00000000  00000000  00010b60  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000015a2  00000000  00000000  00011a4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003942  00000000  00000000  00012fee  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004e0  00000000  00000000  00016930  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8c 00 	jmp	0x118	; 0x118 <__ctors_end>
       4:	0c 94 f1 12 	jmp	0x25e2	; 0x25e2 <__vector_1>
       8:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
       c:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      10:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      14:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      18:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      1c:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      20:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      24:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      28:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      2c:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      30:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      34:	0c 94 6c 12 	jmp	0x24d8	; 0x24d8 <__vector_13>
      38:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      3c:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      40:	0c 94 2b 13 	jmp	0x2656	; 0x2656 <__vector_16>
      44:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      48:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      4c:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      50:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      54:	92 04       	cpc	r9, r2
      56:	96 04       	cpc	r9, r6
      58:	9a 04       	cpc	r9, r10
      5a:	9e 04       	cpc	r9, r14
      5c:	a2 04       	cpc	r10, r2
      5e:	a6 04       	cpc	r10, r6
      60:	aa 04       	cpc	r10, r10
      62:	b4 06       	cpc	r11, r20
      64:	c8 06       	cpc	r12, r24
      66:	c8 06       	cpc	r12, r24
      68:	c8 06       	cpc	r12, r24
      6a:	c8 06       	cpc	r12, r24
      6c:	c8 06       	cpc	r12, r24
      6e:	c8 06       	cpc	r12, r24
      70:	c8 06       	cpc	r12, r24
      72:	ca 06       	cpc	r12, r26
      74:	c8 06       	cpc	r12, r24
      76:	c8 06       	cpc	r12, r24
      78:	c8 06       	cpc	r12, r24
      7a:	c8 06       	cpc	r12, r24
      7c:	c8 06       	cpc	r12, r24
      7e:	c8 06       	cpc	r12, r24
      80:	c8 06       	cpc	r12, r24
      82:	b6 06       	cpc	r11, r22
      84:	c8 06       	cpc	r12, r24
      86:	c8 06       	cpc	r12, r24
      88:	c8 06       	cpc	r12, r24
      8a:	c8 06       	cpc	r12, r24
      8c:	c8 06       	cpc	r12, r24
      8e:	c8 06       	cpc	r12, r24
      90:	c8 06       	cpc	r12, r24
      92:	b8 06       	cpc	r11, r24
      94:	c8 06       	cpc	r12, r24
      96:	c8 06       	cpc	r12, r24
      98:	c8 06       	cpc	r12, r24
      9a:	c8 06       	cpc	r12, r24
      9c:	c8 06       	cpc	r12, r24
      9e:	c8 06       	cpc	r12, r24
      a0:	c8 06       	cpc	r12, r24
      a2:	ba 06       	cpc	r11, r26
      a4:	c8 06       	cpc	r12, r24
      a6:	c8 06       	cpc	r12, r24
      a8:	c8 06       	cpc	r12, r24
      aa:	c8 06       	cpc	r12, r24
      ac:	c8 06       	cpc	r12, r24
      ae:	c8 06       	cpc	r12, r24
      b0:	c8 06       	cpc	r12, r24
      b2:	bc 06       	cpc	r11, r28
      b4:	c8 06       	cpc	r12, r24
      b6:	c8 06       	cpc	r12, r24
      b8:	c8 06       	cpc	r12, r24
      ba:	c8 06       	cpc	r12, r24
      bc:	c8 06       	cpc	r12, r24
      be:	c8 06       	cpc	r12, r24
      c0:	c8 06       	cpc	r12, r24
      c2:	be 06       	cpc	r11, r30
      c4:	c8 06       	cpc	r12, r24
      c6:	c8 06       	cpc	r12, r24
      c8:	c8 06       	cpc	r12, r24
      ca:	c8 06       	cpc	r12, r24
      cc:	c8 06       	cpc	r12, r24
      ce:	c8 06       	cpc	r12, r24
      d0:	c8 06       	cpc	r12, r24
      d2:	c0 06       	cpc	r12, r16
      d4:	c8 06       	cpc	r12, r24
      d6:	c8 06       	cpc	r12, r24
      d8:	c8 06       	cpc	r12, r24
      da:	c8 06       	cpc	r12, r24
      dc:	c8 06       	cpc	r12, r24
      de:	c8 06       	cpc	r12, r24
      e0:	c8 06       	cpc	r12, r24
      e2:	c2 06       	cpc	r12, r18
      e4:	c8 06       	cpc	r12, r24
      e6:	c8 06       	cpc	r12, r24
      e8:	c8 06       	cpc	r12, r24
      ea:	c8 06       	cpc	r12, r24
      ec:	c8 06       	cpc	r12, r24
      ee:	c8 06       	cpc	r12, r24
      f0:	c8 06       	cpc	r12, r24
      f2:	c4 06       	cpc	r12, r20
      f4:	c8 06       	cpc	r12, r24
      f6:	c8 06       	cpc	r12, r24
      f8:	c8 06       	cpc	r12, r24
      fa:	c8 06       	cpc	r12, r24
      fc:	c8 06       	cpc	r12, r24
      fe:	c8 06       	cpc	r12, r24
     100:	c8 06       	cpc	r12, r24
     102:	c6 06       	cpc	r12, r22
     104:	44 0b       	sbc	r20, r20
     106:	4b 0b       	sbc	r20, r27
     108:	52 0b       	sbc	r21, r18
     10a:	59 0b       	sbc	r21, r25
     10c:	60 0b       	sbc	r22, r16
     10e:	67 0b       	sbc	r22, r23
     110:	6e 0b       	sbc	r22, r30
     112:	75 0b       	sbc	r23, r21
     114:	7c 0b       	sbc	r23, r28
     116:	83 0b       	sbc	r24, r19

00000118 <__ctors_end>:
     118:	11 24       	eor	r1, r1
     11a:	1f be       	out	0x3f, r1	; 63
     11c:	cf e5       	ldi	r28, 0x5F	; 95
     11e:	d8 e0       	ldi	r29, 0x08	; 8
     120:	de bf       	out	0x3e, r29	; 62
     122:	cd bf       	out	0x3d, r28	; 61

00000124 <__do_copy_data>:
     124:	17 e0       	ldi	r17, 0x07	; 7
     126:	a0 e6       	ldi	r26, 0x60	; 96
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	ea e8       	ldi	r30, 0x8A	; 138
     12c:	f5 e3       	ldi	r31, 0x35	; 53
     12e:	02 c0       	rjmp	.+4      	; 0x134 <__do_copy_data+0x10>
     130:	05 90       	lpm	r0, Z+
     132:	0d 92       	st	X+, r0
     134:	a6 3a       	cpi	r26, 0xA6	; 166
     136:	b1 07       	cpc	r27, r17
     138:	d9 f7       	brne	.-10     	; 0x130 <__do_copy_data+0xc>

0000013a <__do_clear_bss>:
     13a:	28 e0       	ldi	r18, 0x08	; 8
     13c:	a6 ea       	ldi	r26, 0xA6	; 166
     13e:	b7 e0       	ldi	r27, 0x07	; 7
     140:	01 c0       	rjmp	.+2      	; 0x144 <.do_clear_bss_start>

00000142 <.do_clear_bss_loop>:
     142:	1d 92       	st	X+, r1

00000144 <.do_clear_bss_start>:
     144:	ac 35       	cpi	r26, 0x5C	; 92
     146:	b2 07       	cpc	r27, r18
     148:	e1 f7       	brne	.-8      	; 0x142 <.do_clear_bss_loop>
     14a:	0e 94 64 04 	call	0x8c8	; 0x8c8 <main>
     14e:	0c 94 c3 1a 	jmp	0x3586	; 0x3586 <_exit>

00000152 <__bad_interrupt>:
     152:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000156 <App_init>:
#include "app.h"

 // Does all the initializations required in the app
void App_init(void) {
  // Remote_init(9600);
  Local_access_init();
     156:	0e 94 0f 0b 	call	0x161e	; 0x161e <Local_access_init>
  Lamps_init();
     15a:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <Lamps_init>
  Door_init();
     15e:	0e 94 4e 0a 	call	0x149c	; 0x149c <Door_init>
  AC_auto_control_service_start();
     162:	0e 94 15 13 	call	0x262a	; 0x262a <AC_auto_control_service_start>
  Buzzer_init(BUZZER_PORT, BUZZER_PIN);
     166:	63 e0       	ldi	r22, 0x03	; 3
     168:	84 e4       	ldi	r24, 0x44	; 68
     16a:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_init>
  sei();
     16e:	78 94       	sei

  // Uncomment and use only one time to initialize the DB
  // User_DB_format();

  run_system = true;
     170:	81 e0       	ldi	r24, 0x01	; 1
     172:	80 93 a9 07 	sts	0x07A9, r24	; 0x8007a9 <run_system>
     176:	08 95       	ret

00000178 <App_start>:
  }

// Contains all functionalities and top level logic of the app
void App_start(void) {
     178:	02 c0       	rjmp	.+4      	; 0x17e <App_start+0x6>
  while (1) {
    while (run_system) {
      Local_control_input_handler();
     17a:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <Local_control_input_handler>
  }

// Contains all functionalities and top level logic of the app
void App_start(void) {
  while (1) {
    while (run_system) {
     17e:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <run_system>
     182:	81 11       	cpse	r24, r1
     184:	fa cf       	rjmp	.-12     	; 0x17a <App_start+0x2>
      Local_control_input_handler();
      }
    cli();
     186:	f8 94       	cli
    // If the invalid attempts are exhausted, the program will halt.
    // The program can halt by returning  and letting it reach the end of main. Or by just entering another infinite loop.
      // Set the alarm
    set_bit(DDRD, 3);
     188:	81 b3       	in	r24, 0x11	; 17
     18a:	88 60       	ori	r24, 0x08	; 8
     18c:	81 bb       	out	0x11, r24	; 17
    set_bit(PORTD, 3);
     18e:	82 b3       	in	r24, 0x12	; 18
     190:	88 60       	ori	r24, 0x08	; 8
     192:	82 bb       	out	0x12, r24	; 18
  }

// Contains all functionalities and top level logic of the app
void App_start(void) {
  while (1) {
    while (run_system) {
     194:	f4 cf       	rjmp	.-24     	; 0x17e <App_start+0x6>

00000196 <Buzzer_init>:
 */

#include "buzzer.h"

 // Initialize the buzzer
EN_BuzzerError_t Buzzer_init(u8 buzzerPort, u8 buzzerPin) {
     196:	98 2f       	mov	r25, r24
     198:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(buzzerPin, buzzerPort, OUT) == DIO_OK) {
     19a:	41 e0       	ldi	r20, 0x01	; 1
     19c:	69 2f       	mov	r22, r25
     19e:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
     1a2:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that the buzzer initialization failed
  return BUZZER_ERROR_INIT;
     1a4:	81 e0       	ldi	r24, 0x01	; 1
  }
     1a6:	08 95       	ret

000001a8 <EEPROM_init>:
 */

#include "eeprom.h"

void EEPROM_init() {
  I2C_init();
     1a8:	0e 94 cc 06 	call	0xd98	; 0xd98 <I2C_init>
     1ac:	08 95       	ret

000001ae <EEPROM_read_byte>:
  }

void EEPROM_read_byte(u8 page, u8 address, s8* data) {
     1ae:	0f 93       	push	r16
     1b0:	1f 93       	push	r17
     1b2:	cf 93       	push	r28
     1b4:	df 93       	push	r29
     1b6:	c8 2f       	mov	r28, r24
     1b8:	d6 2f       	mov	r29, r22
     1ba:	8a 01       	movw	r16, r20
  I2C_start();
     1bc:	0e 94 d0 06 	call	0xda0	; 0xda0 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     1c0:	cc 0f       	add	r28, r28
     1c2:	80 ea       	ldi	r24, 0xA0	; 160
     1c4:	8c 0f       	add	r24, r28
     1c6:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  I2C_write(address);
     1ca:	8d 2f       	mov	r24, r29
     1cc:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  I2C_start();
     1d0:	0e 94 d0 06 	call	0xda0	; 0xda0 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     1d4:	81 ea       	ldi	r24, 0xA1	; 161
     1d6:	8c 0f       	add	r24, r28
     1d8:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  // read_Ack will halt the reading here, because it will send the next byte, which will not be received and wait for ack, which will not be sent. 
  // Nack must be sent after the arrival of the last requested byte. It's used basically to indicate that no further data transmission is required and then the stop condition is sent
  I2C_read_Nack(data);
     1dc:	c8 01       	movw	r24, r16
     1de:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <I2C_read_Nack>
  I2C_stop();
     1e2:	0e 94 f7 06 	call	0xdee	; 0xdee <I2C_stop>
  }
     1e6:	df 91       	pop	r29
     1e8:	cf 91       	pop	r28
     1ea:	1f 91       	pop	r17
     1ec:	0f 91       	pop	r16
     1ee:	08 95       	ret

000001f0 <EEPROM_read_block>:

void EEPROM_read_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     1f0:	ef 92       	push	r14
     1f2:	ff 92       	push	r15
     1f4:	0f 93       	push	r16
     1f6:	1f 93       	push	r17
     1f8:	cf 93       	push	r28
     1fa:	df 93       	push	r29
     1fc:	c8 2f       	mov	r28, r24
     1fe:	d6 2f       	mov	r29, r22
     200:	7a 01       	movw	r14, r20
     202:	89 01       	movw	r16, r18
  u16 i;
  for (i = 0;i < bytes_number;i++) {
    EEPROM_read_byte(page, address + i, &data[i]);
    }
#elif READ_BLOCK_METHOD == MULTIBYTE
  I2C_start();
     204:	0e 94 d0 06 	call	0xda0	; 0xda0 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     208:	cc 0f       	add	r28, r28
     20a:	80 ea       	ldi	r24, 0xA0	; 160
     20c:	8c 0f       	add	r24, r28
     20e:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  I2C_write(address);
     212:	8d 2f       	mov	r24, r29
     214:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  I2C_start();
     218:	0e 94 d0 06 	call	0xda0	; 0xda0 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     21c:	81 ea       	ldi	r24, 0xA1	; 161
     21e:	8c 0f       	add	r24, r28
     220:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     224:	c0 e0       	ldi	r28, 0x00	; 0
     226:	d0 e0       	ldi	r29, 0x00	; 0
     228:	06 c0       	rjmp	.+12     	; 0x236 <EEPROM_read_block+0x46>
    I2C_read_Ack(&data[i]);
     22a:	c8 01       	movw	r24, r16
     22c:	8c 0f       	add	r24, r28
     22e:	9d 1f       	adc	r25, r29
     230:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <I2C_read_Ack>
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  I2C_start();
  I2C_write(0xA0 + (page << 1) + 1);
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     234:	21 96       	adiw	r28, 0x01	; 1
     236:	c7 01       	movw	r24, r14
     238:	01 97       	sbiw	r24, 0x01	; 1
     23a:	c8 17       	cp	r28, r24
     23c:	d9 07       	cpc	r29, r25
     23e:	a8 f3       	brcs	.-22     	; 0x22a <EEPROM_read_block+0x3a>
    I2C_read_Ack(&data[i]);
    }
  I2C_read_Nack(&data[i]);
     240:	c8 01       	movw	r24, r16
     242:	8c 0f       	add	r24, r28
     244:	9d 1f       	adc	r25, r29
     246:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <I2C_read_Nack>
  I2C_stop();
     24a:	0e 94 f7 06 	call	0xdee	; 0xdee <I2C_stop>
#endif
  }
     24e:	df 91       	pop	r29
     250:	cf 91       	pop	r28
     252:	1f 91       	pop	r17
     254:	0f 91       	pop	r16
     256:	ff 90       	pop	r15
     258:	ef 90       	pop	r14
     25a:	08 95       	ret

0000025c <EEPROM_write_byte>:

void EEPROM_write_byte(u8 page, u8 address, s8 data) {
     25c:	1f 93       	push	r17
     25e:	cf 93       	push	r28
     260:	df 93       	push	r29
     262:	c8 2f       	mov	r28, r24
     264:	16 2f       	mov	r17, r22
     266:	d4 2f       	mov	r29, r20
  I2C_start();
     268:	0e 94 d0 06 	call	0xda0	; 0xda0 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     26c:	8c 2f       	mov	r24, r28
     26e:	88 0f       	add	r24, r24
     270:	80 56       	subi	r24, 0x60	; 96
     272:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  I2C_write(address);
     276:	81 2f       	mov	r24, r17
     278:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  I2C_write(data);
     27c:	8d 2f       	mov	r24, r29
     27e:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  I2C_stop();
     282:	0e 94 f7 06 	call	0xdee	; 0xdee <I2C_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     286:	8f e3       	ldi	r24, 0x3F	; 63
     288:	9c e9       	ldi	r25, 0x9C	; 156
     28a:	01 97       	sbiw	r24, 0x01	; 1
     28c:	f1 f7       	brne	.-4      	; 0x28a <EEPROM_write_byte+0x2e>
     28e:	00 c0       	rjmp	.+0      	; 0x290 <EEPROM_write_byte+0x34>
     290:	00 00       	nop

#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
  }
     292:	df 91       	pop	r29
     294:	cf 91       	pop	r28
     296:	1f 91       	pop	r17
     298:	08 95       	ret

0000029a <EEPROM_write_block>:

// bytes_number must be within page size (256 bytes)
void EEPROM_write_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     29a:	6f 92       	push	r6
     29c:	7f 92       	push	r7
     29e:	8f 92       	push	r8
     2a0:	9f 92       	push	r9
     2a2:	af 92       	push	r10
     2a4:	bf 92       	push	r11
     2a6:	cf 92       	push	r12
     2a8:	df 92       	push	r13
     2aa:	ef 92       	push	r14
     2ac:	ff 92       	push	r15
     2ae:	0f 93       	push	r16
     2b0:	1f 93       	push	r17
     2b2:	cf 93       	push	r28
     2b4:	df 93       	push	r29
     2b6:	78 2e       	mov	r7, r24
     2b8:	66 2e       	mov	r6, r22
     2ba:	6a 01       	movw	r12, r20
     2bc:	89 01       	movw	r16, r18
  //! If data is required to be written in the first 16 bytes starting from byte 10 for example, the data will be stored starting from bytes 10, 
  //! and if the data exceeds the row limit ** IT WILL ROLL OVER AND OVERWRITE THE ROW **. Therefore, in a single multibyte write cycle, we can't write more than 16 bytes at maximum if starting from the first byte in the row
  //! or the remaining bytes till the end of the row from the starting position. The remaining bytes must be written in another write cycle to avoind the roll over problem.

  u16 dataIndex, blockNumber, i;
  u16 first_block_size = 16 - (address % 16);
     2be:	86 2f       	mov	r24, r22
     2c0:	8f 70       	andi	r24, 0x0F	; 15
     2c2:	20 e1       	ldi	r18, 0x10	; 16
     2c4:	30 e0       	ldi	r19, 0x00	; 0
     2c6:	79 01       	movw	r14, r18
     2c8:	e8 1a       	sub	r14, r24
     2ca:	f1 08       	sbc	r15, r1
  if (16 - (address % 16) > bytes_number) first_block_size = bytes_number;
     2cc:	4e 15       	cp	r20, r14
     2ce:	5f 05       	cpc	r21, r15
     2d0:	08 f4       	brcc	.+2      	; 0x2d4 <EEPROM_write_block+0x3a>
     2d2:	7a 01       	movw	r14, r20

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
     2d4:	0e 94 d0 06 	call	0xda0	; 0xda0 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     2d8:	87 2d       	mov	r24, r7
     2da:	88 0f       	add	r24, r24
     2dc:	0f 2e       	mov	r0, r31
     2de:	f0 ea       	ldi	r31, 0xA0	; 160
     2e0:	7f 2e       	mov	r7, r31
     2e2:	f0 2d       	mov	r31, r0
     2e4:	78 0e       	add	r7, r24
     2e6:	87 2d       	mov	r24, r7
     2e8:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  I2C_write(address);
     2ec:	86 2d       	mov	r24, r6
     2ee:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2f2:	c0 e0       	ldi	r28, 0x00	; 0
     2f4:	d0 e0       	ldi	r29, 0x00	; 0
     2f6:	07 c0       	rjmp	.+14     	; 0x306 <EEPROM_write_block+0x6c>
    I2C_write(data[dataIndex]);
     2f8:	f8 01       	movw	r30, r16
     2fa:	ec 0f       	add	r30, r28
     2fc:	fd 1f       	adc	r31, r29
     2fe:	80 81       	ld	r24, Z
     300:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     304:	21 96       	adiw	r28, 0x01	; 1
     306:	ce 15       	cp	r28, r14
     308:	df 05       	cpc	r29, r15
     30a:	b0 f3       	brcs	.-20     	; 0x2f8 <EEPROM_write_block+0x5e>
    I2C_write(data[dataIndex]);
    }
  I2C_stop();
     30c:	0e 94 f7 06 	call	0xdee	; 0xdee <I2C_stop>
     310:	8f e3       	ldi	r24, 0x3F	; 63
     312:	9c e9       	ldi	r25, 0x9C	; 156
     314:	01 97       	sbiw	r24, 0x01	; 1
     316:	f1 f7       	brne	.-4      	; 0x314 <EEPROM_write_block+0x7a>
     318:	00 c0       	rjmp	.+0      	; 0x31a <EEPROM_write_block+0x80>
     31a:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif

  // Return if the data fits in the row (data fits in a single row or the remaining part of it after the address)
  if (first_block_size == bytes_number) return;
     31c:	ec 14       	cp	r14, r12
     31e:	fd 04       	cpc	r15, r13
     320:	09 f4       	brne	.+2      	; 0x324 <EEPROM_write_block+0x8a>
     322:	61 c0       	rjmp	.+194    	; 0x3e6 <EEPROM_write_block+0x14c>

  u16 last_block_size = (address + bytes_number) % 16;
     324:	56 01       	movw	r10, r12
     326:	a6 0c       	add	r10, r6
     328:	b1 1c       	adc	r11, r1
     32a:	9f e0       	ldi	r25, 0x0F	; 15
     32c:	a9 22       	and	r10, r25
     32e:	bb 24       	eor	r11, r11
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
     330:	ce 18       	sub	r12, r14
     332:	df 08       	sbc	r13, r15
     334:	ca 18       	sub	r12, r10
     336:	db 08       	sbc	r13, r11
     338:	d6 94       	lsr	r13
     33a:	c7 94       	ror	r12
     33c:	d6 94       	lsr	r13
     33e:	c7 94       	ror	r12
     340:	d6 94       	lsr	r13
     342:	c7 94       	ror	r12
     344:	d6 94       	lsr	r13
     346:	c7 94       	ror	r12
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     348:	e1 2c       	mov	r14, r1
     34a:	f1 2c       	mov	r15, r1
     34c:	27 c0       	rjmp	.+78     	; 0x39c <EEPROM_write_block+0x102>
    I2C_start();
     34e:	0e 94 d0 06 	call	0xda0	; 0xda0 <I2C_start>
    I2C_write(0xA0 + (page << 1));
     352:	87 2d       	mov	r24, r7
     354:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
    I2C_write(address + dataIndex);
     358:	8c 2f       	mov	r24, r28
     35a:	86 0d       	add	r24, r6
     35c:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
    for (i = 0;i < 16;i++) {
     360:	81 2c       	mov	r8, r1
     362:	91 2c       	mov	r9, r1
     364:	0b c0       	rjmp	.+22     	; 0x37c <EEPROM_write_block+0xe2>
      I2C_write(data[dataIndex + i]);
     366:	fe 01       	movw	r30, r28
     368:	e8 0d       	add	r30, r8
     36a:	f9 1d       	adc	r31, r9
     36c:	e0 0f       	add	r30, r16
     36e:	f1 1f       	adc	r31, r17
     370:	80 81       	ld	r24, Z
     372:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
    I2C_start();
    I2C_write(0xA0 + (page << 1));
    I2C_write(address + dataIndex);
    for (i = 0;i < 16;i++) {
     376:	8f ef       	ldi	r24, 0xFF	; 255
     378:	88 1a       	sub	r8, r24
     37a:	98 0a       	sbc	r9, r24
     37c:	90 e1       	ldi	r25, 0x10	; 16
     37e:	89 16       	cp	r8, r25
     380:	91 04       	cpc	r9, r1
     382:	88 f3       	brcs	.-30     	; 0x366 <EEPROM_write_block+0xcc>
      I2C_write(data[dataIndex + i]);
      }
    dataIndex += 16;
     384:	60 96       	adiw	r28, 0x10	; 16
    I2C_stop();
     386:	0e 94 f7 06 	call	0xdee	; 0xdee <I2C_stop>
     38a:	8f e3       	ldi	r24, 0x3F	; 63
     38c:	9c e9       	ldi	r25, 0x9C	; 156
     38e:	01 97       	sbiw	r24, 0x01	; 1
     390:	f1 f7       	brne	.-4      	; 0x38e <EEPROM_write_block+0xf4>
     392:	00 c0       	rjmp	.+0      	; 0x394 <EEPROM_write_block+0xfa>
     394:	00 00       	nop
  if (first_block_size == bytes_number) return;

  u16 last_block_size = (address + bytes_number) % 16;
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     396:	9f ef       	ldi	r25, 0xFF	; 255
     398:	e9 1a       	sub	r14, r25
     39a:	f9 0a       	sbc	r15, r25
     39c:	ec 14       	cp	r14, r12
     39e:	fd 04       	cpc	r15, r13
     3a0:	b0 f2       	brcs	.-84     	; 0x34e <EEPROM_write_block+0xb4>
    _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
    }

  // Write the last part of the data
  I2C_start();
     3a2:	0e 94 d0 06 	call	0xda0	; 0xda0 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     3a6:	87 2d       	mov	r24, r7
     3a8:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  I2C_write(address + dataIndex);
     3ac:	8c 2f       	mov	r24, r28
     3ae:	86 0d       	add	r24, r6
     3b0:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>
  for (i = 0;i < last_block_size;i++) {
     3b4:	e1 2c       	mov	r14, r1
     3b6:	f1 2c       	mov	r15, r1
     3b8:	0b c0       	rjmp	.+22     	; 0x3d0 <EEPROM_write_block+0x136>
    I2C_write(data[dataIndex + i]);
     3ba:	fe 01       	movw	r30, r28
     3bc:	ee 0d       	add	r30, r14
     3be:	ff 1d       	adc	r31, r15
     3c0:	e0 0f       	add	r30, r16
     3c2:	f1 1f       	adc	r31, r17
     3c4:	80 81       	ld	r24, Z
     3c6:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <I2C_write>

  // Write the last part of the data
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address + dataIndex);
  for (i = 0;i < last_block_size;i++) {
     3ca:	8f ef       	ldi	r24, 0xFF	; 255
     3cc:	e8 1a       	sub	r14, r24
     3ce:	f8 0a       	sbc	r15, r24
     3d0:	ea 14       	cp	r14, r10
     3d2:	fb 04       	cpc	r15, r11
     3d4:	90 f3       	brcs	.-28     	; 0x3ba <EEPROM_write_block+0x120>
    I2C_write(data[dataIndex + i]);
    }
  I2C_stop();
     3d6:	0e 94 f7 06 	call	0xdee	; 0xdee <I2C_stop>
     3da:	8f e3       	ldi	r24, 0x3F	; 63
     3dc:	9c e9       	ldi	r25, 0x9C	; 156
     3de:	01 97       	sbiw	r24, 0x01	; 1
     3e0:	f1 f7       	brne	.-4      	; 0x3de <EEPROM_write_block+0x144>
     3e2:	00 c0       	rjmp	.+0      	; 0x3e4 <EEPROM_write_block+0x14a>
     3e4:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
#endif
     3e6:	df 91       	pop	r29
     3e8:	cf 91       	pop	r28
     3ea:	1f 91       	pop	r17
     3ec:	0f 91       	pop	r16
     3ee:	ff 90       	pop	r15
     3f0:	ef 90       	pop	r14
     3f2:	df 90       	pop	r13
     3f4:	cf 90       	pop	r12
     3f6:	bf 90       	pop	r11
     3f8:	af 90       	pop	r10
     3fa:	9f 90       	pop	r9
     3fc:	8f 90       	pop	r8
     3fe:	7f 90       	pop	r7
     400:	6f 90       	pop	r6
     402:	08 95       	ret

00000404 <BT_sendChar>:
  DIO_init(HC_05_STATUS_PIN, HC_05_STATUS_PORT, IN);
  UART_init(baudRate);
  }

void BT_sendChar(s8 data) {
  UART_sendChar(data);
     404:	0e 94 27 0a 	call	0x144e	; 0x144e <UART_sendChar>
     408:	08 95       	ret

0000040a <BT_sendString>:
  }

void BT_sendString(s8* str) {
  UART_sendString(str);
     40a:	0e 94 2d 0a 	call	0x145a	; 0x145a <UART_sendString>
     40e:	08 95       	ret

00000410 <Keypad_init>:

#include "keypad.h"

EN_KeypadStatusCode_t Keypad_init(void) {
  // Set rows as outputs
  DIO_init(KEYPAD_R0_PIN, KEYPAD_PORT, OUT);
     410:	41 e0       	ldi	r20, 0x01	; 1
     412:	62 e4       	ldi	r22, 0x42	; 66
     414:	80 e0       	ldi	r24, 0x00	; 0
     416:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  DIO_init(KEYPAD_R1_PIN, KEYPAD_PORT, OUT);
     41a:	41 e0       	ldi	r20, 0x01	; 1
     41c:	62 e4       	ldi	r22, 0x42	; 66
     41e:	81 e0       	ldi	r24, 0x01	; 1
     420:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  DIO_init(KEYPAD_R2_PIN, KEYPAD_PORT, OUT);
     424:	41 e0       	ldi	r20, 0x01	; 1
     426:	62 e4       	ldi	r22, 0x42	; 66
     428:	82 e0       	ldi	r24, 0x02	; 2
     42a:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  DIO_init(KEYPAD_R3_PIN, KEYPAD_PORT, OUT);
     42e:	41 e0       	ldi	r20, 0x01	; 1
     430:	62 e4       	ldi	r22, 0x42	; 66
     432:	83 e0       	ldi	r24, 0x03	; 3
     434:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  // Set all high
  DIO_write(KEYPAD_R0_PIN, KEYPAD_PORT, HIGH);
     438:	41 e0       	ldi	r20, 0x01	; 1
     43a:	62 e4       	ldi	r22, 0x42	; 66
     43c:	80 e0       	ldi	r24, 0x00	; 0
     43e:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  DIO_write(KEYPAD_R1_PIN, KEYPAD_PORT, HIGH);
     442:	41 e0       	ldi	r20, 0x01	; 1
     444:	62 e4       	ldi	r22, 0x42	; 66
     446:	81 e0       	ldi	r24, 0x01	; 1
     448:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  DIO_write(KEYPAD_R2_PIN, KEYPAD_PORT, HIGH);
     44c:	41 e0       	ldi	r20, 0x01	; 1
     44e:	62 e4       	ldi	r22, 0x42	; 66
     450:	82 e0       	ldi	r24, 0x02	; 2
     452:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  DIO_write(KEYPAD_R3_PIN, KEYPAD_PORT, HIGH);
     456:	41 e0       	ldi	r20, 0x01	; 1
     458:	62 e4       	ldi	r22, 0x42	; 66
     45a:	83 e0       	ldi	r24, 0x03	; 3
     45c:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  // Set columns as inputs
  DIO_init(KEYPAD_C0_PIN, KEYPAD_PORT, IN);
     460:	40 e0       	ldi	r20, 0x00	; 0
     462:	62 e4       	ldi	r22, 0x42	; 66
     464:	84 e0       	ldi	r24, 0x04	; 4
     466:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  DIO_init(KEYPAD_C1_PIN, KEYPAD_PORT, IN);
     46a:	40 e0       	ldi	r20, 0x00	; 0
     46c:	62 e4       	ldi	r22, 0x42	; 66
     46e:	85 e0       	ldi	r24, 0x05	; 5
     470:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  DIO_init(KEYPAD_C2_PIN, KEYPAD_PORT, IN);
     474:	40 e0       	ldi	r20, 0x00	; 0
     476:	62 e4       	ldi	r22, 0x42	; 66
     478:	86 e0       	ldi	r24, 0x06	; 6
     47a:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  DIO_init(KEYPAD_C3_PIN, KEYPAD_PORT, IN);
     47e:	40 e0       	ldi	r20, 0x00	; 0
     480:	62 e4       	ldi	r22, 0x42	; 66
     482:	87 e0       	ldi	r24, 0x07	; 7
     484:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  // Activate the pull up resistors
  DIO_write(KEYPAD_C0_PIN, KEYPAD_PORT, HIGH);
     488:	41 e0       	ldi	r20, 0x01	; 1
     48a:	62 e4       	ldi	r22, 0x42	; 66
     48c:	84 e0       	ldi	r24, 0x04	; 4
     48e:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  DIO_write(KEYPAD_C1_PIN, KEYPAD_PORT, HIGH);
     492:	41 e0       	ldi	r20, 0x01	; 1
     494:	62 e4       	ldi	r22, 0x42	; 66
     496:	85 e0       	ldi	r24, 0x05	; 5
     498:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  DIO_write(KEYPAD_C2_PIN, KEYPAD_PORT, HIGH);
     49c:	41 e0       	ldi	r20, 0x01	; 1
     49e:	62 e4       	ldi	r22, 0x42	; 66
     4a0:	86 e0       	ldi	r24, 0x06	; 6
     4a2:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  DIO_write(KEYPAD_C3_PIN, KEYPAD_PORT, HIGH);
     4a6:	41 e0       	ldi	r20, 0x01	; 1
     4a8:	62 e4       	ldi	r22, 0x42	; 66
     4aa:	87 e0       	ldi	r24, 0x07	; 7
     4ac:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>

  return KEYPAD_INIT_OK;
  }
     4b0:	80 e0       	ldi	r24, 0x00	; 0
     4b2:	08 95       	ret

000004b4 <toggle_row>:

void toggle_row(u8 row) {
  switch (row) {
     4b4:	81 30       	cpi	r24, 0x01	; 1
     4b6:	59 f0       	breq	.+22     	; 0x4ce <toggle_row+0x1a>
     4b8:	28 f0       	brcs	.+10     	; 0x4c4 <toggle_row+0x10>
     4ba:	82 30       	cpi	r24, 0x02	; 2
     4bc:	69 f0       	breq	.+26     	; 0x4d8 <toggle_row+0x24>
     4be:	83 30       	cpi	r24, 0x03	; 3
     4c0:	81 f0       	breq	.+32     	; 0x4e2 <toggle_row+0x2e>
     4c2:	08 95       	ret
      case 0:
        DIO_toggle(KEYPAD_R0_PIN, KEYPAD_PORT);
     4c4:	62 e4       	ldi	r22, 0x42	; 66
     4c6:	80 e0       	ldi	r24, 0x00	; 0
     4c8:	0e 94 55 06 	call	0xcaa	; 0xcaa <DIO_toggle>
        break;
     4cc:	08 95       	ret
      case 1:
        DIO_toggle(KEYPAD_R1_PIN, KEYPAD_PORT);
     4ce:	62 e4       	ldi	r22, 0x42	; 66
     4d0:	81 e0       	ldi	r24, 0x01	; 1
     4d2:	0e 94 55 06 	call	0xcaa	; 0xcaa <DIO_toggle>
        break;
     4d6:	08 95       	ret
      case 2:
        DIO_toggle(KEYPAD_R2_PIN, KEYPAD_PORT);
     4d8:	62 e4       	ldi	r22, 0x42	; 66
     4da:	82 e0       	ldi	r24, 0x02	; 2
     4dc:	0e 94 55 06 	call	0xcaa	; 0xcaa <DIO_toggle>
        break;
     4e0:	08 95       	ret
      case 3:
        DIO_toggle(KEYPAD_R3_PIN, KEYPAD_PORT);
     4e2:	62 e4       	ldi	r22, 0x42	; 66
     4e4:	83 e0       	ldi	r24, 0x03	; 3
     4e6:	0e 94 55 06 	call	0xcaa	; 0xcaa <DIO_toggle>
     4ea:	08 95       	ret

000004ec <check_col>:
        break;
    }
  }

void check_col(u8 col, u8* res) {
  switch (col) {
     4ec:	81 30       	cpi	r24, 0x01	; 1
     4ee:	61 f0       	breq	.+24     	; 0x508 <check_col+0x1c>
     4f0:	28 f0       	brcs	.+10     	; 0x4fc <check_col+0x10>
     4f2:	82 30       	cpi	r24, 0x02	; 2
     4f4:	79 f0       	breq	.+30     	; 0x514 <check_col+0x28>
     4f6:	83 30       	cpi	r24, 0x03	; 3
     4f8:	99 f0       	breq	.+38     	; 0x520 <check_col+0x34>
     4fa:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_C0_PIN, KEYPAD_PORT, res);
     4fc:	ab 01       	movw	r20, r22
     4fe:	62 e4       	ldi	r22, 0x42	; 66
     500:	84 e0       	ldi	r24, 0x04	; 4
     502:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DIO_Read>
        break;
     506:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_C1_PIN, KEYPAD_PORT, res);
     508:	ab 01       	movw	r20, r22
     50a:	62 e4       	ldi	r22, 0x42	; 66
     50c:	85 e0       	ldi	r24, 0x05	; 5
     50e:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DIO_Read>
        break;
     512:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_C2_PIN, KEYPAD_PORT, res);
     514:	ab 01       	movw	r20, r22
     516:	62 e4       	ldi	r22, 0x42	; 66
     518:	86 e0       	ldi	r24, 0x06	; 6
     51a:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DIO_Read>
        break;
     51e:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_C3_PIN, KEYPAD_PORT, res);
     520:	ab 01       	movw	r20, r22
     522:	62 e4       	ldi	r22, 0x42	; 66
     524:	87 e0       	ldi	r24, 0x07	; 7
     526:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DIO_Read>
     52a:	08 95       	ret

0000052c <check_row>:
        break;
    }
  }

void check_row(u8 row, u8* res) {
  switch (row) {
     52c:	81 30       	cpi	r24, 0x01	; 1
     52e:	61 f0       	breq	.+24     	; 0x548 <check_row+0x1c>
     530:	28 f0       	brcs	.+10     	; 0x53c <check_row+0x10>
     532:	82 30       	cpi	r24, 0x02	; 2
     534:	79 f0       	breq	.+30     	; 0x554 <check_row+0x28>
     536:	83 30       	cpi	r24, 0x03	; 3
     538:	99 f0       	breq	.+38     	; 0x560 <check_row+0x34>
     53a:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_R0_PIN, KEYPAD_PORT, res);
     53c:	ab 01       	movw	r20, r22
     53e:	62 e4       	ldi	r22, 0x42	; 66
     540:	80 e0       	ldi	r24, 0x00	; 0
     542:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DIO_Read>
        break;
     546:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_R1_PIN, KEYPAD_PORT, res);
     548:	ab 01       	movw	r20, r22
     54a:	62 e4       	ldi	r22, 0x42	; 66
     54c:	81 e0       	ldi	r24, 0x01	; 1
     54e:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DIO_Read>
        break;
     552:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_R2_PIN, KEYPAD_PORT, res);
     554:	ab 01       	movw	r20, r22
     556:	62 e4       	ldi	r22, 0x42	; 66
     558:	82 e0       	ldi	r24, 0x02	; 2
     55a:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DIO_Read>
        break;
     55e:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_R3_PIN, KEYPAD_PORT, res);
     560:	ab 01       	movw	r20, r22
     562:	62 e4       	ldi	r22, 0x42	; 66
     564:	83 e0       	ldi	r24, 0x03	; 3
     566:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DIO_Read>
     56a:	08 95       	ret

0000056c <Keypad_getPressedKey>:
        break;
    }
  }

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
     56c:	ef 92       	push	r14
     56e:	ff 92       	push	r15
     570:	0f 93       	push	r16
     572:	1f 93       	push	r17
     574:	cf 93       	push	r28
     576:	df 93       	push	r29
     578:	cd b7       	in	r28, 0x3d	; 61
     57a:	de b7       	in	r29, 0x3e	; 62
     57c:	62 97       	sbiw	r28, 0x12	; 18
     57e:	0f b6       	in	r0, 0x3f	; 63
     580:	f8 94       	cli
     582:	de bf       	out	0x3e, r29	; 62
     584:	0f be       	out	0x3f, r0	; 63
     586:	cd bf       	out	0x3d, r28	; 61
     588:	7c 01       	movw	r14, r24
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
     58a:	80 e1       	ldi	r24, 0x10	; 16
     58c:	e0 e6       	ldi	r30, 0x60	; 96
     58e:	f0 e0       	ldi	r31, 0x00	; 0
     590:	de 01       	movw	r26, r28
     592:	11 96       	adiw	r26, 0x01	; 1
     594:	01 90       	ld	r0, Z+
     596:	0d 92       	st	X+, r0
     598:	8a 95       	dec	r24
     59a:	e1 f7       	brne	.-8      	; 0x594 <Keypad_getPressedKey+0x28>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     59c:	00 e0       	ldi	r16, 0x00	; 0
     59e:	1c c0       	rjmp	.+56     	; 0x5d8 <Keypad_getPressedKey+0x6c>
    check_row(row, &row_state);
     5a0:	be 01       	movw	r22, r28
     5a2:	6e 5e       	subi	r22, 0xEE	; 238
     5a4:	7f 4f       	sbci	r23, 0xFF	; 255
     5a6:	80 2f       	mov	r24, r16
     5a8:	0e 94 96 02 	call	0x52c	; 0x52c <check_row>
    if (row_state == LOW) {
     5ac:	8a 89       	ldd	r24, Y+18	; 0x12
     5ae:	88 23       	and	r24, r24
     5b0:	61 f0       	breq	.+24     	; 0x5ca <Keypad_getPressedKey+0x5e>
     5b2:	11 c0       	rjmp	.+34     	; 0x5d6 <Keypad_getPressedKey+0x6a>
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
     5b4:	be 01       	movw	r22, r28
     5b6:	6f 5e       	subi	r22, 0xEF	; 239
     5b8:	7f 4f       	sbci	r23, 0xFF	; 255
     5ba:	81 2f       	mov	r24, r17
     5bc:	0e 94 76 02 	call	0x4ec	; 0x4ec <check_col>
        if (col_state == LOW) {
     5c0:	89 89       	ldd	r24, Y+17	; 0x11
     5c2:	88 23       	and	r24, r24
     5c4:	c9 f1       	breq	.+114    	; 0x638 <Keypad_getPressedKey+0xcc>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
     5c6:	1f 5f       	subi	r17, 0xFF	; 255
     5c8:	01 c0       	rjmp	.+2      	; 0x5cc <Keypad_getPressedKey+0x60>
     5ca:	10 e0       	ldi	r17, 0x00	; 0
     5cc:	14 30       	cpi	r17, 0x04	; 4
     5ce:	90 f3       	brcs	.-28     	; 0x5b4 <Keypad_getPressedKey+0x48>
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
          }
        }
      toggle_row(row);
     5d0:	80 2f       	mov	r24, r16
     5d2:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <toggle_row>

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     5d6:	0f 5f       	subi	r16, 0xFF	; 255
     5d8:	04 30       	cpi	r16, 0x04	; 4
     5da:	10 f3       	brcs	.-60     	; 0x5a0 <Keypad_getPressedKey+0x34>
     5dc:	00 e0       	ldi	r16, 0x00	; 0
     5de:	28 c0       	rjmp	.+80     	; 0x630 <Keypad_getPressedKey+0xc4>
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
     5e0:	80 2f       	mov	r24, r16
     5e2:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <toggle_row>
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     5e6:	10 e0       	ldi	r17, 0x00	; 0
     5e8:	1d c0       	rjmp	.+58     	; 0x624 <Keypad_getPressedKey+0xb8>
      check_col(col, &col_state);
     5ea:	be 01       	movw	r22, r28
     5ec:	6f 5e       	subi	r22, 0xEF	; 239
     5ee:	7f 4f       	sbci	r23, 0xFF	; 255
     5f0:	81 2f       	mov	r24, r17
     5f2:	0e 94 76 02 	call	0x4ec	; 0x4ec <check_col>
      if (col_state == LOW) {
     5f6:	89 89       	ldd	r24, Y+17	; 0x11
     5f8:	81 11       	cpse	r24, r1
     5fa:	13 c0       	rjmp	.+38     	; 0x622 <Keypad_getPressedKey+0xb6>
        // while (col_state == LOW) {  // Wait until the key is released (busy waiting - halts the system)
        //   check_col(col, &col_state);
        //   }
        *key = keys[row][col];
     5fc:	e0 2f       	mov	r30, r16
     5fe:	f0 e0       	ldi	r31, 0x00	; 0
     600:	ee 0f       	add	r30, r30
     602:	ff 1f       	adc	r31, r31
     604:	ee 0f       	add	r30, r30
     606:	ff 1f       	adc	r31, r31
     608:	81 e0       	ldi	r24, 0x01	; 1
     60a:	90 e0       	ldi	r25, 0x00	; 0
     60c:	8c 0f       	add	r24, r28
     60e:	9d 1f       	adc	r25, r29
     610:	e8 0f       	add	r30, r24
     612:	f9 1f       	adc	r31, r25
     614:	e1 0f       	add	r30, r17
     616:	f1 1d       	adc	r31, r1
     618:	80 81       	ld	r24, Z
     61a:	f7 01       	movw	r30, r14
     61c:	80 83       	st	Z, r24
        return KEY_PRESSED;
     61e:	81 e0       	ldi	r24, 0x01	; 1
     620:	0c c0       	rjmp	.+24     	; 0x63a <Keypad_getPressedKey+0xce>
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     622:	1f 5f       	subi	r17, 0xFF	; 255
     624:	14 30       	cpi	r17, 0x04	; 4
     626:	08 f3       	brcs	.-62     	; 0x5ea <Keypad_getPressedKey+0x7e>
        //   }
        *key = keys[row][col];
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
     628:	80 2f       	mov	r24, r16
     62a:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <toggle_row>
          }
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
     62e:	0f 5f       	subi	r16, 0xFF	; 255
     630:	04 30       	cpi	r16, 0x04	; 4
     632:	b0 f2       	brcs	.-84     	; 0x5e0 <Keypad_getPressedKey+0x74>
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     634:	82 e0       	ldi	r24, 0x02	; 2
     636:	01 c0       	rjmp	.+2      	; 0x63a <Keypad_getPressedKey+0xce>
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
     638:	82 e0       	ldi	r24, 0x02	; 2
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     63a:	62 96       	adiw	r28, 0x12	; 18
     63c:	0f b6       	in	r0, 0x3f	; 63
     63e:	f8 94       	cli
     640:	de bf       	out	0x3e, r29	; 62
     642:	0f be       	out	0x3f, r0	; 63
     644:	cd bf       	out	0x3d, r28	; 61
     646:	df 91       	pop	r29
     648:	cf 91       	pop	r28
     64a:	1f 91       	pop	r17
     64c:	0f 91       	pop	r16
     64e:	ff 90       	pop	r15
     650:	ef 90       	pop	r14
     652:	08 95       	ret

00000654 <LCD_sendEnablePulse>:
#include "lcd.h"

 // TODO: implement the eight bit mode

void LCD_sendEnablePulse(void) {
  DIO_write(EN, LCD_CTRL_PORT, HIGH);
     654:	41 e0       	ldi	r20, 0x01	; 1
     656:	61 e4       	ldi	r22, 0x41	; 65
     658:	86 e0       	ldi	r24, 0x06	; 6
     65a:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     65e:	8a e1       	ldi	r24, 0x1A	; 26
     660:	8a 95       	dec	r24
     662:	f1 f7       	brne	.-4      	; 0x660 <LCD_sendEnablePulse+0xc>
     664:	00 c0       	rjmp	.+0      	; 0x666 <LCD_sendEnablePulse+0x12>
  _delay_us(5);
  DIO_write(EN, LCD_CTRL_PORT, LOW);
     666:	40 e0       	ldi	r20, 0x00	; 0
     668:	61 e4       	ldi	r22, 0x41	; 65
     66a:	86 e0       	ldi	r24, 0x06	; 6
     66c:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
     670:	08 95       	ret

00000672 <LCD_write_4bits>:
  }

void LCD_write_4bits(u8 data) {
     672:	cf 93       	push	r28
     674:	c8 2f       	mov	r28, r24
  DIO_write(LCD_DATA_PIN4, LCD_DATA_PORT, read_bit(data, 0));
     676:	48 2f       	mov	r20, r24
     678:	41 70       	andi	r20, 0x01	; 1
     67a:	61 e4       	ldi	r22, 0x41	; 65
     67c:	80 e0       	ldi	r24, 0x00	; 0
     67e:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  DIO_write(LCD_DATA_PIN5, LCD_DATA_PORT, read_bit(data, 1));
     682:	c1 fb       	bst	r28, 1
     684:	44 27       	eor	r20, r20
     686:	40 f9       	bld	r20, 0
     688:	61 e4       	ldi	r22, 0x41	; 65
     68a:	81 e0       	ldi	r24, 0x01	; 1
     68c:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  DIO_write(LCD_DATA_PIN6, LCD_DATA_PORT, read_bit(data, 2));
     690:	c2 fb       	bst	r28, 2
     692:	44 27       	eor	r20, r20
     694:	40 f9       	bld	r20, 0
     696:	61 e4       	ldi	r22, 0x41	; 65
     698:	82 e0       	ldi	r24, 0x02	; 2
     69a:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  DIO_write(LCD_DATA_PIN7, LCD_DATA_PORT, read_bit(data, 3));
     69e:	c3 fb       	bst	r28, 3
     6a0:	44 27       	eor	r20, r20
     6a2:	40 f9       	bld	r20, 0
     6a4:	61 e4       	ldi	r22, 0x41	; 65
     6a6:	83 e0       	ldi	r24, 0x03	; 3
     6a8:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  }
     6ac:	cf 91       	pop	r28
     6ae:	08 95       	ret

000006b0 <LCD_sendData>:

void LCD_sendData(u8 data) {
     6b0:	cf 93       	push	r28
     6b2:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(data >> 4);
     6b4:	82 95       	swap	r24
     6b6:	8f 70       	andi	r24, 0x0F	; 15
     6b8:	0e 94 39 03 	call	0x672	; 0x672 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, HIGH); // To indicate that this data
     6bc:	41 e0       	ldi	r20, 0x01	; 1
     6be:	61 e4       	ldi	r22, 0x41	; 65
     6c0:	84 e0       	ldi	r24, 0x04	; 4
     6c2:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>

  LCD_sendEnablePulse();
     6c6:	0e 94 2a 03 	call	0x654	; 0x654 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the data to be sent

  LCD_write_4bits(data);
     6ca:	8c 2f       	mov	r24, r28
     6cc:	0e 94 39 03 	call	0x672	; 0x672 <LCD_write_4bits>

  LCD_sendEnablePulse();
     6d0:	0e 94 2a 03 	call	0x654	; 0x654 <LCD_sendEnablePulse>
     6d4:	85 e0       	ldi	r24, 0x05	; 5
     6d6:	8a 95       	dec	r24
     6d8:	f1 f7       	brne	.-4      	; 0x6d6 <LCD_sendData+0x26>
     6da:	00 00       	nop

  _delay_us(1); // wait for the data to be processed
#else

#endif
  }
     6dc:	cf 91       	pop	r28
     6de:	08 95       	ret

000006e0 <LCD_sendCommand>:

void LCD_sendCommand(u8 cmd) {
     6e0:	cf 93       	push	r28
     6e2:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(cmd >> 4);
     6e4:	82 95       	swap	r24
     6e6:	8f 70       	andi	r24, 0x0F	; 15
     6e8:	0e 94 39 03 	call	0x672	; 0x672 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, LOW); // To indicate that this a command
     6ec:	40 e0       	ldi	r20, 0x00	; 0
     6ee:	61 e4       	ldi	r22, 0x41	; 65
     6f0:	84 e0       	ldi	r24, 0x04	; 4
     6f2:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>

  LCD_sendEnablePulse();
     6f6:	0e 94 2a 03 	call	0x654	; 0x654 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the command to be sent

  LCD_write_4bits(cmd);
     6fa:	8c 2f       	mov	r24, r28
     6fc:	0e 94 39 03 	call	0x672	; 0x672 <LCD_write_4bits>

  LCD_sendEnablePulse();
     700:	0e 94 2a 03 	call	0x654	; 0x654 <LCD_sendEnablePulse>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     704:	8f ed       	ldi	r24, 0xDF	; 223
     706:	9e e2       	ldi	r25, 0x2E	; 46
     708:	01 97       	sbiw	r24, 0x01	; 1
     70a:	f1 f7       	brne	.-4      	; 0x708 <LCD_sendCommand+0x28>
     70c:	00 c0       	rjmp	.+0      	; 0x70e <LCD_sendCommand+0x2e>
     70e:	00 00       	nop

  _delay_ms(3); // wait for the command to be executed
#else

#endif
  }
     710:	cf 91       	pop	r28
     712:	08 95       	ret

00000714 <LCD_clear_screen>:

void LCD_clear_screen() {
  LCD_sendCommand(0x01);
     714:	81 e0       	ldi	r24, 0x01	; 1
     716:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_sendCommand>
     71a:	08 95       	ret

0000071c <LCD_init>:
     71c:	2f ef       	ldi	r18, 0xFF	; 255
     71e:	89 ef       	ldi	r24, 0xF9	; 249
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	21 50       	subi	r18, 0x01	; 1
     724:	80 40       	sbci	r24, 0x00	; 0
     726:	90 40       	sbci	r25, 0x00	; 0
     728:	e1 f7       	brne	.-8      	; 0x722 <LCD_init+0x6>
     72a:	00 c0       	rjmp	.+0      	; 0x72c <LCD_init+0x10>
     72c:	00 00       	nop

void LCD_init(void) {
  _delay_ms(20); // wait for the LCD to start up.

#if LCD_MODE == FOUR_BIT_MODE
  DIO_init(LCD_DATA_PIN4, LCD_DATA_PORT, OUT);
     72e:	41 e0       	ldi	r20, 0x01	; 1
     730:	61 e4       	ldi	r22, 0x41	; 65
     732:	80 e0       	ldi	r24, 0x00	; 0
     734:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  DIO_init(LCD_DATA_PIN5, LCD_DATA_PORT, OUT);
     738:	41 e0       	ldi	r20, 0x01	; 1
     73a:	61 e4       	ldi	r22, 0x41	; 65
     73c:	81 e0       	ldi	r24, 0x01	; 1
     73e:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  DIO_init(LCD_DATA_PIN6, LCD_DATA_PORT, OUT);
     742:	41 e0       	ldi	r20, 0x01	; 1
     744:	61 e4       	ldi	r22, 0x41	; 65
     746:	82 e0       	ldi	r24, 0x02	; 2
     748:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  DIO_init(LCD_DATA_PIN7, LCD_DATA_PORT, OUT);
     74c:	41 e0       	ldi	r20, 0x01	; 1
     74e:	61 e4       	ldi	r22, 0x41	; 65
     750:	83 e0       	ldi	r24, 0x03	; 3
     752:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>

  DIO_init(RS, LCD_CTRL_PORT, OUT);
     756:	41 e0       	ldi	r20, 0x01	; 1
     758:	61 e4       	ldi	r22, 0x41	; 65
     75a:	84 e0       	ldi	r24, 0x04	; 4
     75c:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  DIO_init(RW, LCD_CTRL_PORT, OUT);
     760:	41 e0       	ldi	r20, 0x01	; 1
     762:	61 e4       	ldi	r22, 0x41	; 65
     764:	85 e0       	ldi	r24, 0x05	; 5
     766:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  DIO_init(EN, LCD_CTRL_PORT, OUT);
     76a:	41 e0       	ldi	r20, 0x01	; 1
     76c:	61 e4       	ldi	r22, 0x41	; 65
     76e:	86 e0       	ldi	r24, 0x06	; 6
     770:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>

  DIO_write(RW, LCD_CTRL_PORT, LOW);
     774:	40 e0       	ldi	r20, 0x00	; 0
     776:	61 e4       	ldi	r22, 0x41	; 65
     778:	85 e0       	ldi	r24, 0x05	; 5
     77a:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>

  LCD_sendCommand(0x02);  // return home 
     77e:	82 e0       	ldi	r24, 0x02	; 2
     780:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_sendCommand>
  LCD_sendCommand(0x28);  // 2 line  and 4 bit mode
     784:	88 e2       	ldi	r24, 0x28	; 40
     786:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_sendCommand>
  LCD_sendCommand(0x0C);  // display on 
     78a:	8c e0       	ldi	r24, 0x0C	; 12
     78c:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_sendCommand>
  LCD_sendCommand(0x06);  // auto increment 
     790:	86 e0       	ldi	r24, 0x06	; 6
     792:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_sendCommand>
  LCD_clear_screen();
     796:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
     79a:	08 95       	ret

0000079c <LCD_write_string>:
#else

#endif
  }

void LCD_write_string(s8* str) {
     79c:	cf 92       	push	r12
     79e:	df 92       	push	r13
     7a0:	ef 92       	push	r14
     7a2:	ff 92       	push	r15
     7a4:	cf 93       	push	r28
     7a6:	df 93       	push	r29
     7a8:	ec 01       	movw	r28, r24
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     7aa:	c1 2c       	mov	r12, r1
     7ac:	d1 2c       	mov	r13, r1
     7ae:	76 01       	movw	r14, r12
     7b0:	07 c0       	rjmp	.+14     	; 0x7c0 <LCD_write_string+0x24>
    LCD_sendData(str[i]);
     7b2:	0e 94 58 03 	call	0x6b0	; 0x6b0 <LCD_sendData>
#endif
  }

void LCD_write_string(s8* str) {
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     7b6:	8f ef       	ldi	r24, 0xFF	; 255
     7b8:	c8 1a       	sub	r12, r24
     7ba:	d8 0a       	sbc	r13, r24
     7bc:	e8 0a       	sbc	r14, r24
     7be:	f8 0a       	sbc	r15, r24
     7c0:	fe 01       	movw	r30, r28
     7c2:	ec 0d       	add	r30, r12
     7c4:	fd 1d       	adc	r31, r13
     7c6:	80 81       	ld	r24, Z
     7c8:	81 11       	cpse	r24, r1
     7ca:	f3 cf       	rjmp	.-26     	; 0x7b2 <LCD_write_string+0x16>
    LCD_sendData(str[i]);
    }
  }
     7cc:	df 91       	pop	r29
     7ce:	cf 91       	pop	r28
     7d0:	ff 90       	pop	r15
     7d2:	ef 90       	pop	r14
     7d4:	df 90       	pop	r13
     7d6:	cf 90       	pop	r12
     7d8:	08 95       	ret

000007da <LCD_move_cursor_xy>:

void LCD_move_cursor_xy(u8 x, u8 y) {
  switch (y) {
     7da:	66 23       	and	r22, r22
     7dc:	19 f0       	breq	.+6      	; 0x7e4 <LCD_move_cursor_xy+0xa>
     7de:	61 30       	cpi	r22, 0x01	; 1
     7e0:	29 f0       	breq	.+10     	; 0x7ec <LCD_move_cursor_xy+0x12>
     7e2:	08 95       	ret
      case 0:
        LCD_sendCommand(0x80 + x);
     7e4:	80 58       	subi	r24, 0x80	; 128
     7e6:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_sendCommand>
        break;
     7ea:	08 95       	ret
      case 1:
        LCD_sendCommand(0xC0 + x);
     7ec:	80 54       	subi	r24, 0x40	; 64
     7ee:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_sendCommand>
     7f2:	08 95       	ret

000007f4 <LCD_write_string_xy>:
        break;
    }
  }

void LCD_write_string_xy(u8 x, u8 y, s8* str) {
     7f4:	cf 93       	push	r28
     7f6:	df 93       	push	r29
     7f8:	ea 01       	movw	r28, r20
  LCD_move_cursor_xy(x, y);
     7fa:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_move_cursor_xy>
  LCD_write_string(str);
     7fe:	ce 01       	movw	r24, r28
     800:	0e 94 ce 03 	call	0x79c	; 0x79c <LCD_write_string>
  // TODO: Input validation
     804:	df 91       	pop	r29
     806:	cf 91       	pop	r28
     808:	08 95       	ret

0000080a <LED_init>:
 */

#include "led.h"

 // Initialize the LED
EN_ledError_t LED_init(u8 ledPort, u8 ledPin) {
     80a:	98 2f       	mov	r25, r24
     80c:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(ledPin, ledPort, OUT) == DIO_OK) {
     80e:	41 e0       	ldi	r20, 0x01	; 1
     810:	69 2f       	mov	r22, r25
     812:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
     816:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that the led initialization failed
  return LED_ERROR_INIT;
     818:	81 e0       	ldi	r24, 0x01	; 1
  }
     81a:	08 95       	ret

0000081c <LED_on>:

// Turn on the LED
EN_ledError_t LED_on(u8 ledPort, u8 ledPin) {
     81c:	98 2f       	mov	r25, r24
     81e:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, HIGH) == DIO_OK) {
     820:	41 e0       	ldi	r20, 0x01	; 1
     822:	69 2f       	mov	r22, r25
     824:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
     828:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn on the led has failed
  return LED_ERROR_ON;
     82a:	82 e0       	ldi	r24, 0x02	; 2
  }
     82c:	08 95       	ret

0000082e <LED_off>:

// Turn off the LED
EN_ledError_t LED_off(u8 ledPort, u8 ledPin) {
     82e:	98 2f       	mov	r25, r24
     830:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, LOW) == DIO_OK) {
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	69 2f       	mov	r22, r25
     836:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
     83a:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn off the led has failed
  return LED_ERROR_OFF;
     83c:	83 e0       	ldi	r24, 0x03	; 3
  }
     83e:	08 95       	ret

00000840 <LED_toggle>:

// Toggle the LED
EN_ledError_t LED_toggle(u8 ledPort, u8 ledPin) {
     840:	98 2f       	mov	r25, r24
     842:	86 2f       	mov	r24, r22
  if (DIO_toggle(ledPin, ledPort) == DIO_OK) {
     844:	69 2f       	mov	r22, r25
     846:	0e 94 55 06 	call	0xcaa	; 0xcaa <DIO_toggle>
     84a:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to toggle the led has failed
  return LED_ERROR_TOGGLE;
     84c:	84 e0       	ldi	r24, 0x04	; 4
     84e:	08 95       	ret

00000850 <LM35_init_INT>:
  ADC_init();
  ADC_select_channel(pinNumber);
  }

// Initialize LM35 with the ADC in auto trigger mode
void LM35_init_INT(u8 pinNumber, u8 trigger) {
     850:	cf 93       	push	r28
     852:	df 93       	push	r29
     854:	c8 2f       	mov	r28, r24
     856:	d6 2f       	mov	r29, r22
  DIO_init(pinNumber, PORT_A, IN);
     858:	40 e0       	ldi	r20, 0x00	; 0
     85a:	61 e4       	ldi	r22, 0x41	; 65
     85c:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  ADC_init_auto_trigger(trigger);
     860:	8d 2f       	mov	r24, r29
     862:	0e 94 75 04 	call	0x8ea	; 0x8ea <ADC_init_auto_trigger>
  ADC_select_channel(pinNumber);
     866:	8c 2f       	mov	r24, r28
     868:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <ADC_select_channel>
     86c:	df 91       	pop	r29
     86e:	cf 91       	pop	r28
     870:	08 95       	ret

00000872 <Servo_init>:

#include "servo.h"

 // Initialized the servo
void Servo_init() {
  DIO_init(SERVO_PIN, SERVO_PORT, OUT);
     872:	41 e0       	ldi	r20, 0x01	; 1
     874:	64 e4       	ldi	r22, 0x44	; 68
     876:	85 e0       	ldi	r24, 0x05	; 5
     878:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
  PWM_init(SERVO_PWM_PIN, (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS), PWM_PHASE_CORRECT);
     87c:	22 e0       	ldi	r18, 0x02	; 2
     87e:	4d ec       	ldi	r20, 0xCD	; 205
     880:	5c ec       	ldi	r21, 0xCC	; 204
     882:	6c ec       	ldi	r22, 0xCC	; 204
     884:	7c e3       	ldi	r23, 0x3C	; 60
     886:	81 e0       	ldi	r24, 0x01	; 1
     888:	0e 94 41 09 	call	0x1282	; 0x1282 <PWM_init>
  Timer_start(TIMER_1, 8);
     88c:	68 e0       	ldi	r22, 0x08	; 8
     88e:	70 e0       	ldi	r23, 0x00	; 0
     890:	81 e0       	ldi	r24, 0x01	; 1
     892:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <Timer_start>
     896:	08 95       	ret

00000898 <Servo_move_to_angle>:
  }

// Moves the servo to a specific angle (relative to the 0 angle position, not the previous one).
void Servo_move_to_angle(u8 angle) {
  PWM_set_DC(SERVO_PWM_PIN, ((double)angle / ((SERVO_MAX_ANGLE - SERVO_MIN_ANGLE) * (SERVO_PULSE_PERIODIC_TIME_mS / (SERVO_MAX_HIGH_PULSE_DURATION_mS - SERVO_MIN_HIGH_PULSE_DURATION_mS)))) + (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS));
     898:	68 2f       	mov	r22, r24
     89a:	70 e0       	ldi	r23, 0x00	; 0
     89c:	80 e0       	ldi	r24, 0x00	; 0
     89e:	90 e0       	ldi	r25, 0x00	; 0
     8a0:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <__floatunsisf>
     8a4:	20 e0       	ldi	r18, 0x00	; 0
     8a6:	30 e0       	ldi	r19, 0x00	; 0
     8a8:	41 ee       	ldi	r20, 0xE1	; 225
     8aa:	54 e4       	ldi	r21, 0x44	; 68
     8ac:	0e 94 20 16 	call	0x2c40	; 0x2c40 <__divsf3>
     8b0:	2d ec       	ldi	r18, 0xCD	; 205
     8b2:	3c ec       	ldi	r19, 0xCC	; 204
     8b4:	4c ec       	ldi	r20, 0xCC	; 204
     8b6:	5c e3       	ldi	r21, 0x3C	; 60
     8b8:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <__addsf3>
     8bc:	ab 01       	movw	r20, r22
     8be:	bc 01       	movw	r22, r24
     8c0:	81 e0       	ldi	r24, 0x01	; 1
     8c2:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <PWM_set_DC>
     8c6:	08 95       	ret

000008c8 <main>:
#include "Application/app.h"
// #include "Services/Local_access/local.h"

int main(void) {
	
	App_init();
     8c8:	0e 94 ab 00 	call	0x156	; 0x156 <App_init>
	
	App_start();
     8cc:	0e 94 bc 00 	call	0x178	; 0x178 <App_start>
	
	}
     8d0:	80 e0       	ldi	r24, 0x00	; 0
     8d2:	90 e0       	ldi	r25, 0x00	; 0
     8d4:	08 95       	ret

000008d6 <ADC_select_channel>:
  //   adjusted and no more than 8 - bit precision is required, it is sufficient to read ADCH.Otherwise, ADCL must be read
  //   first, then ADCH.
  * result = (u16)ADCL + ((u16)ADCH << 8); //? This will work
  //! *result = ((u16)ADCH << 8) + (u16)ADCL; // This won't work
  return ADC_OK;
  }
     8d6:	88 30       	cpi	r24, 0x08	; 8
     8d8:	30 f4       	brcc	.+12     	; 0x8e6 <ADC_select_channel+0x10>
     8da:	97 b1       	in	r25, 0x07	; 7
     8dc:	90 7e       	andi	r25, 0xE0	; 224
     8de:	89 2b       	or	r24, r25
     8e0:	87 b9       	out	0x07, r24	; 7
     8e2:	80 e0       	ldi	r24, 0x00	; 0
     8e4:	08 95       	ret
     8e6:	81 e0       	ldi	r24, 0x01	; 1
     8e8:	08 95       	ret

000008ea <ADC_init_auto_trigger>:

// Initialize the ADC in auto trigger mode
EN_ADCError_t ADC_init_auto_trigger(u8 trigger) {
     8ea:	e8 2f       	mov	r30, r24
  // since the defualt for pins is to be low (0) we don't need to change anything here(since it's 0).
  // I don't need to write anything too. Because the VREF won't be changed during the run time. The only case I will need to clear a bit is if it was set by the MCU or me.
#elif (ADC_VREF == AVCC)
  set_bit(ADMUX, REFS0);
#elif (ADC_VREF == INTERNAL_VREF)
  set_bit(ADMUX, REFS0);
     8ec:	87 b1       	in	r24, 0x07	; 7
     8ee:	80 64       	ori	r24, 0x40	; 64
     8f0:	87 b9       	out	0x07, r24	; 7
  set_bit(ADMUX, REFS1);
     8f2:	87 b1       	in	r24, 0x07	; 7
     8f4:	80 68       	ori	r24, 0x80	; 128
     8f6:	87 b9       	out	0x07, r24	; 7
#endif
  // Setting the prescalar to 128 so the operation frequency of the adc be within
  // the applicable range (50KHz-200KHz). The oscillator frequency is 16000000, Therefore the only applicable prescalar is 128.
  set_bit(ADCSRA, ADPS0);
     8f8:	86 b1       	in	r24, 0x06	; 6
     8fa:	81 60       	ori	r24, 0x01	; 1
     8fc:	86 b9       	out	0x06, r24	; 6
  set_bit(ADCSRA, ADPS1);
     8fe:	86 b1       	in	r24, 0x06	; 6
     900:	82 60       	ori	r24, 0x02	; 2
     902:	86 b9       	out	0x06, r24	; 6
  set_bit(ADCSRA, ADPS2);
     904:	86 b1       	in	r24, 0x06	; 6
     906:	84 60       	ori	r24, 0x04	; 4
     908:	86 b9       	out	0x06, r24	; 6
  // Enable the auto trigger mode
  set_bit(ADCSRA, ADATE);
     90a:	86 b1       	in	r24, 0x06	; 6
     90c:	80 62       	ori	r24, 0x20	; 32
     90e:	86 b9       	out	0x06, r24	; 6
  // Select the auto trigger source
  //! Cause of a bug: setting ADTS bits one by one. when setting them one by one, only the last bit is set and the rest are cleared. 
  //! The bits must be set in one write operation.
  //^ Generally, in this project, setting bits in a register one by one has caused multiple issues, also sometimes the order matters. other times a register must be read before another.
  //? Setting one bit is okay. But multiple bits need to be set in one write operation.
  switch (trigger) {
     910:	8e 2f       	mov	r24, r30
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	87 30       	cpi	r24, 0x07	; 7
     916:	91 05       	cpc	r25, r1
     918:	00 f5       	brcc	.+64     	; 0x95a <ADC_init_auto_trigger+0x70>
     91a:	fc 01       	movw	r30, r24
     91c:	e6 5d       	subi	r30, 0xD6	; 214
     91e:	ff 4f       	sbci	r31, 0xFF	; 255
     920:	0c 94 c3 17 	jmp	0x2f86	; 0x2f86 <__tablejump2__>
      case FREE_RUNNING_MODE_TRIGGER:
        // All bits are clear by default
        // Start free running mode first conversion
        set_bit(ADCSRA, ADSC);
     924:	86 b1       	in	r24, 0x06	; 6
     926:	80 64       	ori	r24, 0x40	; 64
     928:	86 b9       	out	0x06, r24	; 6
        break;
     92a:	17 c0       	rjmp	.+46     	; 0x95a <ADC_init_auto_trigger+0x70>
      case ANALOG_COMPARATOR_TRIGGER:
        set_bit(SFIOR, ADTS0);
     92c:	80 b7       	in	r24, 0x30	; 48
     92e:	80 62       	ori	r24, 0x20	; 32
     930:	80 bf       	out	0x30, r24	; 48
        break;
     932:	13 c0       	rjmp	.+38     	; 0x95a <ADC_init_auto_trigger+0x70>
      case INT0_TRIGGER:
        set_bit(SFIOR, ADTS1);
     934:	80 b7       	in	r24, 0x30	; 48
     936:	80 64       	ori	r24, 0x40	; 64
     938:	80 bf       	out	0x30, r24	; 48
        break;
     93a:	0f c0       	rjmp	.+30     	; 0x95a <ADC_init_auto_trigger+0x70>
      case TIMER_0_COMPARE_MATCH_TRIGGER:
        SFIOR |= (1 << ADTS0) | (1 << ADTS1);
     93c:	80 b7       	in	r24, 0x30	; 48
     93e:	80 66       	ori	r24, 0x60	; 96
     940:	80 bf       	out	0x30, r24	; 48
        break;
     942:	0b c0       	rjmp	.+22     	; 0x95a <ADC_init_auto_trigger+0x70>
      case TIMER_0_OVF_TRIGGER:
        set_bit(SFIOR, ADTS2);
     944:	80 b7       	in	r24, 0x30	; 48
     946:	80 68       	ori	r24, 0x80	; 128
     948:	80 bf       	out	0x30, r24	; 48
        break;
     94a:	07 c0       	rjmp	.+14     	; 0x95a <ADC_init_auto_trigger+0x70>
      case TIMER_1_COMPARE_MATCH_B_TRIGGER:
        SFIOR |= (1 << ADTS0) | (1 << ADTS2);
     94c:	80 b7       	in	r24, 0x30	; 48
     94e:	80 6a       	ori	r24, 0xA0	; 160
     950:	80 bf       	out	0x30, r24	; 48
        break;
     952:	03 c0       	rjmp	.+6      	; 0x95a <ADC_init_auto_trigger+0x70>
      case TIMER_1_OVF_TRIGGER:
        SFIOR |= (1 << ADTS1) | (1 << ADTS2);
     954:	80 b7       	in	r24, 0x30	; 48
     956:	80 6c       	ori	r24, 0xC0	; 192
     958:	80 bf       	out	0x30, r24	; 48
        break;
    }
  // Enable the ADC
  set_bit(ADCSRA, ADEN);
     95a:	86 b1       	in	r24, 0x06	; 6
     95c:	80 68       	ori	r24, 0x80	; 128
     95e:	86 b9       	out	0x06, r24	; 6
  return ADC_OK;
     960:	80 e0       	ldi	r24, 0x00	; 0
     962:	08 95       	ret

00000964 <isValidPinNumber>:
 */

#include "dio.h"

bool isValidPinNumber(u8 pinNumber) {
	if (pinNumber < 8) {
     964:	88 30       	cpi	r24, 0x08	; 8
     966:	10 f4       	brcc	.+4      	; 0x96c <isValidPinNumber+0x8>
		return true;
     968:	81 e0       	ldi	r24, 0x01	; 1
     96a:	08 95       	ret
		}
	return false;
     96c:	80 e0       	ldi	r24, 0x00	; 0
	}
     96e:	08 95       	ret

00000970 <isValidPortNumber>:

bool isValidPortNumber(u8 portNumber) {
	if (portNumber == PORT_A || portNumber == PORT_B || portNumber == PORT_C || portNumber == PORT_D) {
     970:	81 54       	subi	r24, 0x41	; 65
     972:	84 30       	cpi	r24, 0x04	; 4
     974:	10 f4       	brcc	.+4      	; 0x97a <isValidPortNumber+0xa>
		return true;
     976:	81 e0       	ldi	r24, 0x01	; 1
     978:	08 95       	ret
		}
	return false;
     97a:	80 e0       	ldi	r24, 0x00	; 0
	}
     97c:	08 95       	ret

0000097e <isValidDirection>:

bool isValidDirection(u8 direction) {
	if (direction == IN || direction == OUT) {
     97e:	82 30       	cpi	r24, 0x02	; 2
     980:	10 f4       	brcc	.+4      	; 0x986 <isValidDirection+0x8>
		return true;
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	08 95       	ret
		}
	return false;
     986:	80 e0       	ldi	r24, 0x00	; 0
	}
     988:	08 95       	ret

0000098a <isValidState>:

bool isValidState(u8 state) {
	if (state == HIGH || state == LOW) {
     98a:	82 30       	cpi	r24, 0x02	; 2
     98c:	10 f4       	brcc	.+4      	; 0x992 <isValidState+0x8>
		return true;
     98e:	81 e0       	ldi	r24, 0x01	; 1
     990:	08 95       	ret
		}
	return false;
     992:	80 e0       	ldi	r24, 0x00	; 0
	}
     994:	08 95       	ret

00000996 <DIO_init>:

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
     996:	1f 93       	push	r17
     998:	cf 93       	push	r28
     99a:	df 93       	push	r29
     99c:	c8 2f       	mov	r28, r24
     99e:	d6 2f       	mov	r29, r22
     9a0:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     9a2:	0e 94 b2 04 	call	0x964	; 0x964 <isValidPinNumber>
     9a6:	88 23       	and	r24, r24
     9a8:	09 f4       	brne	.+2      	; 0x9ac <DIO_init+0x16>
     9aa:	84 c0       	rjmp	.+264    	; 0xab4 <DIO_init+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     9ac:	8d 2f       	mov	r24, r29
     9ae:	0e 94 b8 04 	call	0x970	; 0x970 <isValidPortNumber>
     9b2:	88 23       	and	r24, r24
     9b4:	09 f4       	brne	.+2      	; 0x9b8 <DIO_init+0x22>
     9b6:	80 c0       	rjmp	.+256    	; 0xab8 <DIO_init+0x122>
		return WRONG_PORT;
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
     9b8:	81 2f       	mov	r24, r17
     9ba:	0e 94 bf 04 	call	0x97e	; 0x97e <isValidDirection>
     9be:	88 23       	and	r24, r24
     9c0:	09 f4       	brne	.+2      	; 0x9c4 <DIO_init+0x2e>
     9c2:	7c c0       	rjmp	.+248    	; 0xabc <DIO_init+0x126>
		return WRONG_DIRECTION;
		}
	switch (portNumber) {
     9c4:	d2 34       	cpi	r29, 0x42	; 66
     9c6:	29 f1       	breq	.+74     	; 0xa12 <DIO_init+0x7c>
     9c8:	18 f4       	brcc	.+6      	; 0x9d0 <DIO_init+0x3a>
     9ca:	d1 34       	cpi	r29, 0x41	; 65
     9cc:	39 f0       	breq	.+14     	; 0x9dc <DIO_init+0x46>
     9ce:	78 c0       	rjmp	.+240    	; 0xac0 <DIO_init+0x12a>
     9d0:	d3 34       	cpi	r29, 0x43	; 67
     9d2:	d1 f1       	breq	.+116    	; 0xa48 <DIO_init+0xb2>
     9d4:	d4 34       	cpi	r29, 0x44	; 68
     9d6:	09 f4       	brne	.+2      	; 0x9da <DIO_init+0x44>
     9d8:	52 c0       	rjmp	.+164    	; 0xa7e <DIO_init+0xe8>
     9da:	72 c0       	rjmp	.+228    	; 0xac0 <DIO_init+0x12a>
			case PORT_A:
				if (direction == OUT) {
     9dc:	11 30       	cpi	r17, 0x01	; 1
     9de:	61 f4       	brne	.+24     	; 0x9f8 <DIO_init+0x62>
					set_bit(DDRA, pinNumber);
     9e0:	2a b3       	in	r18, 0x1a	; 26
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	90 e0       	ldi	r25, 0x00	; 0
     9e6:	02 c0       	rjmp	.+4      	; 0x9ec <DIO_init+0x56>
     9e8:	88 0f       	add	r24, r24
     9ea:	99 1f       	adc	r25, r25
     9ec:	ca 95       	dec	r28
     9ee:	e2 f7       	brpl	.-8      	; 0x9e8 <DIO_init+0x52>
     9f0:	82 2b       	or	r24, r18
     9f2:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     9f4:	80 e0       	ldi	r24, 0x00	; 0
     9f6:	65 c0       	rjmp	.+202    	; 0xac2 <DIO_init+0x12c>
			case PORT_A:
				if (direction == OUT) {
					set_bit(DDRA, pinNumber);
					}
				else {
					clear_bit(DDRA, pinNumber);
     9f8:	2a b3       	in	r18, 0x1a	; 26
     9fa:	81 e0       	ldi	r24, 0x01	; 1
     9fc:	90 e0       	ldi	r25, 0x00	; 0
     9fe:	02 c0       	rjmp	.+4      	; 0xa04 <DIO_init+0x6e>
     a00:	88 0f       	add	r24, r24
     a02:	99 1f       	adc	r25, r25
     a04:	ca 95       	dec	r28
     a06:	e2 f7       	brpl	.-8      	; 0xa00 <DIO_init+0x6a>
     a08:	80 95       	com	r24
     a0a:	82 23       	and	r24, r18
     a0c:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a0e:	80 e0       	ldi	r24, 0x00	; 0
     a10:	58 c0       	rjmp	.+176    	; 0xac2 <DIO_init+0x12c>
				else {
					clear_bit(DDRA, pinNumber);
					}
				break;
			case PORT_B:
				if (direction == OUT) {
     a12:	11 30       	cpi	r17, 0x01	; 1
     a14:	61 f4       	brne	.+24     	; 0xa2e <DIO_init+0x98>
					set_bit(DDRB, pinNumber);
     a16:	27 b3       	in	r18, 0x17	; 23
     a18:	81 e0       	ldi	r24, 0x01	; 1
     a1a:	90 e0       	ldi	r25, 0x00	; 0
     a1c:	02 c0       	rjmp	.+4      	; 0xa22 <DIO_init+0x8c>
     a1e:	88 0f       	add	r24, r24
     a20:	99 1f       	adc	r25, r25
     a22:	ca 95       	dec	r28
     a24:	e2 f7       	brpl	.-8      	; 0xa1e <DIO_init+0x88>
     a26:	82 2b       	or	r24, r18
     a28:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	4a c0       	rjmp	.+148    	; 0xac2 <DIO_init+0x12c>
			case PORT_B:
				if (direction == OUT) {
					set_bit(DDRB, pinNumber);
					}
				else {
					clear_bit(DDRB, pinNumber);
     a2e:	27 b3       	in	r18, 0x17	; 23
     a30:	81 e0       	ldi	r24, 0x01	; 1
     a32:	90 e0       	ldi	r25, 0x00	; 0
     a34:	02 c0       	rjmp	.+4      	; 0xa3a <DIO_init+0xa4>
     a36:	88 0f       	add	r24, r24
     a38:	99 1f       	adc	r25, r25
     a3a:	ca 95       	dec	r28
     a3c:	e2 f7       	brpl	.-8      	; 0xa36 <DIO_init+0xa0>
     a3e:	80 95       	com	r24
     a40:	82 23       	and	r24, r18
     a42:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a44:	80 e0       	ldi	r24, 0x00	; 0
     a46:	3d c0       	rjmp	.+122    	; 0xac2 <DIO_init+0x12c>
				else {
					clear_bit(DDRB, pinNumber);
					}
				break;
			case PORT_C:
				if (direction == OUT) {
     a48:	11 30       	cpi	r17, 0x01	; 1
     a4a:	61 f4       	brne	.+24     	; 0xa64 <DIO_init+0xce>
					set_bit(DDRC, pinNumber);
     a4c:	24 b3       	in	r18, 0x14	; 20
     a4e:	81 e0       	ldi	r24, 0x01	; 1
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	02 c0       	rjmp	.+4      	; 0xa58 <DIO_init+0xc2>
     a54:	88 0f       	add	r24, r24
     a56:	99 1f       	adc	r25, r25
     a58:	ca 95       	dec	r28
     a5a:	e2 f7       	brpl	.-8      	; 0xa54 <DIO_init+0xbe>
     a5c:	82 2b       	or	r24, r18
     a5e:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a60:	80 e0       	ldi	r24, 0x00	; 0
     a62:	2f c0       	rjmp	.+94     	; 0xac2 <DIO_init+0x12c>
			case PORT_C:
				if (direction == OUT) {
					set_bit(DDRC, pinNumber);
					}
				else {
					clear_bit(DDRC, pinNumber);
     a64:	24 b3       	in	r18, 0x14	; 20
     a66:	81 e0       	ldi	r24, 0x01	; 1
     a68:	90 e0       	ldi	r25, 0x00	; 0
     a6a:	02 c0       	rjmp	.+4      	; 0xa70 <DIO_init+0xda>
     a6c:	88 0f       	add	r24, r24
     a6e:	99 1f       	adc	r25, r25
     a70:	ca 95       	dec	r28
     a72:	e2 f7       	brpl	.-8      	; 0xa6c <DIO_init+0xd6>
     a74:	80 95       	com	r24
     a76:	82 23       	and	r24, r18
     a78:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	22 c0       	rjmp	.+68     	; 0xac2 <DIO_init+0x12c>
				else {
					clear_bit(DDRC, pinNumber);
					}
				break;
			case PORT_D:
				if (direction == OUT) {
     a7e:	11 30       	cpi	r17, 0x01	; 1
     a80:	61 f4       	brne	.+24     	; 0xa9a <DIO_init+0x104>
					set_bit(DDRD, pinNumber);
     a82:	21 b3       	in	r18, 0x11	; 17
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	02 c0       	rjmp	.+4      	; 0xa8e <DIO_init+0xf8>
     a8a:	88 0f       	add	r24, r24
     a8c:	99 1f       	adc	r25, r25
     a8e:	ca 95       	dec	r28
     a90:	e2 f7       	brpl	.-8      	; 0xa8a <DIO_init+0xf4>
     a92:	82 2b       	or	r24, r18
     a94:	81 bb       	out	0x11, r24	; 17
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a96:	80 e0       	ldi	r24, 0x00	; 0
     a98:	14 c0       	rjmp	.+40     	; 0xac2 <DIO_init+0x12c>
			case PORT_D:
				if (direction == OUT) {
					set_bit(DDRD, pinNumber);
					}
				else {
					clear_bit(DDRD, pinNumber);
     a9a:	21 b3       	in	r18, 0x11	; 17
     a9c:	81 e0       	ldi	r24, 0x01	; 1
     a9e:	90 e0       	ldi	r25, 0x00	; 0
     aa0:	02 c0       	rjmp	.+4      	; 0xaa6 <DIO_init+0x110>
     aa2:	88 0f       	add	r24, r24
     aa4:	99 1f       	adc	r25, r25
     aa6:	ca 95       	dec	r28
     aa8:	e2 f7       	brpl	.-8      	; 0xaa2 <DIO_init+0x10c>
     aaa:	80 95       	com	r24
     aac:	82 23       	and	r24, r18
     aae:	81 bb       	out	0x11, r24	; 17
					}
				break;
		}
	return DIO_OK;
     ab0:	80 e0       	ldi	r24, 0x00	; 0
     ab2:	07 c0       	rjmp	.+14     	; 0xac2 <DIO_init+0x12c>

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     ab4:	81 e0       	ldi	r24, 0x01	; 1
     ab6:	05 c0       	rjmp	.+10     	; 0xac2 <DIO_init+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     ab8:	82 e0       	ldi	r24, 0x02	; 2
     aba:	03 c0       	rjmp	.+6      	; 0xac2 <DIO_init+0x12c>
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
		return WRONG_DIRECTION;
     abc:	83 e0       	ldi	r24, 0x03	; 3
     abe:	01 c0       	rjmp	.+2      	; 0xac2 <DIO_init+0x12c>
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     ac0:	80 e0       	ldi	r24, 0x00	; 0
	}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	1f 91       	pop	r17
     ac8:	08 95       	ret

00000aca <DIO_write>:

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
     aca:	1f 93       	push	r17
     acc:	cf 93       	push	r28
     ace:	df 93       	push	r29
     ad0:	c8 2f       	mov	r28, r24
     ad2:	d6 2f       	mov	r29, r22
     ad4:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     ad6:	0e 94 b2 04 	call	0x964	; 0x964 <isValidPinNumber>
     ada:	88 23       	and	r24, r24
     adc:	09 f4       	brne	.+2      	; 0xae0 <DIO_write+0x16>
     ade:	84 c0       	rjmp	.+264    	; 0xbe8 <DIO_write+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     ae0:	8d 2f       	mov	r24, r29
     ae2:	0e 94 b8 04 	call	0x970	; 0x970 <isValidPortNumber>
     ae6:	88 23       	and	r24, r24
     ae8:	09 f4       	brne	.+2      	; 0xaec <DIO_write+0x22>
     aea:	80 c0       	rjmp	.+256    	; 0xbec <DIO_write+0x122>
		return WRONG_PORT;
		}
	// Validate the pin state
	if (!isValidState(state)) {
     aec:	81 2f       	mov	r24, r17
     aee:	0e 94 c5 04 	call	0x98a	; 0x98a <isValidState>
     af2:	88 23       	and	r24, r24
     af4:	09 f4       	brne	.+2      	; 0xaf8 <DIO_write+0x2e>
     af6:	7c c0       	rjmp	.+248    	; 0xbf0 <DIO_write+0x126>
		return WRONG_STATE;
		}
	switch (portNumber) {
     af8:	d2 34       	cpi	r29, 0x42	; 66
     afa:	29 f1       	breq	.+74     	; 0xb46 <DIO_write+0x7c>
     afc:	18 f4       	brcc	.+6      	; 0xb04 <DIO_write+0x3a>
     afe:	d1 34       	cpi	r29, 0x41	; 65
     b00:	39 f0       	breq	.+14     	; 0xb10 <DIO_write+0x46>
     b02:	78 c0       	rjmp	.+240    	; 0xbf4 <DIO_write+0x12a>
     b04:	d3 34       	cpi	r29, 0x43	; 67
     b06:	d1 f1       	breq	.+116    	; 0xb7c <DIO_write+0xb2>
     b08:	d4 34       	cpi	r29, 0x44	; 68
     b0a:	09 f4       	brne	.+2      	; 0xb0e <DIO_write+0x44>
     b0c:	52 c0       	rjmp	.+164    	; 0xbb2 <DIO_write+0xe8>
     b0e:	72 c0       	rjmp	.+228    	; 0xbf4 <DIO_write+0x12a>
			case PORT_A:
				if (state == HIGH) {
     b10:	11 30       	cpi	r17, 0x01	; 1
     b12:	61 f4       	brne	.+24     	; 0xb2c <DIO_write+0x62>
					set_bit(PORTA, pinNumber);
     b14:	2b b3       	in	r18, 0x1b	; 27
     b16:	81 e0       	ldi	r24, 0x01	; 1
     b18:	90 e0       	ldi	r25, 0x00	; 0
     b1a:	02 c0       	rjmp	.+4      	; 0xb20 <DIO_write+0x56>
     b1c:	88 0f       	add	r24, r24
     b1e:	99 1f       	adc	r25, r25
     b20:	ca 95       	dec	r28
     b22:	e2 f7       	brpl	.-8      	; 0xb1c <DIO_write+0x52>
     b24:	82 2b       	or	r24, r18
     b26:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     b28:	80 e0       	ldi	r24, 0x00	; 0
     b2a:	65 c0       	rjmp	.+202    	; 0xbf6 <DIO_write+0x12c>
			case PORT_A:
				if (state == HIGH) {
					set_bit(PORTA, pinNumber);
					}
				else {
					clear_bit(PORTA, pinNumber);
     b2c:	2b b3       	in	r18, 0x1b	; 27
     b2e:	81 e0       	ldi	r24, 0x01	; 1
     b30:	90 e0       	ldi	r25, 0x00	; 0
     b32:	02 c0       	rjmp	.+4      	; 0xb38 <DIO_write+0x6e>
     b34:	88 0f       	add	r24, r24
     b36:	99 1f       	adc	r25, r25
     b38:	ca 95       	dec	r28
     b3a:	e2 f7       	brpl	.-8      	; 0xb34 <DIO_write+0x6a>
     b3c:	80 95       	com	r24
     b3e:	82 23       	and	r24, r18
     b40:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     b42:	80 e0       	ldi	r24, 0x00	; 0
     b44:	58 c0       	rjmp	.+176    	; 0xbf6 <DIO_write+0x12c>
				else {
					clear_bit(PORTA, pinNumber);
					}
				break;
			case PORT_B:
				if (state == HIGH) {
     b46:	11 30       	cpi	r17, 0x01	; 1
     b48:	61 f4       	brne	.+24     	; 0xb62 <DIO_write+0x98>
					set_bit(PORTB, pinNumber);
     b4a:	28 b3       	in	r18, 0x18	; 24
     b4c:	81 e0       	ldi	r24, 0x01	; 1
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	02 c0       	rjmp	.+4      	; 0xb56 <DIO_write+0x8c>
     b52:	88 0f       	add	r24, r24
     b54:	99 1f       	adc	r25, r25
     b56:	ca 95       	dec	r28
     b58:	e2 f7       	brpl	.-8      	; 0xb52 <DIO_write+0x88>
     b5a:	82 2b       	or	r24, r18
     b5c:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	4a c0       	rjmp	.+148    	; 0xbf6 <DIO_write+0x12c>
			case PORT_B:
				if (state == HIGH) {
					set_bit(PORTB, pinNumber);
					}
				else {
					clear_bit(PORTB, pinNumber);
     b62:	28 b3       	in	r18, 0x18	; 24
     b64:	81 e0       	ldi	r24, 0x01	; 1
     b66:	90 e0       	ldi	r25, 0x00	; 0
     b68:	02 c0       	rjmp	.+4      	; 0xb6e <DIO_write+0xa4>
     b6a:	88 0f       	add	r24, r24
     b6c:	99 1f       	adc	r25, r25
     b6e:	ca 95       	dec	r28
     b70:	e2 f7       	brpl	.-8      	; 0xb6a <DIO_write+0xa0>
     b72:	80 95       	com	r24
     b74:	82 23       	and	r24, r18
     b76:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     b78:	80 e0       	ldi	r24, 0x00	; 0
     b7a:	3d c0       	rjmp	.+122    	; 0xbf6 <DIO_write+0x12c>
				else {
					clear_bit(PORTB, pinNumber);
					}
				break;
			case PORT_C:
				if (state == HIGH) {
     b7c:	11 30       	cpi	r17, 0x01	; 1
     b7e:	61 f4       	brne	.+24     	; 0xb98 <DIO_write+0xce>
					set_bit(PORTC, pinNumber);
     b80:	25 b3       	in	r18, 0x15	; 21
     b82:	81 e0       	ldi	r24, 0x01	; 1
     b84:	90 e0       	ldi	r25, 0x00	; 0
     b86:	02 c0       	rjmp	.+4      	; 0xb8c <DIO_write+0xc2>
     b88:	88 0f       	add	r24, r24
     b8a:	99 1f       	adc	r25, r25
     b8c:	ca 95       	dec	r28
     b8e:	e2 f7       	brpl	.-8      	; 0xb88 <DIO_write+0xbe>
     b90:	82 2b       	or	r24, r18
     b92:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     b94:	80 e0       	ldi	r24, 0x00	; 0
     b96:	2f c0       	rjmp	.+94     	; 0xbf6 <DIO_write+0x12c>
			case PORT_C:
				if (state == HIGH) {
					set_bit(PORTC, pinNumber);
					}
				else {
					clear_bit(PORTC, pinNumber);
     b98:	25 b3       	in	r18, 0x15	; 21
     b9a:	81 e0       	ldi	r24, 0x01	; 1
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	02 c0       	rjmp	.+4      	; 0xba4 <DIO_write+0xda>
     ba0:	88 0f       	add	r24, r24
     ba2:	99 1f       	adc	r25, r25
     ba4:	ca 95       	dec	r28
     ba6:	e2 f7       	brpl	.-8      	; 0xba0 <DIO_write+0xd6>
     ba8:	80 95       	com	r24
     baa:	82 23       	and	r24, r18
     bac:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     bae:	80 e0       	ldi	r24, 0x00	; 0
     bb0:	22 c0       	rjmp	.+68     	; 0xbf6 <DIO_write+0x12c>
				else {
					clear_bit(PORTC, pinNumber);
					}
				break;
			case PORT_D:
				if (state == HIGH) {
     bb2:	11 30       	cpi	r17, 0x01	; 1
     bb4:	61 f4       	brne	.+24     	; 0xbce <DIO_write+0x104>
					set_bit(PORTD, pinNumber);
     bb6:	22 b3       	in	r18, 0x12	; 18
     bb8:	81 e0       	ldi	r24, 0x01	; 1
     bba:	90 e0       	ldi	r25, 0x00	; 0
     bbc:	02 c0       	rjmp	.+4      	; 0xbc2 <DIO_write+0xf8>
     bbe:	88 0f       	add	r24, r24
     bc0:	99 1f       	adc	r25, r25
     bc2:	ca 95       	dec	r28
     bc4:	e2 f7       	brpl	.-8      	; 0xbbe <DIO_write+0xf4>
     bc6:	82 2b       	or	r24, r18
     bc8:	82 bb       	out	0x12, r24	; 18
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     bca:	80 e0       	ldi	r24, 0x00	; 0
     bcc:	14 c0       	rjmp	.+40     	; 0xbf6 <DIO_write+0x12c>
			case PORT_D:
				if (state == HIGH) {
					set_bit(PORTD, pinNumber);
					}
				else {
					clear_bit(PORTD, pinNumber);
     bce:	22 b3       	in	r18, 0x12	; 18
     bd0:	81 e0       	ldi	r24, 0x01	; 1
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	02 c0       	rjmp	.+4      	; 0xbda <DIO_write+0x110>
     bd6:	88 0f       	add	r24, r24
     bd8:	99 1f       	adc	r25, r25
     bda:	ca 95       	dec	r28
     bdc:	e2 f7       	brpl	.-8      	; 0xbd6 <DIO_write+0x10c>
     bde:	80 95       	com	r24
     be0:	82 23       	and	r24, r18
     be2:	82 bb       	out	0x12, r24	; 18
					}
				break;
		}
	return DIO_OK;
     be4:	80 e0       	ldi	r24, 0x00	; 0
     be6:	07 c0       	rjmp	.+14     	; 0xbf6 <DIO_write+0x12c>

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     be8:	81 e0       	ldi	r24, 0x01	; 1
     bea:	05 c0       	rjmp	.+10     	; 0xbf6 <DIO_write+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     bec:	82 e0       	ldi	r24, 0x02	; 2
     bee:	03 c0       	rjmp	.+6      	; 0xbf6 <DIO_write+0x12c>
		}
	// Validate the pin state
	if (!isValidState(state)) {
		return WRONG_STATE;
     bf0:	84 e0       	ldi	r24, 0x04	; 4
     bf2:	01 c0       	rjmp	.+2      	; 0xbf6 <DIO_write+0x12c>
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     bf4:	80 e0       	ldi	r24, 0x00	; 0
	}
     bf6:	df 91       	pop	r29
     bf8:	cf 91       	pop	r28
     bfa:	1f 91       	pop	r17
     bfc:	08 95       	ret

00000bfe <DIO_Read>:

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
     bfe:	0f 93       	push	r16
     c00:	1f 93       	push	r17
     c02:	cf 93       	push	r28
     c04:	df 93       	push	r29
     c06:	d8 2f       	mov	r29, r24
     c08:	c6 2f       	mov	r28, r22
     c0a:	8a 01       	movw	r16, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     c0c:	0e 94 b2 04 	call	0x964	; 0x964 <isValidPinNumber>
     c10:	88 23       	and	r24, r24
     c12:	09 f4       	brne	.+2      	; 0xc16 <DIO_Read+0x18>
     c14:	40 c0       	rjmp	.+128    	; 0xc96 <DIO_Read+0x98>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     c16:	8c 2f       	mov	r24, r28
     c18:	0e 94 b8 04 	call	0x970	; 0x970 <isValidPortNumber>
     c1c:	88 23       	and	r24, r24
     c1e:	e9 f1       	breq	.+122    	; 0xc9a <DIO_Read+0x9c>
		return WRONG_PORT;
		}
	switch (portNumber) {
     c20:	c2 34       	cpi	r28, 0x42	; 66
     c22:	a9 f0       	breq	.+42     	; 0xc4e <DIO_Read+0x50>
     c24:	18 f4       	brcc	.+6      	; 0xc2c <DIO_Read+0x2e>
     c26:	c1 34       	cpi	r28, 0x41	; 65
     c28:	31 f0       	breq	.+12     	; 0xc36 <DIO_Read+0x38>
     c2a:	39 c0       	rjmp	.+114    	; 0xc9e <DIO_Read+0xa0>
     c2c:	c3 34       	cpi	r28, 0x43	; 67
     c2e:	d9 f0       	breq	.+54     	; 0xc66 <DIO_Read+0x68>
     c30:	c4 34       	cpi	r28, 0x44	; 68
     c32:	29 f1       	breq	.+74     	; 0xc7e <DIO_Read+0x80>
     c34:	34 c0       	rjmp	.+104    	; 0xc9e <DIO_Read+0xa0>
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
     c36:	89 b3       	in	r24, 0x19	; 25
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	02 c0       	rjmp	.+4      	; 0xc40 <DIO_Read+0x42>
     c3c:	95 95       	asr	r25
     c3e:	87 95       	ror	r24
     c40:	da 95       	dec	r29
     c42:	e2 f7       	brpl	.-8      	; 0xc3c <DIO_Read+0x3e>
     c44:	81 70       	andi	r24, 0x01	; 1
     c46:	f8 01       	movw	r30, r16
     c48:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     c4a:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
     c4c:	29 c0       	rjmp	.+82     	; 0xca0 <DIO_Read+0xa2>
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
     c4e:	86 b3       	in	r24, 0x16	; 22
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	02 c0       	rjmp	.+4      	; 0xc58 <DIO_Read+0x5a>
     c54:	95 95       	asr	r25
     c56:	87 95       	ror	r24
     c58:	da 95       	dec	r29
     c5a:	e2 f7       	brpl	.-8      	; 0xc54 <DIO_Read+0x56>
     c5c:	81 70       	andi	r24, 0x01	; 1
     c5e:	f8 01       	movw	r30, r16
     c60:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     c62:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
     c64:	1d c0       	rjmp	.+58     	; 0xca0 <DIO_Read+0xa2>
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
     c66:	83 b3       	in	r24, 0x13	; 19
     c68:	90 e0       	ldi	r25, 0x00	; 0
     c6a:	02 c0       	rjmp	.+4      	; 0xc70 <DIO_Read+0x72>
     c6c:	95 95       	asr	r25
     c6e:	87 95       	ror	r24
     c70:	da 95       	dec	r29
     c72:	e2 f7       	brpl	.-8      	; 0xc6c <DIO_Read+0x6e>
     c74:	81 70       	andi	r24, 0x01	; 1
     c76:	f8 01       	movw	r30, r16
     c78:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     c7a:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
     c7c:	11 c0       	rjmp	.+34     	; 0xca0 <DIO_Read+0xa2>
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
     c7e:	80 b3       	in	r24, 0x10	; 16
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	02 c0       	rjmp	.+4      	; 0xc88 <DIO_Read+0x8a>
     c84:	95 95       	asr	r25
     c86:	87 95       	ror	r24
     c88:	da 95       	dec	r29
     c8a:	e2 f7       	brpl	.-8      	; 0xc84 <DIO_Read+0x86>
     c8c:	81 70       	andi	r24, 0x01	; 1
     c8e:	f8 01       	movw	r30, r16
     c90:	80 83       	st	Z, r24
				break;
		}
	return DIO_OK;
     c92:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
     c94:	05 c0       	rjmp	.+10     	; 0xca0 <DIO_Read+0xa2>

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     c96:	81 e0       	ldi	r24, 0x01	; 1
     c98:	03 c0       	rjmp	.+6      	; 0xca0 <DIO_Read+0xa2>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     c9a:	82 e0       	ldi	r24, 0x02	; 2
     c9c:	01 c0       	rjmp	.+2      	; 0xca0 <DIO_Read+0xa2>
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     c9e:	80 e0       	ldi	r24, 0x00	; 0
	}
     ca0:	df 91       	pop	r29
     ca2:	cf 91       	pop	r28
     ca4:	1f 91       	pop	r17
     ca6:	0f 91       	pop	r16
     ca8:	08 95       	ret

00000caa <DIO_toggle>:

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
     caa:	cf 93       	push	r28
     cac:	df 93       	push	r29
     cae:	d8 2f       	mov	r29, r24
     cb0:	c6 2f       	mov	r28, r22
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     cb2:	0e 94 b2 04 	call	0x964	; 0x964 <isValidPinNumber>
     cb6:	88 23       	and	r24, r24
     cb8:	09 f4       	brne	.+2      	; 0xcbc <DIO_toggle+0x12>
     cba:	40 c0       	rjmp	.+128    	; 0xd3c <DIO_toggle+0x92>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     cbc:	8c 2f       	mov	r24, r28
     cbe:	0e 94 b8 04 	call	0x970	; 0x970 <isValidPortNumber>
     cc2:	88 23       	and	r24, r24
     cc4:	e9 f1       	breq	.+122    	; 0xd40 <DIO_toggle+0x96>
		return WRONG_PORT;
		}
	switch (portNumber) {
     cc6:	c2 34       	cpi	r28, 0x42	; 66
     cc8:	a9 f0       	breq	.+42     	; 0xcf4 <DIO_toggle+0x4a>
     cca:	18 f4       	brcc	.+6      	; 0xcd2 <DIO_toggle+0x28>
     ccc:	c1 34       	cpi	r28, 0x41	; 65
     cce:	31 f0       	breq	.+12     	; 0xcdc <DIO_toggle+0x32>
     cd0:	39 c0       	rjmp	.+114    	; 0xd44 <DIO_toggle+0x9a>
     cd2:	c3 34       	cpi	r28, 0x43	; 67
     cd4:	d9 f0       	breq	.+54     	; 0xd0c <DIO_toggle+0x62>
     cd6:	c4 34       	cpi	r28, 0x44	; 68
     cd8:	29 f1       	breq	.+74     	; 0xd24 <DIO_toggle+0x7a>
     cda:	34 c0       	rjmp	.+104    	; 0xd44 <DIO_toggle+0x9a>
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
     cdc:	2b b3       	in	r18, 0x1b	; 27
     cde:	81 e0       	ldi	r24, 0x01	; 1
     ce0:	90 e0       	ldi	r25, 0x00	; 0
     ce2:	02 c0       	rjmp	.+4      	; 0xce8 <DIO_toggle+0x3e>
     ce4:	88 0f       	add	r24, r24
     ce6:	99 1f       	adc	r25, r25
     ce8:	da 95       	dec	r29
     cea:	e2 f7       	brpl	.-8      	; 0xce4 <DIO_toggle+0x3a>
     cec:	82 27       	eor	r24, r18
     cee:	8b bb       	out	0x1b, r24	; 27
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     cf0:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
     cf2:	29 c0       	rjmp	.+82     	; 0xd46 <DIO_toggle+0x9c>
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
     cf4:	28 b3       	in	r18, 0x18	; 24
     cf6:	81 e0       	ldi	r24, 0x01	; 1
     cf8:	90 e0       	ldi	r25, 0x00	; 0
     cfa:	02 c0       	rjmp	.+4      	; 0xd00 <DIO_toggle+0x56>
     cfc:	88 0f       	add	r24, r24
     cfe:	99 1f       	adc	r25, r25
     d00:	da 95       	dec	r29
     d02:	e2 f7       	brpl	.-8      	; 0xcfc <DIO_toggle+0x52>
     d04:	82 27       	eor	r24, r18
     d06:	88 bb       	out	0x18, r24	; 24
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     d08:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
     d0a:	1d c0       	rjmp	.+58     	; 0xd46 <DIO_toggle+0x9c>
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
     d0c:	25 b3       	in	r18, 0x15	; 21
     d0e:	81 e0       	ldi	r24, 0x01	; 1
     d10:	90 e0       	ldi	r25, 0x00	; 0
     d12:	02 c0       	rjmp	.+4      	; 0xd18 <DIO_toggle+0x6e>
     d14:	88 0f       	add	r24, r24
     d16:	99 1f       	adc	r25, r25
     d18:	da 95       	dec	r29
     d1a:	e2 f7       	brpl	.-8      	; 0xd14 <DIO_toggle+0x6a>
     d1c:	82 27       	eor	r24, r18
     d1e:	85 bb       	out	0x15, r24	; 21
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     d20:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
     d22:	11 c0       	rjmp	.+34     	; 0xd46 <DIO_toggle+0x9c>
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
     d24:	22 b3       	in	r18, 0x12	; 18
     d26:	81 e0       	ldi	r24, 0x01	; 1
     d28:	90 e0       	ldi	r25, 0x00	; 0
     d2a:	02 c0       	rjmp	.+4      	; 0xd30 <DIO_toggle+0x86>
     d2c:	88 0f       	add	r24, r24
     d2e:	99 1f       	adc	r25, r25
     d30:	da 95       	dec	r29
     d32:	e2 f7       	brpl	.-8      	; 0xd2c <DIO_toggle+0x82>
     d34:	82 27       	eor	r24, r18
     d36:	82 bb       	out	0x12, r24	; 18
				break;
		}
	return DIO_OK;
     d38:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
     d3a:	05 c0       	rjmp	.+10     	; 0xd46 <DIO_toggle+0x9c>

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     d3c:	81 e0       	ldi	r24, 0x01	; 1
     d3e:	03 c0       	rjmp	.+6      	; 0xd46 <DIO_toggle+0x9c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     d40:	82 e0       	ldi	r24, 0x02	; 2
     d42:	01 c0       	rjmp	.+2      	; 0xd46 <DIO_toggle+0x9c>
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     d44:	80 e0       	ldi	r24, 0x00	; 0
     d46:	df 91       	pop	r29
     d48:	cf 91       	pop	r28
     d4a:	08 95       	ret

00000d4c <getCurrentStatus>:

EN_I2CMasterStatusCode_t I2C_repeatedStart() {   // Same as start, just a different name
  TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  while (read_bit(TWCR, TWINT) == 0);
  return getCurrentStatus();
  }
     d4c:	81 b1       	in	r24, 0x01	; 1
     d4e:	e8 2f       	mov	r30, r24
     d50:	e8 7f       	andi	r30, 0xF8	; 248
     d52:	8e 2f       	mov	r24, r30
     d54:	90 e0       	ldi	r25, 0x00	; 0
     d56:	fc 01       	movw	r30, r24
     d58:	38 97       	sbiw	r30, 0x08	; 8
     d5a:	e1 35       	cpi	r30, 0x51	; 81
     d5c:	f1 05       	cpc	r31, r1
     d5e:	c0 f4       	brcc	.+48     	; 0xd90 <getCurrentStatus+0x44>
     d60:	ef 5c       	subi	r30, 0xCF	; 207
     d62:	ff 4f       	sbci	r31, 0xFF	; 255
     d64:	0c 94 c3 17 	jmp	0x2f86	; 0x2f86 <__tablejump2__>
     d68:	80 e0       	ldi	r24, 0x00	; 0
     d6a:	08 95       	ret
     d6c:	82 e0       	ldi	r24, 0x02	; 2
     d6e:	08 95       	ret
     d70:	83 e0       	ldi	r24, 0x03	; 3
     d72:	08 95       	ret
     d74:	84 e0       	ldi	r24, 0x04	; 4
     d76:	08 95       	ret
     d78:	85 e0       	ldi	r24, 0x05	; 5
     d7a:	08 95       	ret
     d7c:	86 e0       	ldi	r24, 0x06	; 6
     d7e:	08 95       	ret
     d80:	87 e0       	ldi	r24, 0x07	; 7
     d82:	08 95       	ret
     d84:	88 e0       	ldi	r24, 0x08	; 8
     d86:	08 95       	ret
     d88:	89 e0       	ldi	r24, 0x09	; 9
     d8a:	08 95       	ret
     d8c:	8a e0       	ldi	r24, 0x0A	; 10
     d8e:	08 95       	ret
     d90:	8b e0       	ldi	r24, 0x0B	; 11
     d92:	08 95       	ret
     d94:	81 e0       	ldi	r24, 0x01	; 1
     d96:	08 95       	ret

00000d98 <I2C_init>:
     d98:	11 b8       	out	0x01, r1	; 1
     d9a:	8f ef       	ldi	r24, 0xFF	; 255
     d9c:	80 b9       	out	0x00, r24	; 0
     d9e:	08 95       	ret

00000da0 <I2C_start>:
     da0:	84 ea       	ldi	r24, 0xA4	; 164
     da2:	86 bf       	out	0x36, r24	; 54
     da4:	06 b6       	in	r0, 0x36	; 54
     da6:	07 fe       	sbrs	r0, 7
     da8:	fd cf       	rjmp	.-6      	; 0xda4 <I2C_start+0x4>
     daa:	0e 94 a6 06 	call	0xd4c	; 0xd4c <getCurrentStatus>
     dae:	08 95       	ret

00000db0 <I2C_write>:

EN_I2CMasterStatusCode_t I2C_write(u8 data) {
  TWDR = data;
     db0:	83 b9       	out	0x03, r24	; 3
  TWCR = (1 << TWEN) | (1 << TWINT);
     db2:	84 e8       	ldi	r24, 0x84	; 132
     db4:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWINT) == 0);
     db6:	06 b6       	in	r0, 0x36	; 54
     db8:	07 fe       	sbrs	r0, 7
     dba:	fd cf       	rjmp	.-6      	; 0xdb6 <I2C_write+0x6>
  return getCurrentStatus();
     dbc:	0e 94 a6 06 	call	0xd4c	; 0xd4c <getCurrentStatus>
  }
     dc0:	08 95       	ret

00000dc2 <I2C_read_Ack>:

EN_I2CMasterStatusCode_t I2C_read_Ack(u8* data) {
  TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWINT);
     dc2:	24 ec       	ldi	r18, 0xC4	; 196
     dc4:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     dc6:	06 b6       	in	r0, 0x36	; 54
     dc8:	07 fe       	sbrs	r0, 7
     dca:	fd cf       	rjmp	.-6      	; 0xdc6 <I2C_read_Ack+0x4>
  *data = TWDR;
     dcc:	23 b1       	in	r18, 0x03	; 3
     dce:	fc 01       	movw	r30, r24
     dd0:	20 83       	st	Z, r18
  return getCurrentStatus();
     dd2:	0e 94 a6 06 	call	0xd4c	; 0xd4c <getCurrentStatus>
  }
     dd6:	08 95       	ret

00000dd8 <I2C_read_Nack>:

EN_I2CMasterStatusCode_t I2C_read_Nack(u8* data) {
  TWCR = (1 << TWEN) | (1 << TWINT);
     dd8:	24 e8       	ldi	r18, 0x84	; 132
     dda:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     ddc:	06 b6       	in	r0, 0x36	; 54
     dde:	07 fe       	sbrs	r0, 7
     de0:	fd cf       	rjmp	.-6      	; 0xddc <I2C_read_Nack+0x4>
  *data = TWDR;
     de2:	23 b1       	in	r18, 0x03	; 3
     de4:	fc 01       	movw	r30, r24
     de6:	20 83       	st	Z, r18
  return getCurrentStatus();
     de8:	0e 94 a6 06 	call	0xd4c	; 0xd4c <getCurrentStatus>
  }
     dec:	08 95       	ret

00000dee <I2C_stop>:

void I2C_stop(void) {
  TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
     dee:	84 e9       	ldi	r24, 0x94	; 148
     df0:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWSTO));	// Wait until stop condition finishes
     df2:	06 b6       	in	r0, 0x36	; 54
     df4:	04 fc       	sbrc	r0, 4
     df6:	fd cf       	rjmp	.-6      	; 0xdf2 <I2C_stop+0x4>
  }
     df8:	08 95       	ret

00000dfa <ADC_INT_init>:
  }

// Initialize the ADC conversion complete interrupt
EN_INT_init_Status_t ADC_INT_init(void) {
  // Enable the ADC conversion complete interrupt
  set_bit(ADCSRA, ADIE);
     dfa:	86 b1       	in	r24, 0x06	; 6
     dfc:	88 60       	ori	r24, 0x08	; 8
     dfe:	86 b9       	out	0x06, r24	; 6
  return INTERRUPT_INIT_OK;
  }
     e00:	80 e0       	ldi	r24, 0x00	; 0
     e02:	08 95       	ret

00000e04 <isValidTimer>:
        clear_bit(TCCR2, COM21);
        set_prescalar(TIMER_2, 0);
        break;
    }
  return TIMER_OK;
  }
     e04:	83 30       	cpi	r24, 0x03	; 3
     e06:	10 f4       	brcc	.+4      	; 0xe0c <isValidTimer+0x8>
     e08:	81 e0       	ldi	r24, 0x01	; 1
     e0a:	08 95       	ret
     e0c:	80 e0       	ldi	r24, 0x00	; 0
     e0e:	08 95       	ret

00000e10 <set_prescalar>:
     e10:	1f 93       	push	r17
     e12:	cf 93       	push	r28
     e14:	df 93       	push	r29
     e16:	18 2f       	mov	r17, r24
     e18:	eb 01       	movw	r28, r22
     e1a:	0e 94 02 07 	call	0xe04	; 0xe04 <isValidTimer>
     e1e:	88 23       	and	r24, r24
     e20:	09 f4       	brne	.+2      	; 0xe24 <set_prescalar+0x14>
     e22:	6a c1       	rjmp	.+724    	; 0x10f8 <set_prescalar+0x2e8>
     e24:	11 30       	cpi	r17, 0x01	; 1
     e26:	09 f4       	brne	.+2      	; 0xe2a <set_prescalar+0x1a>
     e28:	6f c0       	rjmp	.+222    	; 0xf08 <set_prescalar+0xf8>
     e2a:	20 f0       	brcs	.+8      	; 0xe34 <set_prescalar+0x24>
     e2c:	12 30       	cpi	r17, 0x02	; 2
     e2e:	09 f4       	brne	.+2      	; 0xe32 <set_prescalar+0x22>
     e30:	d5 c0       	rjmp	.+426    	; 0xfdc <set_prescalar+0x1cc>
     e32:	64 c1       	rjmp	.+712    	; 0x10fc <set_prescalar+0x2ec>
     e34:	c2 30       	cpi	r28, 0x02	; 2
     e36:	d1 05       	cpc	r29, r1
     e38:	78 f0       	brcs	.+30     	; 0xe58 <set_prescalar+0x48>
     e3a:	c8 30       	cpi	r28, 0x08	; 8
     e3c:	d1 05       	cpc	r29, r1
     e3e:	61 f0       	breq	.+24     	; 0xe58 <set_prescalar+0x48>
     e40:	c0 34       	cpi	r28, 0x40	; 64
     e42:	d1 05       	cpc	r29, r1
     e44:	49 f0       	breq	.+18     	; 0xe58 <set_prescalar+0x48>
     e46:	c1 15       	cp	r28, r1
     e48:	81 e0       	ldi	r24, 0x01	; 1
     e4a:	d8 07       	cpc	r29, r24
     e4c:	29 f0       	breq	.+10     	; 0xe58 <set_prescalar+0x48>
     e4e:	c1 15       	cp	r28, r1
     e50:	84 e0       	ldi	r24, 0x04	; 4
     e52:	d8 07       	cpc	r29, r24
     e54:	09 f0       	breq	.+2      	; 0xe58 <set_prescalar+0x48>
     e56:	54 c1       	rjmp	.+680    	; 0x1100 <set_prescalar+0x2f0>
     e58:	c8 30       	cpi	r28, 0x08	; 8
     e5a:	d1 05       	cpc	r29, r1
     e5c:	49 f1       	breq	.+82     	; 0xeb0 <set_prescalar+0xa0>
     e5e:	28 f4       	brcc	.+10     	; 0xe6a <set_prescalar+0x5a>
     e60:	20 97       	sbiw	r28, 0x00	; 0
     e62:	81 f0       	breq	.+32     	; 0xe84 <set_prescalar+0x74>
     e64:	21 97       	sbiw	r28, 0x01	; 1
     e66:	c9 f0       	breq	.+50     	; 0xe9a <set_prescalar+0x8a>
     e68:	4d c1       	rjmp	.+666    	; 0x1104 <set_prescalar+0x2f4>
     e6a:	c1 15       	cp	r28, r1
     e6c:	81 e0       	ldi	r24, 0x01	; 1
     e6e:	d8 07       	cpc	r29, r24
     e70:	a9 f1       	breq	.+106    	; 0xedc <set_prescalar+0xcc>
     e72:	c1 15       	cp	r28, r1
     e74:	84 e0       	ldi	r24, 0x04	; 4
     e76:	d8 07       	cpc	r29, r24
     e78:	e1 f1       	breq	.+120    	; 0xef2 <set_prescalar+0xe2>
     e7a:	c0 34       	cpi	r28, 0x40	; 64
     e7c:	d1 05       	cpc	r29, r1
     e7e:	09 f0       	breq	.+2      	; 0xe82 <set_prescalar+0x72>
     e80:	41 c1       	rjmp	.+642    	; 0x1104 <set_prescalar+0x2f4>
     e82:	21 c0       	rjmp	.+66     	; 0xec6 <set_prescalar+0xb6>
     e84:	83 b7       	in	r24, 0x33	; 51
     e86:	8e 7f       	andi	r24, 0xFE	; 254
     e88:	83 bf       	out	0x33, r24	; 51
     e8a:	83 b7       	in	r24, 0x33	; 51
     e8c:	8d 7f       	andi	r24, 0xFD	; 253
     e8e:	83 bf       	out	0x33, r24	; 51
     e90:	83 b7       	in	r24, 0x33	; 51
     e92:	8b 7f       	andi	r24, 0xFB	; 251
     e94:	83 bf       	out	0x33, r24	; 51
     e96:	80 e0       	ldi	r24, 0x00	; 0
     e98:	3e c1       	rjmp	.+636    	; 0x1116 <set_prescalar+0x306>
     e9a:	83 b7       	in	r24, 0x33	; 51
     e9c:	81 60       	ori	r24, 0x01	; 1
     e9e:	83 bf       	out	0x33, r24	; 51
     ea0:	83 b7       	in	r24, 0x33	; 51
     ea2:	8d 7f       	andi	r24, 0xFD	; 253
     ea4:	83 bf       	out	0x33, r24	; 51
     ea6:	83 b7       	in	r24, 0x33	; 51
     ea8:	8b 7f       	andi	r24, 0xFB	; 251
     eaa:	83 bf       	out	0x33, r24	; 51
     eac:	80 e0       	ldi	r24, 0x00	; 0
     eae:	33 c1       	rjmp	.+614    	; 0x1116 <set_prescalar+0x306>
     eb0:	83 b7       	in	r24, 0x33	; 51
     eb2:	8e 7f       	andi	r24, 0xFE	; 254
     eb4:	83 bf       	out	0x33, r24	; 51
     eb6:	83 b7       	in	r24, 0x33	; 51
     eb8:	82 60       	ori	r24, 0x02	; 2
     eba:	83 bf       	out	0x33, r24	; 51
     ebc:	83 b7       	in	r24, 0x33	; 51
     ebe:	8b 7f       	andi	r24, 0xFB	; 251
     ec0:	83 bf       	out	0x33, r24	; 51
     ec2:	80 e0       	ldi	r24, 0x00	; 0
     ec4:	28 c1       	rjmp	.+592    	; 0x1116 <set_prescalar+0x306>
     ec6:	83 b7       	in	r24, 0x33	; 51
     ec8:	81 60       	ori	r24, 0x01	; 1
     eca:	83 bf       	out	0x33, r24	; 51
     ecc:	83 b7       	in	r24, 0x33	; 51
     ece:	82 60       	ori	r24, 0x02	; 2
     ed0:	83 bf       	out	0x33, r24	; 51
     ed2:	83 b7       	in	r24, 0x33	; 51
     ed4:	8b 7f       	andi	r24, 0xFB	; 251
     ed6:	83 bf       	out	0x33, r24	; 51
     ed8:	80 e0       	ldi	r24, 0x00	; 0
     eda:	1d c1       	rjmp	.+570    	; 0x1116 <set_prescalar+0x306>
     edc:	83 b7       	in	r24, 0x33	; 51
     ede:	8e 7f       	andi	r24, 0xFE	; 254
     ee0:	83 bf       	out	0x33, r24	; 51
     ee2:	83 b7       	in	r24, 0x33	; 51
     ee4:	8d 7f       	andi	r24, 0xFD	; 253
     ee6:	83 bf       	out	0x33, r24	; 51
     ee8:	83 b7       	in	r24, 0x33	; 51
     eea:	84 60       	ori	r24, 0x04	; 4
     eec:	83 bf       	out	0x33, r24	; 51
     eee:	80 e0       	ldi	r24, 0x00	; 0
     ef0:	12 c1       	rjmp	.+548    	; 0x1116 <set_prescalar+0x306>
     ef2:	83 b7       	in	r24, 0x33	; 51
     ef4:	81 60       	ori	r24, 0x01	; 1
     ef6:	83 bf       	out	0x33, r24	; 51
     ef8:	83 b7       	in	r24, 0x33	; 51
     efa:	8d 7f       	andi	r24, 0xFD	; 253
     efc:	83 bf       	out	0x33, r24	; 51
     efe:	83 b7       	in	r24, 0x33	; 51
     f00:	84 60       	ori	r24, 0x04	; 4
     f02:	83 bf       	out	0x33, r24	; 51
     f04:	80 e0       	ldi	r24, 0x00	; 0
     f06:	07 c1       	rjmp	.+526    	; 0x1116 <set_prescalar+0x306>
     f08:	c2 30       	cpi	r28, 0x02	; 2
     f0a:	d1 05       	cpc	r29, r1
     f0c:	78 f0       	brcs	.+30     	; 0xf2c <set_prescalar+0x11c>
     f0e:	c8 30       	cpi	r28, 0x08	; 8
     f10:	d1 05       	cpc	r29, r1
     f12:	61 f0       	breq	.+24     	; 0xf2c <set_prescalar+0x11c>
     f14:	c0 34       	cpi	r28, 0x40	; 64
     f16:	d1 05       	cpc	r29, r1
     f18:	49 f0       	breq	.+18     	; 0xf2c <set_prescalar+0x11c>
     f1a:	c1 15       	cp	r28, r1
     f1c:	81 e0       	ldi	r24, 0x01	; 1
     f1e:	d8 07       	cpc	r29, r24
     f20:	29 f0       	breq	.+10     	; 0xf2c <set_prescalar+0x11c>
     f22:	c1 15       	cp	r28, r1
     f24:	84 e0       	ldi	r24, 0x04	; 4
     f26:	d8 07       	cpc	r29, r24
     f28:	09 f0       	breq	.+2      	; 0xf2c <set_prescalar+0x11c>
     f2a:	ee c0       	rjmp	.+476    	; 0x1108 <set_prescalar+0x2f8>
     f2c:	c8 30       	cpi	r28, 0x08	; 8
     f2e:	d1 05       	cpc	r29, r1
     f30:	49 f1       	breq	.+82     	; 0xf84 <set_prescalar+0x174>
     f32:	28 f4       	brcc	.+10     	; 0xf3e <set_prescalar+0x12e>
     f34:	20 97       	sbiw	r28, 0x00	; 0
     f36:	81 f0       	breq	.+32     	; 0xf58 <set_prescalar+0x148>
     f38:	21 97       	sbiw	r28, 0x01	; 1
     f3a:	c9 f0       	breq	.+50     	; 0xf6e <set_prescalar+0x15e>
     f3c:	e7 c0       	rjmp	.+462    	; 0x110c <set_prescalar+0x2fc>
     f3e:	c1 15       	cp	r28, r1
     f40:	81 e0       	ldi	r24, 0x01	; 1
     f42:	d8 07       	cpc	r29, r24
     f44:	a9 f1       	breq	.+106    	; 0xfb0 <set_prescalar+0x1a0>
     f46:	c1 15       	cp	r28, r1
     f48:	84 e0       	ldi	r24, 0x04	; 4
     f4a:	d8 07       	cpc	r29, r24
     f4c:	e1 f1       	breq	.+120    	; 0xfc6 <set_prescalar+0x1b6>
     f4e:	c0 34       	cpi	r28, 0x40	; 64
     f50:	d1 05       	cpc	r29, r1
     f52:	09 f0       	breq	.+2      	; 0xf56 <set_prescalar+0x146>
     f54:	db c0       	rjmp	.+438    	; 0x110c <set_prescalar+0x2fc>
     f56:	21 c0       	rjmp	.+66     	; 0xf9a <set_prescalar+0x18a>
     f58:	8e b5       	in	r24, 0x2e	; 46
     f5a:	8e 7f       	andi	r24, 0xFE	; 254
     f5c:	8e bd       	out	0x2e, r24	; 46
     f5e:	8e b5       	in	r24, 0x2e	; 46
     f60:	8d 7f       	andi	r24, 0xFD	; 253
     f62:	8e bd       	out	0x2e, r24	; 46
     f64:	8e b5       	in	r24, 0x2e	; 46
     f66:	8b 7f       	andi	r24, 0xFB	; 251
     f68:	8e bd       	out	0x2e, r24	; 46
     f6a:	80 e0       	ldi	r24, 0x00	; 0
     f6c:	d4 c0       	rjmp	.+424    	; 0x1116 <set_prescalar+0x306>
     f6e:	8e b5       	in	r24, 0x2e	; 46
     f70:	81 60       	ori	r24, 0x01	; 1
     f72:	8e bd       	out	0x2e, r24	; 46
     f74:	8e b5       	in	r24, 0x2e	; 46
     f76:	8d 7f       	andi	r24, 0xFD	; 253
     f78:	8e bd       	out	0x2e, r24	; 46
     f7a:	8e b5       	in	r24, 0x2e	; 46
     f7c:	8b 7f       	andi	r24, 0xFB	; 251
     f7e:	8e bd       	out	0x2e, r24	; 46
     f80:	80 e0       	ldi	r24, 0x00	; 0
     f82:	c9 c0       	rjmp	.+402    	; 0x1116 <set_prescalar+0x306>
     f84:	8e b5       	in	r24, 0x2e	; 46
     f86:	8e 7f       	andi	r24, 0xFE	; 254
     f88:	8e bd       	out	0x2e, r24	; 46
     f8a:	8e b5       	in	r24, 0x2e	; 46
     f8c:	82 60       	ori	r24, 0x02	; 2
     f8e:	8e bd       	out	0x2e, r24	; 46
     f90:	8e b5       	in	r24, 0x2e	; 46
     f92:	8b 7f       	andi	r24, 0xFB	; 251
     f94:	8e bd       	out	0x2e, r24	; 46
     f96:	80 e0       	ldi	r24, 0x00	; 0
     f98:	be c0       	rjmp	.+380    	; 0x1116 <set_prescalar+0x306>
     f9a:	8e b5       	in	r24, 0x2e	; 46
     f9c:	81 60       	ori	r24, 0x01	; 1
     f9e:	8e bd       	out	0x2e, r24	; 46
     fa0:	8e b5       	in	r24, 0x2e	; 46
     fa2:	82 60       	ori	r24, 0x02	; 2
     fa4:	8e bd       	out	0x2e, r24	; 46
     fa6:	8e b5       	in	r24, 0x2e	; 46
     fa8:	8b 7f       	andi	r24, 0xFB	; 251
     faa:	8e bd       	out	0x2e, r24	; 46
     fac:	80 e0       	ldi	r24, 0x00	; 0
     fae:	b3 c0       	rjmp	.+358    	; 0x1116 <set_prescalar+0x306>
     fb0:	8e b5       	in	r24, 0x2e	; 46
     fb2:	8e 7f       	andi	r24, 0xFE	; 254
     fb4:	8e bd       	out	0x2e, r24	; 46
     fb6:	8e b5       	in	r24, 0x2e	; 46
     fb8:	8d 7f       	andi	r24, 0xFD	; 253
     fba:	8e bd       	out	0x2e, r24	; 46
     fbc:	8e b5       	in	r24, 0x2e	; 46
     fbe:	84 60       	ori	r24, 0x04	; 4
     fc0:	8e bd       	out	0x2e, r24	; 46
     fc2:	80 e0       	ldi	r24, 0x00	; 0
     fc4:	a8 c0       	rjmp	.+336    	; 0x1116 <set_prescalar+0x306>
     fc6:	8e b5       	in	r24, 0x2e	; 46
     fc8:	81 60       	ori	r24, 0x01	; 1
     fca:	8e bd       	out	0x2e, r24	; 46
     fcc:	8e b5       	in	r24, 0x2e	; 46
     fce:	8d 7f       	andi	r24, 0xFD	; 253
     fd0:	8e bd       	out	0x2e, r24	; 46
     fd2:	8e b5       	in	r24, 0x2e	; 46
     fd4:	84 60       	ori	r24, 0x04	; 4
     fd6:	8e bd       	out	0x2e, r24	; 46
     fd8:	80 e0       	ldi	r24, 0x00	; 0
     fda:	9d c0       	rjmp	.+314    	; 0x1116 <set_prescalar+0x306>
     fdc:	c2 30       	cpi	r28, 0x02	; 2
     fde:	d1 05       	cpc	r29, r1
     fe0:	a8 f0       	brcs	.+42     	; 0x100c <set_prescalar+0x1fc>
     fe2:	c8 30       	cpi	r28, 0x08	; 8
     fe4:	d1 05       	cpc	r29, r1
     fe6:	91 f0       	breq	.+36     	; 0x100c <set_prescalar+0x1fc>
     fe8:	c0 32       	cpi	r28, 0x20	; 32
     fea:	d1 05       	cpc	r29, r1
     fec:	79 f0       	breq	.+30     	; 0x100c <set_prescalar+0x1fc>
     fee:	c0 34       	cpi	r28, 0x40	; 64
     ff0:	d1 05       	cpc	r29, r1
     ff2:	61 f0       	breq	.+24     	; 0x100c <set_prescalar+0x1fc>
     ff4:	c0 38       	cpi	r28, 0x80	; 128
     ff6:	d1 05       	cpc	r29, r1
     ff8:	49 f0       	breq	.+18     	; 0x100c <set_prescalar+0x1fc>
     ffa:	c1 15       	cp	r28, r1
     ffc:	81 e0       	ldi	r24, 0x01	; 1
     ffe:	d8 07       	cpc	r29, r24
    1000:	29 f0       	breq	.+10     	; 0x100c <set_prescalar+0x1fc>
    1002:	c1 15       	cp	r28, r1
    1004:	84 e0       	ldi	r24, 0x04	; 4
    1006:	d8 07       	cpc	r29, r24
    1008:	09 f0       	breq	.+2      	; 0x100c <set_prescalar+0x1fc>
    100a:	82 c0       	rjmp	.+260    	; 0x1110 <set_prescalar+0x300>
    100c:	c0 32       	cpi	r28, 0x20	; 32
    100e:	d1 05       	cpc	r29, r1
    1010:	e1 f1       	breq	.+120    	; 0x108a <set_prescalar+0x27a>
    1012:	38 f4       	brcc	.+14     	; 0x1022 <set_prescalar+0x212>
    1014:	c1 30       	cpi	r28, 0x01	; 1
    1016:	d1 05       	cpc	r29, r1
    1018:	11 f1       	breq	.+68     	; 0x105e <set_prescalar+0x24e>
    101a:	b0 f0       	brcs	.+44     	; 0x1048 <set_prescalar+0x238>
    101c:	28 97       	sbiw	r28, 0x08	; 8
    101e:	51 f1       	breq	.+84     	; 0x1074 <set_prescalar+0x264>
    1020:	79 c0       	rjmp	.+242    	; 0x1114 <set_prescalar+0x304>
    1022:	c0 38       	cpi	r28, 0x80	; 128
    1024:	d1 05       	cpc	r29, r1
    1026:	09 f4       	brne	.+2      	; 0x102a <set_prescalar+0x21a>
    1028:	46 c0       	rjmp	.+140    	; 0x10b6 <set_prescalar+0x2a6>
    102a:	20 f4       	brcc	.+8      	; 0x1034 <set_prescalar+0x224>
    102c:	c0 34       	cpi	r28, 0x40	; 64
    102e:	d1 05       	cpc	r29, r1
    1030:	b9 f1       	breq	.+110    	; 0x10a0 <set_prescalar+0x290>
    1032:	70 c0       	rjmp	.+224    	; 0x1114 <set_prescalar+0x304>
    1034:	c1 15       	cp	r28, r1
    1036:	81 e0       	ldi	r24, 0x01	; 1
    1038:	d8 07       	cpc	r29, r24
    103a:	09 f4       	brne	.+2      	; 0x103e <set_prescalar+0x22e>
    103c:	47 c0       	rjmp	.+142    	; 0x10cc <set_prescalar+0x2bc>
    103e:	c1 15       	cp	r28, r1
    1040:	d4 40       	sbci	r29, 0x04	; 4
    1042:	09 f4       	brne	.+2      	; 0x1046 <set_prescalar+0x236>
    1044:	4e c0       	rjmp	.+156    	; 0x10e2 <set_prescalar+0x2d2>
    1046:	66 c0       	rjmp	.+204    	; 0x1114 <set_prescalar+0x304>
    1048:	85 b5       	in	r24, 0x25	; 37
    104a:	8e 7f       	andi	r24, 0xFE	; 254
    104c:	85 bd       	out	0x25, r24	; 37
    104e:	85 b5       	in	r24, 0x25	; 37
    1050:	8d 7f       	andi	r24, 0xFD	; 253
    1052:	85 bd       	out	0x25, r24	; 37
    1054:	85 b5       	in	r24, 0x25	; 37
    1056:	8b 7f       	andi	r24, 0xFB	; 251
    1058:	85 bd       	out	0x25, r24	; 37
    105a:	80 e0       	ldi	r24, 0x00	; 0
    105c:	5c c0       	rjmp	.+184    	; 0x1116 <set_prescalar+0x306>
    105e:	85 b5       	in	r24, 0x25	; 37
    1060:	81 60       	ori	r24, 0x01	; 1
    1062:	85 bd       	out	0x25, r24	; 37
    1064:	85 b5       	in	r24, 0x25	; 37
    1066:	8d 7f       	andi	r24, 0xFD	; 253
    1068:	85 bd       	out	0x25, r24	; 37
    106a:	85 b5       	in	r24, 0x25	; 37
    106c:	8b 7f       	andi	r24, 0xFB	; 251
    106e:	85 bd       	out	0x25, r24	; 37
    1070:	80 e0       	ldi	r24, 0x00	; 0
    1072:	51 c0       	rjmp	.+162    	; 0x1116 <set_prescalar+0x306>
    1074:	85 b5       	in	r24, 0x25	; 37
    1076:	8e 7f       	andi	r24, 0xFE	; 254
    1078:	85 bd       	out	0x25, r24	; 37
    107a:	85 b5       	in	r24, 0x25	; 37
    107c:	82 60       	ori	r24, 0x02	; 2
    107e:	85 bd       	out	0x25, r24	; 37
    1080:	85 b5       	in	r24, 0x25	; 37
    1082:	8b 7f       	andi	r24, 0xFB	; 251
    1084:	85 bd       	out	0x25, r24	; 37
    1086:	80 e0       	ldi	r24, 0x00	; 0
    1088:	46 c0       	rjmp	.+140    	; 0x1116 <set_prescalar+0x306>
    108a:	85 b5       	in	r24, 0x25	; 37
    108c:	81 60       	ori	r24, 0x01	; 1
    108e:	85 bd       	out	0x25, r24	; 37
    1090:	85 b5       	in	r24, 0x25	; 37
    1092:	82 60       	ori	r24, 0x02	; 2
    1094:	85 bd       	out	0x25, r24	; 37
    1096:	85 b5       	in	r24, 0x25	; 37
    1098:	8b 7f       	andi	r24, 0xFB	; 251
    109a:	85 bd       	out	0x25, r24	; 37
    109c:	80 e0       	ldi	r24, 0x00	; 0
    109e:	3b c0       	rjmp	.+118    	; 0x1116 <set_prescalar+0x306>
    10a0:	85 b5       	in	r24, 0x25	; 37
    10a2:	8e 7f       	andi	r24, 0xFE	; 254
    10a4:	85 bd       	out	0x25, r24	; 37
    10a6:	85 b5       	in	r24, 0x25	; 37
    10a8:	8d 7f       	andi	r24, 0xFD	; 253
    10aa:	85 bd       	out	0x25, r24	; 37
    10ac:	85 b5       	in	r24, 0x25	; 37
    10ae:	84 60       	ori	r24, 0x04	; 4
    10b0:	85 bd       	out	0x25, r24	; 37
    10b2:	80 e0       	ldi	r24, 0x00	; 0
    10b4:	30 c0       	rjmp	.+96     	; 0x1116 <set_prescalar+0x306>
    10b6:	85 b5       	in	r24, 0x25	; 37
    10b8:	81 60       	ori	r24, 0x01	; 1
    10ba:	85 bd       	out	0x25, r24	; 37
    10bc:	85 b5       	in	r24, 0x25	; 37
    10be:	8d 7f       	andi	r24, 0xFD	; 253
    10c0:	85 bd       	out	0x25, r24	; 37
    10c2:	85 b5       	in	r24, 0x25	; 37
    10c4:	84 60       	ori	r24, 0x04	; 4
    10c6:	85 bd       	out	0x25, r24	; 37
    10c8:	80 e0       	ldi	r24, 0x00	; 0
    10ca:	25 c0       	rjmp	.+74     	; 0x1116 <set_prescalar+0x306>
    10cc:	85 b5       	in	r24, 0x25	; 37
    10ce:	8e 7f       	andi	r24, 0xFE	; 254
    10d0:	85 bd       	out	0x25, r24	; 37
    10d2:	85 b5       	in	r24, 0x25	; 37
    10d4:	82 60       	ori	r24, 0x02	; 2
    10d6:	85 bd       	out	0x25, r24	; 37
    10d8:	85 b5       	in	r24, 0x25	; 37
    10da:	84 60       	ori	r24, 0x04	; 4
    10dc:	85 bd       	out	0x25, r24	; 37
    10de:	80 e0       	ldi	r24, 0x00	; 0
    10e0:	1a c0       	rjmp	.+52     	; 0x1116 <set_prescalar+0x306>
    10e2:	85 b5       	in	r24, 0x25	; 37
    10e4:	81 60       	ori	r24, 0x01	; 1
    10e6:	85 bd       	out	0x25, r24	; 37
    10e8:	85 b5       	in	r24, 0x25	; 37
    10ea:	82 60       	ori	r24, 0x02	; 2
    10ec:	85 bd       	out	0x25, r24	; 37
    10ee:	85 b5       	in	r24, 0x25	; 37
    10f0:	84 60       	ori	r24, 0x04	; 4
    10f2:	85 bd       	out	0x25, r24	; 37
    10f4:	80 e0       	ldi	r24, 0x00	; 0
    10f6:	0f c0       	rjmp	.+30     	; 0x1116 <set_prescalar+0x306>
    10f8:	81 e0       	ldi	r24, 0x01	; 1
    10fa:	0d c0       	rjmp	.+26     	; 0x1116 <set_prescalar+0x306>
    10fc:	80 e0       	ldi	r24, 0x00	; 0
    10fe:	0b c0       	rjmp	.+22     	; 0x1116 <set_prescalar+0x306>
    1100:	82 e0       	ldi	r24, 0x02	; 2
    1102:	09 c0       	rjmp	.+18     	; 0x1116 <set_prescalar+0x306>
    1104:	80 e0       	ldi	r24, 0x00	; 0
    1106:	07 c0       	rjmp	.+14     	; 0x1116 <set_prescalar+0x306>
    1108:	82 e0       	ldi	r24, 0x02	; 2
    110a:	05 c0       	rjmp	.+10     	; 0x1116 <set_prescalar+0x306>
    110c:	80 e0       	ldi	r24, 0x00	; 0
    110e:	03 c0       	rjmp	.+6      	; 0x1116 <set_prescalar+0x306>
    1110:	82 e0       	ldi	r24, 0x02	; 2
    1112:	01 c0       	rjmp	.+2      	; 0x1116 <set_prescalar+0x306>
    1114:	80 e0       	ldi	r24, 0x00	; 0
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	1f 91       	pop	r17
    111c:	08 95       	ret

0000111e <Timer_normal_init>:
    111e:	0f 93       	push	r16
    1120:	1f 93       	push	r17
    1122:	cf 93       	push	r28
    1124:	c8 2f       	mov	r28, r24
    1126:	8b 01       	movw	r16, r22
    1128:	0e 94 02 07 	call	0xe04	; 0xe04 <isValidTimer>
    112c:	88 23       	and	r24, r24
    112e:	81 f1       	breq	.+96     	; 0x1190 <Timer_normal_init+0x72>
    1130:	cc 23       	and	r28, r28
    1132:	11 f0       	breq	.+4      	; 0x1138 <Timer_normal_init+0x1a>
    1134:	c2 30       	cpi	r28, 0x02	; 2
    1136:	21 f4       	brne	.+8      	; 0x1140 <Timer_normal_init+0x22>
    1138:	0f 3f       	cpi	r16, 0xFF	; 255
    113a:	11 05       	cpc	r17, r1
    113c:	09 f0       	breq	.+2      	; 0x1140 <Timer_normal_init+0x22>
    113e:	50 f5       	brcc	.+84     	; 0x1194 <Timer_normal_init+0x76>
    1140:	c1 30       	cpi	r28, 0x01	; 1
    1142:	69 f0       	breq	.+26     	; 0x115e <Timer_normal_init+0x40>
    1144:	18 f0       	brcs	.+6      	; 0x114c <Timer_normal_init+0x2e>
    1146:	c2 30       	cpi	r28, 0x02	; 2
    1148:	d1 f0       	breq	.+52     	; 0x117e <Timer_normal_init+0x60>
    114a:	26 c0       	rjmp	.+76     	; 0x1198 <Timer_normal_init+0x7a>
    114c:	83 b7       	in	r24, 0x33	; 51
    114e:	87 7f       	andi	r24, 0xF7	; 247
    1150:	83 bf       	out	0x33, r24	; 51
    1152:	83 b7       	in	r24, 0x33	; 51
    1154:	8f 7b       	andi	r24, 0xBF	; 191
    1156:	83 bf       	out	0x33, r24	; 51
    1158:	02 bf       	out	0x32, r16	; 50
    115a:	80 e0       	ldi	r24, 0x00	; 0
    115c:	1e c0       	rjmp	.+60     	; 0x119a <Timer_normal_init+0x7c>
    115e:	8f b5       	in	r24, 0x2f	; 47
    1160:	8e 7f       	andi	r24, 0xFE	; 254
    1162:	8f bd       	out	0x2f, r24	; 47
    1164:	8f b5       	in	r24, 0x2f	; 47
    1166:	8d 7f       	andi	r24, 0xFD	; 253
    1168:	8f bd       	out	0x2f, r24	; 47
    116a:	8e b5       	in	r24, 0x2e	; 46
    116c:	87 7f       	andi	r24, 0xF7	; 247
    116e:	8e bd       	out	0x2e, r24	; 46
    1170:	8e b5       	in	r24, 0x2e	; 46
    1172:	8f 7e       	andi	r24, 0xEF	; 239
    1174:	8e bd       	out	0x2e, r24	; 46
    1176:	1d bd       	out	0x2d, r17	; 45
    1178:	0c bd       	out	0x2c, r16	; 44
    117a:	80 e0       	ldi	r24, 0x00	; 0
    117c:	0e c0       	rjmp	.+28     	; 0x119a <Timer_normal_init+0x7c>
    117e:	85 b5       	in	r24, 0x25	; 37
    1180:	87 7f       	andi	r24, 0xF7	; 247
    1182:	85 bd       	out	0x25, r24	; 37
    1184:	85 b5       	in	r24, 0x25	; 37
    1186:	8f 7b       	andi	r24, 0xBF	; 191
    1188:	85 bd       	out	0x25, r24	; 37
    118a:	04 bd       	out	0x24, r16	; 36
    118c:	80 e0       	ldi	r24, 0x00	; 0
    118e:	05 c0       	rjmp	.+10     	; 0x119a <Timer_normal_init+0x7c>
    1190:	81 e0       	ldi	r24, 0x01	; 1
    1192:	03 c0       	rjmp	.+6      	; 0x119a <Timer_normal_init+0x7c>
    1194:	83 e0       	ldi	r24, 0x03	; 3
    1196:	01 c0       	rjmp	.+2      	; 0x119a <Timer_normal_init+0x7c>
    1198:	80 e0       	ldi	r24, 0x00	; 0
    119a:	cf 91       	pop	r28
    119c:	1f 91       	pop	r17
    119e:	0f 91       	pop	r16
    11a0:	08 95       	ret

000011a2 <Timer_start>:
    11a2:	0f 93       	push	r16
    11a4:	1f 93       	push	r17
    11a6:	cf 93       	push	r28
    11a8:	c8 2f       	mov	r28, r24
    11aa:	8b 01       	movw	r16, r22
    11ac:	0e 94 02 07 	call	0xe04	; 0xe04 <isValidTimer>
    11b0:	88 23       	and	r24, r24
    11b2:	31 f0       	breq	.+12     	; 0x11c0 <Timer_start+0x1e>
    11b4:	b8 01       	movw	r22, r16
    11b6:	8c 2f       	mov	r24, r28
    11b8:	0e 94 08 07 	call	0xe10	; 0xe10 <set_prescalar>
    11bc:	80 e0       	ldi	r24, 0x00	; 0
    11be:	01 c0       	rjmp	.+2      	; 0x11c2 <Timer_start+0x20>
    11c0:	81 e0       	ldi	r24, 0x01	; 1
    11c2:	cf 91       	pop	r28
    11c4:	1f 91       	pop	r17
    11c6:	0f 91       	pop	r16
    11c8:	08 95       	ret

000011ca <PWM_OCP_disconnect>:

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    11ca:	84 30       	cpi	r24, 0x04	; 4
    11cc:	40 f5       	brcc	.+80     	; 0x121e <PWM_OCP_disconnect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    11ce:	81 30       	cpi	r24, 0x01	; 1
    11d0:	71 f0       	breq	.+28     	; 0x11ee <PWM_OCP_disconnect+0x24>
    11d2:	28 f0       	brcs	.+10     	; 0x11de <PWM_OCP_disconnect+0x14>
    11d4:	82 30       	cpi	r24, 0x02	; 2
    11d6:	99 f0       	breq	.+38     	; 0x11fe <PWM_OCP_disconnect+0x34>
    11d8:	83 30       	cpi	r24, 0x03	; 3
    11da:	c9 f0       	breq	.+50     	; 0x120e <PWM_OCP_disconnect+0x44>
    11dc:	22 c0       	rjmp	.+68     	; 0x1222 <PWM_OCP_disconnect+0x58>
      case OC_0:
        clear_bit(TCCR0, COM00);
    11de:	83 b7       	in	r24, 0x33	; 51
    11e0:	8f 7e       	andi	r24, 0xEF	; 239
    11e2:	83 bf       	out	0x33, r24	; 51
        clear_bit(TCCR0, COM01);
    11e4:	83 b7       	in	r24, 0x33	; 51
    11e6:	8f 7d       	andi	r24, 0xDF	; 223
    11e8:	83 bf       	out	0x33, r24	; 51
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    }
  switch (pwmPin) {
      case OC_0:
        clear_bit(TCCR0, COM00);
        clear_bit(TCCR0, COM01);
        break;
    11ec:	08 95       	ret
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
    11ee:	8f b5       	in	r24, 0x2f	; 47
    11f0:	8f 7b       	andi	r24, 0xBF	; 191
    11f2:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1A1);
    11f4:	8f b5       	in	r24, 0x2f	; 47
    11f6:	8f 77       	andi	r24, 0x7F	; 127
    11f8:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    11fa:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR0, COM01);
        break;
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
        clear_bit(TCCR1A, COM1A1);
        break;
    11fc:	08 95       	ret
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
    11fe:	8f b5       	in	r24, 0x2f	; 47
    1200:	8f 7e       	andi	r24, 0xEF	; 239
    1202:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1B1);
    1204:	8f b5       	in	r24, 0x2f	; 47
    1206:	8f 7d       	andi	r24, 0xDF	; 223
    1208:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    120a:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1A1);
        break;
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
        clear_bit(TCCR1A, COM1B1);
        break;
    120c:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
    120e:	85 b5       	in	r24, 0x25	; 37
    1210:	8f 7e       	andi	r24, 0xEF	; 239
    1212:	85 bd       	out	0x25, r24	; 37
        clear_bit(TCCR2, COM21);
    1214:	85 b5       	in	r24, 0x25	; 37
    1216:	8f 7d       	andi	r24, 0xDF	; 223
    1218:	85 bd       	out	0x25, r24	; 37
        break;
    }
  return TIMER_OK;
    121a:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1B1);
        break;
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    121c:	08 95       	ret
  }

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    121e:	87 e0       	ldi	r24, 0x07	; 7
    1220:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1222:	80 e0       	ldi	r24, 0x00	; 0
  }
    1224:	08 95       	ret

00001226 <PWM_OCP_connect>:

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    1226:	84 30       	cpi	r24, 0x04	; 4
    1228:	40 f5       	brcc	.+80     	; 0x127a <PWM_OCP_connect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    122a:	81 30       	cpi	r24, 0x01	; 1
    122c:	71 f0       	breq	.+28     	; 0x124a <PWM_OCP_connect+0x24>
    122e:	28 f0       	brcs	.+10     	; 0x123a <PWM_OCP_connect+0x14>
    1230:	82 30       	cpi	r24, 0x02	; 2
    1232:	99 f0       	breq	.+38     	; 0x125a <PWM_OCP_connect+0x34>
    1234:	83 30       	cpi	r24, 0x03	; 3
    1236:	c9 f0       	breq	.+50     	; 0x126a <PWM_OCP_connect+0x44>
    1238:	22 c0       	rjmp	.+68     	; 0x127e <PWM_OCP_connect+0x58>
      case OC_0:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR0, COM00);
    123a:	83 b7       	in	r24, 0x33	; 51
    123c:	8f 7e       	andi	r24, 0xEF	; 239
    123e:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR0, COM01);
    1240:	83 b7       	in	r24, 0x33	; 51
    1242:	80 62       	ori	r24, 0x20	; 32
    1244:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    1246:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR0, COM01);
#else 
        set_bit(TCCR0, COM00);
        set_bit(TCCR0, COM01);
#endif
        break;
    1248:	08 95       	ret
      case OC_1A:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1A0);
    124a:	8f b5       	in	r24, 0x2f	; 47
    124c:	8f 7b       	andi	r24, 0xBF	; 191
    124e:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1A1);
    1250:	8f b5       	in	r24, 0x2f	; 47
    1252:	80 68       	ori	r24, 0x80	; 128
    1254:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    1256:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1A1);
#else 
        set_bit(TCCR1A, COM1A0);
        set_bit(TCCR1A, COM1A1);
#endif
        break;
    1258:	08 95       	ret
      case OC_1B:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1B0);
    125a:	8f b5       	in	r24, 0x2f	; 47
    125c:	8f 7e       	andi	r24, 0xEF	; 239
    125e:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1B1);
    1260:	8f b5       	in	r24, 0x2f	; 47
    1262:	80 62       	ori	r24, 0x20	; 32
    1264:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    1266:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1B1);
#else 
        set_bit(TCCR1A, COM1B0);
        set_bit(TCCR1A, COM1B1);
#endif
        break;
    1268:	08 95       	ret
      case OC_2:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR2, COM20);
    126a:	85 b5       	in	r24, 0x25	; 37
    126c:	8f 7e       	andi	r24, 0xEF	; 239
    126e:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM21);
    1270:	85 b5       	in	r24, 0x25	; 37
    1272:	80 62       	ori	r24, 0x20	; 32
    1274:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    1276:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR2, COM21);
#else 
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    1278:	08 95       	ret
  }

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    127a:	87 e0       	ldi	r24, 0x07	; 7
    127c:	08 95       	ret
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    127e:	80 e0       	ldi	r24, 0x00	; 0
  }
    1280:	08 95       	ret

00001282 <PWM_init>:
  return TIMER_OK;
  }

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
    1282:	cf 92       	push	r12
    1284:	df 92       	push	r13
    1286:	ef 92       	push	r14
    1288:	ff 92       	push	r15
    128a:	cf 93       	push	r28
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    128c:	84 30       	cpi	r24, 0x04	; 4
    128e:	08 f0       	brcs	.+2      	; 0x1292 <PWM_init+0x10>
    1290:	96 c0       	rjmp	.+300    	; 0x13be <PWM_init+0x13c>
    return WRONG_PWM_PIN;
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    1292:	9f ef       	ldi	r25, 0xFF	; 255
    1294:	92 0f       	add	r25, r18
    1296:	92 30       	cpi	r25, 0x02	; 2
    1298:	08 f0       	brcs	.+2      	; 0x129c <PWM_init+0x1a>
    129a:	93 c0       	rjmp	.+294    	; 0x13c2 <PWM_init+0x140>
    129c:	6a 01       	movw	r12, r20
    129e:	7b 01       	movw	r14, r22
    12a0:	c8 2f       	mov	r28, r24
    return WRONG_PWM_MODE;
    }
  switch (pwmPin) {
    12a2:	83 30       	cpi	r24, 0x03	; 3
    12a4:	18 f4       	brcc	.+6      	; 0x12ac <PWM_init+0x2a>
    12a6:	81 30       	cpi	r24, 0x01	; 1
    12a8:	28 f0       	brcs	.+10     	; 0x12b4 <PWM_init+0x32>
    12aa:	22 c0       	rjmp	.+68     	; 0x12f0 <PWM_init+0x6e>
    12ac:	83 30       	cpi	r24, 0x03	; 3
    12ae:	09 f4       	brne	.+2      	; 0x12b2 <PWM_init+0x30>
    12b0:	64 c0       	rjmp	.+200    	; 0x137a <PWM_init+0xf8>
    12b2:	80 c0       	rjmp	.+256    	; 0x13b4 <PWM_init+0x132>
      case OC_0:
        switch (mode) {
    12b4:	21 30       	cpi	r18, 0x01	; 1
    12b6:	19 f0       	breq	.+6      	; 0x12be <PWM_init+0x3c>
    12b8:	22 30       	cpi	r18, 0x02	; 2
    12ba:	41 f0       	breq	.+16     	; 0x12cc <PWM_init+0x4a>
    12bc:	0d c0       	rjmp	.+26     	; 0x12d8 <PWM_init+0x56>
            case PWM_FAST:
              set_bit(TCCR0, WGM00);
    12be:	83 b7       	in	r24, 0x33	; 51
    12c0:	80 64       	ori	r24, 0x40	; 64
    12c2:	83 bf       	out	0x33, r24	; 51
              set_bit(TCCR0, WGM01);
    12c4:	83 b7       	in	r24, 0x33	; 51
    12c6:	88 60       	ori	r24, 0x08	; 8
    12c8:	83 bf       	out	0x33, r24	; 51
              break;
    12ca:	06 c0       	rjmp	.+12     	; 0x12d8 <PWM_init+0x56>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR0, WGM00);
    12cc:	83 b7       	in	r24, 0x33	; 51
    12ce:	80 64       	ori	r24, 0x40	; 64
    12d0:	83 bf       	out	0x33, r24	; 51
              clear_bit(TCCR0, WGM01);
    12d2:	83 b7       	in	r24, 0x33	; 51
    12d4:	87 7f       	andi	r24, 0xF7	; 247
    12d6:	83 bf       	out	0x33, r24	; 51
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR0 = (u8)(dutyCycle * 255);
    12d8:	20 e0       	ldi	r18, 0x00	; 0
    12da:	30 e0       	ldi	r19, 0x00	; 0
    12dc:	4f e7       	ldi	r20, 0x7F	; 127
    12de:	53 e4       	ldi	r21, 0x43	; 67
    12e0:	c7 01       	movw	r24, r14
    12e2:	b6 01       	movw	r22, r12
    12e4:	0e 94 56 17 	call	0x2eac	; 0x2eac <__mulsf3>
    12e8:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__fixunssfsi>
    12ec:	6c bf       	out	0x3c, r22	; 60
        break;
    12ee:	62 c0       	rjmp	.+196    	; 0x13b4 <PWM_init+0x132>
        //? The fix for this issue is to use ICR1 as TOP instead (mode 14 in fast pwm), thus allowing OCR1A and OCR1B to be used to set the duty cycle while ICR1 is used tyo set the frequency.
        //? Mode 15 can be used at the cost of disabling PWM on OC1A, but we get more glitch-free variable frequency PWM signal on OC1B due to the double buffering of OC1A, which ICR1 doesn't have.
        //? Since I don't need a variable frequency pwm signal, ICR1 will be used as TOP by default and set to MAX.
      case OC_1A:
      case OC_1B:
        switch (mode) {
    12f0:	21 30       	cpi	r18, 0x01	; 1
    12f2:	19 f0       	breq	.+6      	; 0x12fa <PWM_init+0x78>
    12f4:	22 30       	cpi	r18, 0x02	; 2
    12f6:	91 f0       	breq	.+36     	; 0x131c <PWM_init+0x9a>
    12f8:	21 c0       	rjmp	.+66     	; 0x133c <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
    12fa:	8f b5       	in	r24, 0x2f	; 47
    12fc:	8e 7f       	andi	r24, 0xFE	; 254
    12fe:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
    1300:	8f b5       	in	r24, 0x2f	; 47
    1302:	82 60       	ori	r24, 0x02	; 2
    1304:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1B, WGM12);
    1306:	8e b5       	in	r24, 0x2e	; 46
    1308:	88 60       	ori	r24, 0x08	; 8
    130a:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
    130c:	8e b5       	in	r24, 0x2e	; 46
    130e:	80 61       	ori	r24, 0x10	; 16
    1310:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
    1312:	80 e2       	ldi	r24, 0x20	; 32
    1314:	9e e4       	ldi	r25, 0x4E	; 78
    1316:	97 bd       	out	0x27, r25	; 39
    1318:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              set_bit(TCCR1B, WGM13);
#endif
              break;
    131a:	10 c0       	rjmp	.+32     	; 0x133c <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              clear_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
    131c:	8f b5       	in	r24, 0x2f	; 47
    131e:	8e 7f       	andi	r24, 0xFE	; 254
    1320:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
    1322:	8f b5       	in	r24, 0x2f	; 47
    1324:	82 60       	ori	r24, 0x02	; 2
    1326:	8f bd       	out	0x2f, r24	; 47
              clear_bit(TCCR1B, WGM12);
    1328:	8e b5       	in	r24, 0x2e	; 46
    132a:	87 7f       	andi	r24, 0xF7	; 247
    132c:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
    132e:	8e b5       	in	r24, 0x2e	; 46
    1330:	80 61       	ori	r24, 0x10	; 16
    1332:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
    1334:	80 e2       	ldi	r24, 0x20	; 32
    1336:	9e e4       	ldi	r25, 0x4E	; 78
    1338:	97 bd       	out	0x27, r25	; 39
    133a:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1B, WGM13);
#endif
              break;
          }
        // Enable the PWM function of the OC pin.
        switch (pwmPin) {
    133c:	c1 30       	cpi	r28, 0x01	; 1
    133e:	19 f0       	breq	.+6      	; 0x1346 <PWM_init+0xc4>
    1340:	c2 30       	cpi	r28, 0x02	; 2
    1342:	71 f0       	breq	.+28     	; 0x1360 <PWM_init+0xde>
    1344:	37 c0       	rjmp	.+110    	; 0x13b4 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    1346:	20 e0       	ldi	r18, 0x00	; 0
    1348:	30 e4       	ldi	r19, 0x40	; 64
    134a:	4c e9       	ldi	r20, 0x9C	; 156
    134c:	56 e4       	ldi	r21, 0x46	; 70
    134e:	c7 01       	movw	r24, r14
    1350:	b6 01       	movw	r22, r12
    1352:	0e 94 56 17 	call	0x2eac	; 0x2eac <__mulsf3>
    1356:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__fixunssfsi>
    135a:	7b bd       	out	0x2b, r23	; 43
    135c:	6a bd       	out	0x2a, r22	; 42
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1A = (u16)(dutyCycle * 65535);
#endif
              break;
    135e:	2a c0       	rjmp	.+84     	; 0x13b4 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    1360:	20 e0       	ldi	r18, 0x00	; 0
    1362:	30 e4       	ldi	r19, 0x40	; 64
    1364:	4c e9       	ldi	r20, 0x9C	; 156
    1366:	56 e4       	ldi	r21, 0x46	; 70
    1368:	c7 01       	movw	r24, r14
    136a:	b6 01       	movw	r22, r12
    136c:	0e 94 56 17 	call	0x2eac	; 0x2eac <__mulsf3>
    1370:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__fixunssfsi>
    1374:	79 bd       	out	0x29, r23	; 41
    1376:	68 bd       	out	0x28, r22	; 40
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1B = (u16)(dutyCycle * 65535);
#endif
              break;
    1378:	1d c0       	rjmp	.+58     	; 0x13b4 <PWM_init+0x132>
          }
        break;
      case OC_2:
        switch (mode) {
    137a:	21 30       	cpi	r18, 0x01	; 1
    137c:	19 f0       	breq	.+6      	; 0x1384 <PWM_init+0x102>
    137e:	22 30       	cpi	r18, 0x02	; 2
    1380:	41 f0       	breq	.+16     	; 0x1392 <PWM_init+0x110>
    1382:	0d c0       	rjmp	.+26     	; 0x139e <PWM_init+0x11c>
            case PWM_FAST:
              set_bit(TCCR2, WGM20);
    1384:	85 b5       	in	r24, 0x25	; 37
    1386:	80 64       	ori	r24, 0x40	; 64
    1388:	85 bd       	out	0x25, r24	; 37
              set_bit(TCCR2, WGM21);
    138a:	85 b5       	in	r24, 0x25	; 37
    138c:	88 60       	ori	r24, 0x08	; 8
    138e:	85 bd       	out	0x25, r24	; 37
              break;
    1390:	06 c0       	rjmp	.+12     	; 0x139e <PWM_init+0x11c>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR2, WGM20);
    1392:	85 b5       	in	r24, 0x25	; 37
    1394:	80 64       	ori	r24, 0x40	; 64
    1396:	85 bd       	out	0x25, r24	; 37
              clear_bit(TCCR2, WGM21);
    1398:	85 b5       	in	r24, 0x25	; 37
    139a:	87 7f       	andi	r24, 0xF7	; 247
    139c:	85 bd       	out	0x25, r24	; 37
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR2 = (u8)(dutyCycle * 255);
    139e:	20 e0       	ldi	r18, 0x00	; 0
    13a0:	30 e0       	ldi	r19, 0x00	; 0
    13a2:	4f e7       	ldi	r20, 0x7F	; 127
    13a4:	53 e4       	ldi	r21, 0x43	; 67
    13a6:	c7 01       	movw	r24, r14
    13a8:	b6 01       	movw	r22, r12
    13aa:	0e 94 56 17 	call	0x2eac	; 0x2eac <__mulsf3>
    13ae:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__fixunssfsi>
    13b2:	63 bd       	out	0x23, r22	; 35
        break;
    }
  PWM_OCP_connect(pwmPin);
    13b4:	8c 2f       	mov	r24, r28
    13b6:	0e 94 13 09 	call	0x1226	; 0x1226 <PWM_OCP_connect>
  return TIMER_OK;
    13ba:	80 e0       	ldi	r24, 0x00	; 0
    13bc:	03 c0       	rjmp	.+6      	; 0x13c4 <PWM_init+0x142>

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    13be:	87 e0       	ldi	r24, 0x07	; 7
    13c0:	01 c0       	rjmp	.+2      	; 0x13c4 <PWM_init+0x142>
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    return WRONG_PWM_MODE;
    13c2:	86 e0       	ldi	r24, 0x06	; 6
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  PWM_OCP_connect(pwmPin);
  return TIMER_OK;
  }
    13c4:	cf 91       	pop	r28
    13c6:	ff 90       	pop	r15
    13c8:	ef 90       	pop	r14
    13ca:	df 90       	pop	r13
    13cc:	cf 90       	pop	r12
    13ce:	08 95       	ret

000013d0 <PWM_set_DC>:
    }
  return TIMER_OK;
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
    13d0:	28 2f       	mov	r18, r24
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    13d2:	84 30       	cpi	r24, 0x04	; 4
    13d4:	c0 f5       	brcc	.+112    	; 0x1446 <PWM_set_DC+0x76>
    13d6:	cb 01       	movw	r24, r22
    13d8:	ba 01       	movw	r22, r20
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    13da:	21 30       	cpi	r18, 0x01	; 1
    13dc:	89 f0       	breq	.+34     	; 0x1400 <PWM_set_DC+0x30>
    13de:	28 f0       	brcs	.+10     	; 0x13ea <PWM_set_DC+0x1a>
    13e0:	22 30       	cpi	r18, 0x02	; 2
    13e2:	d1 f0       	breq	.+52     	; 0x1418 <PWM_set_DC+0x48>
    13e4:	23 30       	cpi	r18, 0x03	; 3
    13e6:	21 f1       	breq	.+72     	; 0x1430 <PWM_set_DC+0x60>
    13e8:	30 c0       	rjmp	.+96     	; 0x144a <PWM_set_DC+0x7a>
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
    13ea:	20 e0       	ldi	r18, 0x00	; 0
    13ec:	30 e0       	ldi	r19, 0x00	; 0
    13ee:	4f e7       	ldi	r20, 0x7F	; 127
    13f0:	53 e4       	ldi	r21, 0x43	; 67
    13f2:	0e 94 56 17 	call	0x2eac	; 0x2eac <__mulsf3>
    13f6:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__fixunssfsi>
    13fa:	6c bf       	out	0x3c, r22	; 60
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    13fc:	80 e0       	ldi	r24, 0x00	; 0
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
        break;
    13fe:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    1400:	20 e0       	ldi	r18, 0x00	; 0
    1402:	30 e4       	ldi	r19, 0x40	; 64
    1404:	4c e9       	ldi	r20, 0x9C	; 156
    1406:	56 e4       	ldi	r21, 0x46	; 70
    1408:	0e 94 56 17 	call	0x2eac	; 0x2eac <__mulsf3>
    140c:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__fixunssfsi>
    1410:	7b bd       	out	0x2b, r23	; 43
    1412:	6a bd       	out	0x2a, r22	; 42
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    1414:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1A = (u16)(dutyCycle * 65535);
#endif
        break;
    1416:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    1418:	20 e0       	ldi	r18, 0x00	; 0
    141a:	30 e4       	ldi	r19, 0x40	; 64
    141c:	4c e9       	ldi	r20, 0x9C	; 156
    141e:	56 e4       	ldi	r21, 0x46	; 70
    1420:	0e 94 56 17 	call	0x2eac	; 0x2eac <__mulsf3>
    1424:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__fixunssfsi>
    1428:	79 bd       	out	0x29, r23	; 41
    142a:	68 bd       	out	0x28, r22	; 40
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    142c:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
    142e:	08 95       	ret
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
    1430:	20 e0       	ldi	r18, 0x00	; 0
    1432:	30 e0       	ldi	r19, 0x00	; 0
    1434:	4f e7       	ldi	r20, 0x7F	; 127
    1436:	53 e4       	ldi	r21, 0x43	; 67
    1438:	0e 94 56 17 	call	0x2eac	; 0x2eac <__mulsf3>
    143c:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__fixunssfsi>
    1440:	63 bd       	out	0x23, r22	; 35
        break;
    }
  return TIMER_OK;
    1442:	80 e0       	ldi	r24, 0x00	; 0
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    1444:	08 95       	ret
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    1446:	87 e0       	ldi	r24, 0x07	; 7
    1448:	08 95       	ret
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    144a:	80 e0       	ldi	r24, 0x00	; 0
  }
    144c:	08 95       	ret

0000144e <UART_sendChar>:
  }

// Receive a Char using UART
void UART_receiveChar(s8* x) {
  while (!read_bit(UCSRA, RXC)); // Wait for the data to be received.
  *x = UDR;
    144e:	5d 9b       	sbis	0x0b, 5	; 11
    1450:	fe cf       	rjmp	.-4      	; 0x144e <UART_sendChar>
    1452:	8c b9       	out	0x0c, r24	; 12
    1454:	5e 9b       	sbis	0x0b, 6	; 11
    1456:	fe cf       	rjmp	.-4      	; 0x1454 <UART_sendChar+0x6>
    1458:	08 95       	ret

0000145a <UART_sendString>:
  }

void UART_sendString(s8* str) {
    145a:	cf 92       	push	r12
    145c:	df 92       	push	r13
    145e:	ef 92       	push	r14
    1460:	ff 92       	push	r15
    1462:	cf 93       	push	r28
    1464:	df 93       	push	r29
    1466:	ec 01       	movw	r28, r24
  u32 i = 0;
    1468:	c1 2c       	mov	r12, r1
    146a:	d1 2c       	mov	r13, r1
    146c:	76 01       	movw	r14, r12
  while (str[i] != 0) {
    146e:	07 c0       	rjmp	.+14     	; 0x147e <UART_sendString+0x24>
    UART_sendChar(str[i]);
    1470:	0e 94 27 0a 	call	0x144e	; 0x144e <UART_sendChar>
    i++;
    1474:	8f ef       	ldi	r24, 0xFF	; 255
    1476:	c8 1a       	sub	r12, r24
    1478:	d8 0a       	sbc	r13, r24
    147a:	e8 0a       	sbc	r14, r24
    147c:	f8 0a       	sbc	r15, r24
  *x = UDR;
  }

void UART_sendString(s8* str) {
  u32 i = 0;
  while (str[i] != 0) {
    147e:	fe 01       	movw	r30, r28
    1480:	ec 0d       	add	r30, r12
    1482:	fd 1d       	adc	r31, r13
    1484:	80 81       	ld	r24, Z
    1486:	81 11       	cpse	r24, r1
    1488:	f3 cf       	rjmp	.-26     	; 0x1470 <UART_sendString+0x16>
    UART_sendChar(str[i]);
    i++;
    }
  UART_sendChar(0); // Send null to terminate the string
    148a:	0e 94 27 0a 	call	0x144e	; 0x144e <UART_sendChar>
  }
    148e:	df 91       	pop	r29
    1490:	cf 91       	pop	r28
    1492:	ff 90       	pop	r15
    1494:	ef 90       	pop	r14
    1496:	df 90       	pop	r13
    1498:	cf 90       	pop	r12
    149a:	08 95       	ret

0000149c <Door_init>:

#include "door.h"

 // Initialize the servo for the door
void Door_init(void) {
  Servo_init();
    149c:	0e 94 39 04 	call	0x872	; 0x872 <Servo_init>
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    14a0:	80 e0       	ldi	r24, 0x00	; 0
    14a2:	0e 94 4c 04 	call	0x898	; 0x898 <Servo_move_to_angle>
    14a6:	08 95       	ret

000014a8 <Door_open>:
  }

// Open the door by moving the servo to the open angle
void Door_open(void) {
  Servo_move_to_angle(DOOR_OPEN_ANGLE);
    14a8:	84 eb       	ldi	r24, 0xB4	; 180
    14aa:	0e 94 4c 04 	call	0x898	; 0x898 <Servo_move_to_angle>
    14ae:	08 95       	ret

000014b0 <Door_close>:
  }

// Close the door by moving the servo to the close angle
void Door_close(void) {
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    14b0:	80 e0       	ldi	r24, 0x00	; 0
    14b2:	0e 94 4c 04 	call	0x898	; 0x898 <Servo_move_to_angle>
    14b6:	08 95       	ret

000014b8 <Lamps_init>:

#include "lights.h"

 // Initializes all six lamps
void Lamps_init(void) {
  LED_init(LAMP_1_PORT, LAMP_1_PIN);
    14b8:	62 e0       	ldi	r22, 0x02	; 2
    14ba:	83 e4       	ldi	r24, 0x43	; 67
    14bc:	0e 94 05 04 	call	0x80a	; 0x80a <LED_init>
  LED_init(LAMP_2_PORT, LAMP_2_PIN);
    14c0:	63 e0       	ldi	r22, 0x03	; 3
    14c2:	83 e4       	ldi	r24, 0x43	; 67
    14c4:	0e 94 05 04 	call	0x80a	; 0x80a <LED_init>
  LED_init(LAMP_3_PORT, LAMP_3_PIN);
    14c8:	64 e0       	ldi	r22, 0x04	; 4
    14ca:	83 e4       	ldi	r24, 0x43	; 67
    14cc:	0e 94 05 04 	call	0x80a	; 0x80a <LED_init>
  LED_init(LAMP_4_PORT, LAMP_4_PIN);
    14d0:	65 e0       	ldi	r22, 0x05	; 5
    14d2:	83 e4       	ldi	r24, 0x43	; 67
    14d4:	0e 94 05 04 	call	0x80a	; 0x80a <LED_init>
  LED_init(LAMP_5_PORT, LAMP_5_PIN);
    14d8:	66 e0       	ldi	r22, 0x06	; 6
    14da:	83 e4       	ldi	r24, 0x43	; 67
    14dc:	0e 94 05 04 	call	0x80a	; 0x80a <LED_init>
  LED_init(LAMP_6_DIMMABLE_PORT, LAMP_6_DIMMABLE_PIN);
    14e0:	67 e0       	ldi	r22, 0x07	; 7
    14e2:	84 e4       	ldi	r24, 0x44	; 68
    14e4:	0e 94 05 04 	call	0x80a	; 0x80a <LED_init>
  // Initialize the pwm pin which lamp6 is on for brightness control
  PWM_init(LAMP_6_DIMMABLE_PWM_PIN, 0, PWM_FAST);
    14e8:	21 e0       	ldi	r18, 0x01	; 1
    14ea:	40 e0       	ldi	r20, 0x00	; 0
    14ec:	50 e0       	ldi	r21, 0x00	; 0
    14ee:	ba 01       	movw	r22, r20
    14f0:	83 e0       	ldi	r24, 0x03	; 3
    14f2:	0e 94 41 09 	call	0x1282	; 0x1282 <PWM_init>

  Timer_start(TIMER_2, LAMP_6_DIMMABLE_PRESCALAR);
    14f6:	60 e0       	ldi	r22, 0x00	; 0
    14f8:	71 e0       	ldi	r23, 0x01	; 1
    14fa:	82 e0       	ldi	r24, 0x02	; 2
    14fc:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <Timer_start>
    1500:	08 95       	ret

00001502 <Lamp_on>:
  }

// Turn on a lamp
void Lamp_on(u8 lampNumber) {
  switch (lampNumber) {
    1502:	83 30       	cpi	r24, 0x03	; 3
    1504:	b1 f0       	breq	.+44     	; 0x1532 <Lamp_on+0x30>
    1506:	28 f4       	brcc	.+10     	; 0x1512 <Lamp_on+0x10>
    1508:	81 30       	cpi	r24, 0x01	; 1
    150a:	49 f0       	breq	.+18     	; 0x151e <Lamp_on+0x1c>
    150c:	82 30       	cpi	r24, 0x02	; 2
    150e:	61 f0       	breq	.+24     	; 0x1528 <Lamp_on+0x26>
    1510:	08 95       	ret
    1512:	85 30       	cpi	r24, 0x05	; 5
    1514:	c1 f0       	breq	.+48     	; 0x1546 <Lamp_on+0x44>
    1516:	90 f0       	brcs	.+36     	; 0x153c <Lamp_on+0x3a>
    1518:	86 30       	cpi	r24, 0x06	; 6
    151a:	d1 f0       	breq	.+52     	; 0x1550 <Lamp_on+0x4e>
    151c:	08 95       	ret
      case LAMP_1:
        LED_on(LAMP_1_PORT, LAMP_1_PIN);
    151e:	62 e0       	ldi	r22, 0x02	; 2
    1520:	83 e4       	ldi	r24, 0x43	; 67
    1522:	0e 94 0e 04 	call	0x81c	; 0x81c <LED_on>
        break;
    1526:	08 95       	ret
      case LAMP_2:
        LED_on(LAMP_2_PORT, LAMP_2_PIN);
    1528:	63 e0       	ldi	r22, 0x03	; 3
    152a:	83 e4       	ldi	r24, 0x43	; 67
    152c:	0e 94 0e 04 	call	0x81c	; 0x81c <LED_on>
        break;
    1530:	08 95       	ret
      case LAMP_3:
        LED_on(LAMP_3_PORT, LAMP_3_PIN);
    1532:	64 e0       	ldi	r22, 0x04	; 4
    1534:	83 e4       	ldi	r24, 0x43	; 67
    1536:	0e 94 0e 04 	call	0x81c	; 0x81c <LED_on>
        break;
    153a:	08 95       	ret
      case LAMP_4:
        LED_on(LAMP_4_PORT, LAMP_4_PIN);
    153c:	65 e0       	ldi	r22, 0x05	; 5
    153e:	83 e4       	ldi	r24, 0x43	; 67
    1540:	0e 94 0e 04 	call	0x81c	; 0x81c <LED_on>
        break;
    1544:	08 95       	ret
      case LAMP_5:
        LED_on(LAMP_5_PORT, LAMP_5_PIN);
    1546:	66 e0       	ldi	r22, 0x06	; 6
    1548:	83 e4       	ldi	r24, 0x43	; 67
    154a:	0e 94 0e 04 	call	0x81c	; 0x81c <LED_on>
        break;
    154e:	08 95       	ret
      case LAMP_6:
        PWM_OCP_connect(LAMP_6_DIMMABLE_PWM_PIN);
    1550:	83 e0       	ldi	r24, 0x03	; 3
    1552:	0e 94 13 09 	call	0x1226	; 0x1226 <PWM_OCP_connect>
    1556:	08 95       	ret

00001558 <Lamp_off>:
    }
  }

// Turn off a lamp
void Lamp_off(u8 lampNumber) {
  switch (lampNumber) {
    1558:	83 30       	cpi	r24, 0x03	; 3
    155a:	b1 f0       	breq	.+44     	; 0x1588 <Lamp_off+0x30>
    155c:	28 f4       	brcc	.+10     	; 0x1568 <Lamp_off+0x10>
    155e:	81 30       	cpi	r24, 0x01	; 1
    1560:	49 f0       	breq	.+18     	; 0x1574 <Lamp_off+0x1c>
    1562:	82 30       	cpi	r24, 0x02	; 2
    1564:	61 f0       	breq	.+24     	; 0x157e <Lamp_off+0x26>
    1566:	08 95       	ret
    1568:	85 30       	cpi	r24, 0x05	; 5
    156a:	c1 f0       	breq	.+48     	; 0x159c <Lamp_off+0x44>
    156c:	90 f0       	brcs	.+36     	; 0x1592 <Lamp_off+0x3a>
    156e:	86 30       	cpi	r24, 0x06	; 6
    1570:	d1 f0       	breq	.+52     	; 0x15a6 <Lamp_off+0x4e>
    1572:	08 95       	ret
      case LAMP_1:
        LED_off(LAMP_1_PORT, LAMP_1_PIN);
    1574:	62 e0       	ldi	r22, 0x02	; 2
    1576:	83 e4       	ldi	r24, 0x43	; 67
    1578:	0e 94 17 04 	call	0x82e	; 0x82e <LED_off>
        break;
    157c:	08 95       	ret
      case LAMP_2:
        LED_off(LAMP_2_PORT, LAMP_2_PIN);
    157e:	63 e0       	ldi	r22, 0x03	; 3
    1580:	83 e4       	ldi	r24, 0x43	; 67
    1582:	0e 94 17 04 	call	0x82e	; 0x82e <LED_off>
        break;
    1586:	08 95       	ret
      case LAMP_3:
        LED_off(LAMP_3_PORT, LAMP_3_PIN);
    1588:	64 e0       	ldi	r22, 0x04	; 4
    158a:	83 e4       	ldi	r24, 0x43	; 67
    158c:	0e 94 17 04 	call	0x82e	; 0x82e <LED_off>
        break;
    1590:	08 95       	ret
      case LAMP_4:
        LED_off(LAMP_4_PORT, LAMP_4_PIN);
    1592:	65 e0       	ldi	r22, 0x05	; 5
    1594:	83 e4       	ldi	r24, 0x43	; 67
    1596:	0e 94 17 04 	call	0x82e	; 0x82e <LED_off>
        break;
    159a:	08 95       	ret
      case LAMP_5:
        LED_off(LAMP_5_PORT, LAMP_5_PIN);
    159c:	66 e0       	ldi	r22, 0x06	; 6
    159e:	83 e4       	ldi	r24, 0x43	; 67
    15a0:	0e 94 17 04 	call	0x82e	; 0x82e <LED_off>
        break;
    15a4:	08 95       	ret
      case LAMP_6:
        PWM_OCP_disconnect(LAMP_6_DIMMABLE_PWM_PIN);
    15a6:	83 e0       	ldi	r24, 0x03	; 3
    15a8:	0e 94 e5 08 	call	0x11ca	; 0x11ca <PWM_OCP_disconnect>
    15ac:	08 95       	ret

000015ae <Lamp_toggle>:
    }
  }

// Toggle a lamp
void Lamp_toggle(u8 lampNumber) {
  switch (lampNumber) {
    15ae:	83 30       	cpi	r24, 0x03	; 3
    15b0:	b1 f0       	breq	.+44     	; 0x15de <Lamp_toggle+0x30>
    15b2:	28 f4       	brcc	.+10     	; 0x15be <Lamp_toggle+0x10>
    15b4:	81 30       	cpi	r24, 0x01	; 1
    15b6:	49 f0       	breq	.+18     	; 0x15ca <Lamp_toggle+0x1c>
    15b8:	82 30       	cpi	r24, 0x02	; 2
    15ba:	61 f0       	breq	.+24     	; 0x15d4 <Lamp_toggle+0x26>
    15bc:	08 95       	ret
    15be:	85 30       	cpi	r24, 0x05	; 5
    15c0:	c1 f0       	breq	.+48     	; 0x15f2 <Lamp_toggle+0x44>
    15c2:	90 f0       	brcs	.+36     	; 0x15e8 <Lamp_toggle+0x3a>
    15c4:	86 30       	cpi	r24, 0x06	; 6
    15c6:	d1 f0       	breq	.+52     	; 0x15fc <Lamp_toggle+0x4e>
    15c8:	08 95       	ret
      case LAMP_1:
        LED_toggle(LAMP_1_PORT, LAMP_1_PIN);
    15ca:	62 e0       	ldi	r22, 0x02	; 2
    15cc:	83 e4       	ldi	r24, 0x43	; 67
    15ce:	0e 94 20 04 	call	0x840	; 0x840 <LED_toggle>
        break;
    15d2:	08 95       	ret
      case LAMP_2:
        LED_toggle(LAMP_2_PORT, LAMP_2_PIN);
    15d4:	63 e0       	ldi	r22, 0x03	; 3
    15d6:	83 e4       	ldi	r24, 0x43	; 67
    15d8:	0e 94 20 04 	call	0x840	; 0x840 <LED_toggle>
        break;
    15dc:	08 95       	ret
      case LAMP_3:
        LED_toggle(LAMP_3_PORT, LAMP_3_PIN);
    15de:	64 e0       	ldi	r22, 0x04	; 4
    15e0:	83 e4       	ldi	r24, 0x43	; 67
    15e2:	0e 94 20 04 	call	0x840	; 0x840 <LED_toggle>
        break;
    15e6:	08 95       	ret
      case LAMP_4:
        LED_toggle(LAMP_4_PORT, LAMP_4_PIN);
    15e8:	65 e0       	ldi	r22, 0x05	; 5
    15ea:	83 e4       	ldi	r24, 0x43	; 67
    15ec:	0e 94 20 04 	call	0x840	; 0x840 <LED_toggle>
        break;
    15f0:	08 95       	ret
      case LAMP_5:
        LED_toggle(LAMP_5_PORT, LAMP_5_PIN);
    15f2:	66 e0       	ldi	r22, 0x06	; 6
    15f4:	83 e4       	ldi	r24, 0x43	; 67
    15f6:	0e 94 20 04 	call	0x840	; 0x840 <LED_toggle>
        break;
    15fa:	08 95       	ret
      case LAMP_6:
        if (read_bit(TCCR2, COM21)) { // OC pin is connected and lamp6 is on
    15fc:	05 b4       	in	r0, 0x25	; 37
    15fe:	05 fe       	sbrs	r0, 5
    1600:	04 c0       	rjmp	.+8      	; 0x160a <Lamp_toggle+0x5c>
          Lamp_off(6);
    1602:	86 e0       	ldi	r24, 0x06	; 6
    1604:	0e 94 ac 0a 	call	0x1558	; 0x1558 <Lamp_off>
    1608:	08 95       	ret
          }
        else {
          Lamp_on(6);
    160a:	86 e0       	ldi	r24, 0x06	; 6
    160c:	0e 94 81 0a 	call	0x1502	; 0x1502 <Lamp_on>
    1610:	08 95       	ret

00001612 <Lamp_dimmable_set_brightness>:
        break;
    }
  }

// Adjust the brightness of the dimmable lamp
void Lamp_dimmable_set_brightness(double brightness) {
    1612:	ab 01       	movw	r20, r22
    1614:	bc 01       	movw	r22, r24
  PWM_set_DC(LAMP_6_DIMMABLE_PWM_PIN, brightness);
    1616:	83 e0       	ldi	r24, 0x03	; 3
    1618:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <PWM_set_DC>
    161c:	08 95       	ret

0000161e <Local_access_init>:

ST_User_t local_user;

// Initialize the local control system
void Local_access_init(void) {
  LCD_init();
    161e:	0e 94 8e 03 	call	0x71c	; 0x71c <LCD_init>
  Keypad_init();
    1622:	0e 94 08 02 	call	0x410	; 0x410 <Keypad_init>
  User_DB_init();
    1626:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <User_DB_init>
    162a:	08 95       	ret

0000162c <Get_running_devices>:
  }

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
    162c:	cf 93       	push	r28
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    162e:	c0 e0       	ldi	r28, 0x00	; 0
    1630:	0a c0       	rjmp	.+20     	; 0x1646 <Get_running_devices+0x1a>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
    1632:	4c 2f       	mov	r20, r28
    1634:	50 e0       	ldi	r21, 0x00	; 0
    1636:	45 52       	subi	r20, 0x25	; 37
    1638:	58 4f       	sbci	r21, 0xF8	; 248
    163a:	63 e4       	ldi	r22, 0x43	; 67
    163c:	82 e0       	ldi	r24, 0x02	; 2
    163e:	8c 0f       	add	r24, r28
    1640:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DIO_Read>

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    1644:	cf 5f       	subi	r28, 0xFF	; 255
    1646:	c5 30       	cpi	r28, 0x05	; 5
    1648:	a0 f3       	brcs	.-24     	; 0x1632 <Get_running_devices+0x6>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
    }
  // Check the dimmable lamp
  running_devices[5] = read_bit(TCCR2, COM21); // To see if the OC pins are connected
    164a:	85 b5       	in	r24, 0x25	; 37
    164c:	85 fb       	bst	r24, 5
    164e:	88 27       	eor	r24, r24
    1650:	80 f9       	bld	r24, 0
    1652:	80 93 e0 07 	sts	0x07E0, r24	; 0x8007e0 <running_devices+0x5>
  // Check the AC
  DIO_Read(7, PORT_D, &running_devices[6]);
    1656:	41 ee       	ldi	r20, 0xE1	; 225
    1658:	57 e0       	ldi	r21, 0x07	; 7
    165a:	64 e4       	ldi	r22, 0x44	; 68
    165c:	87 e0       	ldi	r24, 0x07	; 7
    165e:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DIO_Read>
  // The value in OCR2 determine the brightness of the led
  dimmer_brightness = OCR2;
    1662:	83 b5       	in	r24, 0x23	; 35
    1664:	90 e0       	ldi	r25, 0x00	; 0
    1666:	90 93 d9 07 	sts	0x07D9, r25	; 0x8007d9 <dimmer_brightness+0x1>
    166a:	80 93 d8 07 	sts	0x07D8, r24	; 0x8007d8 <dimmer_brightness>
  }
    166e:	cf 91       	pop	r28
    1670:	08 95       	ret

00001672 <Show_bottom_options_menu>:

// Shows the bottom line options on the LCD
void Show_bottom_options_menu(u8 menu) {
  switch (menu) {
    1672:	90 e0       	ldi	r25, 0x00	; 0
    1674:	fc 01       	movw	r30, r24
    1676:	31 97       	sbiw	r30, 0x01	; 1
    1678:	ea 30       	cpi	r30, 0x0A	; 10
    167a:	f1 05       	cpc	r31, r1
    167c:	08 f0       	brcs	.+2      	; 0x1680 <Show_bottom_options_menu+0xe>
    167e:	49 c0       	rjmp	.+146    	; 0x1712 <Show_bottom_options_menu+0xa0>
    1680:	ee 57       	subi	r30, 0x7E	; 126
    1682:	ff 4f       	sbci	r31, 0xFF	; 255
    1684:	0c 94 c3 17 	jmp	0x2f86	; 0x2f86 <__tablejump2__>
      case 1:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_1);
    1688:	40 e7       	ldi	r20, 0x70	; 112
    168a:	50 e0       	ldi	r21, 0x00	; 0
    168c:	61 e0       	ldi	r22, 0x01	; 1
    168e:	80 e0       	ldi	r24, 0x00	; 0
    1690:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
        break;
    1694:	08 95       	ret
      case 2:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_2);
    1696:	41 e8       	ldi	r20, 0x81	; 129
    1698:	50 e0       	ldi	r21, 0x00	; 0
    169a:	61 e0       	ldi	r22, 0x01	; 1
    169c:	80 e0       	ldi	r24, 0x00	; 0
    169e:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
        break;
    16a2:	08 95       	ret
      case 3:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_3);
    16a4:	42 e9       	ldi	r20, 0x92	; 146
    16a6:	50 e0       	ldi	r21, 0x00	; 0
    16a8:	61 e0       	ldi	r22, 0x01	; 1
    16aa:	80 e0       	ldi	r24, 0x00	; 0
    16ac:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
        break;
    16b0:	08 95       	ret
      case 4:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_4);
    16b2:	43 ea       	ldi	r20, 0xA3	; 163
    16b4:	50 e0       	ldi	r21, 0x00	; 0
    16b6:	61 e0       	ldi	r22, 0x01	; 1
    16b8:	80 e0       	ldi	r24, 0x00	; 0
    16ba:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
        break;
    16be:	08 95       	ret
      case 5:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_5);
    16c0:	44 eb       	ldi	r20, 0xB4	; 180
    16c2:	50 e0       	ldi	r21, 0x00	; 0
    16c4:	61 e0       	ldi	r22, 0x01	; 1
    16c6:	80 e0       	ldi	r24, 0x00	; 0
    16c8:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
        break;
    16cc:	08 95       	ret
      case 6:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_6);
    16ce:	45 ec       	ldi	r20, 0xC5	; 197
    16d0:	50 e0       	ldi	r21, 0x00	; 0
    16d2:	61 e0       	ldi	r22, 0x01	; 1
    16d4:	80 e0       	ldi	r24, 0x00	; 0
    16d6:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
        break;
    16da:	08 95       	ret
      case 7:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_7);
    16dc:	46 ed       	ldi	r20, 0xD6	; 214
    16de:	50 e0       	ldi	r21, 0x00	; 0
    16e0:	61 e0       	ldi	r22, 0x01	; 1
    16e2:	80 e0       	ldi	r24, 0x00	; 0
    16e4:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
        break;
    16e8:	08 95       	ret
      case 8:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_8);
    16ea:	47 ee       	ldi	r20, 0xE7	; 231
    16ec:	50 e0       	ldi	r21, 0x00	; 0
    16ee:	61 e0       	ldi	r22, 0x01	; 1
    16f0:	80 e0       	ldi	r24, 0x00	; 0
    16f2:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
        break;
    16f6:	08 95       	ret
      case 9:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_9);
    16f8:	48 ef       	ldi	r20, 0xF8	; 248
    16fa:	50 e0       	ldi	r21, 0x00	; 0
    16fc:	61 e0       	ldi	r22, 0x01	; 1
    16fe:	80 e0       	ldi	r24, 0x00	; 0
    1700:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
        break;
    1704:	08 95       	ret
      case 10:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_10);
    1706:	49 e0       	ldi	r20, 0x09	; 9
    1708:	51 e0       	ldi	r21, 0x01	; 1
    170a:	61 e0       	ldi	r22, 0x01	; 1
    170c:	80 e0       	ldi	r24, 0x00	; 0
    170e:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
    1712:	08 95       	ret

00001714 <Show_side_options_menu>:
    }
  }

// Shows the side options list on the LCD
void Show_side_options_menu(void) {
  LCD_write_string_xy(12, 0, BACKSPACE_OPTION);
    1714:	4a e1       	ldi	r20, 0x1A	; 26
    1716:	51 e0       	ldi	r21, 0x01	; 1
    1718:	60 e0       	ldi	r22, 0x00	; 0
    171a:	8c e0       	ldi	r24, 0x0C	; 12
    171c:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
  LCD_write_string_xy(12, 1, ENTER_OPTION);
    1720:	4f e1       	ldi	r20, 0x1F	; 31
    1722:	51 e0       	ldi	r21, 0x01	; 1
    1724:	61 e0       	ldi	r22, 0x01	; 1
    1726:	8c e0       	ldi	r24, 0x0C	; 12
    1728:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
    172c:	08 95       	ret

0000172e <Show_running_devices>:
  }

// Shows the currently running devices with the appropriate control menu appended (Screen controls and login- no device controls)
void Show_running_devices(u8 screen) {
    172e:	ef 92       	push	r14
    1730:	ff 92       	push	r15
    1732:	1f 93       	push	r17
    1734:	cf 93       	push	r28
    1736:	df 93       	push	r29
    1738:	00 d0       	rcall	.+0      	; 0x173a <Show_running_devices+0xc>
    173a:	00 d0       	rcall	.+0      	; 0x173c <Show_running_devices+0xe>
    173c:	cd b7       	in	r28, 0x3d	; 61
    173e:	de b7       	in	r29, 0x3e	; 62
    1740:	18 2f       	mov	r17, r24
  // Do nothing if the correct screen is shown.
  // if (screen == running_devices_screen) return;
  LCD_clear_screen();
    1742:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
  // Write device name
  switch (screen) {
    1746:	17 30       	cpi	r17, 0x07	; 7
    1748:	39 f4       	brne	.+14     	; 0x1758 <Show_running_devices+0x2a>
      case 7:
        LCD_write_string_xy(0, 0, "AC: ");
    174a:	44 e2       	ldi	r20, 0x24	; 36
    174c:	51 e0       	ldi	r21, 0x01	; 1
    174e:	60 e0       	ldi	r22, 0x00	; 0
    1750:	80 e0       	ldi	r24, 0x00	; 0
    1752:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
        break;
    1756:	0e c0       	rjmp	.+28     	; 0x1774 <Show_running_devices+0x46>
      default:
        LCD_write_string_xy(0, 0, "Lamp");
    1758:	49 e2       	ldi	r20, 0x29	; 41
    175a:	51 e0       	ldi	r21, 0x01	; 1
    175c:	60 e0       	ldi	r22, 0x00	; 0
    175e:	80 e0       	ldi	r24, 0x00	; 0
    1760:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
        LCD_sendData(screen + 48);
    1764:	80 e3       	ldi	r24, 0x30	; 48
    1766:	81 0f       	add	r24, r17
    1768:	0e 94 58 03 	call	0x6b0	; 0x6b0 <LCD_sendData>
        LCD_write_string(":  ");
    176c:	8e e2       	ldi	r24, 0x2E	; 46
    176e:	91 e0       	ldi	r25, 0x01	; 1
    1770:	0e 94 ce 03 	call	0x79c	; 0x79c <LCD_write_string>
        break;
    }
  if (screen == 6) {
    1774:	16 30       	cpi	r17, 0x06	; 6
    1776:	49 f5       	brne	.+82     	; 0x17ca <Show_running_devices+0x9c>
    s8 brightness[4];
    sprintf(brightness, "%d%%", (u8)((double)dimmer_brightness / 2.55));
    1778:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    177c:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1780:	07 2e       	mov	r0, r23
    1782:	00 0c       	add	r0, r0
    1784:	88 0b       	sbc	r24, r24
    1786:	99 0b       	sbc	r25, r25
    1788:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <__floatsisf>
    178c:	23 e3       	ldi	r18, 0x33	; 51
    178e:	33 e3       	ldi	r19, 0x33	; 51
    1790:	43 e2       	ldi	r20, 0x23	; 35
    1792:	50 e4       	ldi	r21, 0x40	; 64
    1794:	0e 94 20 16 	call	0x2c40	; 0x2c40 <__divsf3>
    1798:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__fixunssfsi>
    179c:	1f 92       	push	r1
    179e:	6f 93       	push	r22
    17a0:	82 e3       	ldi	r24, 0x32	; 50
    17a2:	91 e0       	ldi	r25, 0x01	; 1
    17a4:	9f 93       	push	r25
    17a6:	8f 93       	push	r24
    17a8:	ce 01       	movw	r24, r28
    17aa:	01 96       	adiw	r24, 0x01	; 1
    17ac:	7c 01       	movw	r14, r24
    17ae:	9f 93       	push	r25
    17b0:	8f 93       	push	r24
    17b2:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <sprintf>
    LCD_write_string(brightness);
    17b6:	c7 01       	movw	r24, r14
    17b8:	0e 94 ce 03 	call	0x79c	; 0x79c <LCD_write_string>
    17bc:	0f 90       	pop	r0
    17be:	0f 90       	pop	r0
    17c0:	0f 90       	pop	r0
    17c2:	0f 90       	pop	r0
    17c4:	0f 90       	pop	r0
    17c6:	0f 90       	pop	r0
    17c8:	10 c0       	rjmp	.+32     	; 0x17ea <Show_running_devices+0xbc>
    }
  else {// Write the device state
    if (running_devices[screen - 1])
    17ca:	e1 2f       	mov	r30, r17
    17cc:	f0 e0       	ldi	r31, 0x00	; 0
    17ce:	e6 52       	subi	r30, 0x26	; 38
    17d0:	f8 4f       	sbci	r31, 0xF8	; 248
    17d2:	80 81       	ld	r24, Z
    17d4:	88 23       	and	r24, r24
    17d6:	29 f0       	breq	.+10     	; 0x17e2 <Show_running_devices+0xb4>
      LCD_write_string("On");
    17d8:	87 e3       	ldi	r24, 0x37	; 55
    17da:	91 e0       	ldi	r25, 0x01	; 1
    17dc:	0e 94 ce 03 	call	0x79c	; 0x79c <LCD_write_string>
    17e0:	04 c0       	rjmp	.+8      	; 0x17ea <Show_running_devices+0xbc>
    else
      LCD_write_string("Off");
    17e2:	8a e3       	ldi	r24, 0x3A	; 58
    17e4:	91 e0       	ldi	r25, 0x01	; 1
    17e6:	0e 94 ce 03 	call	0x79c	; 0x79c <LCD_write_string>
    }
  // Show the options menu
  switch (screen) {
    17ea:	11 30       	cpi	r17, 0x01	; 1
    17ec:	19 f0       	breq	.+6      	; 0x17f4 <Show_running_devices+0xc6>
    17ee:	17 30       	cpi	r17, 0x07	; 7
    17f0:	29 f0       	breq	.+10     	; 0x17fc <Show_running_devices+0xce>
    17f2:	08 c0       	rjmp	.+16     	; 0x1804 <Show_running_devices+0xd6>
      case 1:
        Show_bottom_options_menu(3);
    17f4:	83 e0       	ldi	r24, 0x03	; 3
    17f6:	0e 94 39 0b 	call	0x1672	; 0x1672 <Show_bottom_options_menu>
        break;
    17fa:	07 c0       	rjmp	.+14     	; 0x180a <Show_running_devices+0xdc>
      case 7:
        Show_bottom_options_menu(2);
    17fc:	82 e0       	ldi	r24, 0x02	; 2
    17fe:	0e 94 39 0b 	call	0x1672	; 0x1672 <Show_bottom_options_menu>
        break;
    1802:	03 c0       	rjmp	.+6      	; 0x180a <Show_running_devices+0xdc>
      default:
        Show_bottom_options_menu(1);
    1804:	81 e0       	ldi	r24, 0x01	; 1
    1806:	0e 94 39 0b 	call	0x1672	; 0x1672 <Show_bottom_options_menu>
        break;
    }
  }
    180a:	0f 90       	pop	r0
    180c:	0f 90       	pop	r0
    180e:	0f 90       	pop	r0
    1810:	0f 90       	pop	r0
    1812:	df 91       	pop	r29
    1814:	cf 91       	pop	r28
    1816:	1f 91       	pop	r17
    1818:	ff 90       	pop	r15
    181a:	ef 90       	pop	r14
    181c:	08 95       	ret

0000181e <Show_devices_controls>:

// Shows the currently running devices with the appropriate control menu appended (Devices' controls)
void Show_devices_controls(u8 screen) {
    181e:	ef 92       	push	r14
    1820:	ff 92       	push	r15
    1822:	1f 93       	push	r17
    1824:	cf 93       	push	r28
    1826:	df 93       	push	r29
    1828:	00 d0       	rcall	.+0      	; 0x182a <Show_devices_controls+0xc>
    182a:	00 d0       	rcall	.+0      	; 0x182c <Show_devices_controls+0xe>
    182c:	cd b7       	in	r28, 0x3d	; 61
    182e:	de b7       	in	r29, 0x3e	; 62
    1830:	18 2f       	mov	r17, r24
  // Do nothing if the correct screen is shown.
  // if (screen == control_devices_screen) return;
  LCD_clear_screen();
    1832:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
  LCD_write_string_xy(0, 0, "Lamp");
    1836:	49 e2       	ldi	r20, 0x29	; 41
    1838:	51 e0       	ldi	r21, 0x01	; 1
    183a:	60 e0       	ldi	r22, 0x00	; 0
    183c:	80 e0       	ldi	r24, 0x00	; 0
    183e:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
  LCD_sendData(screen + 48);
    1842:	80 e3       	ldi	r24, 0x30	; 48
    1844:	81 0f       	add	r24, r17
    1846:	0e 94 58 03 	call	0x6b0	; 0x6b0 <LCD_sendData>
  LCD_write_string(":  ");
    184a:	8e e2       	ldi	r24, 0x2E	; 46
    184c:	91 e0       	ldi	r25, 0x01	; 1
    184e:	0e 94 ce 03 	call	0x79c	; 0x79c <LCD_write_string>

  if (screen < 6) {
    1852:	16 30       	cpi	r17, 0x06	; 6
    1854:	88 f4       	brcc	.+34     	; 0x1878 <Show_devices_controls+0x5a>
    // Write the device state
    if (running_devices[screen - 1])
    1856:	e1 2f       	mov	r30, r17
    1858:	f0 e0       	ldi	r31, 0x00	; 0
    185a:	e6 52       	subi	r30, 0x26	; 38
    185c:	f8 4f       	sbci	r31, 0xF8	; 248
    185e:	80 81       	ld	r24, Z
    1860:	88 23       	and	r24, r24
    1862:	29 f0       	breq	.+10     	; 0x186e <Show_devices_controls+0x50>
      LCD_write_string("On");
    1864:	87 e3       	ldi	r24, 0x37	; 55
    1866:	91 e0       	ldi	r25, 0x01	; 1
    1868:	0e 94 ce 03 	call	0x79c	; 0x79c <LCD_write_string>
    186c:	38 c0       	rjmp	.+112    	; 0x18de <Show_devices_controls+0xc0>
    else
      LCD_write_string("Off");
    186e:	8a e3       	ldi	r24, 0x3A	; 58
    1870:	91 e0       	ldi	r25, 0x01	; 1
    1872:	0e 94 ce 03 	call	0x79c	; 0x79c <LCD_write_string>
    1876:	33 c0       	rjmp	.+102    	; 0x18de <Show_devices_controls+0xc0>
    }
  else if (screen == 6) { // Dimmer
    1878:	16 30       	cpi	r17, 0x06	; 6
    187a:	49 f5       	brne	.+82     	; 0x18ce <Show_devices_controls+0xb0>
    s8 brightness[4];
    sprintf(brightness, "%d%%", (u8)((double)dimmer_brightness / 2.55));
    187c:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1880:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1884:	07 2e       	mov	r0, r23
    1886:	00 0c       	add	r0, r0
    1888:	88 0b       	sbc	r24, r24
    188a:	99 0b       	sbc	r25, r25
    188c:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <__floatsisf>
    1890:	23 e3       	ldi	r18, 0x33	; 51
    1892:	33 e3       	ldi	r19, 0x33	; 51
    1894:	43 e2       	ldi	r20, 0x23	; 35
    1896:	50 e4       	ldi	r21, 0x40	; 64
    1898:	0e 94 20 16 	call	0x2c40	; 0x2c40 <__divsf3>
    189c:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__fixunssfsi>
    18a0:	1f 92       	push	r1
    18a2:	6f 93       	push	r22
    18a4:	82 e3       	ldi	r24, 0x32	; 50
    18a6:	91 e0       	ldi	r25, 0x01	; 1
    18a8:	9f 93       	push	r25
    18aa:	8f 93       	push	r24
    18ac:	ce 01       	movw	r24, r28
    18ae:	01 96       	adiw	r24, 0x01	; 1
    18b0:	7c 01       	movw	r14, r24
    18b2:	9f 93       	push	r25
    18b4:	8f 93       	push	r24
    18b6:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <sprintf>
    LCD_write_string(brightness);
    18ba:	c7 01       	movw	r24, r14
    18bc:	0e 94 ce 03 	call	0x79c	; 0x79c <LCD_write_string>
    18c0:	0f 90       	pop	r0
    18c2:	0f 90       	pop	r0
    18c4:	0f 90       	pop	r0
    18c6:	0f 90       	pop	r0
    18c8:	0f 90       	pop	r0
    18ca:	0f 90       	pop	r0
    18cc:	08 c0       	rjmp	.+16     	; 0x18de <Show_devices_controls+0xc0>
    }
  else {  // Logout screen
    LCD_clear_screen();
    18ce:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
    LCD_write_string_xy(4, 0, "Log out?");
    18d2:	4e e3       	ldi	r20, 0x3E	; 62
    18d4:	51 e0       	ldi	r21, 0x01	; 1
    18d6:	60 e0       	ldi	r22, 0x00	; 0
    18d8:	84 e0       	ldi	r24, 0x04	; 4
    18da:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
    }
  // Show the options menu
  switch (screen) {
    18de:	16 30       	cpi	r17, 0x06	; 6
    18e0:	81 f0       	breq	.+32     	; 0x1902 <Show_devices_controls+0xe4>
    18e2:	17 30       	cpi	r17, 0x07	; 7
    18e4:	91 f0       	breq	.+36     	; 0x190a <Show_devices_controls+0xec>
    18e6:	11 30       	cpi	r17, 0x01	; 1
    18e8:	a1 f4       	brne	.+40     	; 0x1912 <Show_devices_controls+0xf4>
      case 1:
        if (running_devices[0])
    18ea:	80 91 db 07 	lds	r24, 0x07DB	; 0x8007db <running_devices>
    18ee:	88 23       	and	r24, r24
    18f0:	21 f0       	breq	.+8      	; 0x18fa <Show_devices_controls+0xdc>
          Show_bottom_options_menu(8);
    18f2:	88 e0       	ldi	r24, 0x08	; 8
    18f4:	0e 94 39 0b 	call	0x1672	; 0x1672 <Show_bottom_options_menu>
    18f8:	1a c0       	rjmp	.+52     	; 0x192e <Show_devices_controls+0x110>
        else
          Show_bottom_options_menu(7);
    18fa:	87 e0       	ldi	r24, 0x07	; 7
    18fc:	0e 94 39 0b 	call	0x1672	; 0x1672 <Show_bottom_options_menu>
    1900:	16 c0       	rjmp	.+44     	; 0x192e <Show_devices_controls+0x110>
        break;
      case 6:
        Show_bottom_options_menu(9);
    1902:	89 e0       	ldi	r24, 0x09	; 9
    1904:	0e 94 39 0b 	call	0x1672	; 0x1672 <Show_bottom_options_menu>
        break;
    1908:	12 c0       	rjmp	.+36     	; 0x192e <Show_devices_controls+0x110>
      case 7:
        Show_bottom_options_menu(10);
    190a:	8a e0       	ldi	r24, 0x0A	; 10
    190c:	0e 94 39 0b 	call	0x1672	; 0x1672 <Show_bottom_options_menu>
        break;
    1910:	0e c0       	rjmp	.+28     	; 0x192e <Show_devices_controls+0x110>
      default:
        if (running_devices[screen - 1])
    1912:	e1 2f       	mov	r30, r17
    1914:	f0 e0       	ldi	r31, 0x00	; 0
    1916:	e6 52       	subi	r30, 0x26	; 38
    1918:	f8 4f       	sbci	r31, 0xF8	; 248
    191a:	80 81       	ld	r24, Z
    191c:	88 23       	and	r24, r24
    191e:	21 f0       	breq	.+8      	; 0x1928 <Show_devices_controls+0x10a>
          Show_bottom_options_menu(6);
    1920:	86 e0       	ldi	r24, 0x06	; 6
    1922:	0e 94 39 0b 	call	0x1672	; 0x1672 <Show_bottom_options_menu>
    1926:	03 c0       	rjmp	.+6      	; 0x192e <Show_devices_controls+0x110>
        else
          Show_bottom_options_menu(5);
    1928:	85 e0       	ldi	r24, 0x05	; 5
    192a:	0e 94 39 0b 	call	0x1672	; 0x1672 <Show_bottom_options_menu>
        break;
    }
  }
    192e:	0f 90       	pop	r0
    1930:	0f 90       	pop	r0
    1932:	0f 90       	pop	r0
    1934:	0f 90       	pop	r0
    1936:	df 91       	pop	r29
    1938:	cf 91       	pop	r28
    193a:	1f 91       	pop	r17
    193c:	ff 90       	pop	r15
    193e:	ef 90       	pop	r14
    1940:	08 95       	ret

00001942 <invalid_local_login_attempt>:

// Handles setting the alarm and halting the system when the user enters invalid credentials during login
void invalid_local_login_attempt(void) {
  invalid_trails++;
    1942:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <invalid_trails>
    1946:	8f 5f       	subi	r24, 0xFF	; 255
    1948:	80 93 aa 07 	sts	0x07AA, r24	; 0x8007aa <invalid_trails>
  if (invalid_trails < 3) {
    194c:	83 30       	cpi	r24, 0x03	; 3
    194e:	00 f5       	brcc	.+64     	; 0x1990 <invalid_local_login_attempt+0x4e>
    LCD_clear_screen();
    1950:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
    LCD_move_cursor_xy(3, 0);
    1954:	60 e0       	ldi	r22, 0x00	; 0
    1956:	83 e0       	ldi	r24, 0x03	; 3
    1958:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_move_cursor_xy>
    LCD_sendData((3 - invalid_trails) + 48);
    195c:	90 91 aa 07 	lds	r25, 0x07AA	; 0x8007aa <invalid_trails>
    1960:	83 e3       	ldi	r24, 0x33	; 51
    1962:	89 1b       	sub	r24, r25
    1964:	0e 94 58 03 	call	0x6b0	; 0x6b0 <LCD_sendData>
    LCD_write_string(" attempts");
    1968:	87 e4       	ldi	r24, 0x47	; 71
    196a:	91 e0       	ldi	r25, 0x01	; 1
    196c:	0e 94 ce 03 	call	0x79c	; 0x79c <LCD_write_string>
    LCD_write_string_xy(3, 1, "remaining !");
    1970:	41 e5       	ldi	r20, 0x51	; 81
    1972:	51 e0       	ldi	r21, 0x01	; 1
    1974:	61 e0       	ldi	r22, 0x01	; 1
    1976:	83 e0       	ldi	r24, 0x03	; 3
    1978:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
    197c:	2f ef       	ldi	r18, 0xFF	; 255
    197e:	83 ed       	ldi	r24, 0xD3	; 211
    1980:	90 e3       	ldi	r25, 0x30	; 48
    1982:	21 50       	subi	r18, 0x01	; 1
    1984:	80 40       	sbci	r24, 0x00	; 0
    1986:	90 40       	sbci	r25, 0x00	; 0
    1988:	e1 f7       	brne	.-8      	; 0x1982 <invalid_local_login_attempt+0x40>
    198a:	00 c0       	rjmp	.+0      	; 0x198c <invalid_local_login_attempt+0x4a>
    198c:	00 00       	nop
    198e:	08 95       	ret
    _delay_ms(1000);
    return;
    }
  LCD_clear_screen();
    1990:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
  LCD_write_string_xy(4, 0, "Too many");
    1994:	4d e5       	ldi	r20, 0x5D	; 93
    1996:	51 e0       	ldi	r21, 0x01	; 1
    1998:	60 e0       	ldi	r22, 0x00	; 0
    199a:	84 e0       	ldi	r24, 0x04	; 4
    199c:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
  LCD_write_string_xy(0, 1, "wrong attempts!");
    19a0:	46 e6       	ldi	r20, 0x66	; 102
    19a2:	51 e0       	ldi	r21, 0x01	; 1
    19a4:	61 e0       	ldi	r22, 0x01	; 1
    19a6:	80 e0       	ldi	r24, 0x00	; 0
    19a8:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
    19ac:	2f ef       	ldi	r18, 0xFF	; 255
    19ae:	83 ed       	ldi	r24, 0xD3	; 211
    19b0:	90 e3       	ldi	r25, 0x30	; 48
    19b2:	21 50       	subi	r18, 0x01	; 1
    19b4:	80 40       	sbci	r24, 0x00	; 0
    19b6:	90 40       	sbci	r25, 0x00	; 0
    19b8:	e1 f7       	brne	.-8      	; 0x19b2 <invalid_local_login_attempt+0x70>
    19ba:	00 c0       	rjmp	.+0      	; 0x19bc <invalid_local_login_attempt+0x7a>
    19bc:	00 00       	nop
  _delay_ms(1000);
  LCD_clear_screen();
    19be:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
  LCD_write_string_xy(3, 0, "- System -");
    19c2:	46 e7       	ldi	r20, 0x76	; 118
    19c4:	51 e0       	ldi	r21, 0x01	; 1
    19c6:	60 e0       	ldi	r22, 0x00	; 0
    19c8:	83 e0       	ldi	r24, 0x03	; 3
    19ca:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
  LCD_write_string_xy(2, 1, "- Suspended -");
    19ce:	41 e8       	ldi	r20, 0x81	; 129
    19d0:	51 e0       	ldi	r21, 0x01	; 1
    19d2:	61 e0       	ldi	r22, 0x01	; 1
    19d4:	82 e0       	ldi	r24, 0x02	; 2
    19d6:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
  run_system = false;
    19da:	10 92 a9 07 	sts	0x07A9, r1	; 0x8007a9 <run_system>
    19de:	08 95       	ret

000019e0 <Local_control_input_handler>:
  }

// Used in the super loop for getting the user input and handling it.
void Local_control_input_handler(void) {
    19e0:	1f 93       	push	r17
    19e2:	cf 93       	push	r28
    19e4:	df 93       	push	r29
    19e6:	1f 92       	push	r1
    19e8:	cd b7       	in	r28, 0x3d	; 61
    19ea:	de b7       	in	r29, 0x3e	; 62
  u8 pressed_key;
  EN_KeypadStatusCode_t keypad_stat = Keypad_getPressedKey(&pressed_key);
    19ec:	ce 01       	movw	r24, r28
    19ee:	01 96       	adiw	r24, 0x01	; 1
    19f0:	0e 94 b6 02 	call	0x56c	; 0x56c <Keypad_getPressedKey>
    19f4:	18 2f       	mov	r17, r24
  switch (local_control_running_task) {
    19f6:	80 91 ab 07 	lds	r24, 0x07AB	; 0x8007ab <local_control_running_task>
    19fa:	81 30       	cpi	r24, 0x01	; 1
    19fc:	a9 f1       	breq	.+106    	; 0x1a68 <Local_control_input_handler+0x88>
    19fe:	20 f0       	brcs	.+8      	; 0x1a08 <Local_control_input_handler+0x28>
    1a00:	82 30       	cpi	r24, 0x02	; 2
    1a02:	09 f4       	brne	.+2      	; 0x1a06 <Local_control_input_handler+0x26>
    1a04:	48 c1       	rjmp	.+656    	; 0x1c96 <Local_control_input_handler+0x2b6>
    1a06:	30 c2       	rjmp	.+1120   	; 0x1e68 <Local_control_input_handler+0x488>
    // Show running devices
      case 0:
        Get_running_devices();
    1a08:	0e 94 16 0b 	call	0x162c	; 0x162c <Get_running_devices>
        if (running_devices_screen == 0) {  // First run
    1a0c:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    1a10:	81 11       	cpse	r24, r1
    1a12:	08 c0       	rjmp	.+16     	; 0x1a24 <Local_control_input_handler+0x44>
          Show_running_devices(1);
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	0e 94 97 0b 	call	0x172e	; 0x172e <Show_running_devices>
          running_devices_screen++;
    1a1a:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    1a1e:	8f 5f       	subi	r24, 0xFF	; 255
    1a20:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <running_devices_screen>
          }
        if (keypad_stat == NO_KEY_PRESSED) return;
    1a24:	12 30       	cpi	r17, 0x02	; 2
    1a26:	09 f4       	brne	.+2      	; 0x1a2a <Local_control_input_handler+0x4a>
    1a28:	1f c2       	rjmp	.+1086   	; 0x1e68 <Local_control_input_handler+0x488>
        switch (pressed_key) {
    1a2a:	89 81       	ldd	r24, Y+1	; 0x01
    1a2c:	82 33       	cpi	r24, 0x32	; 50
    1a2e:	61 f0       	breq	.+24     	; 0x1a48 <Local_control_input_handler+0x68>
    1a30:	83 33       	cpi	r24, 0x33	; 51
    1a32:	71 f0       	breq	.+28     	; 0x1a50 <Local_control_input_handler+0x70>
    1a34:	81 33       	cpi	r24, 0x31	; 49
    1a36:	99 f4       	brne	.+38     	; 0x1a5e <Local_control_input_handler+0x7e>
            case '1':
              if (running_devices_screen > 1) running_devices_screen--;
    1a38:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    1a3c:	82 30       	cpi	r24, 0x02	; 2
    1a3e:	78 f0       	brcs	.+30     	; 0x1a5e <Local_control_input_handler+0x7e>
    1a40:	81 50       	subi	r24, 0x01	; 1
    1a42:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <running_devices_screen>
    1a46:	0b c0       	rjmp	.+22     	; 0x1a5e <Local_control_input_handler+0x7e>
              break;
            case '2':
              local_control_running_task = 1;
    1a48:	81 e0       	ldi	r24, 0x01	; 1
    1a4a:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <local_control_running_task>
              break;
    1a4e:	07 c0       	rjmp	.+14     	; 0x1a5e <Local_control_input_handler+0x7e>
            case '3':
              if (running_devices_screen < 7) running_devices_screen++;
    1a50:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    1a54:	87 30       	cpi	r24, 0x07	; 7
    1a56:	18 f4       	brcc	.+6      	; 0x1a5e <Local_control_input_handler+0x7e>
    1a58:	8f 5f       	subi	r24, 0xFF	; 255
    1a5a:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <running_devices_screen>
              break;
          }
        Show_running_devices(running_devices_screen);
    1a5e:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    1a62:	0e 94 97 0b 	call	0x172e	; 0x172e <Show_running_devices>
        break;
    1a66:	00 c2       	rjmp	.+1024   	; 0x1e68 <Local_control_input_handler+0x488>
        // Logging in
      case 1:
        switch (login_stage) {
    1a68:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <login_stage>
    1a6c:	88 23       	and	r24, r24
    1a6e:	21 f0       	breq	.+8      	; 0x1a78 <Local_control_input_handler+0x98>
    1a70:	81 30       	cpi	r24, 0x01	; 1
    1a72:	09 f4       	brne	.+2      	; 0x1a76 <Local_control_input_handler+0x96>
    1a74:	73 c0       	rjmp	.+230    	; 0x1b5c <Local_control_input_handler+0x17c>
    1a76:	f8 c1       	rjmp	.+1008   	; 0x1e68 <Local_control_input_handler+0x488>
          // Entering the user code
            case 0:
              if (!login_stage_started) {
    1a78:	80 91 e2 07 	lds	r24, 0x07E2	; 0x8007e2 <login_stage_started>
    1a7c:	81 11       	cpse	r24, r1
    1a7e:	13 c0       	rjmp	.+38     	; 0x1aa6 <Local_control_input_handler+0xc6>
                LCD_clear_screen();
    1a80:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
                Show_side_options_menu();
    1a84:	0e 94 8a 0b 	call	0x1714	; 0x1714 <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "User Code:");
    1a88:	4f e8       	ldi	r20, 0x8F	; 143
    1a8a:	51 e0       	ldi	r21, 0x01	; 1
    1a8c:	60 e0       	ldi	r22, 0x00	; 0
    1a8e:	80 e0       	ldi	r24, 0x00	; 0
    1a90:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    1a94:	61 e0       	ldi	r22, 0x01	; 1
    1a96:	80 e0       	ldi	r24, 0x00	; 0
    1a98:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_move_cursor_xy>
                login_stage_started = true;
    1a9c:	81 e0       	ldi	r24, 0x01	; 1
    1a9e:	80 93 e2 07 	sts	0x07E2, r24	; 0x8007e2 <login_stage_started>
                input_buffer_pointer = 0;
    1aa2:	10 92 ac 07 	sts	0x07AC, r1	; 0x8007ac <input_buffer_pointer>
                }
              if (keypad_stat == NO_KEY_PRESSED) return;
    1aa6:	12 30       	cpi	r17, 0x02	; 2
    1aa8:	09 f4       	brne	.+2      	; 0x1aac <Local_control_input_handler+0xcc>
    1aaa:	de c1       	rjmp	.+956    	; 0x1e68 <Local_control_input_handler+0x488>
              if (pressed_key == '-') { // Delete last input number
    1aac:	89 81       	ldd	r24, Y+1	; 0x01
    1aae:	8d 32       	cpi	r24, 0x2D	; 45
    1ab0:	a1 f4       	brne	.+40     	; 0x1ada <Local_control_input_handler+0xfa>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    1ab2:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1ab6:	88 23       	and	r24, r24
    1ab8:	19 f0       	breq	.+6      	; 0x1ac0 <Local_control_input_handler+0xe0>
    1aba:	81 50       	subi	r24, 0x01	; 1
    1abc:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    1ac0:	40 e3       	ldi	r20, 0x30	; 48
    1ac2:	51 e0       	ldi	r21, 0x01	; 1
    1ac4:	61 e0       	ldi	r22, 0x01	; 1
    1ac6:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1aca:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    1ace:	61 e0       	ldi	r22, 0x01	; 1
    1ad0:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1ad4:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_move_cursor_xy>
    1ad8:	c7 c1       	rjmp	.+910    	; 0x1e68 <Local_control_input_handler+0x488>
                }
              else if (pressed_key == '=') {
    1ada:	8d 33       	cpi	r24, 0x3D	; 61
    1adc:	39 f5       	brne	.+78     	; 0x1b2c <Local_control_input_handler+0x14c>
                input_buffer[input_buffer_pointer] = 0;
    1ade:	e0 91 ac 07 	lds	r30, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1ae2:	f0 e0       	ldi	r31, 0x00	; 0
    1ae4:	e3 53       	subi	r30, 0x33	; 51
    1ae6:	f8 4f       	sbci	r31, 0xF8	; 248
    1ae8:	10 82       	st	Z, r1
                // Validate user code
                EN_UserStatusCode_t codeExists = getUserByCode(input_buffer, &local_user);
    1aea:	6d ea       	ldi	r22, 0xAD	; 173
    1aec:	77 e0       	ldi	r23, 0x07	; 7
    1aee:	8d ec       	ldi	r24, 0xCD	; 205
    1af0:	97 e0       	ldi	r25, 0x07	; 7
    1af2:	0e 94 08 14 	call	0x2810	; 0x2810 <getUserByCode>
                if (codeExists == USER_FOUND) {
    1af6:	82 30       	cpi	r24, 0x02	; 2
    1af8:	31 f4       	brne	.+12     	; 0x1b06 <Local_control_input_handler+0x126>
                  login_stage_started = false;
    1afa:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
                  login_stage = 1;
    1afe:	81 e0       	ldi	r24, 0x01	; 1
    1b00:	80 93 e3 07 	sts	0x07E3, r24	; 0x8007e3 <login_stage>
    1b04:	b1 c1       	rjmp	.+866    	; 0x1e68 <Local_control_input_handler+0x488>
                  }
                else {
                  LCD_clear_screen();
    1b06:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    1b0a:	4a e9       	ldi	r20, 0x9A	; 154
    1b0c:	51 e0       	ldi	r21, 0x01	; 1
    1b0e:	60 e0       	ldi	r22, 0x00	; 0
    1b10:	85 e0       	ldi	r24, 0x05	; 5
    1b12:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
                  LCD_write_string_xy(2, 1, "User Code !");
    1b16:	40 ea       	ldi	r20, 0xA0	; 160
    1b18:	51 e0       	ldi	r21, 0x01	; 1
    1b1a:	61 e0       	ldi	r22, 0x01	; 1
    1b1c:	82 e0       	ldi	r24, 0x02	; 2
    1b1e:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
                  invalid_local_login_attempt();
    1b22:	0e 94 a1 0c 	call	0x1942	; 0x1942 <invalid_local_login_attempt>
                  login_stage_started = false;
    1b26:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
    1b2a:	9e c1       	rjmp	.+828    	; 0x1e68 <Local_control_input_handler+0x488>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    1b2c:	90 ed       	ldi	r25, 0xD0	; 208
    1b2e:	98 0f       	add	r25, r24
    1b30:	9a 30       	cpi	r25, 0x0A	; 10
    1b32:	08 f0       	brcs	.+2      	; 0x1b36 <Local_control_input_handler+0x156>
    1b34:	99 c1       	rjmp	.+818    	; 0x1e68 <Local_control_input_handler+0x488>
                if (input_buffer_pointer < 6) {
    1b36:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1b3a:	96 30       	cpi	r25, 0x06	; 6
    1b3c:	08 f0       	brcs	.+2      	; 0x1b40 <Local_control_input_handler+0x160>
    1b3e:	94 c1       	rjmp	.+808    	; 0x1e68 <Local_control_input_handler+0x488>
                  // Echo the input on the LCD
                  LCD_sendData(pressed_key);
    1b40:	0e 94 58 03 	call	0x6b0	; 0x6b0 <LCD_sendData>
                  input_buffer[input_buffer_pointer] = pressed_key;
    1b44:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1b48:	e8 2f       	mov	r30, r24
    1b4a:	f0 e0       	ldi	r31, 0x00	; 0
    1b4c:	e3 53       	subi	r30, 0x33	; 51
    1b4e:	f8 4f       	sbci	r31, 0xF8	; 248
    1b50:	99 81       	ldd	r25, Y+1	; 0x01
    1b52:	90 83       	st	Z, r25
                  input_buffer_pointer++;
    1b54:	8f 5f       	subi	r24, 0xFF	; 255
    1b56:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
    1b5a:	86 c1       	rjmp	.+780    	; 0x1e68 <Local_control_input_handler+0x488>
                  }
                }
              break;
              //  Entering the password
            case 1:
              if (!login_stage_started) {
    1b5c:	80 91 e2 07 	lds	r24, 0x07E2	; 0x8007e2 <login_stage_started>
    1b60:	81 11       	cpse	r24, r1
    1b62:	13 c0       	rjmp	.+38     	; 0x1b8a <Local_control_input_handler+0x1aa>
                LCD_clear_screen();
    1b64:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
                Show_side_options_menu();
    1b68:	0e 94 8a 0b 	call	0x1714	; 0x1714 <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "Password:");
    1b6c:	4c ea       	ldi	r20, 0xAC	; 172
    1b6e:	51 e0       	ldi	r21, 0x01	; 1
    1b70:	60 e0       	ldi	r22, 0x00	; 0
    1b72:	80 e0       	ldi	r24, 0x00	; 0
    1b74:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    1b78:	61 e0       	ldi	r22, 0x01	; 1
    1b7a:	80 e0       	ldi	r24, 0x00	; 0
    1b7c:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_move_cursor_xy>
                login_stage_started = true;
    1b80:	81 e0       	ldi	r24, 0x01	; 1
    1b82:	80 93 e2 07 	sts	0x07E2, r24	; 0x8007e2 <login_stage_started>
                input_buffer_pointer = 0;
    1b86:	10 92 ac 07 	sts	0x07AC, r1	; 0x8007ac <input_buffer_pointer>
                }
              if (pressed_key == '-') { // Delete last input number
    1b8a:	89 81       	ldd	r24, Y+1	; 0x01
    1b8c:	8d 32       	cpi	r24, 0x2D	; 45
    1b8e:	a1 f4       	brne	.+40     	; 0x1bb8 <Local_control_input_handler+0x1d8>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    1b90:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1b94:	88 23       	and	r24, r24
    1b96:	19 f0       	breq	.+6      	; 0x1b9e <Local_control_input_handler+0x1be>
    1b98:	81 50       	subi	r24, 0x01	; 1
    1b9a:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    1b9e:	40 e3       	ldi	r20, 0x30	; 48
    1ba0:	51 e0       	ldi	r21, 0x01	; 1
    1ba2:	61 e0       	ldi	r22, 0x01	; 1
    1ba4:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1ba8:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    1bac:	61 e0       	ldi	r22, 0x01	; 1
    1bae:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1bb2:	0e 94 ed 03 	call	0x7da	; 0x7da <LCD_move_cursor_xy>
    1bb6:	58 c1       	rjmp	.+688    	; 0x1e68 <Local_control_input_handler+0x488>
                }
              else if (pressed_key == '=') {
    1bb8:	8d 33       	cpi	r24, 0x3D	; 61
    1bba:	09 f0       	breq	.+2      	; 0x1bbe <Local_control_input_handler+0x1de>
    1bbc:	54 c0       	rjmp	.+168    	; 0x1c66 <Local_control_input_handler+0x286>
                input_buffer[input_buffer_pointer] = 0;
    1bbe:	e0 91 ac 07 	lds	r30, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1bc2:	f0 e0       	ldi	r31, 0x00	; 0
    1bc4:	e3 53       	subi	r30, 0x33	; 51
    1bc6:	f8 4f       	sbci	r31, 0xF8	; 248
    1bc8:	10 82       	st	Z, r1
                // Validate user password
                if (strcmp(input_buffer, local_user.password) == 0) { // Password is correct
    1bca:	62 ec       	ldi	r22, 0xC2	; 194
    1bcc:	77 e0       	ldi	r23, 0x07	; 7
    1bce:	8d ec       	ldi	r24, 0xCD	; 205
    1bd0:	97 e0       	ldi	r25, 0x07	; 7
    1bd2:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <strcmp>
    1bd6:	89 2b       	or	r24, r25
    1bd8:	99 f5       	brne	.+102    	; 0x1c40 <Local_control_input_handler+0x260>
                  login_stage_started = false;
    1bda:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
                  login_stage = 0;
    1bde:	10 92 e3 07 	sts	0x07E3, r1	; 0x8007e3 <login_stage>
                  local_control_running_task = 2;
    1be2:	82 e0       	ldi	r24, 0x02	; 2
    1be4:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <local_control_running_task>
                  local_user_loggedin = true;
    1be8:	81 e0       	ldi	r24, 0x01	; 1
    1bea:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <__data_end>
                  LCD_clear_screen();
    1bee:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
                  LCD_write_string_xy(4, 0, "Welcome");
    1bf2:	46 eb       	ldi	r20, 0xB6	; 182
    1bf4:	51 e0       	ldi	r21, 0x01	; 1
    1bf6:	60 e0       	ldi	r22, 0x00	; 0
    1bf8:	84 e0       	ldi	r24, 0x04	; 4
    1bfa:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
                  LCD_write_string_xy((16 - strlen(local_user.name)) / 2 - 1, 1, local_user.name);
    1bfe:	ee ea       	ldi	r30, 0xAE	; 174
    1c00:	f7 e0       	ldi	r31, 0x07	; 7
    1c02:	01 90       	ld	r0, Z+
    1c04:	00 20       	and	r0, r0
    1c06:	e9 f7       	brne	.-6      	; 0x1c02 <Local_control_input_handler+0x222>
    1c08:	9f 01       	movw	r18, r30
    1c0a:	2f 5a       	subi	r18, 0xAF	; 175
    1c0c:	37 40       	sbci	r19, 0x07	; 7
    1c0e:	80 e1       	ldi	r24, 0x10	; 16
    1c10:	90 e0       	ldi	r25, 0x00	; 0
    1c12:	82 1b       	sub	r24, r18
    1c14:	93 0b       	sbc	r25, r19
    1c16:	96 95       	lsr	r25
    1c18:	87 95       	ror	r24
    1c1a:	4e ea       	ldi	r20, 0xAE	; 174
    1c1c:	57 e0       	ldi	r21, 0x07	; 7
    1c1e:	61 e0       	ldi	r22, 0x01	; 1
    1c20:	81 50       	subi	r24, 0x01	; 1
    1c22:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
                  LCD_sendData('!');
    1c26:	81 e2       	ldi	r24, 0x21	; 33
    1c28:	0e 94 58 03 	call	0x6b0	; 0x6b0 <LCD_sendData>
    1c2c:	2f ef       	ldi	r18, 0xFF	; 255
    1c2e:	83 ed       	ldi	r24, 0xD3	; 211
    1c30:	90 e3       	ldi	r25, 0x30	; 48
    1c32:	21 50       	subi	r18, 0x01	; 1
    1c34:	80 40       	sbci	r24, 0x00	; 0
    1c36:	90 40       	sbci	r25, 0x00	; 0
    1c38:	e1 f7       	brne	.-8      	; 0x1c32 <Local_control_input_handler+0x252>
    1c3a:	00 c0       	rjmp	.+0      	; 0x1c3c <Local_control_input_handler+0x25c>
    1c3c:	00 00       	nop
    1c3e:	14 c1       	rjmp	.+552    	; 0x1e68 <Local_control_input_handler+0x488>
                  _delay_ms(1000);
                  }
                else {
                  LCD_clear_screen();
    1c40:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    1c44:	4a e9       	ldi	r20, 0x9A	; 154
    1c46:	51 e0       	ldi	r21, 0x01	; 1
    1c48:	60 e0       	ldi	r22, 0x00	; 0
    1c4a:	85 e0       	ldi	r24, 0x05	; 5
    1c4c:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
                  LCD_write_string_xy(3, 1, "Password !");
    1c50:	4e eb       	ldi	r20, 0xBE	; 190
    1c52:	51 e0       	ldi	r21, 0x01	; 1
    1c54:	61 e0       	ldi	r22, 0x01	; 1
    1c56:	83 e0       	ldi	r24, 0x03	; 3
    1c58:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
                  login_stage_started = false;
    1c5c:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
                  invalid_local_login_attempt();
    1c60:	0e 94 a1 0c 	call	0x1942	; 0x1942 <invalid_local_login_attempt>
    1c64:	01 c1       	rjmp	.+514    	; 0x1e68 <Local_control_input_handler+0x488>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    1c66:	90 ed       	ldi	r25, 0xD0	; 208
    1c68:	98 0f       	add	r25, r24
    1c6a:	9a 30       	cpi	r25, 0x0A	; 10
    1c6c:	08 f0       	brcs	.+2      	; 0x1c70 <Local_control_input_handler+0x290>
    1c6e:	fc c0       	rjmp	.+504    	; 0x1e68 <Local_control_input_handler+0x488>
                // Limit the input length
                if (input_buffer_pointer < 10) {
    1c70:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1c74:	9a 30       	cpi	r25, 0x0A	; 10
    1c76:	08 f0       	brcs	.+2      	; 0x1c7a <Local_control_input_handler+0x29a>
    1c78:	f7 c0       	rjmp	.+494    	; 0x1e68 <Local_control_input_handler+0x488>
                  // Echo the input on the LCD
                  LCD_sendData(pressed_key);
    1c7a:	0e 94 58 03 	call	0x6b0	; 0x6b0 <LCD_sendData>
                  input_buffer[input_buffer_pointer] = pressed_key;
    1c7e:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1c82:	e8 2f       	mov	r30, r24
    1c84:	f0 e0       	ldi	r31, 0x00	; 0
    1c86:	e3 53       	subi	r30, 0x33	; 51
    1c88:	f8 4f       	sbci	r31, 0xF8	; 248
    1c8a:	99 81       	ldd	r25, Y+1	; 0x01
    1c8c:	90 83       	st	Z, r25
                  input_buffer_pointer++;
    1c8e:	8f 5f       	subi	r24, 0xFF	; 255
    1c90:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
    1c94:	e9 c0       	rjmp	.+466    	; 0x1e68 <Local_control_input_handler+0x488>
              break;
          }
        break;
        // Devices control
      case 2:
        if (remote_user_loggedin && !local_control_permission_granted) {
    1c96:	80 91 a8 07 	lds	r24, 0x07A8	; 0x8007a8 <remote_user_loggedin>
    1c9a:	88 23       	and	r24, r24
    1c9c:	99 f0       	breq	.+38     	; 0x1cc4 <Local_control_input_handler+0x2e4>
    1c9e:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <local_control_permission_granted>
    1ca2:	81 11       	cpse	r24, r1
    1ca4:	0f c0       	rjmp	.+30     	; 0x1cc4 <Local_control_input_handler+0x2e4>
          LCD_clear_screen();
    1ca6:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
          LCD_write_string_xy(0, 0, "Admin Permission");
    1caa:	49 ec       	ldi	r20, 0xC9	; 201
    1cac:	51 e0       	ldi	r21, 0x01	; 1
    1cae:	60 e0       	ldi	r22, 0x00	; 0
    1cb0:	80 e0       	ldi	r24, 0x00	; 0
    1cb2:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
          LCD_write_string_xy(3, 1, "Required !");
    1cb6:	4a ed       	ldi	r20, 0xDA	; 218
    1cb8:	51 e0       	ldi	r21, 0x01	; 1
    1cba:	61 e0       	ldi	r22, 0x01	; 1
    1cbc:	83 e0       	ldi	r24, 0x03	; 3
    1cbe:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
    1cc2:	d2 c0       	rjmp	.+420    	; 0x1e68 <Local_control_input_handler+0x488>
          //~ Controls can be added to allow the user to go back and view the running devices if needed.
          }
        else {
          Get_running_devices();
    1cc4:	0e 94 16 0b 	call	0x162c	; 0x162c <Get_running_devices>
          if (control_devices_screen == 0) {  // First run
    1cc8:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1ccc:	81 11       	cpse	r24, r1
    1cce:	08 c0       	rjmp	.+16     	; 0x1ce0 <Local_control_input_handler+0x300>
            Show_devices_controls(1);
    1cd0:	81 e0       	ldi	r24, 0x01	; 1
    1cd2:	0e 94 0f 0c 	call	0x181e	; 0x181e <Show_devices_controls>
            control_devices_screen++;
    1cd6:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1cda:	8f 5f       	subi	r24, 0xFF	; 255
    1cdc:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
            }
          if (keypad_stat == NO_KEY_PRESSED) return;
    1ce0:	12 30       	cpi	r17, 0x02	; 2
    1ce2:	09 f4       	brne	.+2      	; 0x1ce6 <Local_control_input_handler+0x306>
    1ce4:	c1 c0       	rjmp	.+386    	; 0x1e68 <Local_control_input_handler+0x488>
          switch (pressed_key) {
    1ce6:	89 81       	ldd	r24, Y+1	; 0x01
    1ce8:	82 33       	cpi	r24, 0x32	; 50
    1cea:	a1 f0       	breq	.+40     	; 0x1d14 <Local_control_input_handler+0x334>
    1cec:	18 f4       	brcc	.+6      	; 0x1cf4 <Local_control_input_handler+0x314>
    1cee:	81 33       	cpi	r24, 0x31	; 49
    1cf0:	41 f0       	breq	.+16     	; 0x1d02 <Local_control_input_handler+0x322>
    1cf2:	b6 c0       	rjmp	.+364    	; 0x1e60 <Local_control_input_handler+0x480>
    1cf4:	83 33       	cpi	r24, 0x33	; 51
    1cf6:	09 f4       	brne	.+2      	; 0x1cfa <Local_control_input_handler+0x31a>
    1cf8:	73 c0       	rjmp	.+230    	; 0x1de0 <Local_control_input_handler+0x400>
    1cfa:	84 33       	cpi	r24, 0x34	; 52
    1cfc:	09 f4       	brne	.+2      	; 0x1d00 <Local_control_input_handler+0x320>
    1cfe:	a9 c0       	rjmp	.+338    	; 0x1e52 <Local_control_input_handler+0x472>
    1d00:	af c0       	rjmp	.+350    	; 0x1e60 <Local_control_input_handler+0x480>
              case '1':
                if (control_devices_screen > 1) control_devices_screen--;
    1d02:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1d06:	82 30       	cpi	r24, 0x02	; 2
    1d08:	08 f4       	brcc	.+2      	; 0x1d0c <Local_control_input_handler+0x32c>
    1d0a:	aa c0       	rjmp	.+340    	; 0x1e60 <Local_control_input_handler+0x480>
    1d0c:	81 50       	subi	r24, 0x01	; 1
    1d0e:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
    1d12:	a6 c0       	rjmp	.+332    	; 0x1e60 <Local_control_input_handler+0x480>
                break;
              case '2':
                switch (control_devices_screen) {
    1d14:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1d18:	86 30       	cpi	r24, 0x06	; 6
    1d1a:	19 f0       	breq	.+6      	; 0x1d22 <Local_control_input_handler+0x342>
    1d1c:	87 30       	cpi	r24, 0x07	; 7
    1d1e:	a1 f1       	breq	.+104    	; 0x1d88 <Local_control_input_handler+0x3a8>
    1d20:	53 c0       	rjmp	.+166    	; 0x1dc8 <Local_control_input_handler+0x3e8>
                    case 6:
                      // Increment the brightness
                      // Floor the brightness
                      dimmer_brightness += ((double)LAMP_6_BRIGHTNESS_PERCENTAGE_STEP * 2.55);
    1d22:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1d26:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1d2a:	07 2e       	mov	r0, r23
    1d2c:	00 0c       	add	r0, r0
    1d2e:	88 0b       	sbc	r24, r24
    1d30:	99 0b       	sbc	r25, r25
    1d32:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <__floatsisf>
    1d36:	20 e0       	ldi	r18, 0x00	; 0
    1d38:	30 e0       	ldi	r19, 0x00	; 0
    1d3a:	4c e4       	ldi	r20, 0x4C	; 76
    1d3c:	52 e4       	ldi	r21, 0x42	; 66
    1d3e:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <__addsf3>
    1d42:	0e 94 92 16 	call	0x2d24	; 0x2d24 <__fixsfsi>
    1d46:	70 93 d9 07 	sts	0x07D9, r23	; 0x8007d9 <dimmer_brightness+0x1>
    1d4a:	60 93 d8 07 	sts	0x07D8, r22	; 0x8007d8 <dimmer_brightness>
                      if (dimmer_brightness > 255) dimmer_brightness = 255;
    1d4e:	6f 3f       	cpi	r22, 0xFF	; 255
    1d50:	71 05       	cpc	r23, r1
    1d52:	39 f0       	breq	.+14     	; 0x1d62 <Local_control_input_handler+0x382>
    1d54:	34 f0       	brlt	.+12     	; 0x1d62 <Local_control_input_handler+0x382>
    1d56:	8f ef       	ldi	r24, 0xFF	; 255
    1d58:	90 e0       	ldi	r25, 0x00	; 0
    1d5a:	90 93 d9 07 	sts	0x07D9, r25	; 0x8007d9 <dimmer_brightness+0x1>
    1d5e:	80 93 d8 07 	sts	0x07D8, r24	; 0x8007d8 <dimmer_brightness>
                      Lamp_dimmable_set_brightness(((double)dimmer_brightness / 255.0));
    1d62:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1d66:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1d6a:	07 2e       	mov	r0, r23
    1d6c:	00 0c       	add	r0, r0
    1d6e:	88 0b       	sbc	r24, r24
    1d70:	99 0b       	sbc	r25, r25
    1d72:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <__floatsisf>
    1d76:	20 e0       	ldi	r18, 0x00	; 0
    1d78:	30 e0       	ldi	r19, 0x00	; 0
    1d7a:	4f e7       	ldi	r20, 0x7F	; 127
    1d7c:	53 e4       	ldi	r21, 0x43	; 67
    1d7e:	0e 94 20 16 	call	0x2c40	; 0x2c40 <__divsf3>
    1d82:	0e 94 09 0b 	call	0x1612	; 0x1612 <Lamp_dimmable_set_brightness>
                      break;
    1d86:	6c c0       	rjmp	.+216    	; 0x1e60 <Local_control_input_handler+0x480>
                    case 7:
                      // Logout
                      local_user_loggedin = false;
    1d88:	10 92 a6 07 	sts	0x07A6, r1	; 0x8007a6 <__data_end>
                      control_devices_screen = 0;
    1d8c:	10 92 da 07 	sts	0x07DA, r1	; 0x8007da <control_devices_screen>
                      running_devices_screen = 0;
    1d90:	10 92 e4 07 	sts	0x07E4, r1	; 0x8007e4 <running_devices_screen>
                      local_control_running_task = 0;
    1d94:	10 92 ab 07 	sts	0x07AB, r1	; 0x8007ab <local_control_running_task>
                      LCD_clear_screen();
    1d98:	0e 94 8a 03 	call	0x714	; 0x714 <LCD_clear_screen>
                      LCD_write_string_xy(1, 0, "logging out...");
    1d9c:	45 ee       	ldi	r20, 0xE5	; 229
    1d9e:	51 e0       	ldi	r21, 0x01	; 1
    1da0:	60 e0       	ldi	r22, 0x00	; 0
    1da2:	81 e0       	ldi	r24, 0x01	; 1
    1da4:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
                      LCD_write_string_xy(4, 1, "Good Bye!");
    1da8:	44 ef       	ldi	r20, 0xF4	; 244
    1daa:	51 e0       	ldi	r21, 0x01	; 1
    1dac:	61 e0       	ldi	r22, 0x01	; 1
    1dae:	84 e0       	ldi	r24, 0x04	; 4
    1db0:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <LCD_write_string_xy>
    1db4:	2f ef       	ldi	r18, 0xFF	; 255
    1db6:	83 ed       	ldi	r24, 0xD3	; 211
    1db8:	90 e3       	ldi	r25, 0x30	; 48
    1dba:	21 50       	subi	r18, 0x01	; 1
    1dbc:	80 40       	sbci	r24, 0x00	; 0
    1dbe:	90 40       	sbci	r25, 0x00	; 0
    1dc0:	e1 f7       	brne	.-8      	; 0x1dba <Local_control_input_handler+0x3da>
    1dc2:	00 c0       	rjmp	.+0      	; 0x1dc4 <Local_control_input_handler+0x3e4>
    1dc4:	00 00       	nop
    1dc6:	4c c0       	rjmp	.+152    	; 0x1e60 <Local_control_input_handler+0x480>
                      _delay_ms(1000);
                      break;
                    default:
                      Lamp_toggle(control_devices_screen);
    1dc8:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Lamp_toggle>
                      running_devices[control_devices_screen - 1] = !running_devices[control_devices_screen - 1];
    1dcc:	e0 91 da 07 	lds	r30, 0x07DA	; 0x8007da <control_devices_screen>
    1dd0:	f0 e0       	ldi	r31, 0x00	; 0
    1dd2:	e6 52       	subi	r30, 0x26	; 38
    1dd4:	f8 4f       	sbci	r31, 0xF8	; 248
    1dd6:	90 81       	ld	r25, Z
    1dd8:	81 e0       	ldi	r24, 0x01	; 1
    1dda:	89 27       	eor	r24, r25
    1ddc:	80 83       	st	Z, r24
                      break;
    1dde:	40 c0       	rjmp	.+128    	; 0x1e60 <Local_control_input_handler+0x480>
                  }
                break;
              case '3':
                switch (control_devices_screen) {
    1de0:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1de4:	86 30       	cpi	r24, 0x06	; 6
    1de6:	79 f5       	brne	.+94     	; 0x1e46 <Local_control_input_handler+0x466>
                    case 6:
                      // Decrement the brightness
                      // Ceil the brightness
                      dimmer_brightness -= ((double)LAMP_6_BRIGHTNESS_PERCENTAGE_STEP * 2.55);
    1de8:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1dec:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1df0:	07 2e       	mov	r0, r23
    1df2:	00 0c       	add	r0, r0
    1df4:	88 0b       	sbc	r24, r24
    1df6:	99 0b       	sbc	r25, r25
    1df8:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <__floatsisf>
    1dfc:	20 e0       	ldi	r18, 0x00	; 0
    1dfe:	30 e0       	ldi	r19, 0x00	; 0
    1e00:	4c e4       	ldi	r20, 0x4C	; 76
    1e02:	52 e4       	ldi	r21, 0x42	; 66
    1e04:	0e 94 b3 15 	call	0x2b66	; 0x2b66 <__subsf3>
    1e08:	0e 94 92 16 	call	0x2d24	; 0x2d24 <__fixsfsi>
    1e0c:	70 93 d9 07 	sts	0x07D9, r23	; 0x8007d9 <dimmer_brightness+0x1>
    1e10:	60 93 d8 07 	sts	0x07D8, r22	; 0x8007d8 <dimmer_brightness>
                      if (dimmer_brightness < 0) dimmer_brightness = 0;
    1e14:	77 23       	and	r23, r23
    1e16:	24 f4       	brge	.+8      	; 0x1e20 <Local_control_input_handler+0x440>
    1e18:	10 92 d9 07 	sts	0x07D9, r1	; 0x8007d9 <dimmer_brightness+0x1>
    1e1c:	10 92 d8 07 	sts	0x07D8, r1	; 0x8007d8 <dimmer_brightness>
                      Lamp_dimmable_set_brightness(((double)dimmer_brightness / 255.0));
    1e20:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1e24:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1e28:	07 2e       	mov	r0, r23
    1e2a:	00 0c       	add	r0, r0
    1e2c:	88 0b       	sbc	r24, r24
    1e2e:	99 0b       	sbc	r25, r25
    1e30:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <__floatsisf>
    1e34:	20 e0       	ldi	r18, 0x00	; 0
    1e36:	30 e0       	ldi	r19, 0x00	; 0
    1e38:	4f e7       	ldi	r20, 0x7F	; 127
    1e3a:	53 e4       	ldi	r21, 0x43	; 67
    1e3c:	0e 94 20 16 	call	0x2c40	; 0x2c40 <__divsf3>
    1e40:	0e 94 09 0b 	call	0x1612	; 0x1612 <Lamp_dimmable_set_brightness>
                      break;
    1e44:	0d c0       	rjmp	.+26     	; 0x1e60 <Local_control_input_handler+0x480>
                    default:
                      if (control_devices_screen < 7) control_devices_screen++;
    1e46:	87 30       	cpi	r24, 0x07	; 7
    1e48:	58 f4       	brcc	.+22     	; 0x1e60 <Local_control_input_handler+0x480>
    1e4a:	8f 5f       	subi	r24, 0xFF	; 255
    1e4c:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
    1e50:	07 c0       	rjmp	.+14     	; 0x1e60 <Local_control_input_handler+0x480>
                      break;
                  }
                break;
              case '4':
                // Moving to logout screen
                if (control_devices_screen == 6) control_devices_screen++;
    1e52:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1e56:	86 30       	cpi	r24, 0x06	; 6
    1e58:	19 f4       	brne	.+6      	; 0x1e60 <Local_control_input_handler+0x480>
    1e5a:	8f 5f       	subi	r24, 0xFF	; 255
    1e5c:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
                break;
            }
          Show_devices_controls(control_devices_screen);
    1e60:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1e64:	0e 94 0f 0c 	call	0x181e	; 0x181e <Show_devices_controls>
          }
        break;
    }
    1e68:	0f 90       	pop	r0
    1e6a:	df 91       	pop	r29
    1e6c:	cf 91       	pop	r28
    1e6e:	1f 91       	pop	r17
    1e70:	08 95       	ret

00001e72 <println_msg>:
  UART_RXC_INT_init();
  }

void println_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    1e72:	0e 94 05 02 	call	0x40a	; 0x40a <BT_sendString>
  // Send CRLF - carriage return + new line
  BT_sendString("\r\n");
    1e76:	8e ef       	ldi	r24, 0xFE	; 254
    1e78:	91 e0       	ldi	r25, 0x01	; 1
    1e7a:	0e 94 05 02 	call	0x40a	; 0x40a <BT_sendString>
    1e7e:	08 95       	ret

00001e80 <print_msg>:
  }

void print_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    1e80:	0e 94 05 02 	call	0x40a	; 0x40a <BT_sendString>
    1e84:	08 95       	ret

00001e86 <callFunWhenBufferReady>:
  }

void callFunWhenBufferReady(void) {
  requesting_function();
    1e86:	e0 91 59 08 	lds	r30, 0x0859	; 0x800859 <requesting_function>
    1e8a:	f0 91 5a 08 	lds	r31, 0x085A	; 0x80085a <requesting_function+0x1>
    1e8e:	09 95       	icall
    1e90:	08 95       	ret

00001e92 <request_user_input>:
  }

void request_user_input(void (*requestingFunction)(void), u8 msgLength, bool numericalInputOnly) {
  requesting_function = requestingFunction;
    1e92:	90 93 5a 08 	sts	0x085A, r25	; 0x80085a <requesting_function+0x1>
    1e96:	80 93 59 08 	sts	0x0859, r24	; 0x800859 <requesting_function>
  msg_length = msgLength;
    1e9a:	60 93 36 08 	sts	0x0836, r22	; 0x800836 <msg_length>
  numerical_input_mode = numericalInputOnly;
    1e9e:	40 93 e6 07 	sts	0x07E6, r20	; 0x8007e6 <numerical_input_mode>
    1ea2:	08 95       	ret

00001ea4 <get_lamp_state>:
  }

void get_lamp_state(u8 lamp, u8* state) {
    1ea4:	ab 01       	movw	r20, r22
  DIO_Read(lamp + 2, PORT_C, state);
    1ea6:	63 e4       	ldi	r22, 0x43	; 67
    1ea8:	8e 5f       	subi	r24, 0xFE	; 254
    1eaa:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DIO_Read>
    1eae:	08 95       	ret

00001eb0 <print_remote_control_menu>:
    initial_options_menu();
    }
  }

void print_remote_control_menu(void) {
  println_msg("Select one of the following devices to control:\t");
    1eb0:	81 e0       	ldi	r24, 0x01	; 1
    1eb2:	92 e0       	ldi	r25, 0x02	; 2
    1eb4:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
  println_msg("[1] Lamp 1");
    1eb8:	82 e3       	ldi	r24, 0x32	; 50
    1eba:	92 e0       	ldi	r25, 0x02	; 2
    1ebc:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
  println_msg("[2] Lamp 2");
    1ec0:	8d e3       	ldi	r24, 0x3D	; 61
    1ec2:	92 e0       	ldi	r25, 0x02	; 2
    1ec4:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
  println_msg("[3] Lamp 3");
    1ec8:	88 e4       	ldi	r24, 0x48	; 72
    1eca:	92 e0       	ldi	r25, 0x02	; 2
    1ecc:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
  println_msg("[4] Lamp 4");
    1ed0:	83 e5       	ldi	r24, 0x53	; 83
    1ed2:	92 e0       	ldi	r25, 0x02	; 2
    1ed4:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
  println_msg("[5] Lamp 5");
    1ed8:	8e e5       	ldi	r24, 0x5E	; 94
    1eda:	92 e0       	ldi	r25, 0x02	; 2
    1edc:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
  println_msg("[6] Lamp 6 (dimmable)");
    1ee0:	89 e6       	ldi	r24, 0x69	; 105
    1ee2:	92 e0       	ldi	r25, 0x02	; 2
    1ee4:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
  if (remote_user.isAdmin) {
    1ee8:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    1eec:	88 23       	and	r24, r24
    1eee:	49 f0       	breq	.+18     	; 0x1f02 <print_remote_control_menu+0x52>
    println_msg("[7] The Door");
    1ef0:	8f e7       	ldi	r24, 0x7F	; 127
    1ef2:	92 e0       	ldi	r25, 0x02	; 2
    1ef4:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    println_msg("[8] Go back to main menu");
    1ef8:	8c e8       	ldi	r24, 0x8C	; 140
    1efa:	92 e0       	ldi	r25, 0x02	; 2
    1efc:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    1f00:	08 95       	ret
    }
  else {
    println_msg("[7] Go back to main menu");
    1f02:	85 ea       	ldi	r24, 0xA5	; 165
    1f04:	92 e0       	ldi	r25, 0x02	; 2
    1f06:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    1f0a:	08 95       	ret

00001f0c <print_initial_options_menu>:
      }
    }
  }

void print_initial_options_menu(void) {
  if (remote_user.isAdmin) {
    1f0c:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    1f10:	88 23       	and	r24, r24
    1f12:	e9 f0       	breq	.+58     	; 0x1f4e <print_initial_options_menu+0x42>
    println_msg("Select one of the following options(by entering its number):\t");
    1f14:	8e eb       	ldi	r24, 0xBE	; 190
    1f16:	92 e0       	ldi	r25, 0x02	; 2
    1f18:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    println_msg("[1] Add user\t");
    1f1c:	8c ef       	ldi	r24, 0xFC	; 252
    1f1e:	92 e0       	ldi	r25, 0x02	; 2
    1f20:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    println_msg("[2] Delete user\t");
    1f24:	8a e0       	ldi	r24, 0x0A	; 10
    1f26:	93 e0       	ldi	r25, 0x03	; 3
    1f28:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    println_msg("[3] Control a device\t");
    1f2c:	8b e1       	ldi	r24, 0x1B	; 27
    1f2e:	93 e0       	ldi	r25, 0x03	; 3
    1f30:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    println_msg("[4] Log out\t");
    1f34:	81 e3       	ldi	r24, 0x31	; 49
    1f36:	93 e0       	ldi	r25, 0x03	; 3
    1f38:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    if (local_user_loggedin) {
    1f3c:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <__data_end>
    1f40:	88 23       	and	r24, r24
    1f42:	89 f0       	breq	.+34     	; 0x1f66 <print_initial_options_menu+0x5a>
      println_msg("[5] Allow local user control\t");
    1f44:	8e e3       	ldi	r24, 0x3E	; 62
    1f46:	93 e0       	ldi	r25, 0x03	; 3
    1f48:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    1f4c:	08 95       	ret
      }
    }
  else {
    println_msg("Select one of the following options(by entering its number):\t");
    1f4e:	8e eb       	ldi	r24, 0xBE	; 190
    1f50:	92 e0       	ldi	r25, 0x02	; 2
    1f52:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    println_msg("[1] Control a device\t");
    1f56:	8c e5       	ldi	r24, 0x5C	; 92
    1f58:	93 e0       	ldi	r25, 0x03	; 3
    1f5a:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    println_msg("[2] Log out\t");
    1f5e:	82 e7       	ldi	r24, 0x72	; 114
    1f60:	93 e0       	ldi	r25, 0x03	; 3
    1f62:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    1f66:	08 95       	ret

00001f68 <grant_local_control_permission>:
    }
  }

void grant_local_control_permission(void) {
  local_control_permission_granted = true;
    1f68:	81 e0       	ldi	r24, 0x01	; 1
    1f6a:	80 93 a7 07 	sts	0x07A7, r24	; 0x8007a7 <local_control_permission_granted>
    1f6e:	08 95       	ret

00001f70 <logout>:
      }
    }
  }

void logout(void) {
  remote_user_loggedin = false;
    1f70:	10 92 a8 07 	sts	0x07A8, r1	; 0x8007a8 <remote_user_loggedin>
  println_msg("To login again you have to disconnect and reconnect to the BT module...");
    1f74:	8f e7       	ldi	r24, 0x7F	; 127
    1f76:	93 e0       	ldi	r25, 0x03	; 3
    1f78:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
  println_msg("You have successfully logged out...");
    1f7c:	87 ec       	ldi	r24, 0xC7	; 199
    1f7e:	93 e0       	ldi	r25, 0x03	; 3
    1f80:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
  msg_length = 0;
    1f84:	10 92 36 08 	sts	0x0836, r1	; 0x800836 <msg_length>
    1f88:	08 95       	ret

00001f8a <initial_options_menu>:
void grant_local_control_permission(void) {
  local_control_permission_granted = true;
  }

void initial_options_menu(void) {
  if (!user_input_accepted) {
    1f8a:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    1f8e:	81 11       	cpse	r24, r1
    1f90:	0c c0       	rjmp	.+24     	; 0x1faa <initial_options_menu+0x20>
    print_initial_options_menu();
    1f92:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <print_initial_options_menu>
    request_user_input(initial_options_menu, 2, true);
    1f96:	41 e0       	ldi	r20, 0x01	; 1
    1f98:	62 e0       	ldi	r22, 0x02	; 2
    1f9a:	85 ec       	ldi	r24, 0xC5	; 197
    1f9c:	9f e0       	ldi	r25, 0x0F	; 15
    1f9e:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
    user_input_accepted = true;
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    1fa8:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    1faa:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (remote_user.isAdmin) {
    1fae:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    1fb2:	88 23       	and	r24, r24
    1fb4:	49 f1       	breq	.+82     	; 0x2008 <initial_options_menu+0x7e>
      u8 option = msg_buffer[0];
    1fb6:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <msg_buffer>
      if (option < '1' || option > '5') {
    1fba:	9f ec       	ldi	r25, 0xCF	; 207
    1fbc:	98 0f       	add	r25, r24
    1fbe:	95 30       	cpi	r25, 0x05	; 5
    1fc0:	38 f0       	brcs	.+14     	; 0x1fd0 <initial_options_menu+0x46>
        println_msg("Invalid option!\t");
    1fc2:	8b ee       	ldi	r24, 0xEB	; 235
    1fc4:	93 e0       	ldi	r25, 0x03	; 3
    1fc6:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
        initial_options_menu();
    1fca:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <initial_options_menu>
    1fce:	08 95       	ret
        }
      else {
        switch (option) {
    1fd0:	83 33       	cpi	r24, 0x33	; 51
    1fd2:	89 f0       	breq	.+34     	; 0x1ff6 <initial_options_menu+0x6c>
    1fd4:	28 f4       	brcc	.+10     	; 0x1fe0 <initial_options_menu+0x56>
    1fd6:	81 33       	cpi	r24, 0x31	; 49
    1fd8:	41 f0       	breq	.+16     	; 0x1fea <initial_options_menu+0x60>
    1fda:	82 33       	cpi	r24, 0x32	; 50
    1fdc:	49 f0       	breq	.+18     	; 0x1ff0 <initial_options_menu+0x66>
    1fde:	08 95       	ret
    1fe0:	84 33       	cpi	r24, 0x34	; 52
    1fe2:	61 f0       	breq	.+24     	; 0x1ffc <initial_options_menu+0x72>
    1fe4:	85 33       	cpi	r24, 0x35	; 53
    1fe6:	69 f0       	breq	.+26     	; 0x2002 <initial_options_menu+0x78>
    1fe8:	08 95       	ret
            case '1':
              add_user_prompt();
    1fea:	0e 94 90 11 	call	0x2320	; 0x2320 <add_user_prompt>
              break;
    1fee:	08 95       	ret
            case '2':
              delete_user_prompt();
    1ff0:	0e 94 1c 10 	call	0x2038	; 0x2038 <delete_user_prompt>
              break;
    1ff4:	08 95       	ret
            case '3':
              remote_control();
    1ff6:	0e 94 48 10 	call	0x2090	; 0x2090 <remote_control>
              break;
    1ffa:	08 95       	ret
            case '4':
              logout();
    1ffc:	0e 94 b8 0f 	call	0x1f70	; 0x1f70 <logout>
              break;
    2000:	08 95       	ret
            case '5':
              grant_local_control_permission();
    2002:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <grant_local_control_permission>
              break;
    2006:	08 95       	ret
          }
        }
      }
    else {
      u8 option = msg_buffer[0];
    2008:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <msg_buffer>
      if (option < '1' || option > '2') {
    200c:	9f ec       	ldi	r25, 0xCF	; 207
    200e:	98 0f       	add	r25, r24
    2010:	92 30       	cpi	r25, 0x02	; 2
    2012:	38 f0       	brcs	.+14     	; 0x2022 <initial_options_menu+0x98>
        println_msg("Invalid option!\t");
    2014:	8b ee       	ldi	r24, 0xEB	; 235
    2016:	93 e0       	ldi	r25, 0x03	; 3
    2018:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
        initial_options_menu();
    201c:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <initial_options_menu>
    2020:	08 95       	ret
        }
      else {
        switch (option) {
    2022:	81 33       	cpi	r24, 0x31	; 49
    2024:	19 f0       	breq	.+6      	; 0x202c <initial_options_menu+0xa2>
    2026:	82 33       	cpi	r24, 0x32	; 50
    2028:	21 f0       	breq	.+8      	; 0x2032 <initial_options_menu+0xa8>
    202a:	08 95       	ret
            case '1':
              remote_control();
    202c:	0e 94 48 10 	call	0x2090	; 0x2090 <remote_control>
              break;
    2030:	08 95       	ret
            case '2':
              logout();
    2032:	0e 94 b8 0f 	call	0x1f70	; 0x1f70 <logout>
    2036:	08 95       	ret

00002038 <delete_user_prompt>:
void get_lamp_state(u8 lamp, u8* state) {
  DIO_Read(lamp + 2, PORT_C, state);
  }

void delete_user_prompt(void) {
  if (!user_input_accepted) {
    2038:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    203c:	81 11       	cpse	r24, r1
    203e:	0e c0       	rjmp	.+28     	; 0x205c <delete_user_prompt+0x24>
    print_msg("Enter the user name of the user you want to delete: ");
    2040:	8c ef       	ldi	r24, 0xFC	; 252
    2042:	93 e0       	ldi	r25, 0x03	; 3
    2044:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <print_msg>
    request_user_input(delete_user_prompt, 13, false);
    2048:	40 e0       	ldi	r20, 0x00	; 0
    204a:	6d e0       	ldi	r22, 0x0D	; 13
    204c:	8c e1       	ldi	r24, 0x1C	; 28
    204e:	90 e1       	ldi	r25, 0x10	; 16
    2050:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
    user_input_accepted = true;
    2054:	81 e0       	ldi	r24, 0x01	; 1
    2056:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    205a:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    205c:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    2060:	67 e0       	ldi	r22, 0x07	; 7
    2062:	78 e0       	ldi	r23, 0x08	; 8
    2064:	87 e2       	ldi	r24, 0x27	; 39
    2066:	98 e0       	ldi	r25, 0x08	; 8
    2068:	0e 94 6f 13 	call	0x26de	; 0x26de <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    206c:	83 30       	cpi	r24, 0x03	; 3
    206e:	29 f4       	brne	.+10     	; 0x207a <delete_user_prompt+0x42>
      println_msg("\rError! User not found. Returning to the main menu...");
    2070:	81 e3       	ldi	r24, 0x31	; 49
    2072:	94 e0       	ldi	r25, 0x04	; 4
    2074:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    2078:	08 c0       	rjmp	.+16     	; 0x208a <delete_user_prompt+0x52>
      }
    else {
      // Delete the user
      delete_user(&temp_user);
    207a:	87 e0       	ldi	r24, 0x07	; 7
    207c:	98 e0       	ldi	r25, 0x08	; 8
    207e:	0e 94 40 15 	call	0x2a80	; 0x2a80 <delete_user>
      println_msg("The user has been deleted successfully!\t");
    2082:	87 e6       	ldi	r24, 0x67	; 103
    2084:	94 e0       	ldi	r25, 0x04	; 4
    2086:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
      }
    initial_options_menu();
    208a:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <initial_options_menu>
    208e:	08 95       	ret

00002090 <remote_control>:
    }
  remote_control();
  }

// Prints the state of the device and prompts the user if he wants to change it.
void remote_control(void) {
    2090:	0f 93       	push	r16
    2092:	1f 93       	push	r17
    2094:	cf 93       	push	r28
    2096:	df 93       	push	r29
    2098:	1f 92       	push	r1
    209a:	cd b7       	in	r28, 0x3d	; 61
    209c:	de b7       	in	r29, 0x3e	; 62
  if (!user_input_accepted) {
    209e:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    20a2:	81 11       	cpse	r24, r1
    20a4:	0c c0       	rjmp	.+24     	; 0x20be <remote_control+0x2e>
    print_remote_control_menu();
    20a6:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <print_remote_control_menu>
    request_user_input(remote_control, 2, true);
    20aa:	41 e0       	ldi	r20, 0x01	; 1
    20ac:	62 e0       	ldi	r22, 0x02	; 2
    20ae:	88 e4       	ldi	r24, 0x48	; 72
    20b0:	90 e1       	ldi	r25, 0x10	; 16
    20b2:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
    user_input_accepted = true;
    20b6:	81 e0       	ldi	r24, 0x01	; 1
    20b8:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    20bc:	4b c0       	rjmp	.+150    	; 0x2154 <remote_control+0xc4>
    }
  else {
    user_input_accepted = false;
    20be:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    u8 option = msg_buffer[0];
    20c2:	10 91 27 08 	lds	r17, 0x0827	; 0x800827 <msg_buffer>
    if ((!remote_user.isAdmin && option > '7') || option < '1' || option > '8') {
    20c6:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    20ca:	81 11       	cpse	r24, r1
    20cc:	02 c0       	rjmp	.+4      	; 0x20d2 <remote_control+0x42>
    20ce:	18 33       	cpi	r17, 0x38	; 56
    20d0:	20 f4       	brcc	.+8      	; 0x20da <remote_control+0x4a>
    20d2:	11 33       	cpi	r17, 0x31	; 49
    20d4:	10 f0       	brcs	.+4      	; 0x20da <remote_control+0x4a>
    20d6:	19 33       	cpi	r17, 0x39	; 57
    20d8:	38 f0       	brcs	.+14     	; 0x20e8 <remote_control+0x58>
      println_msg("Invalid option!\t");
    20da:	8b ee       	ldi	r24, 0xEB	; 235
    20dc:	93 e0       	ldi	r25, 0x03	; 3
    20de:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
      remote_control();
    20e2:	0e 94 48 10 	call	0x2090	; 0x2090 <remote_control>
    20e6:	36 c0       	rjmp	.+108    	; 0x2154 <remote_control+0xc4>
      }
    else {
      u8 state;
      get_lamp_state(option - 48, &state);
    20e8:	be 01       	movw	r22, r28
    20ea:	6f 5f       	subi	r22, 0xFF	; 255
    20ec:	7f 4f       	sbci	r23, 0xFF	; 255
    20ee:	00 ed       	ldi	r16, 0xD0	; 208
    20f0:	01 0f       	add	r16, r17
    20f2:	80 2f       	mov	r24, r16
    20f4:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <get_lamp_state>
      device_number = option - 48;
    20f8:	00 93 38 08 	sts	0x0838, r16	; 0x800838 <device_number>
      switch (option) {
    20fc:	17 33       	cpi	r17, 0x37	; 55
    20fe:	79 f0       	breq	.+30     	; 0x211e <remote_control+0x8e>
    2100:	18 33       	cpi	r17, 0x38	; 56
    2102:	f9 f0       	breq	.+62     	; 0x2142 <remote_control+0xb2>
    2104:	16 33       	cpi	r17, 0x36	; 54
    2106:	01 f5       	brne	.+64     	; 0x2148 <remote_control+0xb8>
          case '6':
            print_msg("Enter the brightness level for the lamp(from 0(off) to 9(max)): ");
    2108:	80 e9       	ldi	r24, 0x90	; 144
    210a:	94 e0       	ldi	r25, 0x04	; 4
    210c:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <print_msg>
            request_user_input(control_device, 2, true);
    2110:	41 e0       	ldi	r20, 0x01	; 1
    2112:	62 e0       	ldi	r22, 0x02	; 2
    2114:	80 eb       	ldi	r24, 0xB0	; 176
    2116:	90 e1       	ldi	r25, 0x10	; 16
    2118:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
            break;
    211c:	1b c0       	rjmp	.+54     	; 0x2154 <remote_control+0xc4>
          case '7':
            if (remote_user.isAdmin) {
    211e:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    2122:	88 23       	and	r24, r24
    2124:	59 f0       	breq	.+22     	; 0x213c <remote_control+0xac>
              println_msg("Enter 1 to open the door and 0 to close it: ");
    2126:	81 ed       	ldi	r24, 0xD1	; 209
    2128:	94 e0       	ldi	r25, 0x04	; 4
    212a:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
              request_user_input(control_device, 2, true);
    212e:	41 e0       	ldi	r20, 0x01	; 1
    2130:	62 e0       	ldi	r22, 0x02	; 2
    2132:	80 eb       	ldi	r24, 0xB0	; 176
    2134:	90 e1       	ldi	r25, 0x10	; 16
    2136:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
    213a:	0c c0       	rjmp	.+24     	; 0x2154 <remote_control+0xc4>
              }
            else {
              initial_options_menu();
    213c:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <initial_options_menu>
    2140:	09 c0       	rjmp	.+18     	; 0x2154 <remote_control+0xc4>
              }
            break;
          case '8':
            initial_options_menu();
    2142:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <initial_options_menu>
            break;
    2146:	06 c0       	rjmp	.+12     	; 0x2154 <remote_control+0xc4>
            // else {
            //   print_msg("Lamp ");
            //   // BT_sendChar(device_number);
            //   println_msg(" is off. Turn it on? (Y/N)");
            //   }
            request_user_input(control_device, 2, false);
    2148:	40 e0       	ldi	r20, 0x00	; 0
    214a:	62 e0       	ldi	r22, 0x02	; 2
    214c:	80 eb       	ldi	r24, 0xB0	; 176
    214e:	90 e1       	ldi	r25, 0x10	; 16
    2150:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
            break;
        }
      }
    }
  }
    2154:	0f 90       	pop	r0
    2156:	df 91       	pop	r29
    2158:	cf 91       	pop	r28
    215a:	1f 91       	pop	r17
    215c:	0f 91       	pop	r16
    215e:	08 95       	ret

00002160 <control_device>:
    println_msg("[7] Go back to main menu");
    }
  }

void control_device(void) {
  u8 option = msg_buffer[0];
    2160:	60 91 27 08 	lds	r22, 0x0827	; 0x800827 <msg_buffer>
  switch (device_number) {
    2164:	80 91 38 08 	lds	r24, 0x0838	; 0x800838 <device_number>
    2168:	86 30       	cpi	r24, 0x06	; 6
    216a:	19 f0       	breq	.+6      	; 0x2172 <control_device+0x12>
    216c:	87 30       	cpi	r24, 0x07	; 7
    216e:	d9 f0       	breq	.+54     	; 0x21a6 <control_device+0x46>
    2170:	33 c0       	rjmp	.+102    	; 0x21d8 <control_device+0x78>
      case 6:
        if (option < '0' || option > '9') {
    2172:	60 53       	subi	r22, 0x30	; 48
    2174:	6a 30       	cpi	r22, 0x0A	; 10
    2176:	28 f0       	brcs	.+10     	; 0x2182 <control_device+0x22>
          println_msg("\r\nInvalid input!!\t");
    2178:	8e ef       	ldi	r24, 0xFE	; 254
    217a:	94 e0       	ldi	r25, 0x04	; 4
    217c:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    2180:	37 c0       	rjmp	.+110    	; 0x21f0 <control_device+0x90>
          }
        else {
          option -= 48; // Convert to int
          Lamp_dimmable_set_brightness((double)option / 9.0);
    2182:	70 e0       	ldi	r23, 0x00	; 0
    2184:	80 e0       	ldi	r24, 0x00	; 0
    2186:	90 e0       	ldi	r25, 0x00	; 0
    2188:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <__floatunsisf>
    218c:	20 e0       	ldi	r18, 0x00	; 0
    218e:	30 e0       	ldi	r19, 0x00	; 0
    2190:	40 e1       	ldi	r20, 0x10	; 16
    2192:	51 e4       	ldi	r21, 0x41	; 65
    2194:	0e 94 20 16 	call	0x2c40	; 0x2c40 <__divsf3>
    2198:	0e 94 09 0b 	call	0x1612	; 0x1612 <Lamp_dimmable_set_brightness>
          println_msg("The brightness has been adjusted!");
    219c:	81 e1       	ldi	r24, 0x11	; 17
    219e:	95 e0       	ldi	r25, 0x05	; 5
    21a0:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    21a4:	25 c0       	rjmp	.+74     	; 0x21f0 <control_device+0x90>
          }
        break;
      case 7:
        if (option != '0' && option != '1') {
    21a6:	80 ed       	ldi	r24, 0xD0	; 208
    21a8:	86 0f       	add	r24, r22
    21aa:	82 30       	cpi	r24, 0x02	; 2
    21ac:	28 f0       	brcs	.+10     	; 0x21b8 <control_device+0x58>
          println_msg("\r\nInvalid input!!\t");
    21ae:	8e ef       	ldi	r24, 0xFE	; 254
    21b0:	94 e0       	ldi	r25, 0x04	; 4
    21b2:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    21b6:	1c c0       	rjmp	.+56     	; 0x21f0 <control_device+0x90>
          }
        else {
          if (option == '0') {
    21b8:	60 33       	cpi	r22, 0x30	; 48
    21ba:	39 f4       	brne	.+14     	; 0x21ca <control_device+0x6a>
            Door_close();
    21bc:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <Door_close>
            println_msg("The Door is closed now.");
    21c0:	83 e3       	ldi	r24, 0x33	; 51
    21c2:	95 e0       	ldi	r25, 0x05	; 5
    21c4:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    21c8:	13 c0       	rjmp	.+38     	; 0x21f0 <control_device+0x90>
            }
          else {
            Door_open();
    21ca:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <Door_open>
            println_msg("The Door is open now.");
    21ce:	8b e4       	ldi	r24, 0x4B	; 75
    21d0:	95 e0       	ldi	r25, 0x05	; 5
    21d2:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    21d6:	0c c0       	rjmp	.+24     	; 0x21f0 <control_device+0x90>
            }
          }
        break;
      default:
        if (option != 'Y' && option != 'y' && option != 'n' && option != 'N') {
    21d8:	69 35       	cpi	r22, 0x59	; 89
    21da:	51 f0       	breq	.+20     	; 0x21f0 <control_device+0x90>
    21dc:	69 37       	cpi	r22, 0x79	; 121
    21de:	41 f0       	breq	.+16     	; 0x21f0 <control_device+0x90>
    21e0:	6e 36       	cpi	r22, 0x6E	; 110
    21e2:	31 f0       	breq	.+12     	; 0x21f0 <control_device+0x90>
    21e4:	6e 34       	cpi	r22, 0x4E	; 78
    21e6:	21 f0       	breq	.+8      	; 0x21f0 <control_device+0x90>
          println_msg("\r\nInvalid input!!\t");
    21e8:	8e ef       	ldi	r24, 0xFE	; 254
    21ea:	94 e0       	ldi	r25, 0x04	; 4
    21ec:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
          //   println_msg("The Lamp is now off!");
          //   }
          }
        break;
    }
  remote_control();
    21f0:	0e 94 48 10 	call	0x2090	; 0x2090 <remote_control>
    21f4:	08 95       	ret

000021f6 <add_user_isAdmin_prompt>:
  println_msg("You have successfully logged out...");
  msg_length = 0;
  }

void add_user_isAdmin_prompt(void) {
  if (!user_input_accepted) {
    21f6:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    21fa:	81 11       	cpse	r24, r1
    21fc:	0e c0       	rjmp	.+28     	; 0x221a <add_user_isAdmin_prompt+0x24>
    println_msg("Do you want to make the new user an admin? (y/n) ");
    21fe:	81 e6       	ldi	r24, 0x61	; 97
    2200:	95 e0       	ldi	r25, 0x05	; 5
    2202:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    request_user_input(add_user_isAdmin_prompt, 2, false);
    2206:	40 e0       	ldi	r20, 0x00	; 0
    2208:	62 e0       	ldi	r22, 0x02	; 2
    220a:	8b ef       	ldi	r24, 0xFB	; 251
    220c:	90 e1       	ldi	r25, 0x10	; 16
    220e:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
    user_input_accepted = true;
    2212:	81 e0       	ldi	r24, 0x01	; 1
    2214:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    2218:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    221a:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    new_user.isAdmin = (msg_buffer[0] == 'y' || msg_buffer[0] == 'Y');
    221e:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <msg_buffer>
    2222:	89 37       	cpi	r24, 0x79	; 121
    2224:	21 f0       	breq	.+8      	; 0x222e <add_user_isAdmin_prompt+0x38>
    2226:	89 35       	cpi	r24, 0x59	; 89
    2228:	21 f4       	brne	.+8      	; 0x2232 <add_user_isAdmin_prompt+0x3c>
    222a:	81 e0       	ldi	r24, 0x01	; 1
    222c:	03 c0       	rjmp	.+6      	; 0x2234 <add_user_isAdmin_prompt+0x3e>
    222e:	81 e0       	ldi	r24, 0x01	; 1
    2230:	01 c0       	rjmp	.+2      	; 0x2234 <add_user_isAdmin_prompt+0x3e>
    2232:	80 e0       	ldi	r24, 0x00	; 0
    2234:	80 93 39 08 	sts	0x0839, r24	; 0x800839 <new_user>
    add_user(&new_user);
    2238:	89 e3       	ldi	r24, 0x39	; 57
    223a:	98 e0       	ldi	r25, 0x08	; 8
    223c:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <add_user>
    println_msg("User has been added successfully!");
    2240:	83 e9       	ldi	r24, 0x93	; 147
    2242:	95 e0       	ldi	r25, 0x05	; 5
    2244:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    // Return to the main menu
    initial_options_menu();
    2248:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <initial_options_menu>
    224c:	08 95       	ret

0000224e <add_user_password_prompt>:
    }
  }

void add_user_password_prompt(void) {
  if (!user_input_accepted) {
    224e:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    2252:	81 11       	cpse	r24, r1
    2254:	0e c0       	rjmp	.+28     	; 0x2272 <add_user_password_prompt+0x24>
    println_msg("Enter the new user's password(The password can only consist of numbers and 4 digits at least, 10 at max): ");
    2256:	85 eb       	ldi	r24, 0xB5	; 181
    2258:	95 e0       	ldi	r25, 0x05	; 5
    225a:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    request_user_input(add_user_password_prompt, 11, true);
    225e:	41 e0       	ldi	r20, 0x01	; 1
    2260:	6b e0       	ldi	r22, 0x0B	; 11
    2262:	87 e2       	ldi	r24, 0x27	; 39
    2264:	91 e1       	ldi	r25, 0x11	; 17
    2266:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
    user_input_accepted = true;
    226a:	81 e0       	ldi	r24, 0x01	; 1
    226c:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    2270:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    2272:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (strlen(msg_buffer) < 4) {
    2276:	e7 e2       	ldi	r30, 0x27	; 39
    2278:	f8 e0       	ldi	r31, 0x08	; 8
    227a:	01 90       	ld	r0, Z+
    227c:	00 20       	and	r0, r0
    227e:	e9 f7       	brne	.-6      	; 0x227a <add_user_password_prompt+0x2c>
    2280:	31 97       	sbiw	r30, 0x01	; 1
    2282:	e7 52       	subi	r30, 0x27	; 39
    2284:	f8 40       	sbci	r31, 0x08	; 8
    2286:	34 97       	sbiw	r30, 0x04	; 4
    2288:	38 f4       	brcc	.+14     	; 0x2298 <add_user_password_prompt+0x4a>
      println_msg("Password too short!!\t");
    228a:	80 e2       	ldi	r24, 0x20	; 32
    228c:	96 e0       	ldi	r25, 0x06	; 6
    228e:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
      add_user_password_prompt();
    2292:	0e 94 27 11 	call	0x224e	; 0x224e <add_user_password_prompt>
    2296:	08 95       	ret
      }
    else {
      strcpy(new_user.password, msg_buffer);
    2298:	67 e2       	ldi	r22, 0x27	; 39
    229a:	78 e0       	ldi	r23, 0x08	; 8
    229c:	8e e4       	ldi	r24, 0x4E	; 78
    229e:	98 e0       	ldi	r25, 0x08	; 8
    22a0:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <strcpy>
      add_user_isAdmin_prompt();
    22a4:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <add_user_isAdmin_prompt>
    22a8:	08 95       	ret

000022aa <add_user_code_prompt>:
      }
    }
  }

void add_user_code_prompt(void) {
  if (!user_input_accepted) {
    22aa:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    22ae:	81 11       	cpse	r24, r1
    22b0:	0e c0       	rjmp	.+28     	; 0x22ce <add_user_code_prompt+0x24>
    print_msg("Enter the new user's code(must be a unique six digit code): ");
    22b2:	86 e3       	ldi	r24, 0x36	; 54
    22b4:	96 e0       	ldi	r25, 0x06	; 6
    22b6:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <print_msg>
    request_user_input(add_user_code_prompt, 7, true);
    22ba:	41 e0       	ldi	r20, 0x01	; 1
    22bc:	67 e0       	ldi	r22, 0x07	; 7
    22be:	85 e5       	ldi	r24, 0x55	; 85
    22c0:	91 e1       	ldi	r25, 0x11	; 17
    22c2:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
    user_input_accepted = true;
    22c6:	81 e0       	ldi	r24, 0x01	; 1
    22c8:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    22cc:	08 95       	ret
    }
  else {// Validating the length of the user code. It can't be more than 6 digits by the input limitations. But the input can be smaller
    user_input_accepted = false;
    22ce:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (strlen(msg_buffer) != 6) {
    22d2:	e7 e2       	ldi	r30, 0x27	; 39
    22d4:	f8 e0       	ldi	r31, 0x08	; 8
    22d6:	01 90       	ld	r0, Z+
    22d8:	00 20       	and	r0, r0
    22da:	e9 f7       	brne	.-6      	; 0x22d6 <add_user_code_prompt+0x2c>
    22dc:	ee 52       	subi	r30, 0x2E	; 46
    22de:	f8 40       	sbci	r31, 0x08	; 8
    22e0:	39 f0       	breq	.+14     	; 0x22f0 <add_user_code_prompt+0x46>
      println_msg("User code too short!");
    22e2:	83 e7       	ldi	r24, 0x73	; 115
    22e4:	96 e0       	ldi	r25, 0x06	; 6
    22e6:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
      add_user_code_prompt();
    22ea:	0e 94 55 11 	call	0x22aa	; 0x22aa <add_user_code_prompt>
    22ee:	08 95       	ret
      }
    else {
      EN_UserStatusCode_t userExists = getUserByCode(msg_buffer, &temp_user);
    22f0:	67 e0       	ldi	r22, 0x07	; 7
    22f2:	78 e0       	ldi	r23, 0x08	; 8
    22f4:	87 e2       	ldi	r24, 0x27	; 39
    22f6:	98 e0       	ldi	r25, 0x08	; 8
    22f8:	0e 94 08 14 	call	0x2810	; 0x2810 <getUserByCode>
      if (userExists == USER_NOT_FOUND) {
    22fc:	83 30       	cpi	r24, 0x03	; 3
    22fe:	49 f4       	brne	.+18     	; 0x2312 <add_user_code_prompt+0x68>
        strcpy(new_user.code, msg_buffer);
    2300:	67 e2       	ldi	r22, 0x27	; 39
    2302:	78 e0       	ldi	r23, 0x08	; 8
    2304:	87 e4       	ldi	r24, 0x47	; 71
    2306:	98 e0       	ldi	r25, 0x08	; 8
    2308:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <strcpy>
        add_user_password_prompt();
    230c:	0e 94 27 11 	call	0x224e	; 0x224e <add_user_password_prompt>
    2310:	08 95       	ret
        }
      else {
        println_msg("\rThe user code already exists!\t");
    2312:	88 e8       	ldi	r24, 0x88	; 136
    2314:	96 e0       	ldi	r25, 0x06	; 6
    2316:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
        add_user_code_prompt();
    231a:	0e 94 55 11 	call	0x22aa	; 0x22aa <add_user_code_prompt>
    231e:	08 95       	ret

00002320 <add_user_prompt>:
      }
    }
  }

void add_user_prompt(void) {
  if (!user_input_accepted) {
    2320:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    2324:	81 11       	cpse	r24, r1
    2326:	0e c0       	rjmp	.+28     	; 0x2344 <add_user_prompt+0x24>
    print_msg("Enter the new user's name: ");
    2328:	88 ea       	ldi	r24, 0xA8	; 168
    232a:	96 e0       	ldi	r25, 0x06	; 6
    232c:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <print_msg>
    request_user_input(add_user_prompt, 13, false);
    2330:	40 e0       	ldi	r20, 0x00	; 0
    2332:	6d e0       	ldi	r22, 0x0D	; 13
    2334:	80 e9       	ldi	r24, 0x90	; 144
    2336:	91 e1       	ldi	r25, 0x11	; 17
    2338:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
    user_input_accepted = true;
    233c:	81 e0       	ldi	r24, 0x01	; 1
    233e:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    2342:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    2344:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    2348:	67 e0       	ldi	r22, 0x07	; 7
    234a:	78 e0       	ldi	r23, 0x08	; 8
    234c:	87 e2       	ldi	r24, 0x27	; 39
    234e:	98 e0       	ldi	r25, 0x08	; 8
    2350:	0e 94 6f 13 	call	0x26de	; 0x26de <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    2354:	83 30       	cpi	r24, 0x03	; 3
    2356:	49 f4       	brne	.+18     	; 0x236a <add_user_prompt+0x4a>
      strcpy(new_user.name, msg_buffer);
    2358:	67 e2       	ldi	r22, 0x27	; 39
    235a:	78 e0       	ldi	r23, 0x08	; 8
    235c:	8a e3       	ldi	r24, 0x3A	; 58
    235e:	98 e0       	ldi	r25, 0x08	; 8
    2360:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <strcpy>
      add_user_code_prompt();
    2364:	0e 94 55 11 	call	0x22aa	; 0x22aa <add_user_code_prompt>
    2368:	08 95       	ret
      }
    else {
      // Prompt the user to enter the user code
      println_msg("\rThe user already exists!\t");
    236a:	84 ec       	ldi	r24, 0xC4	; 196
    236c:	96 e0       	ldi	r25, 0x06	; 6
    236e:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
      //! Return to the main menu
      initial_options_menu();
    2372:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <initial_options_menu>
    2376:	08 95       	ret

00002378 <invalid_remote_login_attempt>:
  // // Show the options menu
  // initial_options_menu();
  // }
  }

void invalid_remote_login_attempt(void) {
    2378:	0f 93       	push	r16
    237a:	1f 93       	push	r17
    237c:	cf 93       	push	r28
    237e:	df 93       	push	r29
    2380:	cd b7       	in	r28, 0x3d	; 61
    2382:	de b7       	in	r29, 0x3e	; 62
    2384:	e2 97       	sbiw	r28, 0x32	; 50
    2386:	0f b6       	in	r0, 0x3f	; 63
    2388:	f8 94       	cli
    238a:	de bf       	out	0x3e, r29	; 62
    238c:	0f be       	out	0x3f, r0	; 63
    238e:	cd bf       	out	0x3d, r28	; 61
  invalid_trails++;
    2390:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <invalid_trails>
    2394:	8f 5f       	subi	r24, 0xFF	; 255
    2396:	80 93 aa 07 	sts	0x07AA, r24	; 0x8007aa <invalid_trails>
  s8 msg[50];
  if (invalid_trails < 3) {
    239a:	83 30       	cpi	r24, 0x03	; 3
    239c:	e8 f4       	brcc	.+58     	; 0x23d8 <invalid_remote_login_attempt+0x60>
    sprintf(msg, "Invalid login attempt! \r\n%d attempts remaining.", 3 - invalid_trails);
    239e:	23 e0       	ldi	r18, 0x03	; 3
    23a0:	30 e0       	ldi	r19, 0x00	; 0
    23a2:	a9 01       	movw	r20, r18
    23a4:	48 1b       	sub	r20, r24
    23a6:	51 09       	sbc	r21, r1
    23a8:	ca 01       	movw	r24, r20
    23aa:	9f 93       	push	r25
    23ac:	4f 93       	push	r20
    23ae:	8f ed       	ldi	r24, 0xDF	; 223
    23b0:	96 e0       	ldi	r25, 0x06	; 6
    23b2:	9f 93       	push	r25
    23b4:	8f 93       	push	r24
    23b6:	8e 01       	movw	r16, r28
    23b8:	0f 5f       	subi	r16, 0xFF	; 255
    23ba:	1f 4f       	sbci	r17, 0xFF	; 255
    23bc:	1f 93       	push	r17
    23be:	0f 93       	push	r16
    23c0:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <sprintf>
    println_msg(msg);
    23c4:	c8 01       	movw	r24, r16
    23c6:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
    return;
    23ca:	0f 90       	pop	r0
    23cc:	0f 90       	pop	r0
    23ce:	0f 90       	pop	r0
    23d0:	0f 90       	pop	r0
    23d2:	0f 90       	pop	r0
    23d4:	0f 90       	pop	r0
    23d6:	0f c0       	rjmp	.+30     	; 0x23f6 <invalid_remote_login_attempt+0x7e>
    }
  strcpy(msg, "Too many login attempts! \r--- System Suspended! ---");
    23d8:	84 e3       	ldi	r24, 0x34	; 52
    23da:	ef e0       	ldi	r30, 0x0F	; 15
    23dc:	f7 e0       	ldi	r31, 0x07	; 7
    23de:	de 01       	movw	r26, r28
    23e0:	11 96       	adiw	r26, 0x01	; 1
    23e2:	01 90       	ld	r0, Z+
    23e4:	0d 92       	st	X+, r0
    23e6:	8a 95       	dec	r24
    23e8:	e1 f7       	brne	.-8      	; 0x23e2 <invalid_remote_login_attempt+0x6a>
  println_msg(msg);
    23ea:	ce 01       	movw	r24, r28
    23ec:	01 96       	adiw	r24, 0x01	; 1
    23ee:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
  run_system = false;
    23f2:	10 92 a9 07 	sts	0x07A9, r1	; 0x8007a9 <run_system>
  }
    23f6:	e2 96       	adiw	r28, 0x32	; 50
    23f8:	0f b6       	in	r0, 0x3f	; 63
    23fa:	f8 94       	cli
    23fc:	de bf       	out	0x3e, r29	; 62
    23fe:	0f be       	out	0x3f, r0	; 63
    2400:	cd bf       	out	0x3d, r28	; 61
    2402:	df 91       	pop	r29
    2404:	cf 91       	pop	r28
    2406:	1f 91       	pop	r17
    2408:	0f 91       	pop	r16
    240a:	08 95       	ret

0000240c <userPassword_prompt_handler>:
      }
    }
  }

void userPassword_prompt_handler(void) {
  if (!user_input_accepted) {
    240c:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    2410:	81 11       	cpse	r24, r1
    2412:	0e c0       	rjmp	.+28     	; 0x2430 <userPassword_prompt_handler+0x24>
    print_msg("Enter your password:\t");
    2414:	83 e4       	ldi	r24, 0x43	; 67
    2416:	97 e0       	ldi	r25, 0x07	; 7
    2418:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <print_msg>
    request_user_input(userPassword_prompt_handler, 11, true);
    241c:	41 e0       	ldi	r20, 0x01	; 1
    241e:	6b e0       	ldi	r22, 0x0B	; 11
    2420:	86 e0       	ldi	r24, 0x06	; 6
    2422:	92 e1       	ldi	r25, 0x12	; 18
    2424:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
    user_input_accepted = true;
    2428:	81 e0       	ldi	r24, 0x01	; 1
    242a:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    242e:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    2430:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (strcmp(remote_user.password, msg_buffer)) { // Wrong password
    2434:	67 e2       	ldi	r22, 0x27	; 39
    2436:	78 e0       	ldi	r23, 0x08	; 8
    2438:	8c ef       	ldi	r24, 0xFC	; 252
    243a:	97 e0       	ldi	r25, 0x07	; 7
    243c:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <strcmp>
    2440:	89 2b       	or	r24, r25
    2442:	49 f0       	breq	.+18     	; 0x2456 <userPassword_prompt_handler+0x4a>
      println_msg("Wrong password!");
    2444:	89 e5       	ldi	r24, 0x59	; 89
    2446:	97 e0       	ldi	r25, 0x07	; 7
    2448:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
      invalid_remote_login_attempt();
    244c:	0e 94 bc 11 	call	0x2378	; 0x2378 <invalid_remote_login_attempt>
      userPassword_prompt_handler();
    2450:	0e 94 06 12 	call	0x240c	; 0x240c <userPassword_prompt_handler>
    2454:	08 95       	ret
      }
    else {
      remote_user_loggedin = true;
    2456:	81 e0       	ldi	r24, 0x01	; 1
    2458:	80 93 a8 07 	sts	0x07A8, r24	; 0x8007a8 <remote_user_loggedin>
      print_msg("Welcome ");
    245c:	89 e6       	ldi	r24, 0x69	; 105
    245e:	97 e0       	ldi	r25, 0x07	; 7
    2460:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <print_msg>
      print_msg(remote_user.name);
    2464:	88 ee       	ldi	r24, 0xE8	; 232
    2466:	97 e0       	ldi	r25, 0x07	; 7
    2468:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <print_msg>
      println_msg("!");
    246c:	83 ee       	ldi	r24, 0xE3	; 227
    246e:	91 e0       	ldi	r25, 0x01	; 1
    2470:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
      // Show the options menu
      initial_options_menu();
    2474:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <initial_options_menu>
    2478:	08 95       	ret

0000247a <userName_prompt_handler>:
    }
  }

void userName_prompt_handler(void) {
  // Request user input for the first time and in case of wrong input
  if (!user_input_accepted) {
    247a:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    247e:	81 11       	cpse	r24, r1
    2480:	0e c0       	rjmp	.+28     	; 0x249e <userName_prompt_handler+0x24>
    print_msg("Enter your user name:\t");
    2482:	82 e7       	ldi	r24, 0x72	; 114
    2484:	97 e0       	ldi	r25, 0x07	; 7
    2486:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <print_msg>
    request_user_input(userName_prompt_handler, 13, false);
    248a:	40 e0       	ldi	r20, 0x00	; 0
    248c:	6d e0       	ldi	r22, 0x0D	; 13
    248e:	8d e3       	ldi	r24, 0x3D	; 61
    2490:	92 e1       	ldi	r25, 0x12	; 18
    2492:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <request_user_input>
    user_input_accepted = true;
    2496:	81 e0       	ldi	r24, 0x01	; 1
    2498:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    249c:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &remote_user);
    249e:	67 ee       	ldi	r22, 0xE7	; 231
    24a0:	77 e0       	ldi	r23, 0x07	; 7
    24a2:	87 e2       	ldi	r24, 0x27	; 39
    24a4:	98 e0       	ldi	r25, 0x08	; 8
    24a6:	0e 94 6f 13 	call	0x26de	; 0x26de <getUserByName>
    user_input_accepted = false;
    24aa:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (userExists == USER_NOT_FOUND) {
    24ae:	83 30       	cpi	r24, 0x03	; 3
    24b0:	49 f4       	brne	.+18     	; 0x24c4 <userName_prompt_handler+0x4a>
      println_msg("User doesn't exist!");
    24b2:	89 e8       	ldi	r24, 0x89	; 137
    24b4:	97 e0       	ldi	r25, 0x07	; 7
    24b6:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
      invalid_remote_login_attempt();
    24ba:	0e 94 bc 11 	call	0x2378	; 0x2378 <invalid_remote_login_attempt>
      userName_prompt_handler();
    24be:	0e 94 3d 12 	call	0x247a	; 0x247a <userName_prompt_handler>
    24c2:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      userPassword_prompt_handler();
    24c4:	0e 94 06 12 	call	0x240c	; 0x240c <userPassword_prompt_handler>
    24c8:	08 95       	ret

000024ca <remote_login_prompt>:
  }

void remote_login_prompt(void) {
  //! for some reason this part causes a compilation error related to .bss section in memory!!!! 
  // if (!remote_user_loggedin) {
  println_msg("Welcome!");
    24ca:	8d e9       	ldi	r24, 0x9D	; 157
    24cc:	97 e0       	ldi	r25, 0x07	; 7
    24ce:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <println_msg>
  // println_msg("Welcome to the Smart Home System!");
  // println_msg("To proceed, please login.");
  userName_prompt_handler();
    24d2:	0e 94 3d 12 	call	0x247a	; 0x247a <userName_prompt_handler>
    24d6:	08 95       	ret

000024d8 <__vector_13>:
  println_msg(msg);
  run_system = false;
  }

// Handles the user input asynchronously.
ISR(USART_RXC_vect) {
    24d8:	1f 92       	push	r1
    24da:	0f 92       	push	r0
    24dc:	0f b6       	in	r0, 0x3f	; 63
    24de:	0f 92       	push	r0
    24e0:	11 24       	eor	r1, r1
    24e2:	2f 93       	push	r18
    24e4:	3f 93       	push	r19
    24e6:	4f 93       	push	r20
    24e8:	5f 93       	push	r21
    24ea:	6f 93       	push	r22
    24ec:	7f 93       	push	r23
    24ee:	8f 93       	push	r24
    24f0:	9f 93       	push	r25
    24f2:	af 93       	push	r26
    24f4:	bf 93       	push	r27
    24f6:	ef 93       	push	r30
    24f8:	ff 93       	push	r31
#if UART_COMMUNICATION_INTERFACE ==  PROTEUS_VIRTUAL_TERMINAL
  // Read the UDR to clear the RXC bit
  udr_temp = UDR;
    24fa:	8c b1       	in	r24, 0x0c	; 12
    24fc:	80 93 37 08 	sts	0x0837, r24	; 0x800837 <udr_temp>

  // If no input requested, ignore the input. No input requested is indicated by msg length of zero
  if (msg_length == 0) return;
    2500:	90 91 36 08 	lds	r25, 0x0836	; 0x800836 <msg_length>
    2504:	99 23       	and	r25, r25
    2506:	09 f4       	brne	.+2      	; 0x250a <__vector_13+0x32>
    2508:	5b c0       	rjmp	.+182    	; 0x25c0 <__vector_13+0xe8>

  // Accept numbers only in the numerical input mode
  if (numerical_input_mode) {
    250a:	90 91 e6 07 	lds	r25, 0x07E6	; 0x8007e6 <numerical_input_mode>
    250e:	99 23       	and	r25, r25
    2510:	59 f0       	breq	.+22     	; 0x2528 <__vector_13+0x50>
    if (!((udr_temp >= '0' && udr_temp <= '9') || udr_temp == '\b' || udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER || udr_temp == '\n')) {
    2512:	90 ed       	ldi	r25, 0xD0	; 208
    2514:	98 0f       	add	r25, r24
    2516:	9a 30       	cpi	r25, 0x0A	; 10
    2518:	38 f0       	brcs	.+14     	; 0x2528 <__vector_13+0x50>
    251a:	88 30       	cpi	r24, 0x08	; 8
    251c:	29 f0       	breq	.+10     	; 0x2528 <__vector_13+0x50>
    251e:	8d 30       	cpi	r24, 0x0D	; 13
    2520:	19 f0       	breq	.+6      	; 0x2528 <__vector_13+0x50>
    2522:	8a 30       	cpi	r24, 0x0A	; 10
    2524:	09 f0       	breq	.+2      	; 0x2528 <__vector_13+0x50>
    2526:	4c c0       	rjmp	.+152    	; 0x25c0 <__vector_13+0xe8>
      return;
      }
    }

  // Handling backspaces
  if (udr_temp == '\b') {
    2528:	88 30       	cpi	r24, 0x08	; 8
    252a:	59 f4       	brne	.+22     	; 0x2542 <__vector_13+0x6a>
    if (msg_buffer_pointer > 0) {
    252c:	90 91 e5 07 	lds	r25, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    2530:	99 23       	and	r25, r25
    2532:	09 f4       	brne	.+2      	; 0x2536 <__vector_13+0x5e>
    2534:	45 c0       	rjmp	.+138    	; 0x25c0 <__vector_13+0xe8>
      msg_buffer_pointer--;
    2536:	91 50       	subi	r25, 0x01	; 1
    2538:	90 93 e5 07 	sts	0x07E5, r25	; 0x8007e5 <msg_buffer_pointer>
      BT_sendChar(udr_temp);
    253c:	0e 94 02 02 	call	0x404	; 0x404 <BT_sendChar>
    2540:	3f c0       	rjmp	.+126    	; 0x25c0 <__vector_13+0xe8>
      }
    return;
    }

  msg_buffer[msg_buffer_pointer] = udr_temp;
    2542:	90 91 e5 07 	lds	r25, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    2546:	e9 2f       	mov	r30, r25
    2548:	f0 e0       	ldi	r31, 0x00	; 0
    254a:	e9 5d       	subi	r30, 0xD9	; 217
    254c:	f7 4f       	sbci	r31, 0xF7	; 247
    254e:	80 83       	st	Z, r24
  msg_buffer_pointer++;
    2550:	9f 5f       	subi	r25, 0xFF	; 255
    2552:	90 93 e5 07 	sts	0x07E5, r25	; 0x8007e5 <msg_buffer_pointer>

  // Msg is empty
  // Ignore null msgs
  if (msg_buffer_pointer == 1) {
    2556:	91 30       	cpi	r25, 0x01	; 1
    2558:	39 f4       	brne	.+14     	; 0x2568 <__vector_13+0x90>
    if (msg_buffer[0] == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    255a:	90 91 27 08 	lds	r25, 0x0827	; 0x800827 <msg_buffer>
    255e:	9d 30       	cpi	r25, 0x0D	; 13
    2560:	19 f4       	brne	.+6      	; 0x2568 <__vector_13+0x90>
      msg_buffer_pointer = 0;
    2562:	10 92 e5 07 	sts	0x07E5, r1	; 0x8007e5 <msg_buffer_pointer>
      return;
    2566:	2c c0       	rjmp	.+88     	; 0x25c0 <__vector_13+0xe8>
      }
    }

  // Echo the sent char on the terminal
  //! Proteus virtual terminal doesn't send a line feed char (ASCII code: 10). Instead it sends a carriage return (ASCII code: 13).
  if (udr_temp != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER)
    2568:	8d 30       	cpi	r24, 0x0D	; 13
    256a:	11 f0       	breq	.+4      	; 0x2570 <__vector_13+0x98>
    BT_sendChar(udr_temp);
    256c:	0e 94 02 02 	call	0x404	; 0x404 <BT_sendChar>

  // Msg is longer than required
  // Delete the last input char. Don't allow the user to enter longer input than the maximum required
  if (msg_buffer_pointer == msg_length) {
    2570:	80 91 e5 07 	lds	r24, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    2574:	90 91 36 08 	lds	r25, 0x0836	; 0x800836 <msg_length>
    2578:	89 13       	cpse	r24, r25
    257a:	0d c0       	rjmp	.+26     	; 0x2596 <__vector_13+0xbe>
    if (msg_buffer[msg_buffer_pointer - 1] != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    257c:	e8 2f       	mov	r30, r24
    257e:	f0 e0       	ldi	r31, 0x00	; 0
    2580:	ea 5d       	subi	r30, 0xDA	; 218
    2582:	f7 4f       	sbci	r31, 0xF7	; 247
    2584:	90 81       	ld	r25, Z
    2586:	9d 30       	cpi	r25, 0x0D	; 13
    2588:	31 f0       	breq	.+12     	; 0x2596 <__vector_13+0xbe>
      msg_buffer_pointer--;
    258a:	81 50       	subi	r24, 0x01	; 1
    258c:	80 93 e5 07 	sts	0x07E5, r24	; 0x8007e5 <msg_buffer_pointer>
      BT_sendChar('\b');
    2590:	88 e0       	ldi	r24, 0x08	; 8
    2592:	0e 94 02 02 	call	0x404	; 0x404 <BT_sendChar>
      }
    }

  // Msg has ended and is within the required length
  if (udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    2596:	80 91 37 08 	lds	r24, 0x0837	; 0x800837 <udr_temp>
    259a:	8d 30       	cpi	r24, 0x0D	; 13
    259c:	89 f4       	brne	.+34     	; 0x25c0 <__vector_13+0xe8>
    if (msg_buffer_pointer <= msg_length) {
    259e:	e0 91 e5 07 	lds	r30, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    25a2:	80 91 36 08 	lds	r24, 0x0836	; 0x800836 <msg_length>
    25a6:	8e 17       	cp	r24, r30
    25a8:	58 f0       	brcs	.+22     	; 0x25c0 <__vector_13+0xe8>
      // Replace the carriage return with null to terminate the string correctly
      msg_buffer[msg_buffer_pointer - 1] = '\0';
    25aa:	f0 e0       	ldi	r31, 0x00	; 0
    25ac:	ea 5d       	subi	r30, 0xDA	; 218
    25ae:	f7 4f       	sbci	r31, 0xF7	; 247
    25b0:	10 82       	st	Z, r1
      BT_sendChar('\r');
    25b2:	8d e0       	ldi	r24, 0x0D	; 13
    25b4:	0e 94 02 02 	call	0x404	; 0x404 <BT_sendChar>
      callFunWhenBufferReady();
    25b8:	0e 94 43 0f 	call	0x1e86	; 0x1e86 <callFunWhenBufferReady>
      msg_buffer_pointer = 0;
    25bc:	10 92 e5 07 	sts	0x07E5, r1	; 0x8007e5 <msg_buffer_pointer>
      callFunWhenBufferReady();
      msg_buffer_pointer = 0;
      }
    }
#endif
  }
    25c0:	ff 91       	pop	r31
    25c2:	ef 91       	pop	r30
    25c4:	bf 91       	pop	r27
    25c6:	af 91       	pop	r26
    25c8:	9f 91       	pop	r25
    25ca:	8f 91       	pop	r24
    25cc:	7f 91       	pop	r23
    25ce:	6f 91       	pop	r22
    25d0:	5f 91       	pop	r21
    25d2:	4f 91       	pop	r20
    25d4:	3f 91       	pop	r19
    25d6:	2f 91       	pop	r18
    25d8:	0f 90       	pop	r0
    25da:	0f be       	out	0x3f, r0	; 63
    25dc:	0f 90       	pop	r0
    25de:	1f 90       	pop	r1
    25e0:	18 95       	reti

000025e2 <__vector_1>:

ISR(INT0_vect) {
    25e2:	1f 92       	push	r1
    25e4:	0f 92       	push	r0
    25e6:	0f b6       	in	r0, 0x3f	; 63
    25e8:	0f 92       	push	r0
    25ea:	11 24       	eor	r1, r1
    25ec:	2f 93       	push	r18
    25ee:	3f 93       	push	r19
    25f0:	4f 93       	push	r20
    25f2:	5f 93       	push	r21
    25f4:	6f 93       	push	r22
    25f6:	7f 93       	push	r23
    25f8:	8f 93       	push	r24
    25fa:	9f 93       	push	r25
    25fc:	af 93       	push	r26
    25fe:	bf 93       	push	r27
    2600:	ef 93       	push	r30
    2602:	ff 93       	push	r31
  // Initialize communication with the user
  // Request user login credentials
  remote_login_prompt();
    2604:	0e 94 65 12 	call	0x24ca	; 0x24ca <remote_login_prompt>
  }
    2608:	ff 91       	pop	r31
    260a:	ef 91       	pop	r30
    260c:	bf 91       	pop	r27
    260e:	af 91       	pop	r26
    2610:	9f 91       	pop	r25
    2612:	8f 91       	pop	r24
    2614:	7f 91       	pop	r23
    2616:	6f 91       	pop	r22
    2618:	5f 91       	pop	r21
    261a:	4f 91       	pop	r20
    261c:	3f 91       	pop	r19
    261e:	2f 91       	pop	r18
    2620:	0f 90       	pop	r0
    2622:	0f be       	out	0x3f, r0	; 63
    2624:	0f 90       	pop	r0
    2626:	1f 90       	pop	r1
    2628:	18 95       	reti

0000262a <AC_auto_control_service_start>:
  DIO_write(AC_PIN, AC_PORT, LOW);
  // Turn off the timer
#if AC_ADC_TRIGGER == TIMER_0_COMPARE_MATCH_TRIGGER
  Timer_stop(TIMER_0);
#elif AC_ADC_TRIGGER == TIMER_0_OVF_TRIGGER
  Timer_stop(TIMER_0);
    262a:	64 e0       	ldi	r22, 0x04	; 4
    262c:	87 e0       	ldi	r24, 0x07	; 7
    262e:	0e 94 28 04 	call	0x850	; 0x850 <LM35_init_INT>
    2632:	41 e0       	ldi	r20, 0x01	; 1
    2634:	63 e4       	ldi	r22, 0x43	; 67
    2636:	87 e0       	ldi	r24, 0x07	; 7
    2638:	0e 94 cb 04 	call	0x996	; 0x996 <DIO_init>
    263c:	0e 94 fd 06 	call	0xdfa	; 0xdfa <ADC_INT_init>
    2640:	60 e0       	ldi	r22, 0x00	; 0
    2642:	70 e0       	ldi	r23, 0x00	; 0
    2644:	80 e0       	ldi	r24, 0x00	; 0
    2646:	0e 94 8f 08 	call	0x111e	; 0x111e <Timer_normal_init>
    264a:	60 e0       	ldi	r22, 0x00	; 0
    264c:	74 e0       	ldi	r23, 0x04	; 4
    264e:	80 e0       	ldi	r24, 0x00	; 0
    2650:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <Timer_start>
    2654:	08 95       	ret

00002656 <__vector_16>:
#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_BY_ACTIVATING_TIMER0_OVF_INT
// To reset the TOV0 flag. Alternatively, it can be reset in the ADC complete interrupt.
ISR(TIMER0_OVF_vect) {}
#endif

ISR(ADC_vect) {
    2656:	1f 92       	push	r1
    2658:	0f 92       	push	r0
    265a:	0f b6       	in	r0, 0x3f	; 63
    265c:	0f 92       	push	r0
    265e:	11 24       	eor	r1, r1
    2660:	2f 93       	push	r18
    2662:	3f 93       	push	r19
    2664:	4f 93       	push	r20
    2666:	5f 93       	push	r21
    2668:	6f 93       	push	r22
    266a:	7f 93       	push	r23
    266c:	8f 93       	push	r24
    266e:	9f 93       	push	r25
    2670:	af 93       	push	r26
    2672:	bf 93       	push	r27
    2674:	cf 93       	push	r28
    2676:	df 93       	push	r29
    2678:	ef 93       	push	r30
    267a:	ff 93       	push	r31
  u16 temperature;
  temperature = ADCL + (ADCH << 8);
    267c:	84 b1       	in	r24, 0x04	; 4
    267e:	c5 b1       	in	r28, 0x05	; 5
    2680:	d0 e0       	ldi	r29, 0x00	; 0
    2682:	dc 2f       	mov	r29, r28
    2684:	cc 27       	eor	r28, r28
    2686:	c8 0f       	add	r28, r24
    2688:	d1 1d       	adc	r29, r1
  // Since the ADC is set to use the internal VREF of 2.56 V, the resolution of the ADC is 2.5 mV. This resolution allows to measure the temperature
  // out of the LM35 with a resolution of 0.25 degree celsius, since each 10mV  increment on the LM35 output is 1 degree C.
  // If the temperature is higher than the maximum specified temperature, turn on the AC.
  if (temperature > AMBIENT_HIGH_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, HIGH);
    268a:	c1 37       	cpi	r28, 0x71	; 113
    268c:	d1 05       	cpc	r29, r1
    268e:	28 f0       	brcs	.+10     	; 0x269a <__vector_16+0x44>
    2690:	41 e0       	ldi	r20, 0x01	; 1
    2692:	63 e4       	ldi	r22, 0x43	; 67
    2694:	87 e0       	ldi	r24, 0x07	; 7
    2696:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>
  // If the temperature became below the minimum specified temperature turn off the AC.
  if (temperature < AMBIENT_LOW_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, LOW);
    269a:	c4 35       	cpi	r28, 0x54	; 84
    269c:	d1 05       	cpc	r29, r1
    269e:	28 f4       	brcc	.+10     	; 0x26aa <__vector_16+0x54>
    26a0:	40 e0       	ldi	r20, 0x00	; 0
    26a2:	63 e4       	ldi	r22, 0x43	; 67
    26a4:	87 e0       	ldi	r24, 0x07	; 7
    26a6:	0e 94 65 05 	call	0xaca	; 0xaca <DIO_write>

#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_VIA_ADC_COMPLETE_INTERRUPT
  // Since the ADC is configured in auto trigger mode with timer 0 overflow as the trigger, 
  // The overflow interrupt flag bit must be cleared by software if timer 0 overflow interrupt isn't used. 
  // Otherwise the triggering won't work and the ADC will halt.
  set_bit(TIFR, TOV0);
    26aa:	88 b7       	in	r24, 0x38	; 56
    26ac:	81 60       	ori	r24, 0x01	; 1
    26ae:	88 bf       	out	0x38, r24	; 56
#endif
    26b0:	ff 91       	pop	r31
    26b2:	ef 91       	pop	r30
    26b4:	df 91       	pop	r29
    26b6:	cf 91       	pop	r28
    26b8:	bf 91       	pop	r27
    26ba:	af 91       	pop	r26
    26bc:	9f 91       	pop	r25
    26be:	8f 91       	pop	r24
    26c0:	7f 91       	pop	r23
    26c2:	6f 91       	pop	r22
    26c4:	5f 91       	pop	r21
    26c6:	4f 91       	pop	r20
    26c8:	3f 91       	pop	r19
    26ca:	2f 91       	pop	r18
    26cc:	0f 90       	pop	r0
    26ce:	0f be       	out	0x3f, r0	; 63
    26d0:	0f 90       	pop	r0
    26d2:	1f 90       	pop	r1
    26d4:	18 95       	reti

000026d6 <User_DB_init>:
    return getUserByName(user_code_or_name, user);
    }
  else {
    return getUserByCode(user_code_or_name, user);
    }
  }
    26d6:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <EEPROM_init>
    26da:	88 e0       	ldi	r24, 0x08	; 8
    26dc:	08 95       	ret

000026de <getUserByName>:
    26de:	9f 92       	push	r9
    26e0:	af 92       	push	r10
    26e2:	bf 92       	push	r11
    26e4:	cf 92       	push	r12
    26e6:	df 92       	push	r13
    26e8:	ef 92       	push	r14
    26ea:	ff 92       	push	r15
    26ec:	0f 93       	push	r16
    26ee:	1f 93       	push	r17
    26f0:	cf 93       	push	r28
    26f2:	df 93       	push	r29
    26f4:	cd b7       	in	r28, 0x3d	; 61
    26f6:	de b7       	in	r29, 0x3e	; 62
    26f8:	6d 97       	sbiw	r28, 0x1d	; 29
    26fa:	0f b6       	in	r0, 0x3f	; 63
    26fc:	f8 94       	cli
    26fe:	de bf       	out	0x3e, r29	; 62
    2700:	0f be       	out	0x3f, r0	; 63
    2702:	cd bf       	out	0x3d, r28	; 61
    2704:	7c 01       	movw	r14, r24
    2706:	6b 01       	movw	r12, r22
    2708:	91 2c       	mov	r9, r1
    270a:	6b c0       	rjmp	.+214    	; 0x27e2 <getUserByName+0x104>
    270c:	ae 01       	movw	r20, r28
    270e:	4f 5f       	subi	r20, 0xFF	; 255
    2710:	5f 4f       	sbci	r21, 0xFF	; 255
    2712:	60 e0       	ldi	r22, 0x00	; 0
    2714:	89 2d       	mov	r24, r9
    2716:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    271a:	ae 01       	movw	r20, r28
    271c:	4e 5f       	subi	r20, 0xFE	; 254
    271e:	5f 4f       	sbci	r21, 0xFF	; 255
    2720:	61 e0       	ldi	r22, 0x01	; 1
    2722:	89 2d       	mov	r24, r9
    2724:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    2728:	b1 2c       	mov	r11, r1
    272a:	56 c0       	rjmp	.+172    	; 0x27d8 <getUserByName+0xfa>
    272c:	89 81       	ldd	r24, Y+1	; 0x01
    272e:	90 e0       	ldi	r25, 0x00	; 0
    2730:	0b 2c       	mov	r0, r11
    2732:	02 c0       	rjmp	.+4      	; 0x2738 <getUserByName+0x5a>
    2734:	95 95       	asr	r25
    2736:	87 95       	ror	r24
    2738:	0a 94       	dec	r0
    273a:	e2 f7       	brpl	.-8      	; 0x2734 <getUserByName+0x56>
    273c:	80 ff       	sbrs	r24, 0
    273e:	4b c0       	rjmp	.+150    	; 0x27d6 <getUserByName+0xf8>
    2740:	6f e1       	ldi	r22, 0x1F	; 31
    2742:	b6 9e       	mul	r11, r22
    2744:	a0 2c       	mov	r10, r0
    2746:	11 24       	eor	r1, r1
    2748:	68 e0       	ldi	r22, 0x08	; 8
    274a:	6a 0d       	add	r22, r10
    274c:	9e 01       	movw	r18, r28
    274e:	2d 5f       	subi	r18, 0xFD	; 253
    2750:	3f 4f       	sbci	r19, 0xFF	; 255
    2752:	4d e0       	ldi	r20, 0x0D	; 13
    2754:	50 e0       	ldi	r21, 0x00	; 0
    2756:	89 2d       	mov	r24, r9
    2758:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    275c:	be 01       	movw	r22, r28
    275e:	6d 5f       	subi	r22, 0xFD	; 253
    2760:	7f 4f       	sbci	r23, 0xFF	; 255
    2762:	c7 01       	movw	r24, r14
    2764:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <strcmp>
    2768:	89 2b       	or	r24, r25
    276a:	a9 f5       	brne	.+106    	; 0x27d6 <getUserByName+0xf8>
    276c:	65 e1       	ldi	r22, 0x15	; 21
    276e:	6a 0d       	add	r22, r10
    2770:	9e 01       	movw	r18, r28
    2772:	20 5f       	subi	r18, 0xF0	; 240
    2774:	3f 4f       	sbci	r19, 0xFF	; 255
    2776:	47 e0       	ldi	r20, 0x07	; 7
    2778:	50 e0       	ldi	r21, 0x00	; 0
    277a:	89 2d       	mov	r24, r9
    277c:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    2780:	6c e1       	ldi	r22, 0x1C	; 28
    2782:	6a 0d       	add	r22, r10
    2784:	9e 01       	movw	r18, r28
    2786:	29 5e       	subi	r18, 0xE9	; 233
    2788:	3f 4f       	sbci	r19, 0xFF	; 255
    278a:	47 e0       	ldi	r20, 0x07	; 7
    278c:	50 e0       	ldi	r21, 0x00	; 0
    278e:	89 2d       	mov	r24, r9
    2790:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    2794:	8a 81       	ldd	r24, Y+2	; 0x02
    2796:	90 e0       	ldi	r25, 0x00	; 0
    2798:	02 c0       	rjmp	.+4      	; 0x279e <getUserByName+0xc0>
    279a:	95 95       	asr	r25
    279c:	87 95       	ror	r24
    279e:	ba 94       	dec	r11
    27a0:	e2 f7       	brpl	.-8      	; 0x279a <getUserByName+0xbc>
    27a2:	98 2f       	mov	r25, r24
    27a4:	91 70       	andi	r25, 0x01	; 1
    27a6:	f6 01       	movw	r30, r12
    27a8:	91 93       	st	Z+, r25
    27aa:	be 01       	movw	r22, r28
    27ac:	6d 5f       	subi	r22, 0xFD	; 253
    27ae:	7f 4f       	sbci	r23, 0xFF	; 255
    27b0:	cf 01       	movw	r24, r30
    27b2:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <strcpy>
    27b6:	be 01       	movw	r22, r28
    27b8:	60 5f       	subi	r22, 0xF0	; 240
    27ba:	7f 4f       	sbci	r23, 0xFF	; 255
    27bc:	c6 01       	movw	r24, r12
    27be:	0e 96       	adiw	r24, 0x0e	; 14
    27c0:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <strcpy>
    27c4:	be 01       	movw	r22, r28
    27c6:	69 5e       	subi	r22, 0xE9	; 233
    27c8:	7f 4f       	sbci	r23, 0xFF	; 255
    27ca:	c6 01       	movw	r24, r12
    27cc:	45 96       	adiw	r24, 0x15	; 21
    27ce:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <strcpy>
    27d2:	82 e0       	ldi	r24, 0x02	; 2
    27d4:	0b c0       	rjmp	.+22     	; 0x27ec <getUserByName+0x10e>
    27d6:	b3 94       	inc	r11
    27d8:	87 e0       	ldi	r24, 0x07	; 7
    27da:	8b 15       	cp	r24, r11
    27dc:	08 f0       	brcs	.+2      	; 0x27e0 <getUserByName+0x102>
    27de:	a6 cf       	rjmp	.-180    	; 0x272c <getUserByName+0x4e>
    27e0:	93 94       	inc	r9
    27e2:	87 e0       	ldi	r24, 0x07	; 7
    27e4:	89 15       	cp	r24, r9
    27e6:	08 f0       	brcs	.+2      	; 0x27ea <getUserByName+0x10c>
    27e8:	91 cf       	rjmp	.-222    	; 0x270c <getUserByName+0x2e>
    27ea:	83 e0       	ldi	r24, 0x03	; 3
    27ec:	6d 96       	adiw	r28, 0x1d	; 29
    27ee:	0f b6       	in	r0, 0x3f	; 63
    27f0:	f8 94       	cli
    27f2:	de bf       	out	0x3e, r29	; 62
    27f4:	0f be       	out	0x3f, r0	; 63
    27f6:	cd bf       	out	0x3d, r28	; 61
    27f8:	df 91       	pop	r29
    27fa:	cf 91       	pop	r28
    27fc:	1f 91       	pop	r17
    27fe:	0f 91       	pop	r16
    2800:	ff 90       	pop	r15
    2802:	ef 90       	pop	r14
    2804:	df 90       	pop	r13
    2806:	cf 90       	pop	r12
    2808:	bf 90       	pop	r11
    280a:	af 90       	pop	r10
    280c:	9f 90       	pop	r9
    280e:	08 95       	ret

00002810 <getUserByCode>:
    2810:	9f 92       	push	r9
    2812:	af 92       	push	r10
    2814:	bf 92       	push	r11
    2816:	cf 92       	push	r12
    2818:	df 92       	push	r13
    281a:	ef 92       	push	r14
    281c:	ff 92       	push	r15
    281e:	0f 93       	push	r16
    2820:	1f 93       	push	r17
    2822:	cf 93       	push	r28
    2824:	df 93       	push	r29
    2826:	cd b7       	in	r28, 0x3d	; 61
    2828:	de b7       	in	r29, 0x3e	; 62
    282a:	6d 97       	sbiw	r28, 0x1d	; 29
    282c:	0f b6       	in	r0, 0x3f	; 63
    282e:	f8 94       	cli
    2830:	de bf       	out	0x3e, r29	; 62
    2832:	0f be       	out	0x3f, r0	; 63
    2834:	cd bf       	out	0x3d, r28	; 61
    2836:	7c 01       	movw	r14, r24
    2838:	6b 01       	movw	r12, r22
    283a:	91 2c       	mov	r9, r1
    283c:	6b c0       	rjmp	.+214    	; 0x2914 <getUserByCode+0x104>
    283e:	ae 01       	movw	r20, r28
    2840:	4f 5f       	subi	r20, 0xFF	; 255
    2842:	5f 4f       	sbci	r21, 0xFF	; 255
    2844:	60 e0       	ldi	r22, 0x00	; 0
    2846:	89 2d       	mov	r24, r9
    2848:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    284c:	ae 01       	movw	r20, r28
    284e:	4e 5f       	subi	r20, 0xFE	; 254
    2850:	5f 4f       	sbci	r21, 0xFF	; 255
    2852:	61 e0       	ldi	r22, 0x01	; 1
    2854:	89 2d       	mov	r24, r9
    2856:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    285a:	b1 2c       	mov	r11, r1
    285c:	56 c0       	rjmp	.+172    	; 0x290a <getUserByCode+0xfa>
    285e:	89 81       	ldd	r24, Y+1	; 0x01
    2860:	90 e0       	ldi	r25, 0x00	; 0
    2862:	0b 2c       	mov	r0, r11
    2864:	02 c0       	rjmp	.+4      	; 0x286a <getUserByCode+0x5a>
    2866:	95 95       	asr	r25
    2868:	87 95       	ror	r24
    286a:	0a 94       	dec	r0
    286c:	e2 f7       	brpl	.-8      	; 0x2866 <getUserByCode+0x56>
    286e:	80 ff       	sbrs	r24, 0
    2870:	4b c0       	rjmp	.+150    	; 0x2908 <getUserByCode+0xf8>
    2872:	6f e1       	ldi	r22, 0x1F	; 31
    2874:	b6 9e       	mul	r11, r22
    2876:	a0 2c       	mov	r10, r0
    2878:	11 24       	eor	r1, r1
    287a:	65 e1       	ldi	r22, 0x15	; 21
    287c:	6a 0d       	add	r22, r10
    287e:	9e 01       	movw	r18, r28
    2880:	20 5f       	subi	r18, 0xF0	; 240
    2882:	3f 4f       	sbci	r19, 0xFF	; 255
    2884:	47 e0       	ldi	r20, 0x07	; 7
    2886:	50 e0       	ldi	r21, 0x00	; 0
    2888:	89 2d       	mov	r24, r9
    288a:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    288e:	be 01       	movw	r22, r28
    2890:	60 5f       	subi	r22, 0xF0	; 240
    2892:	7f 4f       	sbci	r23, 0xFF	; 255
    2894:	c7 01       	movw	r24, r14
    2896:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <strcmp>
    289a:	89 2b       	or	r24, r25
    289c:	a9 f5       	brne	.+106    	; 0x2908 <getUserByCode+0xf8>
    289e:	68 e0       	ldi	r22, 0x08	; 8
    28a0:	6a 0d       	add	r22, r10
    28a2:	9e 01       	movw	r18, r28
    28a4:	2d 5f       	subi	r18, 0xFD	; 253
    28a6:	3f 4f       	sbci	r19, 0xFF	; 255
    28a8:	4d e0       	ldi	r20, 0x0D	; 13
    28aa:	50 e0       	ldi	r21, 0x00	; 0
    28ac:	89 2d       	mov	r24, r9
    28ae:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    28b2:	6c e1       	ldi	r22, 0x1C	; 28
    28b4:	6a 0d       	add	r22, r10
    28b6:	9e 01       	movw	r18, r28
    28b8:	29 5e       	subi	r18, 0xE9	; 233
    28ba:	3f 4f       	sbci	r19, 0xFF	; 255
    28bc:	47 e0       	ldi	r20, 0x07	; 7
    28be:	50 e0       	ldi	r21, 0x00	; 0
    28c0:	89 2d       	mov	r24, r9
    28c2:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
    28c6:	8a 81       	ldd	r24, Y+2	; 0x02
    28c8:	90 e0       	ldi	r25, 0x00	; 0
    28ca:	02 c0       	rjmp	.+4      	; 0x28d0 <getUserByCode+0xc0>
    28cc:	95 95       	asr	r25
    28ce:	87 95       	ror	r24
    28d0:	ba 94       	dec	r11
    28d2:	e2 f7       	brpl	.-8      	; 0x28cc <getUserByCode+0xbc>
    28d4:	98 2f       	mov	r25, r24
    28d6:	91 70       	andi	r25, 0x01	; 1
    28d8:	f6 01       	movw	r30, r12
    28da:	91 93       	st	Z+, r25
    28dc:	be 01       	movw	r22, r28
    28de:	6d 5f       	subi	r22, 0xFD	; 253
    28e0:	7f 4f       	sbci	r23, 0xFF	; 255
    28e2:	cf 01       	movw	r24, r30
    28e4:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <strcpy>
    28e8:	be 01       	movw	r22, r28
    28ea:	60 5f       	subi	r22, 0xF0	; 240
    28ec:	7f 4f       	sbci	r23, 0xFF	; 255
    28ee:	c6 01       	movw	r24, r12
    28f0:	0e 96       	adiw	r24, 0x0e	; 14
    28f2:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <strcpy>
    28f6:	be 01       	movw	r22, r28
    28f8:	69 5e       	subi	r22, 0xE9	; 233
    28fa:	7f 4f       	sbci	r23, 0xFF	; 255
    28fc:	c6 01       	movw	r24, r12
    28fe:	45 96       	adiw	r24, 0x15	; 21
    2900:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <strcpy>
    2904:	82 e0       	ldi	r24, 0x02	; 2
    2906:	0b c0       	rjmp	.+22     	; 0x291e <getUserByCode+0x10e>
    2908:	b3 94       	inc	r11
    290a:	87 e0       	ldi	r24, 0x07	; 7
    290c:	8b 15       	cp	r24, r11
    290e:	08 f0       	brcs	.+2      	; 0x2912 <getUserByCode+0x102>
    2910:	a6 cf       	rjmp	.-180    	; 0x285e <getUserByCode+0x4e>
    2912:	93 94       	inc	r9
    2914:	87 e0       	ldi	r24, 0x07	; 7
    2916:	89 15       	cp	r24, r9
    2918:	08 f0       	brcs	.+2      	; 0x291c <getUserByCode+0x10c>
    291a:	91 cf       	rjmp	.-222    	; 0x283e <getUserByCode+0x2e>
    291c:	83 e0       	ldi	r24, 0x03	; 3
    291e:	6d 96       	adiw	r28, 0x1d	; 29
    2920:	0f b6       	in	r0, 0x3f	; 63
    2922:	f8 94       	cli
    2924:	de bf       	out	0x3e, r29	; 62
    2926:	0f be       	out	0x3f, r0	; 63
    2928:	cd bf       	out	0x3d, r28	; 61
    292a:	df 91       	pop	r29
    292c:	cf 91       	pop	r28
    292e:	1f 91       	pop	r17
    2930:	0f 91       	pop	r16
    2932:	ff 90       	pop	r15
    2934:	ef 90       	pop	r14
    2936:	df 90       	pop	r13
    2938:	cf 90       	pop	r12
    293a:	bf 90       	pop	r11
    293c:	af 90       	pop	r10
    293e:	9f 90       	pop	r9
    2940:	08 95       	ret

00002942 <write_user>:

void write_user(u8 userBlockIndex, ST_User_t* user) {
    2942:	ef 92       	push	r14
    2944:	ff 92       	push	r15
    2946:	0f 93       	push	r16
    2948:	1f 93       	push	r17
    294a:	cf 93       	push	r28
    294c:	df 93       	push	r29
    294e:	00 d0       	rcall	.+0      	; 0x2950 <write_user+0xe>
    2950:	cd b7       	in	r28, 0x3d	; 61
    2952:	de b7       	in	r29, 0x3e	; 62
    2954:	7b 01       	movw	r14, r22
  // Get the user block location (page - index)
  u8 page = userBlockIndex / 8;
    2956:	08 2f       	mov	r16, r24
    2958:	06 95       	lsr	r16
    295a:	06 95       	lsr	r16
    295c:	06 95       	lsr	r16
  u8 blockNumber = userBlockIndex % 8;
    295e:	18 2f       	mov	r17, r24
    2960:	17 70       	andi	r17, 0x07	; 7
  // Read and update the block status (reserve the block). And update the user authority level flag if the user is admin
  u8 usersBlockStatus, usersAuthorityLevel;
  EEPROM_read_byte(page, 0, &usersBlockStatus);
    2962:	ae 01       	movw	r20, r28
    2964:	4f 5f       	subi	r20, 0xFF	; 255
    2966:	5f 4f       	sbci	r21, 0xFF	; 255
    2968:	60 e0       	ldi	r22, 0x00	; 0
    296a:	80 2f       	mov	r24, r16
    296c:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
  EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    2970:	ae 01       	movw	r20, r28
    2972:	4e 5f       	subi	r20, 0xFE	; 254
    2974:	5f 4f       	sbci	r21, 0xFF	; 255
    2976:	61 e0       	ldi	r22, 0x01	; 1
    2978:	80 2f       	mov	r24, r16
    297a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
  set_bit(usersBlockStatus, blockNumber);
    297e:	81 e0       	ldi	r24, 0x01	; 1
    2980:	90 e0       	ldi	r25, 0x00	; 0
    2982:	01 2e       	mov	r0, r17
    2984:	02 c0       	rjmp	.+4      	; 0x298a <write_user+0x48>
    2986:	88 0f       	add	r24, r24
    2988:	99 1f       	adc	r25, r25
    298a:	0a 94       	dec	r0
    298c:	e2 f7       	brpl	.-8      	; 0x2986 <write_user+0x44>
    298e:	49 81       	ldd	r20, Y+1	; 0x01
    2990:	48 2b       	or	r20, r24
    2992:	49 83       	std	Y+1, r20	; 0x01
  if (user->isAdmin) set_bit(usersAuthorityLevel, blockNumber);
    2994:	f7 01       	movw	r30, r14
    2996:	20 81       	ld	r18, Z
    2998:	22 23       	and	r18, r18
    299a:	19 f0       	breq	.+6      	; 0x29a2 <write_user+0x60>
    299c:	9a 81       	ldd	r25, Y+2	; 0x02
    299e:	89 2b       	or	r24, r25
    29a0:	8a 83       	std	Y+2, r24	; 0x02
  EEPROM_write_byte(page, 0, usersBlockStatus);
    29a2:	60 e0       	ldi	r22, 0x00	; 0
    29a4:	80 2f       	mov	r24, r16
    29a6:	0e 94 2e 01 	call	0x25c	; 0x25c <EEPROM_write_byte>
  EEPROM_write_byte(page, 1, usersAuthorityLevel);
    29aa:	4a 81       	ldd	r20, Y+2	; 0x02
    29ac:	61 e0       	ldi	r22, 0x01	; 1
    29ae:	80 2f       	mov	r24, r16
    29b0:	0e 94 2e 01 	call	0x25c	; 0x25c <EEPROM_write_byte>
  // Write the user data
  EEPROM_write_block(page, 8 + 31 * blockNumber, 13, user->name);
    29b4:	97 01       	movw	r18, r14
    29b6:	2f 5f       	subi	r18, 0xFF	; 255
    29b8:	3f 4f       	sbci	r19, 0xFF	; 255
    29ba:	6f e1       	ldi	r22, 0x1F	; 31
    29bc:	16 9f       	mul	r17, r22
    29be:	10 2d       	mov	r17, r0
    29c0:	11 24       	eor	r1, r1
    29c2:	68 e0       	ldi	r22, 0x08	; 8
    29c4:	61 0f       	add	r22, r17
    29c6:	4d e0       	ldi	r20, 0x0D	; 13
    29c8:	50 e0       	ldi	r21, 0x00	; 0
    29ca:	80 2f       	mov	r24, r16
    29cc:	0e 94 4d 01 	call	0x29a	; 0x29a <EEPROM_write_block>
  EEPROM_write_block(page, 21 + 31 * blockNumber, 7, user->code);
    29d0:	97 01       	movw	r18, r14
    29d2:	22 5f       	subi	r18, 0xF2	; 242
    29d4:	3f 4f       	sbci	r19, 0xFF	; 255
    29d6:	65 e1       	ldi	r22, 0x15	; 21
    29d8:	61 0f       	add	r22, r17
    29da:	47 e0       	ldi	r20, 0x07	; 7
    29dc:	50 e0       	ldi	r21, 0x00	; 0
    29de:	80 2f       	mov	r24, r16
    29e0:	0e 94 4d 01 	call	0x29a	; 0x29a <EEPROM_write_block>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
    29e4:	97 01       	movw	r18, r14
    29e6:	2b 5e       	subi	r18, 0xEB	; 235
    29e8:	3f 4f       	sbci	r19, 0xFF	; 255
    29ea:	6c e1       	ldi	r22, 0x1C	; 28
    29ec:	61 0f       	add	r22, r17
    29ee:	4b e0       	ldi	r20, 0x0B	; 11
    29f0:	50 e0       	ldi	r21, 0x00	; 0
    29f2:	80 2f       	mov	r24, r16
    29f4:	0e 94 4d 01 	call	0x29a	; 0x29a <EEPROM_write_block>
  }
    29f8:	0f 90       	pop	r0
    29fa:	0f 90       	pop	r0
    29fc:	df 91       	pop	r29
    29fe:	cf 91       	pop	r28
    2a00:	1f 91       	pop	r17
    2a02:	0f 91       	pop	r16
    2a04:	ff 90       	pop	r15
    2a06:	ef 90       	pop	r14
    2a08:	08 95       	ret

00002a0a <add_user>:

EN_UserStatusCode_t add_user(ST_User_t* user) {
    2a0a:	ef 92       	push	r14
    2a0c:	ff 92       	push	r15
    2a0e:	1f 93       	push	r17
    2a10:	cf 93       	push	r28
    2a12:	df 93       	push	r29
    2a14:	1f 92       	push	r1
    2a16:	cd b7       	in	r28, 0x3d	; 61
    2a18:	de b7       	in	r29, 0x3e	; 62
    2a1a:	7c 01       	movw	r14, r24
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    2a1c:	10 e0       	ldi	r17, 0x00	; 0
    2a1e:	1a c0       	rjmp	.+52     	; 0x2a54 <add_user+0x4a>
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    2a20:	ae 01       	movw	r20, r28
    2a22:	4f 5f       	subi	r20, 0xFF	; 255
    2a24:	5f 4f       	sbci	r21, 0xFF	; 255
    2a26:	60 e0       	ldi	r22, 0x00	; 0
    2a28:	81 2f       	mov	r24, r17
    2a2a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    if (usersBlockStatus != 0xFF) {
    2a2e:	99 81       	ldd	r25, Y+1	; 0x01
    2a30:	9f 3f       	cpi	r25, 0xFF	; 255
    2a32:	79 f0       	breq	.+30     	; 0x2a52 <add_user+0x48>
    2a34:	02 c0       	rjmp	.+4      	; 0x2a3a <add_user+0x30>
      // Find the block number in the page
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
    2a36:	8f 5f       	subi	r24, 0xFF	; 255
    2a38:	01 c0       	rjmp	.+2      	; 0x2a3c <add_user+0x32>
    2a3a:	80 e0       	ldi	r24, 0x00	; 0
    2a3c:	29 2f       	mov	r18, r25
    2a3e:	30 e0       	ldi	r19, 0x00	; 0
    2a40:	08 2e       	mov	r0, r24
    2a42:	02 c0       	rjmp	.+4      	; 0x2a48 <add_user+0x3e>
    2a44:	35 95       	asr	r19
    2a46:	27 95       	ror	r18
    2a48:	0a 94       	dec	r0
    2a4a:	e2 f7       	brpl	.-8      	; 0x2a44 <add_user+0x3a>
    2a4c:	20 fd       	sbrc	r18, 0
    2a4e:	f3 cf       	rjmp	.-26     	; 0x2a36 <add_user+0x2c>
    2a50:	04 c0       	rjmp	.+8      	; 0x2a5a <add_user+0x50>
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    2a52:	1f 5f       	subi	r17, 0xFF	; 255
    2a54:	18 30       	cpi	r17, 0x08	; 8
    2a56:	20 f3       	brcs	.-56     	; 0x2a20 <add_user+0x16>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
    2a58:	80 e0       	ldi	r24, 0x00	; 0
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    2a5a:	18 30       	cpi	r17, 0x08	; 8
    2a5c:	49 f0       	breq	.+18     	; 0x2a70 <add_user+0x66>
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
    2a5e:	11 0f       	add	r17, r17
    2a60:	11 0f       	add	r17, r17
    2a62:	11 0f       	add	r17, r17
  write_user(availableUserBlockIndex, user);
    2a64:	b7 01       	movw	r22, r14
    2a66:	81 0f       	add	r24, r17
    2a68:	0e 94 a1 14 	call	0x2942	; 0x2942 <write_user>
  return USER_ADDED_SUCCESSFULLY;
    2a6c:	8a e0       	ldi	r24, 0x0A	; 10
    2a6e:	01 c0       	rjmp	.+2      	; 0x2a72 <add_user+0x68>
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    2a70:	8c e0       	ldi	r24, 0x0C	; 12
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
  write_user(availableUserBlockIndex, user);
  return USER_ADDED_SUCCESSFULLY;
  }
    2a72:	0f 90       	pop	r0
    2a74:	df 91       	pop	r29
    2a76:	cf 91       	pop	r28
    2a78:	1f 91       	pop	r17
    2a7a:	ff 90       	pop	r15
    2a7c:	ef 90       	pop	r14
    2a7e:	08 95       	ret

00002a80 <delete_user>:

EN_UserStatusCode_t delete_user(ST_User_t* user) {
    2a80:	cf 92       	push	r12
    2a82:	df 92       	push	r13
    2a84:	ef 92       	push	r14
    2a86:	ff 92       	push	r15
    2a88:	0f 93       	push	r16
    2a8a:	1f 93       	push	r17
    2a8c:	cf 93       	push	r28
    2a8e:	df 93       	push	r29
    2a90:	cd b7       	in	r28, 0x3d	; 61
    2a92:	de b7       	in	r29, 0x3e	; 62
    2a94:	29 97       	sbiw	r28, 0x09	; 9
    2a96:	0f b6       	in	r0, 0x3f	; 63
    2a98:	f8 94       	cli
    2a9a:	de bf       	out	0x3e, r29	; 62
    2a9c:	0f be       	out	0x3f, r0	; 63
    2a9e:	cd bf       	out	0x3d, r28	; 61
    2aa0:	6c 01       	movw	r12, r24
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    2aa2:	00 e0       	ldi	r16, 0x00	; 0
    2aa4:	4d c0       	rjmp	.+154    	; 0x2b40 <delete_user+0xc0>
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    2aa6:	ae 01       	movw	r20, r28
    2aa8:	4f 5f       	subi	r20, 0xFF	; 255
    2aaa:	5f 4f       	sbci	r21, 0xFF	; 255
    2aac:	60 e0       	ldi	r22, 0x00	; 0
    2aae:	80 2f       	mov	r24, r16
    2ab0:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    2ab4:	ae 01       	movw	r20, r28
    2ab6:	4e 5f       	subi	r20, 0xFE	; 254
    2ab8:	5f 4f       	sbci	r21, 0xFF	; 255
    2aba:	61 e0       	ldi	r22, 0x01	; 1
    2abc:	80 2f       	mov	r24, r16
    2abe:	0e 94 d7 00 	call	0x1ae	; 0x1ae <EEPROM_read_byte>
    for (userIndex = 0; userIndex < 8;userIndex++) {
    2ac2:	10 e0       	ldi	r17, 0x00	; 0
    2ac4:	3a c0       	rjmp	.+116    	; 0x2b3a <delete_user+0xba>
      if (read_bit(usersBlockStatus, userIndex)) {  // If the user isn't deleted
    2ac6:	89 81       	ldd	r24, Y+1	; 0x01
    2ac8:	90 e0       	ldi	r25, 0x00	; 0
    2aca:	01 2e       	mov	r0, r17
    2acc:	02 c0       	rjmp	.+4      	; 0x2ad2 <delete_user+0x52>
    2ace:	95 95       	asr	r25
    2ad0:	87 95       	ror	r24
    2ad2:	0a 94       	dec	r0
    2ad4:	e2 f7       	brpl	.-8      	; 0x2ace <delete_user+0x4e>
    2ad6:	80 ff       	sbrs	r24, 0
    2ad8:	2f c0       	rjmp	.+94     	; 0x2b38 <delete_user+0xb8>
        EEPROM_read_block(page, 21 + 31 * userIndex, 7, tempUserCode);
    2ada:	6f e1       	ldi	r22, 0x1F	; 31
    2adc:	16 9f       	mul	r17, r22
    2ade:	60 2d       	mov	r22, r0
    2ae0:	11 24       	eor	r1, r1
    2ae2:	6b 5e       	subi	r22, 0xEB	; 235
    2ae4:	9e 01       	movw	r18, r28
    2ae6:	2d 5f       	subi	r18, 0xFD	; 253
    2ae8:	3f 4f       	sbci	r19, 0xFF	; 255
    2aea:	47 e0       	ldi	r20, 0x07	; 7
    2aec:	50 e0       	ldi	r21, 0x00	; 0
    2aee:	80 2f       	mov	r24, r16
    2af0:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <EEPROM_read_block>
        if (strcmp(user->code, tempUserCode) == 0) { // User has been found
    2af4:	be 01       	movw	r22, r28
    2af6:	6d 5f       	subi	r22, 0xFD	; 253
    2af8:	7f 4f       	sbci	r23, 0xFF	; 255
    2afa:	c6 01       	movw	r24, r12
    2afc:	0e 96       	adiw	r24, 0x0e	; 14
    2afe:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <strcmp>
    2b02:	89 2b       	or	r24, r25
    2b04:	c9 f4       	brne	.+50     	; 0x2b38 <delete_user+0xb8>
          // Mark it as deleted
          clear_bit(usersBlockStatus, userIndex);
    2b06:	81 e0       	ldi	r24, 0x01	; 1
    2b08:	90 e0       	ldi	r25, 0x00	; 0
    2b0a:	02 c0       	rjmp	.+4      	; 0x2b10 <delete_user+0x90>
    2b0c:	88 0f       	add	r24, r24
    2b0e:	99 1f       	adc	r25, r25
    2b10:	1a 95       	dec	r17
    2b12:	e2 f7       	brpl	.-8      	; 0x2b0c <delete_user+0x8c>
    2b14:	80 95       	com	r24
    2b16:	49 81       	ldd	r20, Y+1	; 0x01
    2b18:	48 23       	and	r20, r24
    2b1a:	49 83       	std	Y+1, r20	; 0x01
          clear_bit(usersAuthorityLevel, userIndex);
    2b1c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b1e:	89 23       	and	r24, r25
    2b20:	8a 83       	std	Y+2, r24	; 0x02
          EEPROM_write_byte(page, 0, usersBlockStatus);
    2b22:	60 e0       	ldi	r22, 0x00	; 0
    2b24:	80 2f       	mov	r24, r16
    2b26:	0e 94 2e 01 	call	0x25c	; 0x25c <EEPROM_write_byte>
          EEPROM_write_byte(page, 1, usersAuthorityLevel);
    2b2a:	4a 81       	ldd	r20, Y+2	; 0x02
    2b2c:	61 e0       	ldi	r22, 0x01	; 1
    2b2e:	80 2f       	mov	r24, r16
    2b30:	0e 94 2e 01 	call	0x25c	; 0x25c <EEPROM_write_byte>
          return USER_DELETED_SUCCESSFULLY;
    2b34:	8b e0       	ldi	r24, 0x0B	; 11
    2b36:	08 c0       	rjmp	.+16     	; 0x2b48 <delete_user+0xc8>
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    for (userIndex = 0; userIndex < 8;userIndex++) {
    2b38:	1f 5f       	subi	r17, 0xFF	; 255
    2b3a:	18 30       	cpi	r17, 0x08	; 8
    2b3c:	20 f2       	brcs	.-120    	; 0x2ac6 <delete_user+0x46>
EN_UserStatusCode_t delete_user(ST_User_t* user) {
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    2b3e:	0f 5f       	subi	r16, 0xFF	; 255
    2b40:	08 30       	cpi	r16, 0x08	; 8
    2b42:	08 f4       	brcc	.+2      	; 0x2b46 <delete_user+0xc6>
    2b44:	b0 cf       	rjmp	.-160    	; 0x2aa6 <delete_user+0x26>
          return USER_DELETED_SUCCESSFULLY;
          }
        }
      }
    }
  return USER_NOT_FOUND;
    2b46:	83 e0       	ldi	r24, 0x03	; 3
  }
    2b48:	29 96       	adiw	r28, 0x09	; 9
    2b4a:	0f b6       	in	r0, 0x3f	; 63
    2b4c:	f8 94       	cli
    2b4e:	de bf       	out	0x3e, r29	; 62
    2b50:	0f be       	out	0x3f, r0	; 63
    2b52:	cd bf       	out	0x3d, r28	; 61
    2b54:	df 91       	pop	r29
    2b56:	cf 91       	pop	r28
    2b58:	1f 91       	pop	r17
    2b5a:	0f 91       	pop	r16
    2b5c:	ff 90       	pop	r15
    2b5e:	ef 90       	pop	r14
    2b60:	df 90       	pop	r13
    2b62:	cf 90       	pop	r12
    2b64:	08 95       	ret

00002b66 <__subsf3>:
    2b66:	50 58       	subi	r21, 0x80	; 128

00002b68 <__addsf3>:
    2b68:	bb 27       	eor	r27, r27
    2b6a:	aa 27       	eor	r26, r26
    2b6c:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <__addsf3x>
    2b70:	0c 94 1c 17 	jmp	0x2e38	; 0x2e38 <__fp_round>
    2b74:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <__fp_pscA>
    2b78:	38 f0       	brcs	.+14     	; 0x2b88 <__addsf3+0x20>
    2b7a:	0e 94 15 17 	call	0x2e2a	; 0x2e2a <__fp_pscB>
    2b7e:	20 f0       	brcs	.+8      	; 0x2b88 <__addsf3+0x20>
    2b80:	39 f4       	brne	.+14     	; 0x2b90 <__addsf3+0x28>
    2b82:	9f 3f       	cpi	r25, 0xFF	; 255
    2b84:	19 f4       	brne	.+6      	; 0x2b8c <__addsf3+0x24>
    2b86:	26 f4       	brtc	.+8      	; 0x2b90 <__addsf3+0x28>
    2b88:	0c 94 0b 17 	jmp	0x2e16	; 0x2e16 <__fp_nan>
    2b8c:	0e f4       	brtc	.+2      	; 0x2b90 <__addsf3+0x28>
    2b8e:	e0 95       	com	r30
    2b90:	e7 fb       	bst	r30, 7
    2b92:	0c 94 05 17 	jmp	0x2e0a	; 0x2e0a <__fp_inf>

00002b96 <__addsf3x>:
    2b96:	e9 2f       	mov	r30, r25
    2b98:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <__fp_split3>
    2b9c:	58 f3       	brcs	.-42     	; 0x2b74 <__addsf3+0xc>
    2b9e:	ba 17       	cp	r27, r26
    2ba0:	62 07       	cpc	r22, r18
    2ba2:	73 07       	cpc	r23, r19
    2ba4:	84 07       	cpc	r24, r20
    2ba6:	95 07       	cpc	r25, r21
    2ba8:	20 f0       	brcs	.+8      	; 0x2bb2 <__addsf3x+0x1c>
    2baa:	79 f4       	brne	.+30     	; 0x2bca <__addsf3x+0x34>
    2bac:	a6 f5       	brtc	.+104    	; 0x2c16 <__addsf3x+0x80>
    2bae:	0c 94 4f 17 	jmp	0x2e9e	; 0x2e9e <__fp_zero>
    2bb2:	0e f4       	brtc	.+2      	; 0x2bb6 <__addsf3x+0x20>
    2bb4:	e0 95       	com	r30
    2bb6:	0b 2e       	mov	r0, r27
    2bb8:	ba 2f       	mov	r27, r26
    2bba:	a0 2d       	mov	r26, r0
    2bbc:	0b 01       	movw	r0, r22
    2bbe:	b9 01       	movw	r22, r18
    2bc0:	90 01       	movw	r18, r0
    2bc2:	0c 01       	movw	r0, r24
    2bc4:	ca 01       	movw	r24, r20
    2bc6:	a0 01       	movw	r20, r0
    2bc8:	11 24       	eor	r1, r1
    2bca:	ff 27       	eor	r31, r31
    2bcc:	59 1b       	sub	r21, r25
    2bce:	99 f0       	breq	.+38     	; 0x2bf6 <__addsf3x+0x60>
    2bd0:	59 3f       	cpi	r21, 0xF9	; 249
    2bd2:	50 f4       	brcc	.+20     	; 0x2be8 <__addsf3x+0x52>
    2bd4:	50 3e       	cpi	r21, 0xE0	; 224
    2bd6:	68 f1       	brcs	.+90     	; 0x2c32 <__addsf3x+0x9c>
    2bd8:	1a 16       	cp	r1, r26
    2bda:	f0 40       	sbci	r31, 0x00	; 0
    2bdc:	a2 2f       	mov	r26, r18
    2bde:	23 2f       	mov	r18, r19
    2be0:	34 2f       	mov	r19, r20
    2be2:	44 27       	eor	r20, r20
    2be4:	58 5f       	subi	r21, 0xF8	; 248
    2be6:	f3 cf       	rjmp	.-26     	; 0x2bce <__addsf3x+0x38>
    2be8:	46 95       	lsr	r20
    2bea:	37 95       	ror	r19
    2bec:	27 95       	ror	r18
    2bee:	a7 95       	ror	r26
    2bf0:	f0 40       	sbci	r31, 0x00	; 0
    2bf2:	53 95       	inc	r21
    2bf4:	c9 f7       	brne	.-14     	; 0x2be8 <__addsf3x+0x52>
    2bf6:	7e f4       	brtc	.+30     	; 0x2c16 <__addsf3x+0x80>
    2bf8:	1f 16       	cp	r1, r31
    2bfa:	ba 0b       	sbc	r27, r26
    2bfc:	62 0b       	sbc	r22, r18
    2bfe:	73 0b       	sbc	r23, r19
    2c00:	84 0b       	sbc	r24, r20
    2c02:	ba f0       	brmi	.+46     	; 0x2c32 <__addsf3x+0x9c>
    2c04:	91 50       	subi	r25, 0x01	; 1
    2c06:	a1 f0       	breq	.+40     	; 0x2c30 <__addsf3x+0x9a>
    2c08:	ff 0f       	add	r31, r31
    2c0a:	bb 1f       	adc	r27, r27
    2c0c:	66 1f       	adc	r22, r22
    2c0e:	77 1f       	adc	r23, r23
    2c10:	88 1f       	adc	r24, r24
    2c12:	c2 f7       	brpl	.-16     	; 0x2c04 <__addsf3x+0x6e>
    2c14:	0e c0       	rjmp	.+28     	; 0x2c32 <__addsf3x+0x9c>
    2c16:	ba 0f       	add	r27, r26
    2c18:	62 1f       	adc	r22, r18
    2c1a:	73 1f       	adc	r23, r19
    2c1c:	84 1f       	adc	r24, r20
    2c1e:	48 f4       	brcc	.+18     	; 0x2c32 <__addsf3x+0x9c>
    2c20:	87 95       	ror	r24
    2c22:	77 95       	ror	r23
    2c24:	67 95       	ror	r22
    2c26:	b7 95       	ror	r27
    2c28:	f7 95       	ror	r31
    2c2a:	9e 3f       	cpi	r25, 0xFE	; 254
    2c2c:	08 f0       	brcs	.+2      	; 0x2c30 <__addsf3x+0x9a>
    2c2e:	b0 cf       	rjmp	.-160    	; 0x2b90 <__addsf3+0x28>
    2c30:	93 95       	inc	r25
    2c32:	88 0f       	add	r24, r24
    2c34:	08 f0       	brcs	.+2      	; 0x2c38 <__addsf3x+0xa2>
    2c36:	99 27       	eor	r25, r25
    2c38:	ee 0f       	add	r30, r30
    2c3a:	97 95       	ror	r25
    2c3c:	87 95       	ror	r24
    2c3e:	08 95       	ret

00002c40 <__divsf3>:
    2c40:	0e 94 34 16 	call	0x2c68	; 0x2c68 <__divsf3x>
    2c44:	0c 94 1c 17 	jmp	0x2e38	; 0x2e38 <__fp_round>
    2c48:	0e 94 15 17 	call	0x2e2a	; 0x2e2a <__fp_pscB>
    2c4c:	58 f0       	brcs	.+22     	; 0x2c64 <__divsf3+0x24>
    2c4e:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <__fp_pscA>
    2c52:	40 f0       	brcs	.+16     	; 0x2c64 <__divsf3+0x24>
    2c54:	29 f4       	brne	.+10     	; 0x2c60 <__divsf3+0x20>
    2c56:	5f 3f       	cpi	r21, 0xFF	; 255
    2c58:	29 f0       	breq	.+10     	; 0x2c64 <__divsf3+0x24>
    2c5a:	0c 94 05 17 	jmp	0x2e0a	; 0x2e0a <__fp_inf>
    2c5e:	51 11       	cpse	r21, r1
    2c60:	0c 94 50 17 	jmp	0x2ea0	; 0x2ea0 <__fp_szero>
    2c64:	0c 94 0b 17 	jmp	0x2e16	; 0x2e16 <__fp_nan>

00002c68 <__divsf3x>:
    2c68:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <__fp_split3>
    2c6c:	68 f3       	brcs	.-38     	; 0x2c48 <__divsf3+0x8>

00002c6e <__divsf3_pse>:
    2c6e:	99 23       	and	r25, r25
    2c70:	b1 f3       	breq	.-20     	; 0x2c5e <__divsf3+0x1e>
    2c72:	55 23       	and	r21, r21
    2c74:	91 f3       	breq	.-28     	; 0x2c5a <__divsf3+0x1a>
    2c76:	95 1b       	sub	r25, r21
    2c78:	55 0b       	sbc	r21, r21
    2c7a:	bb 27       	eor	r27, r27
    2c7c:	aa 27       	eor	r26, r26
    2c7e:	62 17       	cp	r22, r18
    2c80:	73 07       	cpc	r23, r19
    2c82:	84 07       	cpc	r24, r20
    2c84:	38 f0       	brcs	.+14     	; 0x2c94 <__divsf3_pse+0x26>
    2c86:	9f 5f       	subi	r25, 0xFF	; 255
    2c88:	5f 4f       	sbci	r21, 0xFF	; 255
    2c8a:	22 0f       	add	r18, r18
    2c8c:	33 1f       	adc	r19, r19
    2c8e:	44 1f       	adc	r20, r20
    2c90:	aa 1f       	adc	r26, r26
    2c92:	a9 f3       	breq	.-22     	; 0x2c7e <__divsf3_pse+0x10>
    2c94:	35 d0       	rcall	.+106    	; 0x2d00 <__divsf3_pse+0x92>
    2c96:	0e 2e       	mov	r0, r30
    2c98:	3a f0       	brmi	.+14     	; 0x2ca8 <__divsf3_pse+0x3a>
    2c9a:	e0 e8       	ldi	r30, 0x80	; 128
    2c9c:	32 d0       	rcall	.+100    	; 0x2d02 <__divsf3_pse+0x94>
    2c9e:	91 50       	subi	r25, 0x01	; 1
    2ca0:	50 40       	sbci	r21, 0x00	; 0
    2ca2:	e6 95       	lsr	r30
    2ca4:	00 1c       	adc	r0, r0
    2ca6:	ca f7       	brpl	.-14     	; 0x2c9a <__divsf3_pse+0x2c>
    2ca8:	2b d0       	rcall	.+86     	; 0x2d00 <__divsf3_pse+0x92>
    2caa:	fe 2f       	mov	r31, r30
    2cac:	29 d0       	rcall	.+82     	; 0x2d00 <__divsf3_pse+0x92>
    2cae:	66 0f       	add	r22, r22
    2cb0:	77 1f       	adc	r23, r23
    2cb2:	88 1f       	adc	r24, r24
    2cb4:	bb 1f       	adc	r27, r27
    2cb6:	26 17       	cp	r18, r22
    2cb8:	37 07       	cpc	r19, r23
    2cba:	48 07       	cpc	r20, r24
    2cbc:	ab 07       	cpc	r26, r27
    2cbe:	b0 e8       	ldi	r27, 0x80	; 128
    2cc0:	09 f0       	breq	.+2      	; 0x2cc4 <__divsf3_pse+0x56>
    2cc2:	bb 0b       	sbc	r27, r27
    2cc4:	80 2d       	mov	r24, r0
    2cc6:	bf 01       	movw	r22, r30
    2cc8:	ff 27       	eor	r31, r31
    2cca:	93 58       	subi	r25, 0x83	; 131
    2ccc:	5f 4f       	sbci	r21, 0xFF	; 255
    2cce:	3a f0       	brmi	.+14     	; 0x2cde <__divsf3_pse+0x70>
    2cd0:	9e 3f       	cpi	r25, 0xFE	; 254
    2cd2:	51 05       	cpc	r21, r1
    2cd4:	78 f0       	brcs	.+30     	; 0x2cf4 <__divsf3_pse+0x86>
    2cd6:	0c 94 05 17 	jmp	0x2e0a	; 0x2e0a <__fp_inf>
    2cda:	0c 94 50 17 	jmp	0x2ea0	; 0x2ea0 <__fp_szero>
    2cde:	5f 3f       	cpi	r21, 0xFF	; 255
    2ce0:	e4 f3       	brlt	.-8      	; 0x2cda <__divsf3_pse+0x6c>
    2ce2:	98 3e       	cpi	r25, 0xE8	; 232
    2ce4:	d4 f3       	brlt	.-12     	; 0x2cda <__divsf3_pse+0x6c>
    2ce6:	86 95       	lsr	r24
    2ce8:	77 95       	ror	r23
    2cea:	67 95       	ror	r22
    2cec:	b7 95       	ror	r27
    2cee:	f7 95       	ror	r31
    2cf0:	9f 5f       	subi	r25, 0xFF	; 255
    2cf2:	c9 f7       	brne	.-14     	; 0x2ce6 <__divsf3_pse+0x78>
    2cf4:	88 0f       	add	r24, r24
    2cf6:	91 1d       	adc	r25, r1
    2cf8:	96 95       	lsr	r25
    2cfa:	87 95       	ror	r24
    2cfc:	97 f9       	bld	r25, 7
    2cfe:	08 95       	ret
    2d00:	e1 e0       	ldi	r30, 0x01	; 1
    2d02:	66 0f       	add	r22, r22
    2d04:	77 1f       	adc	r23, r23
    2d06:	88 1f       	adc	r24, r24
    2d08:	bb 1f       	adc	r27, r27
    2d0a:	62 17       	cp	r22, r18
    2d0c:	73 07       	cpc	r23, r19
    2d0e:	84 07       	cpc	r24, r20
    2d10:	ba 07       	cpc	r27, r26
    2d12:	20 f0       	brcs	.+8      	; 0x2d1c <__divsf3_pse+0xae>
    2d14:	62 1b       	sub	r22, r18
    2d16:	73 0b       	sbc	r23, r19
    2d18:	84 0b       	sbc	r24, r20
    2d1a:	ba 0b       	sbc	r27, r26
    2d1c:	ee 1f       	adc	r30, r30
    2d1e:	88 f7       	brcc	.-30     	; 0x2d02 <__divsf3_pse+0x94>
    2d20:	e0 95       	com	r30
    2d22:	08 95       	ret

00002d24 <__fixsfsi>:
    2d24:	0e 94 99 16 	call	0x2d32	; 0x2d32 <__fixunssfsi>
    2d28:	68 94       	set
    2d2a:	b1 11       	cpse	r27, r1
    2d2c:	0c 94 50 17 	jmp	0x2ea0	; 0x2ea0 <__fp_szero>
    2d30:	08 95       	ret

00002d32 <__fixunssfsi>:
    2d32:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <__fp_splitA>
    2d36:	88 f0       	brcs	.+34     	; 0x2d5a <__fixunssfsi+0x28>
    2d38:	9f 57       	subi	r25, 0x7F	; 127
    2d3a:	98 f0       	brcs	.+38     	; 0x2d62 <__fixunssfsi+0x30>
    2d3c:	b9 2f       	mov	r27, r25
    2d3e:	99 27       	eor	r25, r25
    2d40:	b7 51       	subi	r27, 0x17	; 23
    2d42:	b0 f0       	brcs	.+44     	; 0x2d70 <__fixunssfsi+0x3e>
    2d44:	e1 f0       	breq	.+56     	; 0x2d7e <__fixunssfsi+0x4c>
    2d46:	66 0f       	add	r22, r22
    2d48:	77 1f       	adc	r23, r23
    2d4a:	88 1f       	adc	r24, r24
    2d4c:	99 1f       	adc	r25, r25
    2d4e:	1a f0       	brmi	.+6      	; 0x2d56 <__fixunssfsi+0x24>
    2d50:	ba 95       	dec	r27
    2d52:	c9 f7       	brne	.-14     	; 0x2d46 <__fixunssfsi+0x14>
    2d54:	14 c0       	rjmp	.+40     	; 0x2d7e <__fixunssfsi+0x4c>
    2d56:	b1 30       	cpi	r27, 0x01	; 1
    2d58:	91 f0       	breq	.+36     	; 0x2d7e <__fixunssfsi+0x4c>
    2d5a:	0e 94 4f 17 	call	0x2e9e	; 0x2e9e <__fp_zero>
    2d5e:	b1 e0       	ldi	r27, 0x01	; 1
    2d60:	08 95       	ret
    2d62:	0c 94 4f 17 	jmp	0x2e9e	; 0x2e9e <__fp_zero>
    2d66:	67 2f       	mov	r22, r23
    2d68:	78 2f       	mov	r23, r24
    2d6a:	88 27       	eor	r24, r24
    2d6c:	b8 5f       	subi	r27, 0xF8	; 248
    2d6e:	39 f0       	breq	.+14     	; 0x2d7e <__fixunssfsi+0x4c>
    2d70:	b9 3f       	cpi	r27, 0xF9	; 249
    2d72:	cc f3       	brlt	.-14     	; 0x2d66 <__fixunssfsi+0x34>
    2d74:	86 95       	lsr	r24
    2d76:	77 95       	ror	r23
    2d78:	67 95       	ror	r22
    2d7a:	b3 95       	inc	r27
    2d7c:	d9 f7       	brne	.-10     	; 0x2d74 <__fixunssfsi+0x42>
    2d7e:	3e f4       	brtc	.+14     	; 0x2d8e <__fixunssfsi+0x5c>
    2d80:	90 95       	com	r25
    2d82:	80 95       	com	r24
    2d84:	70 95       	com	r23
    2d86:	61 95       	neg	r22
    2d88:	7f 4f       	sbci	r23, 0xFF	; 255
    2d8a:	8f 4f       	sbci	r24, 0xFF	; 255
    2d8c:	9f 4f       	sbci	r25, 0xFF	; 255
    2d8e:	08 95       	ret

00002d90 <__floatunsisf>:
    2d90:	e8 94       	clt
    2d92:	09 c0       	rjmp	.+18     	; 0x2da6 <__floatsisf+0x12>

00002d94 <__floatsisf>:
    2d94:	97 fb       	bst	r25, 7
    2d96:	3e f4       	brtc	.+14     	; 0x2da6 <__floatsisf+0x12>
    2d98:	90 95       	com	r25
    2d9a:	80 95       	com	r24
    2d9c:	70 95       	com	r23
    2d9e:	61 95       	neg	r22
    2da0:	7f 4f       	sbci	r23, 0xFF	; 255
    2da2:	8f 4f       	sbci	r24, 0xFF	; 255
    2da4:	9f 4f       	sbci	r25, 0xFF	; 255
    2da6:	99 23       	and	r25, r25
    2da8:	a9 f0       	breq	.+42     	; 0x2dd4 <__floatsisf+0x40>
    2daa:	f9 2f       	mov	r31, r25
    2dac:	96 e9       	ldi	r25, 0x96	; 150
    2dae:	bb 27       	eor	r27, r27
    2db0:	93 95       	inc	r25
    2db2:	f6 95       	lsr	r31
    2db4:	87 95       	ror	r24
    2db6:	77 95       	ror	r23
    2db8:	67 95       	ror	r22
    2dba:	b7 95       	ror	r27
    2dbc:	f1 11       	cpse	r31, r1
    2dbe:	f8 cf       	rjmp	.-16     	; 0x2db0 <__floatsisf+0x1c>
    2dc0:	fa f4       	brpl	.+62     	; 0x2e00 <__floatsisf+0x6c>
    2dc2:	bb 0f       	add	r27, r27
    2dc4:	11 f4       	brne	.+4      	; 0x2dca <__floatsisf+0x36>
    2dc6:	60 ff       	sbrs	r22, 0
    2dc8:	1b c0       	rjmp	.+54     	; 0x2e00 <__floatsisf+0x6c>
    2dca:	6f 5f       	subi	r22, 0xFF	; 255
    2dcc:	7f 4f       	sbci	r23, 0xFF	; 255
    2dce:	8f 4f       	sbci	r24, 0xFF	; 255
    2dd0:	9f 4f       	sbci	r25, 0xFF	; 255
    2dd2:	16 c0       	rjmp	.+44     	; 0x2e00 <__floatsisf+0x6c>
    2dd4:	88 23       	and	r24, r24
    2dd6:	11 f0       	breq	.+4      	; 0x2ddc <__floatsisf+0x48>
    2dd8:	96 e9       	ldi	r25, 0x96	; 150
    2dda:	11 c0       	rjmp	.+34     	; 0x2dfe <__floatsisf+0x6a>
    2ddc:	77 23       	and	r23, r23
    2dde:	21 f0       	breq	.+8      	; 0x2de8 <__floatsisf+0x54>
    2de0:	9e e8       	ldi	r25, 0x8E	; 142
    2de2:	87 2f       	mov	r24, r23
    2de4:	76 2f       	mov	r23, r22
    2de6:	05 c0       	rjmp	.+10     	; 0x2df2 <__floatsisf+0x5e>
    2de8:	66 23       	and	r22, r22
    2dea:	71 f0       	breq	.+28     	; 0x2e08 <__floatsisf+0x74>
    2dec:	96 e8       	ldi	r25, 0x86	; 134
    2dee:	86 2f       	mov	r24, r22
    2df0:	70 e0       	ldi	r23, 0x00	; 0
    2df2:	60 e0       	ldi	r22, 0x00	; 0
    2df4:	2a f0       	brmi	.+10     	; 0x2e00 <__floatsisf+0x6c>
    2df6:	9a 95       	dec	r25
    2df8:	66 0f       	add	r22, r22
    2dfa:	77 1f       	adc	r23, r23
    2dfc:	88 1f       	adc	r24, r24
    2dfe:	da f7       	brpl	.-10     	; 0x2df6 <__floatsisf+0x62>
    2e00:	88 0f       	add	r24, r24
    2e02:	96 95       	lsr	r25
    2e04:	87 95       	ror	r24
    2e06:	97 f9       	bld	r25, 7
    2e08:	08 95       	ret

00002e0a <__fp_inf>:
    2e0a:	97 f9       	bld	r25, 7
    2e0c:	9f 67       	ori	r25, 0x7F	; 127
    2e0e:	80 e8       	ldi	r24, 0x80	; 128
    2e10:	70 e0       	ldi	r23, 0x00	; 0
    2e12:	60 e0       	ldi	r22, 0x00	; 0
    2e14:	08 95       	ret

00002e16 <__fp_nan>:
    2e16:	9f ef       	ldi	r25, 0xFF	; 255
    2e18:	80 ec       	ldi	r24, 0xC0	; 192
    2e1a:	08 95       	ret

00002e1c <__fp_pscA>:
    2e1c:	00 24       	eor	r0, r0
    2e1e:	0a 94       	dec	r0
    2e20:	16 16       	cp	r1, r22
    2e22:	17 06       	cpc	r1, r23
    2e24:	18 06       	cpc	r1, r24
    2e26:	09 06       	cpc	r0, r25
    2e28:	08 95       	ret

00002e2a <__fp_pscB>:
    2e2a:	00 24       	eor	r0, r0
    2e2c:	0a 94       	dec	r0
    2e2e:	12 16       	cp	r1, r18
    2e30:	13 06       	cpc	r1, r19
    2e32:	14 06       	cpc	r1, r20
    2e34:	05 06       	cpc	r0, r21
    2e36:	08 95       	ret

00002e38 <__fp_round>:
    2e38:	09 2e       	mov	r0, r25
    2e3a:	03 94       	inc	r0
    2e3c:	00 0c       	add	r0, r0
    2e3e:	11 f4       	brne	.+4      	; 0x2e44 <__fp_round+0xc>
    2e40:	88 23       	and	r24, r24
    2e42:	52 f0       	brmi	.+20     	; 0x2e58 <__fp_round+0x20>
    2e44:	bb 0f       	add	r27, r27
    2e46:	40 f4       	brcc	.+16     	; 0x2e58 <__fp_round+0x20>
    2e48:	bf 2b       	or	r27, r31
    2e4a:	11 f4       	brne	.+4      	; 0x2e50 <__fp_round+0x18>
    2e4c:	60 ff       	sbrs	r22, 0
    2e4e:	04 c0       	rjmp	.+8      	; 0x2e58 <__fp_round+0x20>
    2e50:	6f 5f       	subi	r22, 0xFF	; 255
    2e52:	7f 4f       	sbci	r23, 0xFF	; 255
    2e54:	8f 4f       	sbci	r24, 0xFF	; 255
    2e56:	9f 4f       	sbci	r25, 0xFF	; 255
    2e58:	08 95       	ret

00002e5a <__fp_split3>:
    2e5a:	57 fd       	sbrc	r21, 7
    2e5c:	90 58       	subi	r25, 0x80	; 128
    2e5e:	44 0f       	add	r20, r20
    2e60:	55 1f       	adc	r21, r21
    2e62:	59 f0       	breq	.+22     	; 0x2e7a <__fp_splitA+0x10>
    2e64:	5f 3f       	cpi	r21, 0xFF	; 255
    2e66:	71 f0       	breq	.+28     	; 0x2e84 <__fp_splitA+0x1a>
    2e68:	47 95       	ror	r20

00002e6a <__fp_splitA>:
    2e6a:	88 0f       	add	r24, r24
    2e6c:	97 fb       	bst	r25, 7
    2e6e:	99 1f       	adc	r25, r25
    2e70:	61 f0       	breq	.+24     	; 0x2e8a <__fp_splitA+0x20>
    2e72:	9f 3f       	cpi	r25, 0xFF	; 255
    2e74:	79 f0       	breq	.+30     	; 0x2e94 <__fp_splitA+0x2a>
    2e76:	87 95       	ror	r24
    2e78:	08 95       	ret
    2e7a:	12 16       	cp	r1, r18
    2e7c:	13 06       	cpc	r1, r19
    2e7e:	14 06       	cpc	r1, r20
    2e80:	55 1f       	adc	r21, r21
    2e82:	f2 cf       	rjmp	.-28     	; 0x2e68 <__fp_split3+0xe>
    2e84:	46 95       	lsr	r20
    2e86:	f1 df       	rcall	.-30     	; 0x2e6a <__fp_splitA>
    2e88:	08 c0       	rjmp	.+16     	; 0x2e9a <__fp_splitA+0x30>
    2e8a:	16 16       	cp	r1, r22
    2e8c:	17 06       	cpc	r1, r23
    2e8e:	18 06       	cpc	r1, r24
    2e90:	99 1f       	adc	r25, r25
    2e92:	f1 cf       	rjmp	.-30     	; 0x2e76 <__fp_splitA+0xc>
    2e94:	86 95       	lsr	r24
    2e96:	71 05       	cpc	r23, r1
    2e98:	61 05       	cpc	r22, r1
    2e9a:	08 94       	sec
    2e9c:	08 95       	ret

00002e9e <__fp_zero>:
    2e9e:	e8 94       	clt

00002ea0 <__fp_szero>:
    2ea0:	bb 27       	eor	r27, r27
    2ea2:	66 27       	eor	r22, r22
    2ea4:	77 27       	eor	r23, r23
    2ea6:	cb 01       	movw	r24, r22
    2ea8:	97 f9       	bld	r25, 7
    2eaa:	08 95       	ret

00002eac <__mulsf3>:
    2eac:	0e 94 69 17 	call	0x2ed2	; 0x2ed2 <__mulsf3x>
    2eb0:	0c 94 1c 17 	jmp	0x2e38	; 0x2e38 <__fp_round>
    2eb4:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <__fp_pscA>
    2eb8:	38 f0       	brcs	.+14     	; 0x2ec8 <__mulsf3+0x1c>
    2eba:	0e 94 15 17 	call	0x2e2a	; 0x2e2a <__fp_pscB>
    2ebe:	20 f0       	brcs	.+8      	; 0x2ec8 <__mulsf3+0x1c>
    2ec0:	95 23       	and	r25, r21
    2ec2:	11 f0       	breq	.+4      	; 0x2ec8 <__mulsf3+0x1c>
    2ec4:	0c 94 05 17 	jmp	0x2e0a	; 0x2e0a <__fp_inf>
    2ec8:	0c 94 0b 17 	jmp	0x2e16	; 0x2e16 <__fp_nan>
    2ecc:	11 24       	eor	r1, r1
    2ece:	0c 94 50 17 	jmp	0x2ea0	; 0x2ea0 <__fp_szero>

00002ed2 <__mulsf3x>:
    2ed2:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <__fp_split3>
    2ed6:	70 f3       	brcs	.-36     	; 0x2eb4 <__mulsf3+0x8>

00002ed8 <__mulsf3_pse>:
    2ed8:	95 9f       	mul	r25, r21
    2eda:	c1 f3       	breq	.-16     	; 0x2ecc <__mulsf3+0x20>
    2edc:	95 0f       	add	r25, r21
    2ede:	50 e0       	ldi	r21, 0x00	; 0
    2ee0:	55 1f       	adc	r21, r21
    2ee2:	62 9f       	mul	r22, r18
    2ee4:	f0 01       	movw	r30, r0
    2ee6:	72 9f       	mul	r23, r18
    2ee8:	bb 27       	eor	r27, r27
    2eea:	f0 0d       	add	r31, r0
    2eec:	b1 1d       	adc	r27, r1
    2eee:	63 9f       	mul	r22, r19
    2ef0:	aa 27       	eor	r26, r26
    2ef2:	f0 0d       	add	r31, r0
    2ef4:	b1 1d       	adc	r27, r1
    2ef6:	aa 1f       	adc	r26, r26
    2ef8:	64 9f       	mul	r22, r20
    2efa:	66 27       	eor	r22, r22
    2efc:	b0 0d       	add	r27, r0
    2efe:	a1 1d       	adc	r26, r1
    2f00:	66 1f       	adc	r22, r22
    2f02:	82 9f       	mul	r24, r18
    2f04:	22 27       	eor	r18, r18
    2f06:	b0 0d       	add	r27, r0
    2f08:	a1 1d       	adc	r26, r1
    2f0a:	62 1f       	adc	r22, r18
    2f0c:	73 9f       	mul	r23, r19
    2f0e:	b0 0d       	add	r27, r0
    2f10:	a1 1d       	adc	r26, r1
    2f12:	62 1f       	adc	r22, r18
    2f14:	83 9f       	mul	r24, r19
    2f16:	a0 0d       	add	r26, r0
    2f18:	61 1d       	adc	r22, r1
    2f1a:	22 1f       	adc	r18, r18
    2f1c:	74 9f       	mul	r23, r20
    2f1e:	33 27       	eor	r19, r19
    2f20:	a0 0d       	add	r26, r0
    2f22:	61 1d       	adc	r22, r1
    2f24:	23 1f       	adc	r18, r19
    2f26:	84 9f       	mul	r24, r20
    2f28:	60 0d       	add	r22, r0
    2f2a:	21 1d       	adc	r18, r1
    2f2c:	82 2f       	mov	r24, r18
    2f2e:	76 2f       	mov	r23, r22
    2f30:	6a 2f       	mov	r22, r26
    2f32:	11 24       	eor	r1, r1
    2f34:	9f 57       	subi	r25, 0x7F	; 127
    2f36:	50 40       	sbci	r21, 0x00	; 0
    2f38:	9a f0       	brmi	.+38     	; 0x2f60 <__mulsf3_pse+0x88>
    2f3a:	f1 f0       	breq	.+60     	; 0x2f78 <__mulsf3_pse+0xa0>
    2f3c:	88 23       	and	r24, r24
    2f3e:	4a f0       	brmi	.+18     	; 0x2f52 <__mulsf3_pse+0x7a>
    2f40:	ee 0f       	add	r30, r30
    2f42:	ff 1f       	adc	r31, r31
    2f44:	bb 1f       	adc	r27, r27
    2f46:	66 1f       	adc	r22, r22
    2f48:	77 1f       	adc	r23, r23
    2f4a:	88 1f       	adc	r24, r24
    2f4c:	91 50       	subi	r25, 0x01	; 1
    2f4e:	50 40       	sbci	r21, 0x00	; 0
    2f50:	a9 f7       	brne	.-22     	; 0x2f3c <__mulsf3_pse+0x64>
    2f52:	9e 3f       	cpi	r25, 0xFE	; 254
    2f54:	51 05       	cpc	r21, r1
    2f56:	80 f0       	brcs	.+32     	; 0x2f78 <__mulsf3_pse+0xa0>
    2f58:	0c 94 05 17 	jmp	0x2e0a	; 0x2e0a <__fp_inf>
    2f5c:	0c 94 50 17 	jmp	0x2ea0	; 0x2ea0 <__fp_szero>
    2f60:	5f 3f       	cpi	r21, 0xFF	; 255
    2f62:	e4 f3       	brlt	.-8      	; 0x2f5c <__mulsf3_pse+0x84>
    2f64:	98 3e       	cpi	r25, 0xE8	; 232
    2f66:	d4 f3       	brlt	.-12     	; 0x2f5c <__mulsf3_pse+0x84>
    2f68:	86 95       	lsr	r24
    2f6a:	77 95       	ror	r23
    2f6c:	67 95       	ror	r22
    2f6e:	b7 95       	ror	r27
    2f70:	f7 95       	ror	r31
    2f72:	e7 95       	ror	r30
    2f74:	9f 5f       	subi	r25, 0xFF	; 255
    2f76:	c1 f7       	brne	.-16     	; 0x2f68 <__mulsf3_pse+0x90>
    2f78:	fe 2b       	or	r31, r30
    2f7a:	88 0f       	add	r24, r24
    2f7c:	91 1d       	adc	r25, r1
    2f7e:	96 95       	lsr	r25
    2f80:	87 95       	ror	r24
    2f82:	97 f9       	bld	r25, 7
    2f84:	08 95       	ret

00002f86 <__tablejump2__>:
    2f86:	ee 0f       	add	r30, r30
    2f88:	ff 1f       	adc	r31, r31
    2f8a:	05 90       	lpm	r0, Z+
    2f8c:	f4 91       	lpm	r31, Z
    2f8e:	e0 2d       	mov	r30, r0
    2f90:	09 94       	ijmp

00002f92 <strcmp>:
    2f92:	fb 01       	movw	r30, r22
    2f94:	dc 01       	movw	r26, r24
    2f96:	8d 91       	ld	r24, X+
    2f98:	01 90       	ld	r0, Z+
    2f9a:	80 19       	sub	r24, r0
    2f9c:	01 10       	cpse	r0, r1
    2f9e:	d9 f3       	breq	.-10     	; 0x2f96 <strcmp+0x4>
    2fa0:	99 0b       	sbc	r25, r25
    2fa2:	08 95       	ret

00002fa4 <strcpy>:
    2fa4:	fb 01       	movw	r30, r22
    2fa6:	dc 01       	movw	r26, r24
    2fa8:	01 90       	ld	r0, Z+
    2faa:	0d 92       	st	X+, r0
    2fac:	00 20       	and	r0, r0
    2fae:	e1 f7       	brne	.-8      	; 0x2fa8 <strcpy+0x4>
    2fb0:	08 95       	ret

00002fb2 <sprintf>:
    2fb2:	ae e0       	ldi	r26, 0x0E	; 14
    2fb4:	b0 e0       	ldi	r27, 0x00	; 0
    2fb6:	ef ed       	ldi	r30, 0xDF	; 223
    2fb8:	f7 e1       	ldi	r31, 0x17	; 23
    2fba:	0c 94 9a 1a 	jmp	0x3534	; 0x3534 <__prologue_saves__+0x1c>
    2fbe:	0d 89       	ldd	r16, Y+21	; 0x15
    2fc0:	1e 89       	ldd	r17, Y+22	; 0x16
    2fc2:	86 e0       	ldi	r24, 0x06	; 6
    2fc4:	8c 83       	std	Y+4, r24	; 0x04
    2fc6:	1a 83       	std	Y+2, r17	; 0x02
    2fc8:	09 83       	std	Y+1, r16	; 0x01
    2fca:	8f ef       	ldi	r24, 0xFF	; 255
    2fcc:	9f e7       	ldi	r25, 0x7F	; 127
    2fce:	9e 83       	std	Y+6, r25	; 0x06
    2fd0:	8d 83       	std	Y+5, r24	; 0x05
    2fd2:	ae 01       	movw	r20, r28
    2fd4:	47 5e       	subi	r20, 0xE7	; 231
    2fd6:	5f 4f       	sbci	r21, 0xFF	; 255
    2fd8:	6f 89       	ldd	r22, Y+23	; 0x17
    2fda:	78 8d       	ldd	r23, Y+24	; 0x18
    2fdc:	ce 01       	movw	r24, r28
    2fde:	01 96       	adiw	r24, 0x01	; 1
    2fe0:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <vfprintf>
    2fe4:	ef 81       	ldd	r30, Y+7	; 0x07
    2fe6:	f8 85       	ldd	r31, Y+8	; 0x08
    2fe8:	e0 0f       	add	r30, r16
    2fea:	f1 1f       	adc	r31, r17
    2fec:	10 82       	st	Z, r1
    2fee:	2e 96       	adiw	r28, 0x0e	; 14
    2ff0:	e4 e0       	ldi	r30, 0x04	; 4
    2ff2:	0c 94 b6 1a 	jmp	0x356c	; 0x356c <__epilogue_restores__+0x1c>

00002ff6 <vfprintf>:
    2ff6:	ab e0       	ldi	r26, 0x0B	; 11
    2ff8:	b0 e0       	ldi	r27, 0x00	; 0
    2ffa:	e1 e0       	ldi	r30, 0x01	; 1
    2ffc:	f8 e1       	ldi	r31, 0x18	; 24
    2ffe:	0c 94 8c 1a 	jmp	0x3518	; 0x3518 <__prologue_saves__>
    3002:	6c 01       	movw	r12, r24
    3004:	7b 01       	movw	r14, r22
    3006:	8a 01       	movw	r16, r20
    3008:	fc 01       	movw	r30, r24
    300a:	17 82       	std	Z+7, r1	; 0x07
    300c:	16 82       	std	Z+6, r1	; 0x06
    300e:	83 81       	ldd	r24, Z+3	; 0x03
    3010:	81 ff       	sbrs	r24, 1
    3012:	cc c1       	rjmp	.+920    	; 0x33ac <vfprintf+0x3b6>
    3014:	ce 01       	movw	r24, r28
    3016:	01 96       	adiw	r24, 0x01	; 1
    3018:	3c 01       	movw	r6, r24
    301a:	f6 01       	movw	r30, r12
    301c:	93 81       	ldd	r25, Z+3	; 0x03
    301e:	f7 01       	movw	r30, r14
    3020:	93 fd       	sbrc	r25, 3
    3022:	85 91       	lpm	r24, Z+
    3024:	93 ff       	sbrs	r25, 3
    3026:	81 91       	ld	r24, Z+
    3028:	7f 01       	movw	r14, r30
    302a:	88 23       	and	r24, r24
    302c:	09 f4       	brne	.+2      	; 0x3030 <vfprintf+0x3a>
    302e:	ba c1       	rjmp	.+884    	; 0x33a4 <vfprintf+0x3ae>
    3030:	85 32       	cpi	r24, 0x25	; 37
    3032:	39 f4       	brne	.+14     	; 0x3042 <vfprintf+0x4c>
    3034:	93 fd       	sbrc	r25, 3
    3036:	85 91       	lpm	r24, Z+
    3038:	93 ff       	sbrs	r25, 3
    303a:	81 91       	ld	r24, Z+
    303c:	7f 01       	movw	r14, r30
    303e:	85 32       	cpi	r24, 0x25	; 37
    3040:	29 f4       	brne	.+10     	; 0x304c <vfprintf+0x56>
    3042:	b6 01       	movw	r22, r12
    3044:	90 e0       	ldi	r25, 0x00	; 0
    3046:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <fputc>
    304a:	e7 cf       	rjmp	.-50     	; 0x301a <vfprintf+0x24>
    304c:	91 2c       	mov	r9, r1
    304e:	21 2c       	mov	r2, r1
    3050:	31 2c       	mov	r3, r1
    3052:	ff e1       	ldi	r31, 0x1F	; 31
    3054:	f3 15       	cp	r31, r3
    3056:	d8 f0       	brcs	.+54     	; 0x308e <vfprintf+0x98>
    3058:	8b 32       	cpi	r24, 0x2B	; 43
    305a:	79 f0       	breq	.+30     	; 0x307a <vfprintf+0x84>
    305c:	38 f4       	brcc	.+14     	; 0x306c <vfprintf+0x76>
    305e:	80 32       	cpi	r24, 0x20	; 32
    3060:	79 f0       	breq	.+30     	; 0x3080 <vfprintf+0x8a>
    3062:	83 32       	cpi	r24, 0x23	; 35
    3064:	a1 f4       	brne	.+40     	; 0x308e <vfprintf+0x98>
    3066:	23 2d       	mov	r18, r3
    3068:	20 61       	ori	r18, 0x10	; 16
    306a:	1d c0       	rjmp	.+58     	; 0x30a6 <vfprintf+0xb0>
    306c:	8d 32       	cpi	r24, 0x2D	; 45
    306e:	61 f0       	breq	.+24     	; 0x3088 <vfprintf+0x92>
    3070:	80 33       	cpi	r24, 0x30	; 48
    3072:	69 f4       	brne	.+26     	; 0x308e <vfprintf+0x98>
    3074:	23 2d       	mov	r18, r3
    3076:	21 60       	ori	r18, 0x01	; 1
    3078:	16 c0       	rjmp	.+44     	; 0x30a6 <vfprintf+0xb0>
    307a:	83 2d       	mov	r24, r3
    307c:	82 60       	ori	r24, 0x02	; 2
    307e:	38 2e       	mov	r3, r24
    3080:	e3 2d       	mov	r30, r3
    3082:	e4 60       	ori	r30, 0x04	; 4
    3084:	3e 2e       	mov	r3, r30
    3086:	2a c0       	rjmp	.+84     	; 0x30dc <vfprintf+0xe6>
    3088:	f3 2d       	mov	r31, r3
    308a:	f8 60       	ori	r31, 0x08	; 8
    308c:	1d c0       	rjmp	.+58     	; 0x30c8 <vfprintf+0xd2>
    308e:	37 fc       	sbrc	r3, 7
    3090:	2d c0       	rjmp	.+90     	; 0x30ec <vfprintf+0xf6>
    3092:	20 ed       	ldi	r18, 0xD0	; 208
    3094:	28 0f       	add	r18, r24
    3096:	2a 30       	cpi	r18, 0x0A	; 10
    3098:	40 f0       	brcs	.+16     	; 0x30aa <vfprintf+0xb4>
    309a:	8e 32       	cpi	r24, 0x2E	; 46
    309c:	b9 f4       	brne	.+46     	; 0x30cc <vfprintf+0xd6>
    309e:	36 fc       	sbrc	r3, 6
    30a0:	81 c1       	rjmp	.+770    	; 0x33a4 <vfprintf+0x3ae>
    30a2:	23 2d       	mov	r18, r3
    30a4:	20 64       	ori	r18, 0x40	; 64
    30a6:	32 2e       	mov	r3, r18
    30a8:	19 c0       	rjmp	.+50     	; 0x30dc <vfprintf+0xe6>
    30aa:	36 fe       	sbrs	r3, 6
    30ac:	06 c0       	rjmp	.+12     	; 0x30ba <vfprintf+0xc4>
    30ae:	8a e0       	ldi	r24, 0x0A	; 10
    30b0:	98 9e       	mul	r9, r24
    30b2:	20 0d       	add	r18, r0
    30b4:	11 24       	eor	r1, r1
    30b6:	92 2e       	mov	r9, r18
    30b8:	11 c0       	rjmp	.+34     	; 0x30dc <vfprintf+0xe6>
    30ba:	ea e0       	ldi	r30, 0x0A	; 10
    30bc:	2e 9e       	mul	r2, r30
    30be:	20 0d       	add	r18, r0
    30c0:	11 24       	eor	r1, r1
    30c2:	22 2e       	mov	r2, r18
    30c4:	f3 2d       	mov	r31, r3
    30c6:	f0 62       	ori	r31, 0x20	; 32
    30c8:	3f 2e       	mov	r3, r31
    30ca:	08 c0       	rjmp	.+16     	; 0x30dc <vfprintf+0xe6>
    30cc:	8c 36       	cpi	r24, 0x6C	; 108
    30ce:	21 f4       	brne	.+8      	; 0x30d8 <vfprintf+0xe2>
    30d0:	83 2d       	mov	r24, r3
    30d2:	80 68       	ori	r24, 0x80	; 128
    30d4:	38 2e       	mov	r3, r24
    30d6:	02 c0       	rjmp	.+4      	; 0x30dc <vfprintf+0xe6>
    30d8:	88 36       	cpi	r24, 0x68	; 104
    30da:	41 f4       	brne	.+16     	; 0x30ec <vfprintf+0xf6>
    30dc:	f7 01       	movw	r30, r14
    30de:	93 fd       	sbrc	r25, 3
    30e0:	85 91       	lpm	r24, Z+
    30e2:	93 ff       	sbrs	r25, 3
    30e4:	81 91       	ld	r24, Z+
    30e6:	7f 01       	movw	r14, r30
    30e8:	81 11       	cpse	r24, r1
    30ea:	b3 cf       	rjmp	.-154    	; 0x3052 <vfprintf+0x5c>
    30ec:	98 2f       	mov	r25, r24
    30ee:	9f 7d       	andi	r25, 0xDF	; 223
    30f0:	95 54       	subi	r25, 0x45	; 69
    30f2:	93 30       	cpi	r25, 0x03	; 3
    30f4:	28 f4       	brcc	.+10     	; 0x3100 <vfprintf+0x10a>
    30f6:	0c 5f       	subi	r16, 0xFC	; 252
    30f8:	1f 4f       	sbci	r17, 0xFF	; 255
    30fa:	9f e3       	ldi	r25, 0x3F	; 63
    30fc:	99 83       	std	Y+1, r25	; 0x01
    30fe:	0d c0       	rjmp	.+26     	; 0x311a <vfprintf+0x124>
    3100:	83 36       	cpi	r24, 0x63	; 99
    3102:	31 f0       	breq	.+12     	; 0x3110 <vfprintf+0x11a>
    3104:	83 37       	cpi	r24, 0x73	; 115
    3106:	71 f0       	breq	.+28     	; 0x3124 <vfprintf+0x12e>
    3108:	83 35       	cpi	r24, 0x53	; 83
    310a:	09 f0       	breq	.+2      	; 0x310e <vfprintf+0x118>
    310c:	59 c0       	rjmp	.+178    	; 0x31c0 <vfprintf+0x1ca>
    310e:	21 c0       	rjmp	.+66     	; 0x3152 <vfprintf+0x15c>
    3110:	f8 01       	movw	r30, r16
    3112:	80 81       	ld	r24, Z
    3114:	89 83       	std	Y+1, r24	; 0x01
    3116:	0e 5f       	subi	r16, 0xFE	; 254
    3118:	1f 4f       	sbci	r17, 0xFF	; 255
    311a:	88 24       	eor	r8, r8
    311c:	83 94       	inc	r8
    311e:	91 2c       	mov	r9, r1
    3120:	53 01       	movw	r10, r6
    3122:	13 c0       	rjmp	.+38     	; 0x314a <vfprintf+0x154>
    3124:	28 01       	movw	r4, r16
    3126:	f2 e0       	ldi	r31, 0x02	; 2
    3128:	4f 0e       	add	r4, r31
    312a:	51 1c       	adc	r5, r1
    312c:	f8 01       	movw	r30, r16
    312e:	a0 80       	ld	r10, Z
    3130:	b1 80       	ldd	r11, Z+1	; 0x01
    3132:	36 fe       	sbrs	r3, 6
    3134:	03 c0       	rjmp	.+6      	; 0x313c <vfprintf+0x146>
    3136:	69 2d       	mov	r22, r9
    3138:	70 e0       	ldi	r23, 0x00	; 0
    313a:	02 c0       	rjmp	.+4      	; 0x3140 <vfprintf+0x14a>
    313c:	6f ef       	ldi	r22, 0xFF	; 255
    313e:	7f ef       	ldi	r23, 0xFF	; 255
    3140:	c5 01       	movw	r24, r10
    3142:	0e 94 e7 19 	call	0x33ce	; 0x33ce <strnlen>
    3146:	4c 01       	movw	r8, r24
    3148:	82 01       	movw	r16, r4
    314a:	f3 2d       	mov	r31, r3
    314c:	ff 77       	andi	r31, 0x7F	; 127
    314e:	3f 2e       	mov	r3, r31
    3150:	16 c0       	rjmp	.+44     	; 0x317e <vfprintf+0x188>
    3152:	28 01       	movw	r4, r16
    3154:	22 e0       	ldi	r18, 0x02	; 2
    3156:	42 0e       	add	r4, r18
    3158:	51 1c       	adc	r5, r1
    315a:	f8 01       	movw	r30, r16
    315c:	a0 80       	ld	r10, Z
    315e:	b1 80       	ldd	r11, Z+1	; 0x01
    3160:	36 fe       	sbrs	r3, 6
    3162:	03 c0       	rjmp	.+6      	; 0x316a <vfprintf+0x174>
    3164:	69 2d       	mov	r22, r9
    3166:	70 e0       	ldi	r23, 0x00	; 0
    3168:	02 c0       	rjmp	.+4      	; 0x316e <vfprintf+0x178>
    316a:	6f ef       	ldi	r22, 0xFF	; 255
    316c:	7f ef       	ldi	r23, 0xFF	; 255
    316e:	c5 01       	movw	r24, r10
    3170:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <strnlen_P>
    3174:	4c 01       	movw	r8, r24
    3176:	f3 2d       	mov	r31, r3
    3178:	f0 68       	ori	r31, 0x80	; 128
    317a:	3f 2e       	mov	r3, r31
    317c:	82 01       	movw	r16, r4
    317e:	33 fc       	sbrc	r3, 3
    3180:	1b c0       	rjmp	.+54     	; 0x31b8 <vfprintf+0x1c2>
    3182:	82 2d       	mov	r24, r2
    3184:	90 e0       	ldi	r25, 0x00	; 0
    3186:	88 16       	cp	r8, r24
    3188:	99 06       	cpc	r9, r25
    318a:	b0 f4       	brcc	.+44     	; 0x31b8 <vfprintf+0x1c2>
    318c:	b6 01       	movw	r22, r12
    318e:	80 e2       	ldi	r24, 0x20	; 32
    3190:	90 e0       	ldi	r25, 0x00	; 0
    3192:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <fputc>
    3196:	2a 94       	dec	r2
    3198:	f4 cf       	rjmp	.-24     	; 0x3182 <vfprintf+0x18c>
    319a:	f5 01       	movw	r30, r10
    319c:	37 fc       	sbrc	r3, 7
    319e:	85 91       	lpm	r24, Z+
    31a0:	37 fe       	sbrs	r3, 7
    31a2:	81 91       	ld	r24, Z+
    31a4:	5f 01       	movw	r10, r30
    31a6:	b6 01       	movw	r22, r12
    31a8:	90 e0       	ldi	r25, 0x00	; 0
    31aa:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <fputc>
    31ae:	21 10       	cpse	r2, r1
    31b0:	2a 94       	dec	r2
    31b2:	21 e0       	ldi	r18, 0x01	; 1
    31b4:	82 1a       	sub	r8, r18
    31b6:	91 08       	sbc	r9, r1
    31b8:	81 14       	cp	r8, r1
    31ba:	91 04       	cpc	r9, r1
    31bc:	71 f7       	brne	.-36     	; 0x319a <vfprintf+0x1a4>
    31be:	e8 c0       	rjmp	.+464    	; 0x3390 <vfprintf+0x39a>
    31c0:	84 36       	cpi	r24, 0x64	; 100
    31c2:	11 f0       	breq	.+4      	; 0x31c8 <vfprintf+0x1d2>
    31c4:	89 36       	cpi	r24, 0x69	; 105
    31c6:	41 f5       	brne	.+80     	; 0x3218 <vfprintf+0x222>
    31c8:	f8 01       	movw	r30, r16
    31ca:	37 fe       	sbrs	r3, 7
    31cc:	07 c0       	rjmp	.+14     	; 0x31dc <vfprintf+0x1e6>
    31ce:	60 81       	ld	r22, Z
    31d0:	71 81       	ldd	r23, Z+1	; 0x01
    31d2:	82 81       	ldd	r24, Z+2	; 0x02
    31d4:	93 81       	ldd	r25, Z+3	; 0x03
    31d6:	0c 5f       	subi	r16, 0xFC	; 252
    31d8:	1f 4f       	sbci	r17, 0xFF	; 255
    31da:	08 c0       	rjmp	.+16     	; 0x31ec <vfprintf+0x1f6>
    31dc:	60 81       	ld	r22, Z
    31de:	71 81       	ldd	r23, Z+1	; 0x01
    31e0:	07 2e       	mov	r0, r23
    31e2:	00 0c       	add	r0, r0
    31e4:	88 0b       	sbc	r24, r24
    31e6:	99 0b       	sbc	r25, r25
    31e8:	0e 5f       	subi	r16, 0xFE	; 254
    31ea:	1f 4f       	sbci	r17, 0xFF	; 255
    31ec:	f3 2d       	mov	r31, r3
    31ee:	ff 76       	andi	r31, 0x6F	; 111
    31f0:	3f 2e       	mov	r3, r31
    31f2:	97 ff       	sbrs	r25, 7
    31f4:	09 c0       	rjmp	.+18     	; 0x3208 <vfprintf+0x212>
    31f6:	90 95       	com	r25
    31f8:	80 95       	com	r24
    31fa:	70 95       	com	r23
    31fc:	61 95       	neg	r22
    31fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3200:	8f 4f       	sbci	r24, 0xFF	; 255
    3202:	9f 4f       	sbci	r25, 0xFF	; 255
    3204:	f0 68       	ori	r31, 0x80	; 128
    3206:	3f 2e       	mov	r3, r31
    3208:	2a e0       	ldi	r18, 0x0A	; 10
    320a:	30 e0       	ldi	r19, 0x00	; 0
    320c:	a3 01       	movw	r20, r6
    320e:	0e 94 2e 1a 	call	0x345c	; 0x345c <__ultoa_invert>
    3212:	88 2e       	mov	r8, r24
    3214:	86 18       	sub	r8, r6
    3216:	45 c0       	rjmp	.+138    	; 0x32a2 <vfprintf+0x2ac>
    3218:	85 37       	cpi	r24, 0x75	; 117
    321a:	31 f4       	brne	.+12     	; 0x3228 <vfprintf+0x232>
    321c:	23 2d       	mov	r18, r3
    321e:	2f 7e       	andi	r18, 0xEF	; 239
    3220:	b2 2e       	mov	r11, r18
    3222:	2a e0       	ldi	r18, 0x0A	; 10
    3224:	30 e0       	ldi	r19, 0x00	; 0
    3226:	25 c0       	rjmp	.+74     	; 0x3272 <vfprintf+0x27c>
    3228:	93 2d       	mov	r25, r3
    322a:	99 7f       	andi	r25, 0xF9	; 249
    322c:	b9 2e       	mov	r11, r25
    322e:	8f 36       	cpi	r24, 0x6F	; 111
    3230:	c1 f0       	breq	.+48     	; 0x3262 <vfprintf+0x26c>
    3232:	18 f4       	brcc	.+6      	; 0x323a <vfprintf+0x244>
    3234:	88 35       	cpi	r24, 0x58	; 88
    3236:	79 f0       	breq	.+30     	; 0x3256 <vfprintf+0x260>
    3238:	b5 c0       	rjmp	.+362    	; 0x33a4 <vfprintf+0x3ae>
    323a:	80 37       	cpi	r24, 0x70	; 112
    323c:	19 f0       	breq	.+6      	; 0x3244 <vfprintf+0x24e>
    323e:	88 37       	cpi	r24, 0x78	; 120
    3240:	21 f0       	breq	.+8      	; 0x324a <vfprintf+0x254>
    3242:	b0 c0       	rjmp	.+352    	; 0x33a4 <vfprintf+0x3ae>
    3244:	e9 2f       	mov	r30, r25
    3246:	e0 61       	ori	r30, 0x10	; 16
    3248:	be 2e       	mov	r11, r30
    324a:	b4 fe       	sbrs	r11, 4
    324c:	0d c0       	rjmp	.+26     	; 0x3268 <vfprintf+0x272>
    324e:	fb 2d       	mov	r31, r11
    3250:	f4 60       	ori	r31, 0x04	; 4
    3252:	bf 2e       	mov	r11, r31
    3254:	09 c0       	rjmp	.+18     	; 0x3268 <vfprintf+0x272>
    3256:	34 fe       	sbrs	r3, 4
    3258:	0a c0       	rjmp	.+20     	; 0x326e <vfprintf+0x278>
    325a:	29 2f       	mov	r18, r25
    325c:	26 60       	ori	r18, 0x06	; 6
    325e:	b2 2e       	mov	r11, r18
    3260:	06 c0       	rjmp	.+12     	; 0x326e <vfprintf+0x278>
    3262:	28 e0       	ldi	r18, 0x08	; 8
    3264:	30 e0       	ldi	r19, 0x00	; 0
    3266:	05 c0       	rjmp	.+10     	; 0x3272 <vfprintf+0x27c>
    3268:	20 e1       	ldi	r18, 0x10	; 16
    326a:	30 e0       	ldi	r19, 0x00	; 0
    326c:	02 c0       	rjmp	.+4      	; 0x3272 <vfprintf+0x27c>
    326e:	20 e1       	ldi	r18, 0x10	; 16
    3270:	32 e0       	ldi	r19, 0x02	; 2
    3272:	f8 01       	movw	r30, r16
    3274:	b7 fe       	sbrs	r11, 7
    3276:	07 c0       	rjmp	.+14     	; 0x3286 <vfprintf+0x290>
    3278:	60 81       	ld	r22, Z
    327a:	71 81       	ldd	r23, Z+1	; 0x01
    327c:	82 81       	ldd	r24, Z+2	; 0x02
    327e:	93 81       	ldd	r25, Z+3	; 0x03
    3280:	0c 5f       	subi	r16, 0xFC	; 252
    3282:	1f 4f       	sbci	r17, 0xFF	; 255
    3284:	06 c0       	rjmp	.+12     	; 0x3292 <vfprintf+0x29c>
    3286:	60 81       	ld	r22, Z
    3288:	71 81       	ldd	r23, Z+1	; 0x01
    328a:	80 e0       	ldi	r24, 0x00	; 0
    328c:	90 e0       	ldi	r25, 0x00	; 0
    328e:	0e 5f       	subi	r16, 0xFE	; 254
    3290:	1f 4f       	sbci	r17, 0xFF	; 255
    3292:	a3 01       	movw	r20, r6
    3294:	0e 94 2e 1a 	call	0x345c	; 0x345c <__ultoa_invert>
    3298:	88 2e       	mov	r8, r24
    329a:	86 18       	sub	r8, r6
    329c:	fb 2d       	mov	r31, r11
    329e:	ff 77       	andi	r31, 0x7F	; 127
    32a0:	3f 2e       	mov	r3, r31
    32a2:	36 fe       	sbrs	r3, 6
    32a4:	0d c0       	rjmp	.+26     	; 0x32c0 <vfprintf+0x2ca>
    32a6:	23 2d       	mov	r18, r3
    32a8:	2e 7f       	andi	r18, 0xFE	; 254
    32aa:	a2 2e       	mov	r10, r18
    32ac:	89 14       	cp	r8, r9
    32ae:	58 f4       	brcc	.+22     	; 0x32c6 <vfprintf+0x2d0>
    32b0:	34 fe       	sbrs	r3, 4
    32b2:	0b c0       	rjmp	.+22     	; 0x32ca <vfprintf+0x2d4>
    32b4:	32 fc       	sbrc	r3, 2
    32b6:	09 c0       	rjmp	.+18     	; 0x32ca <vfprintf+0x2d4>
    32b8:	83 2d       	mov	r24, r3
    32ba:	8e 7e       	andi	r24, 0xEE	; 238
    32bc:	a8 2e       	mov	r10, r24
    32be:	05 c0       	rjmp	.+10     	; 0x32ca <vfprintf+0x2d4>
    32c0:	b8 2c       	mov	r11, r8
    32c2:	a3 2c       	mov	r10, r3
    32c4:	03 c0       	rjmp	.+6      	; 0x32cc <vfprintf+0x2d6>
    32c6:	b8 2c       	mov	r11, r8
    32c8:	01 c0       	rjmp	.+2      	; 0x32cc <vfprintf+0x2d6>
    32ca:	b9 2c       	mov	r11, r9
    32cc:	a4 fe       	sbrs	r10, 4
    32ce:	0f c0       	rjmp	.+30     	; 0x32ee <vfprintf+0x2f8>
    32d0:	fe 01       	movw	r30, r28
    32d2:	e8 0d       	add	r30, r8
    32d4:	f1 1d       	adc	r31, r1
    32d6:	80 81       	ld	r24, Z
    32d8:	80 33       	cpi	r24, 0x30	; 48
    32da:	21 f4       	brne	.+8      	; 0x32e4 <vfprintf+0x2ee>
    32dc:	9a 2d       	mov	r25, r10
    32de:	99 7e       	andi	r25, 0xE9	; 233
    32e0:	a9 2e       	mov	r10, r25
    32e2:	09 c0       	rjmp	.+18     	; 0x32f6 <vfprintf+0x300>
    32e4:	a2 fe       	sbrs	r10, 2
    32e6:	06 c0       	rjmp	.+12     	; 0x32f4 <vfprintf+0x2fe>
    32e8:	b3 94       	inc	r11
    32ea:	b3 94       	inc	r11
    32ec:	04 c0       	rjmp	.+8      	; 0x32f6 <vfprintf+0x300>
    32ee:	8a 2d       	mov	r24, r10
    32f0:	86 78       	andi	r24, 0x86	; 134
    32f2:	09 f0       	breq	.+2      	; 0x32f6 <vfprintf+0x300>
    32f4:	b3 94       	inc	r11
    32f6:	a3 fc       	sbrc	r10, 3
    32f8:	11 c0       	rjmp	.+34     	; 0x331c <vfprintf+0x326>
    32fa:	a0 fe       	sbrs	r10, 0
    32fc:	06 c0       	rjmp	.+12     	; 0x330a <vfprintf+0x314>
    32fe:	b2 14       	cp	r11, r2
    3300:	88 f4       	brcc	.+34     	; 0x3324 <vfprintf+0x32e>
    3302:	28 0c       	add	r2, r8
    3304:	92 2c       	mov	r9, r2
    3306:	9b 18       	sub	r9, r11
    3308:	0e c0       	rjmp	.+28     	; 0x3326 <vfprintf+0x330>
    330a:	b2 14       	cp	r11, r2
    330c:	60 f4       	brcc	.+24     	; 0x3326 <vfprintf+0x330>
    330e:	b6 01       	movw	r22, r12
    3310:	80 e2       	ldi	r24, 0x20	; 32
    3312:	90 e0       	ldi	r25, 0x00	; 0
    3314:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <fputc>
    3318:	b3 94       	inc	r11
    331a:	f7 cf       	rjmp	.-18     	; 0x330a <vfprintf+0x314>
    331c:	b2 14       	cp	r11, r2
    331e:	18 f4       	brcc	.+6      	; 0x3326 <vfprintf+0x330>
    3320:	2b 18       	sub	r2, r11
    3322:	02 c0       	rjmp	.+4      	; 0x3328 <vfprintf+0x332>
    3324:	98 2c       	mov	r9, r8
    3326:	21 2c       	mov	r2, r1
    3328:	a4 fe       	sbrs	r10, 4
    332a:	10 c0       	rjmp	.+32     	; 0x334c <vfprintf+0x356>
    332c:	b6 01       	movw	r22, r12
    332e:	80 e3       	ldi	r24, 0x30	; 48
    3330:	90 e0       	ldi	r25, 0x00	; 0
    3332:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <fputc>
    3336:	a2 fe       	sbrs	r10, 2
    3338:	17 c0       	rjmp	.+46     	; 0x3368 <vfprintf+0x372>
    333a:	a1 fc       	sbrc	r10, 1
    333c:	03 c0       	rjmp	.+6      	; 0x3344 <vfprintf+0x34e>
    333e:	88 e7       	ldi	r24, 0x78	; 120
    3340:	90 e0       	ldi	r25, 0x00	; 0
    3342:	02 c0       	rjmp	.+4      	; 0x3348 <vfprintf+0x352>
    3344:	88 e5       	ldi	r24, 0x58	; 88
    3346:	90 e0       	ldi	r25, 0x00	; 0
    3348:	b6 01       	movw	r22, r12
    334a:	0c c0       	rjmp	.+24     	; 0x3364 <vfprintf+0x36e>
    334c:	8a 2d       	mov	r24, r10
    334e:	86 78       	andi	r24, 0x86	; 134
    3350:	59 f0       	breq	.+22     	; 0x3368 <vfprintf+0x372>
    3352:	a1 fe       	sbrs	r10, 1
    3354:	02 c0       	rjmp	.+4      	; 0x335a <vfprintf+0x364>
    3356:	8b e2       	ldi	r24, 0x2B	; 43
    3358:	01 c0       	rjmp	.+2      	; 0x335c <vfprintf+0x366>
    335a:	80 e2       	ldi	r24, 0x20	; 32
    335c:	a7 fc       	sbrc	r10, 7
    335e:	8d e2       	ldi	r24, 0x2D	; 45
    3360:	b6 01       	movw	r22, r12
    3362:	90 e0       	ldi	r25, 0x00	; 0
    3364:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <fputc>
    3368:	89 14       	cp	r8, r9
    336a:	38 f4       	brcc	.+14     	; 0x337a <vfprintf+0x384>
    336c:	b6 01       	movw	r22, r12
    336e:	80 e3       	ldi	r24, 0x30	; 48
    3370:	90 e0       	ldi	r25, 0x00	; 0
    3372:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <fputc>
    3376:	9a 94       	dec	r9
    3378:	f7 cf       	rjmp	.-18     	; 0x3368 <vfprintf+0x372>
    337a:	8a 94       	dec	r8
    337c:	f3 01       	movw	r30, r6
    337e:	e8 0d       	add	r30, r8
    3380:	f1 1d       	adc	r31, r1
    3382:	80 81       	ld	r24, Z
    3384:	b6 01       	movw	r22, r12
    3386:	90 e0       	ldi	r25, 0x00	; 0
    3388:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <fputc>
    338c:	81 10       	cpse	r8, r1
    338e:	f5 cf       	rjmp	.-22     	; 0x337a <vfprintf+0x384>
    3390:	22 20       	and	r2, r2
    3392:	09 f4       	brne	.+2      	; 0x3396 <vfprintf+0x3a0>
    3394:	42 ce       	rjmp	.-892    	; 0x301a <vfprintf+0x24>
    3396:	b6 01       	movw	r22, r12
    3398:	80 e2       	ldi	r24, 0x20	; 32
    339a:	90 e0       	ldi	r25, 0x00	; 0
    339c:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <fputc>
    33a0:	2a 94       	dec	r2
    33a2:	f6 cf       	rjmp	.-20     	; 0x3390 <vfprintf+0x39a>
    33a4:	f6 01       	movw	r30, r12
    33a6:	86 81       	ldd	r24, Z+6	; 0x06
    33a8:	97 81       	ldd	r25, Z+7	; 0x07
    33aa:	02 c0       	rjmp	.+4      	; 0x33b0 <vfprintf+0x3ba>
    33ac:	8f ef       	ldi	r24, 0xFF	; 255
    33ae:	9f ef       	ldi	r25, 0xFF	; 255
    33b0:	2b 96       	adiw	r28, 0x0b	; 11
    33b2:	e2 e1       	ldi	r30, 0x12	; 18
    33b4:	0c 94 a8 1a 	jmp	0x3550	; 0x3550 <__epilogue_restores__>

000033b8 <strnlen_P>:
    33b8:	fc 01       	movw	r30, r24
    33ba:	05 90       	lpm	r0, Z+
    33bc:	61 50       	subi	r22, 0x01	; 1
    33be:	70 40       	sbci	r23, 0x00	; 0
    33c0:	01 10       	cpse	r0, r1
    33c2:	d8 f7       	brcc	.-10     	; 0x33ba <strnlen_P+0x2>
    33c4:	80 95       	com	r24
    33c6:	90 95       	com	r25
    33c8:	8e 0f       	add	r24, r30
    33ca:	9f 1f       	adc	r25, r31
    33cc:	08 95       	ret

000033ce <strnlen>:
    33ce:	fc 01       	movw	r30, r24
    33d0:	61 50       	subi	r22, 0x01	; 1
    33d2:	70 40       	sbci	r23, 0x00	; 0
    33d4:	01 90       	ld	r0, Z+
    33d6:	01 10       	cpse	r0, r1
    33d8:	d8 f7       	brcc	.-10     	; 0x33d0 <strnlen+0x2>
    33da:	80 95       	com	r24
    33dc:	90 95       	com	r25
    33de:	8e 0f       	add	r24, r30
    33e0:	9f 1f       	adc	r25, r31
    33e2:	08 95       	ret

000033e4 <fputc>:
    33e4:	0f 93       	push	r16
    33e6:	1f 93       	push	r17
    33e8:	cf 93       	push	r28
    33ea:	df 93       	push	r29
    33ec:	fb 01       	movw	r30, r22
    33ee:	23 81       	ldd	r18, Z+3	; 0x03
    33f0:	21 fd       	sbrc	r18, 1
    33f2:	03 c0       	rjmp	.+6      	; 0x33fa <fputc+0x16>
    33f4:	8f ef       	ldi	r24, 0xFF	; 255
    33f6:	9f ef       	ldi	r25, 0xFF	; 255
    33f8:	2c c0       	rjmp	.+88     	; 0x3452 <fputc+0x6e>
    33fa:	22 ff       	sbrs	r18, 2
    33fc:	16 c0       	rjmp	.+44     	; 0x342a <fputc+0x46>
    33fe:	46 81       	ldd	r20, Z+6	; 0x06
    3400:	57 81       	ldd	r21, Z+7	; 0x07
    3402:	24 81       	ldd	r18, Z+4	; 0x04
    3404:	35 81       	ldd	r19, Z+5	; 0x05
    3406:	42 17       	cp	r20, r18
    3408:	53 07       	cpc	r21, r19
    340a:	44 f4       	brge	.+16     	; 0x341c <fputc+0x38>
    340c:	a0 81       	ld	r26, Z
    340e:	b1 81       	ldd	r27, Z+1	; 0x01
    3410:	9d 01       	movw	r18, r26
    3412:	2f 5f       	subi	r18, 0xFF	; 255
    3414:	3f 4f       	sbci	r19, 0xFF	; 255
    3416:	31 83       	std	Z+1, r19	; 0x01
    3418:	20 83       	st	Z, r18
    341a:	8c 93       	st	X, r24
    341c:	26 81       	ldd	r18, Z+6	; 0x06
    341e:	37 81       	ldd	r19, Z+7	; 0x07
    3420:	2f 5f       	subi	r18, 0xFF	; 255
    3422:	3f 4f       	sbci	r19, 0xFF	; 255
    3424:	37 83       	std	Z+7, r19	; 0x07
    3426:	26 83       	std	Z+6, r18	; 0x06
    3428:	14 c0       	rjmp	.+40     	; 0x3452 <fputc+0x6e>
    342a:	8b 01       	movw	r16, r22
    342c:	ec 01       	movw	r28, r24
    342e:	fb 01       	movw	r30, r22
    3430:	00 84       	ldd	r0, Z+8	; 0x08
    3432:	f1 85       	ldd	r31, Z+9	; 0x09
    3434:	e0 2d       	mov	r30, r0
    3436:	09 95       	icall
    3438:	89 2b       	or	r24, r25
    343a:	e1 f6       	brne	.-72     	; 0x33f4 <fputc+0x10>
    343c:	d8 01       	movw	r26, r16
    343e:	16 96       	adiw	r26, 0x06	; 6
    3440:	8d 91       	ld	r24, X+
    3442:	9c 91       	ld	r25, X
    3444:	17 97       	sbiw	r26, 0x07	; 7
    3446:	01 96       	adiw	r24, 0x01	; 1
    3448:	17 96       	adiw	r26, 0x07	; 7
    344a:	9c 93       	st	X, r25
    344c:	8e 93       	st	-X, r24
    344e:	16 97       	sbiw	r26, 0x06	; 6
    3450:	ce 01       	movw	r24, r28
    3452:	df 91       	pop	r29
    3454:	cf 91       	pop	r28
    3456:	1f 91       	pop	r17
    3458:	0f 91       	pop	r16
    345a:	08 95       	ret

0000345c <__ultoa_invert>:
    345c:	fa 01       	movw	r30, r20
    345e:	aa 27       	eor	r26, r26
    3460:	28 30       	cpi	r18, 0x08	; 8
    3462:	51 f1       	breq	.+84     	; 0x34b8 <__ultoa_invert+0x5c>
    3464:	20 31       	cpi	r18, 0x10	; 16
    3466:	81 f1       	breq	.+96     	; 0x34c8 <__ultoa_invert+0x6c>
    3468:	e8 94       	clt
    346a:	6f 93       	push	r22
    346c:	6e 7f       	andi	r22, 0xFE	; 254
    346e:	6e 5f       	subi	r22, 0xFE	; 254
    3470:	7f 4f       	sbci	r23, 0xFF	; 255
    3472:	8f 4f       	sbci	r24, 0xFF	; 255
    3474:	9f 4f       	sbci	r25, 0xFF	; 255
    3476:	af 4f       	sbci	r26, 0xFF	; 255
    3478:	b1 e0       	ldi	r27, 0x01	; 1
    347a:	3e d0       	rcall	.+124    	; 0x34f8 <__ultoa_invert+0x9c>
    347c:	b4 e0       	ldi	r27, 0x04	; 4
    347e:	3c d0       	rcall	.+120    	; 0x34f8 <__ultoa_invert+0x9c>
    3480:	67 0f       	add	r22, r23
    3482:	78 1f       	adc	r23, r24
    3484:	89 1f       	adc	r24, r25
    3486:	9a 1f       	adc	r25, r26
    3488:	a1 1d       	adc	r26, r1
    348a:	68 0f       	add	r22, r24
    348c:	79 1f       	adc	r23, r25
    348e:	8a 1f       	adc	r24, r26
    3490:	91 1d       	adc	r25, r1
    3492:	a1 1d       	adc	r26, r1
    3494:	6a 0f       	add	r22, r26
    3496:	71 1d       	adc	r23, r1
    3498:	81 1d       	adc	r24, r1
    349a:	91 1d       	adc	r25, r1
    349c:	a1 1d       	adc	r26, r1
    349e:	20 d0       	rcall	.+64     	; 0x34e0 <__ultoa_invert+0x84>
    34a0:	09 f4       	brne	.+2      	; 0x34a4 <__ultoa_invert+0x48>
    34a2:	68 94       	set
    34a4:	3f 91       	pop	r19
    34a6:	2a e0       	ldi	r18, 0x0A	; 10
    34a8:	26 9f       	mul	r18, r22
    34aa:	11 24       	eor	r1, r1
    34ac:	30 19       	sub	r19, r0
    34ae:	30 5d       	subi	r19, 0xD0	; 208
    34b0:	31 93       	st	Z+, r19
    34b2:	de f6       	brtc	.-74     	; 0x346a <__ultoa_invert+0xe>
    34b4:	cf 01       	movw	r24, r30
    34b6:	08 95       	ret
    34b8:	46 2f       	mov	r20, r22
    34ba:	47 70       	andi	r20, 0x07	; 7
    34bc:	40 5d       	subi	r20, 0xD0	; 208
    34be:	41 93       	st	Z+, r20
    34c0:	b3 e0       	ldi	r27, 0x03	; 3
    34c2:	0f d0       	rcall	.+30     	; 0x34e2 <__ultoa_invert+0x86>
    34c4:	c9 f7       	brne	.-14     	; 0x34b8 <__ultoa_invert+0x5c>
    34c6:	f6 cf       	rjmp	.-20     	; 0x34b4 <__ultoa_invert+0x58>
    34c8:	46 2f       	mov	r20, r22
    34ca:	4f 70       	andi	r20, 0x0F	; 15
    34cc:	40 5d       	subi	r20, 0xD0	; 208
    34ce:	4a 33       	cpi	r20, 0x3A	; 58
    34d0:	18 f0       	brcs	.+6      	; 0x34d8 <__ultoa_invert+0x7c>
    34d2:	49 5d       	subi	r20, 0xD9	; 217
    34d4:	31 fd       	sbrc	r19, 1
    34d6:	40 52       	subi	r20, 0x20	; 32
    34d8:	41 93       	st	Z+, r20
    34da:	02 d0       	rcall	.+4      	; 0x34e0 <__ultoa_invert+0x84>
    34dc:	a9 f7       	brne	.-22     	; 0x34c8 <__ultoa_invert+0x6c>
    34de:	ea cf       	rjmp	.-44     	; 0x34b4 <__ultoa_invert+0x58>
    34e0:	b4 e0       	ldi	r27, 0x04	; 4
    34e2:	a6 95       	lsr	r26
    34e4:	97 95       	ror	r25
    34e6:	87 95       	ror	r24
    34e8:	77 95       	ror	r23
    34ea:	67 95       	ror	r22
    34ec:	ba 95       	dec	r27
    34ee:	c9 f7       	brne	.-14     	; 0x34e2 <__ultoa_invert+0x86>
    34f0:	00 97       	sbiw	r24, 0x00	; 0
    34f2:	61 05       	cpc	r22, r1
    34f4:	71 05       	cpc	r23, r1
    34f6:	08 95       	ret
    34f8:	9b 01       	movw	r18, r22
    34fa:	ac 01       	movw	r20, r24
    34fc:	0a 2e       	mov	r0, r26
    34fe:	06 94       	lsr	r0
    3500:	57 95       	ror	r21
    3502:	47 95       	ror	r20
    3504:	37 95       	ror	r19
    3506:	27 95       	ror	r18
    3508:	ba 95       	dec	r27
    350a:	c9 f7       	brne	.-14     	; 0x34fe <__ultoa_invert+0xa2>
    350c:	62 0f       	add	r22, r18
    350e:	73 1f       	adc	r23, r19
    3510:	84 1f       	adc	r24, r20
    3512:	95 1f       	adc	r25, r21
    3514:	a0 1d       	adc	r26, r0
    3516:	08 95       	ret

00003518 <__prologue_saves__>:
    3518:	2f 92       	push	r2
    351a:	3f 92       	push	r3
    351c:	4f 92       	push	r4
    351e:	5f 92       	push	r5
    3520:	6f 92       	push	r6
    3522:	7f 92       	push	r7
    3524:	8f 92       	push	r8
    3526:	9f 92       	push	r9
    3528:	af 92       	push	r10
    352a:	bf 92       	push	r11
    352c:	cf 92       	push	r12
    352e:	df 92       	push	r13
    3530:	ef 92       	push	r14
    3532:	ff 92       	push	r15
    3534:	0f 93       	push	r16
    3536:	1f 93       	push	r17
    3538:	cf 93       	push	r28
    353a:	df 93       	push	r29
    353c:	cd b7       	in	r28, 0x3d	; 61
    353e:	de b7       	in	r29, 0x3e	; 62
    3540:	ca 1b       	sub	r28, r26
    3542:	db 0b       	sbc	r29, r27
    3544:	0f b6       	in	r0, 0x3f	; 63
    3546:	f8 94       	cli
    3548:	de bf       	out	0x3e, r29	; 62
    354a:	0f be       	out	0x3f, r0	; 63
    354c:	cd bf       	out	0x3d, r28	; 61
    354e:	09 94       	ijmp

00003550 <__epilogue_restores__>:
    3550:	2a 88       	ldd	r2, Y+18	; 0x12
    3552:	39 88       	ldd	r3, Y+17	; 0x11
    3554:	48 88       	ldd	r4, Y+16	; 0x10
    3556:	5f 84       	ldd	r5, Y+15	; 0x0f
    3558:	6e 84       	ldd	r6, Y+14	; 0x0e
    355a:	7d 84       	ldd	r7, Y+13	; 0x0d
    355c:	8c 84       	ldd	r8, Y+12	; 0x0c
    355e:	9b 84       	ldd	r9, Y+11	; 0x0b
    3560:	aa 84       	ldd	r10, Y+10	; 0x0a
    3562:	b9 84       	ldd	r11, Y+9	; 0x09
    3564:	c8 84       	ldd	r12, Y+8	; 0x08
    3566:	df 80       	ldd	r13, Y+7	; 0x07
    3568:	ee 80       	ldd	r14, Y+6	; 0x06
    356a:	fd 80       	ldd	r15, Y+5	; 0x05
    356c:	0c 81       	ldd	r16, Y+4	; 0x04
    356e:	1b 81       	ldd	r17, Y+3	; 0x03
    3570:	aa 81       	ldd	r26, Y+2	; 0x02
    3572:	b9 81       	ldd	r27, Y+1	; 0x01
    3574:	ce 0f       	add	r28, r30
    3576:	d1 1d       	adc	r29, r1
    3578:	0f b6       	in	r0, 0x3f	; 63
    357a:	f8 94       	cli
    357c:	de bf       	out	0x3e, r29	; 62
    357e:	0f be       	out	0x3f, r0	; 63
    3580:	cd bf       	out	0x3d, r28	; 61
    3582:	ed 01       	movw	r28, r26
    3584:	08 95       	ret

00003586 <_exit>:
    3586:	f8 94       	cli

00003588 <__stop_program>:
    3588:	ff cf       	rjmp	.-2      	; 0x3588 <__stop_program>
