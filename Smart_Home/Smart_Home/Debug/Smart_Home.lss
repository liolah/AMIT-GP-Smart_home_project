
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004ae  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000522  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000003b  00800060  00800060  00000522  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000522  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000554  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000118  00000000  00000000  00000590  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000132f  00000000  00000000  000006a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000886  00000000  00000000  000019d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000ab6  00000000  00000000  0000225d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002f4  00000000  00000000  00002d14  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000072c  00000000  00000000  00003008  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000713  00000000  00000000  00003734  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d8  00000000  00000000  00003e47  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 84 00 	jmp	0x108	; 0x108 <__vector_10>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 ec 01 	jmp	0x3d8	; 0x3d8 <__vector_13>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 49 00 	jmp	0x92	; 0x92 <__vector_16>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ee ea       	ldi	r30, 0xAE	; 174
  68:	f4 e0       	ldi	r31, 0x04	; 4
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a0 36       	cpi	r26, 0x60	; 96
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a0 e6       	ldi	r26, 0x60	; 96
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ab 39       	cpi	r26, 0x9B	; 155
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 aa 00 	call	0x154	; 0x154 <main>
  8a:	0c 94 55 02 	jmp	0x4aa	; 0x4aa <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__vector_16>:
#include "Services/User/user.h"
#include "Services/Remote_access/remote.h"

u16 temperature;
 // #include "Application/app.h"
ISR(ADC_vect) {
  92:	1f 92       	push	r1
  94:	0f 92       	push	r0
  96:	0f b6       	in	r0, 0x3f	; 63
  98:	0f 92       	push	r0
  9a:	11 24       	eor	r1, r1
  9c:	2f 93       	push	r18
  9e:	3f 93       	push	r19
  a0:	4f 93       	push	r20
  a2:	5f 93       	push	r21
  a4:	6f 93       	push	r22
  a6:	7f 93       	push	r23
  a8:	8f 93       	push	r24
  aa:	9f 93       	push	r25
  ac:	af 93       	push	r26
  ae:	bf 93       	push	r27
  b0:	ef 93       	push	r30
  b2:	ff 93       	push	r31
	temperature = (u16)ADCL;
  b4:	84 b1       	in	r24, 0x04	; 4
  b6:	28 2f       	mov	r18, r24
  b8:	30 e0       	ldi	r19, 0x00	; 0
  ba:	30 93 73 00 	sts	0x0073, r19	; 0x800073 <temperature+0x1>
  be:	20 93 72 00 	sts	0x0072, r18	; 0x800072 <temperature>
	temperature += ((u16)ADCH << 8);
  c2:	95 b1       	in	r25, 0x05	; 5
  c4:	89 2f       	mov	r24, r25
  c6:	90 e0       	ldi	r25, 0x00	; 0
  c8:	98 2f       	mov	r25, r24
  ca:	88 27       	eor	r24, r24
  cc:	82 0f       	add	r24, r18
  ce:	93 1f       	adc	r25, r19
  d0:	90 93 73 00 	sts	0x0073, r25	; 0x800073 <temperature+0x1>
  d4:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <temperature>
	DIO_toggle(1, 'B');
  d8:	62 e4       	ldi	r22, 0x42	; 66
  da:	81 e0       	ldi	r24, 0x01	; 1
  dc:	0e 94 95 01 	call	0x32a	; 0x32a <DIO_toggle>
	// set_bit(TIFR, TOV1);
	set_bit(TIFR, OCF0);
  e0:	88 b7       	in	r24, 0x38	; 56
  e2:	82 60       	ori	r24, 0x02	; 2
  e4:	88 bf       	out	0x38, r24	; 56
	}
  e6:	ff 91       	pop	r31
  e8:	ef 91       	pop	r30
  ea:	bf 91       	pop	r27
  ec:	af 91       	pop	r26
  ee:	9f 91       	pop	r25
  f0:	8f 91       	pop	r24
  f2:	7f 91       	pop	r23
  f4:	6f 91       	pop	r22
  f6:	5f 91       	pop	r21
  f8:	4f 91       	pop	r20
  fa:	3f 91       	pop	r19
  fc:	2f 91       	pop	r18
  fe:	0f 90       	pop	r0
 100:	0f be       	out	0x3f, r0	; 63
 102:	0f 90       	pop	r0
 104:	1f 90       	pop	r1
 106:	18 95       	reti

00000108 <__vector_10>:

// ISR(TIMER1_OVF_vect) {
// 	// PORTB = PORTB - 1;
// 	DIO_toggle(7, 'D');
// 	}
ISR(TIMER0_COMP_vect) {
 108:	1f 92       	push	r1
 10a:	0f 92       	push	r0
 10c:	0f b6       	in	r0, 0x3f	; 63
 10e:	0f 92       	push	r0
 110:	11 24       	eor	r1, r1
 112:	2f 93       	push	r18
 114:	3f 93       	push	r19
 116:	4f 93       	push	r20
 118:	5f 93       	push	r21
 11a:	6f 93       	push	r22
 11c:	7f 93       	push	r23
 11e:	8f 93       	push	r24
 120:	9f 93       	push	r25
 122:	af 93       	push	r26
 124:	bf 93       	push	r27
 126:	ef 93       	push	r30
 128:	ff 93       	push	r31
	// PORTB = PORTB - 1;
	DIO_toggle(7, 'D');
 12a:	64 e4       	ldi	r22, 0x44	; 68
 12c:	87 e0       	ldi	r24, 0x07	; 7
 12e:	0e 94 95 01 	call	0x32a	; 0x32a <DIO_toggle>
	}
 132:	ff 91       	pop	r31
 134:	ef 91       	pop	r30
 136:	bf 91       	pop	r27
 138:	af 91       	pop	r26
 13a:	9f 91       	pop	r25
 13c:	8f 91       	pop	r24
 13e:	7f 91       	pop	r23
 140:	6f 91       	pop	r22
 142:	5f 91       	pop	r21
 144:	4f 91       	pop	r20
 146:	3f 91       	pop	r19
 148:	2f 91       	pop	r18
 14a:	0f 90       	pop	r0
 14c:	0f be       	out	0x3f, r0	; 63
 14e:	0f 90       	pop	r0
 150:	1f 90       	pop	r1
 152:	18 95       	reti

00000154 <main>:
int main(void) {
	// PWM_init(OC_1A, 0.5, PWM_PHASE_CORRECT);
	// DIO_init(5, PORT_D, OUT);
	// Timer_start(TIMER_1, 8);
	sei();
 154:	78 94       	sei
	DIO_init(7, PORT_A, IN);
 156:	40 e0       	ldi	r20, 0x00	; 0
 158:	61 e4       	ldi	r22, 0x41	; 65
 15a:	87 e0       	ldi	r24, 0x07	; 7
 15c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <DIO_init>
	DIO_init(7, PORT_D, OUT);
 160:	41 e0       	ldi	r20, 0x01	; 1
 162:	64 e4       	ldi	r22, 0x44	; 68
 164:	87 e0       	ldi	r24, 0x07	; 7
 166:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <DIO_init>
	
	set_bit(TCCR0, WGM01);
 16a:	83 b7       	in	r24, 0x33	; 51
 16c:	88 60       	ori	r24, 0x08	; 8
 16e:	83 bf       	out	0x33, r24	; 51
	OCR0 = 255;
 170:	8f ef       	ldi	r24, 0xFF	; 255
 172:	8c bf       	out	0x3c, r24	; 60
	set_bit(TCCR0, CS00);
 174:	83 b7       	in	r24, 0x33	; 51
 176:	81 60       	ori	r24, 0x01	; 1
 178:	83 bf       	out	0x33, r24	; 51
	set_bit(TCCR0, CS02);
 17a:	83 b7       	in	r24, 0x33	; 51
 17c:	84 60       	ori	r24, 0x04	; 4
 17e:	83 bf       	out	0x33, r24	; 51
	// set_bit(TCCR1B, CS10);

	// set_bit(TIMSK, TOIE1);
	set_bit(TIMSK, OCIE0);
 180:	89 b7       	in	r24, 0x39	; 57
 182:	82 60       	ori	r24, 0x02	; 2
 184:	89 bf       	out	0x39, r24	; 57
	
	set_bit(ADMUX, REFS0);
 186:	87 b1       	in	r24, 0x07	; 7
 188:	80 64       	ori	r24, 0x40	; 64
 18a:	87 b9       	out	0x07, r24	; 7
	set_bit(ADMUX, REFS1);
 18c:	87 b1       	in	r24, 0x07	; 7
 18e:	80 68       	ori	r24, 0x80	; 128
 190:	87 b9       	out	0x07, r24	; 7

	set_bit(ADCSRA, ADPS0);
 192:	86 b1       	in	r24, 0x06	; 6
 194:	81 60       	ori	r24, 0x01	; 1
 196:	86 b9       	out	0x06, r24	; 6
	set_bit(ADCSRA, ADPS1);
 198:	86 b1       	in	r24, 0x06	; 6
 19a:	82 60       	ori	r24, 0x02	; 2
 19c:	86 b9       	out	0x06, r24	; 6
	set_bit(ADCSRA, ADPS2);
 19e:	86 b1       	in	r24, 0x06	; 6
 1a0:	84 60       	ori	r24, 0x04	; 4
 1a2:	86 b9       	out	0x06, r24	; 6
	// Enable the auto trigger mode
	set_bit(ADCSRA, ADATE);
 1a4:	86 b1       	in	r24, 0x06	; 6
 1a6:	80 62       	ori	r24, 0x20	; 32
 1a8:	86 b9       	out	0x06, r24	; 6
	
	SFIOR |= (1 << ADTS0) | (1 << ADTS1);
 1aa:	80 b7       	in	r24, 0x30	; 48
 1ac:	80 66       	ori	r24, 0x60	; 96
 1ae:	80 bf       	out	0x30, r24	; 48
	// SFIOR |= (1 << ADTS2) | (1 << ADTS1);
	// set_bit(SFIOR, ADTS2);

	ADMUX = (ADMUX & 0xE0) | 7;
 1b0:	87 b1       	in	r24, 0x07	; 7
 1b2:	80 7e       	andi	r24, 0xE0	; 224
 1b4:	87 60       	ori	r24, 0x07	; 7
 1b6:	87 b9       	out	0x07, r24	; 7

	set_bit(ADCSRA, ADIE);
 1b8:	86 b1       	in	r24, 0x06	; 6
 1ba:	88 60       	ori	r24, 0x08	; 8
 1bc:	86 b9       	out	0x06, r24	; 6
	set_bit(ADCSRA, ADEN);
 1be:	86 b1       	in	r24, 0x06	; 6
 1c0:	80 68       	ori	r24, 0x80	; 128
 1c2:	86 b9       	out	0x06, r24	; 6

	DIO_init(1, 'B', OUT);
 1c4:	41 e0       	ldi	r20, 0x01	; 1
 1c6:	62 e4       	ldi	r22, 0x42	; 66
 1c8:	81 e0       	ldi	r24, 0x01	; 1
 1ca:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <DIO_init>
 1ce:	ff cf       	rjmp	.-2      	; 0x1ce <main+0x7a>

000001d0 <isValidPinNumber>:
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
	}
 1d0:	88 30       	cpi	r24, 0x08	; 8
 1d2:	10 f4       	brcc	.+4      	; 0x1d8 <isValidPinNumber+0x8>
 1d4:	81 e0       	ldi	r24, 0x01	; 1
 1d6:	08 95       	ret
 1d8:	80 e0       	ldi	r24, 0x00	; 0
 1da:	08 95       	ret

000001dc <isValidPortNumber>:
 1dc:	81 54       	subi	r24, 0x41	; 65
 1de:	84 30       	cpi	r24, 0x04	; 4
 1e0:	10 f4       	brcc	.+4      	; 0x1e6 <isValidPortNumber+0xa>
 1e2:	81 e0       	ldi	r24, 0x01	; 1
 1e4:	08 95       	ret
 1e6:	80 e0       	ldi	r24, 0x00	; 0
 1e8:	08 95       	ret

000001ea <isValidDirection>:
 1ea:	82 30       	cpi	r24, 0x02	; 2
 1ec:	10 f4       	brcc	.+4      	; 0x1f2 <isValidDirection+0x8>
 1ee:	81 e0       	ldi	r24, 0x01	; 1
 1f0:	08 95       	ret
 1f2:	80 e0       	ldi	r24, 0x00	; 0
 1f4:	08 95       	ret

000001f6 <DIO_init>:
 1f6:	1f 93       	push	r17
 1f8:	cf 93       	push	r28
 1fa:	df 93       	push	r29
 1fc:	c8 2f       	mov	r28, r24
 1fe:	d6 2f       	mov	r29, r22
 200:	14 2f       	mov	r17, r20
 202:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <isValidPinNumber>
 206:	88 23       	and	r24, r24
 208:	09 f4       	brne	.+2      	; 0x20c <DIO_init+0x16>
 20a:	84 c0       	rjmp	.+264    	; 0x314 <DIO_init+0x11e>
 20c:	8d 2f       	mov	r24, r29
 20e:	0e 94 ee 00 	call	0x1dc	; 0x1dc <isValidPortNumber>
 212:	88 23       	and	r24, r24
 214:	09 f4       	brne	.+2      	; 0x218 <DIO_init+0x22>
 216:	80 c0       	rjmp	.+256    	; 0x318 <DIO_init+0x122>
 218:	81 2f       	mov	r24, r17
 21a:	0e 94 f5 00 	call	0x1ea	; 0x1ea <isValidDirection>
 21e:	88 23       	and	r24, r24
 220:	09 f4       	brne	.+2      	; 0x224 <DIO_init+0x2e>
 222:	7c c0       	rjmp	.+248    	; 0x31c <DIO_init+0x126>
 224:	d2 34       	cpi	r29, 0x42	; 66
 226:	29 f1       	breq	.+74     	; 0x272 <DIO_init+0x7c>
 228:	18 f4       	brcc	.+6      	; 0x230 <DIO_init+0x3a>
 22a:	d1 34       	cpi	r29, 0x41	; 65
 22c:	39 f0       	breq	.+14     	; 0x23c <DIO_init+0x46>
 22e:	78 c0       	rjmp	.+240    	; 0x320 <DIO_init+0x12a>
 230:	d3 34       	cpi	r29, 0x43	; 67
 232:	d1 f1       	breq	.+116    	; 0x2a8 <DIO_init+0xb2>
 234:	d4 34       	cpi	r29, 0x44	; 68
 236:	09 f4       	brne	.+2      	; 0x23a <DIO_init+0x44>
 238:	52 c0       	rjmp	.+164    	; 0x2de <DIO_init+0xe8>
 23a:	72 c0       	rjmp	.+228    	; 0x320 <DIO_init+0x12a>
 23c:	11 30       	cpi	r17, 0x01	; 1
 23e:	61 f4       	brne	.+24     	; 0x258 <DIO_init+0x62>
 240:	2a b3       	in	r18, 0x1a	; 26
 242:	81 e0       	ldi	r24, 0x01	; 1
 244:	90 e0       	ldi	r25, 0x00	; 0
 246:	02 c0       	rjmp	.+4      	; 0x24c <DIO_init+0x56>
 248:	88 0f       	add	r24, r24
 24a:	99 1f       	adc	r25, r25
 24c:	ca 95       	dec	r28
 24e:	e2 f7       	brpl	.-8      	; 0x248 <DIO_init+0x52>
 250:	82 2b       	or	r24, r18
 252:	8a bb       	out	0x1a, r24	; 26
 254:	80 e0       	ldi	r24, 0x00	; 0
 256:	65 c0       	rjmp	.+202    	; 0x322 <DIO_init+0x12c>
 258:	2a b3       	in	r18, 0x1a	; 26
 25a:	81 e0       	ldi	r24, 0x01	; 1
 25c:	90 e0       	ldi	r25, 0x00	; 0
 25e:	02 c0       	rjmp	.+4      	; 0x264 <DIO_init+0x6e>
 260:	88 0f       	add	r24, r24
 262:	99 1f       	adc	r25, r25
 264:	ca 95       	dec	r28
 266:	e2 f7       	brpl	.-8      	; 0x260 <DIO_init+0x6a>
 268:	80 95       	com	r24
 26a:	82 23       	and	r24, r18
 26c:	8a bb       	out	0x1a, r24	; 26
 26e:	80 e0       	ldi	r24, 0x00	; 0
 270:	58 c0       	rjmp	.+176    	; 0x322 <DIO_init+0x12c>
 272:	11 30       	cpi	r17, 0x01	; 1
 274:	61 f4       	brne	.+24     	; 0x28e <DIO_init+0x98>
 276:	27 b3       	in	r18, 0x17	; 23
 278:	81 e0       	ldi	r24, 0x01	; 1
 27a:	90 e0       	ldi	r25, 0x00	; 0
 27c:	02 c0       	rjmp	.+4      	; 0x282 <DIO_init+0x8c>
 27e:	88 0f       	add	r24, r24
 280:	99 1f       	adc	r25, r25
 282:	ca 95       	dec	r28
 284:	e2 f7       	brpl	.-8      	; 0x27e <DIO_init+0x88>
 286:	82 2b       	or	r24, r18
 288:	87 bb       	out	0x17, r24	; 23
 28a:	80 e0       	ldi	r24, 0x00	; 0
 28c:	4a c0       	rjmp	.+148    	; 0x322 <DIO_init+0x12c>
 28e:	27 b3       	in	r18, 0x17	; 23
 290:	81 e0       	ldi	r24, 0x01	; 1
 292:	90 e0       	ldi	r25, 0x00	; 0
 294:	02 c0       	rjmp	.+4      	; 0x29a <DIO_init+0xa4>
 296:	88 0f       	add	r24, r24
 298:	99 1f       	adc	r25, r25
 29a:	ca 95       	dec	r28
 29c:	e2 f7       	brpl	.-8      	; 0x296 <DIO_init+0xa0>
 29e:	80 95       	com	r24
 2a0:	82 23       	and	r24, r18
 2a2:	87 bb       	out	0x17, r24	; 23
 2a4:	80 e0       	ldi	r24, 0x00	; 0
 2a6:	3d c0       	rjmp	.+122    	; 0x322 <DIO_init+0x12c>
 2a8:	11 30       	cpi	r17, 0x01	; 1
 2aa:	61 f4       	brne	.+24     	; 0x2c4 <DIO_init+0xce>
 2ac:	24 b3       	in	r18, 0x14	; 20
 2ae:	81 e0       	ldi	r24, 0x01	; 1
 2b0:	90 e0       	ldi	r25, 0x00	; 0
 2b2:	02 c0       	rjmp	.+4      	; 0x2b8 <DIO_init+0xc2>
 2b4:	88 0f       	add	r24, r24
 2b6:	99 1f       	adc	r25, r25
 2b8:	ca 95       	dec	r28
 2ba:	e2 f7       	brpl	.-8      	; 0x2b4 <DIO_init+0xbe>
 2bc:	82 2b       	or	r24, r18
 2be:	84 bb       	out	0x14, r24	; 20
 2c0:	80 e0       	ldi	r24, 0x00	; 0
 2c2:	2f c0       	rjmp	.+94     	; 0x322 <DIO_init+0x12c>
 2c4:	24 b3       	in	r18, 0x14	; 20
 2c6:	81 e0       	ldi	r24, 0x01	; 1
 2c8:	90 e0       	ldi	r25, 0x00	; 0
 2ca:	02 c0       	rjmp	.+4      	; 0x2d0 <DIO_init+0xda>
 2cc:	88 0f       	add	r24, r24
 2ce:	99 1f       	adc	r25, r25
 2d0:	ca 95       	dec	r28
 2d2:	e2 f7       	brpl	.-8      	; 0x2cc <DIO_init+0xd6>
 2d4:	80 95       	com	r24
 2d6:	82 23       	and	r24, r18
 2d8:	84 bb       	out	0x14, r24	; 20
 2da:	80 e0       	ldi	r24, 0x00	; 0
 2dc:	22 c0       	rjmp	.+68     	; 0x322 <DIO_init+0x12c>
 2de:	11 30       	cpi	r17, 0x01	; 1
 2e0:	61 f4       	brne	.+24     	; 0x2fa <DIO_init+0x104>
 2e2:	21 b3       	in	r18, 0x11	; 17
 2e4:	81 e0       	ldi	r24, 0x01	; 1
 2e6:	90 e0       	ldi	r25, 0x00	; 0
 2e8:	02 c0       	rjmp	.+4      	; 0x2ee <DIO_init+0xf8>
 2ea:	88 0f       	add	r24, r24
 2ec:	99 1f       	adc	r25, r25
 2ee:	ca 95       	dec	r28
 2f0:	e2 f7       	brpl	.-8      	; 0x2ea <DIO_init+0xf4>
 2f2:	82 2b       	or	r24, r18
 2f4:	81 bb       	out	0x11, r24	; 17
 2f6:	80 e0       	ldi	r24, 0x00	; 0
 2f8:	14 c0       	rjmp	.+40     	; 0x322 <DIO_init+0x12c>
 2fa:	21 b3       	in	r18, 0x11	; 17
 2fc:	81 e0       	ldi	r24, 0x01	; 1
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	02 c0       	rjmp	.+4      	; 0x306 <DIO_init+0x110>
 302:	88 0f       	add	r24, r24
 304:	99 1f       	adc	r25, r25
 306:	ca 95       	dec	r28
 308:	e2 f7       	brpl	.-8      	; 0x302 <DIO_init+0x10c>
 30a:	80 95       	com	r24
 30c:	82 23       	and	r24, r18
 30e:	81 bb       	out	0x11, r24	; 17
 310:	80 e0       	ldi	r24, 0x00	; 0
 312:	07 c0       	rjmp	.+14     	; 0x322 <DIO_init+0x12c>
 314:	81 e0       	ldi	r24, 0x01	; 1
 316:	05 c0       	rjmp	.+10     	; 0x322 <DIO_init+0x12c>
 318:	82 e0       	ldi	r24, 0x02	; 2
 31a:	03 c0       	rjmp	.+6      	; 0x322 <DIO_init+0x12c>
 31c:	83 e0       	ldi	r24, 0x03	; 3
 31e:	01 c0       	rjmp	.+2      	; 0x322 <DIO_init+0x12c>
 320:	80 e0       	ldi	r24, 0x00	; 0
 322:	df 91       	pop	r29
 324:	cf 91       	pop	r28
 326:	1f 91       	pop	r17
 328:	08 95       	ret

0000032a <DIO_toggle>:

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
 32a:	cf 93       	push	r28
 32c:	df 93       	push	r29
 32e:	d8 2f       	mov	r29, r24
 330:	c6 2f       	mov	r28, r22
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
 332:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <isValidPinNumber>
 336:	88 23       	and	r24, r24
 338:	09 f4       	brne	.+2      	; 0x33c <DIO_toggle+0x12>
 33a:	40 c0       	rjmp	.+128    	; 0x3bc <DIO_toggle+0x92>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
 33c:	8c 2f       	mov	r24, r28
 33e:	0e 94 ee 00 	call	0x1dc	; 0x1dc <isValidPortNumber>
 342:	88 23       	and	r24, r24
 344:	e9 f1       	breq	.+122    	; 0x3c0 <DIO_toggle+0x96>
		return WRONG_PORT;
		}
	switch (portNumber) {
 346:	c2 34       	cpi	r28, 0x42	; 66
 348:	a9 f0       	breq	.+42     	; 0x374 <DIO_toggle+0x4a>
 34a:	18 f4       	brcc	.+6      	; 0x352 <DIO_toggle+0x28>
 34c:	c1 34       	cpi	r28, 0x41	; 65
 34e:	31 f0       	breq	.+12     	; 0x35c <DIO_toggle+0x32>
 350:	39 c0       	rjmp	.+114    	; 0x3c4 <DIO_toggle+0x9a>
 352:	c3 34       	cpi	r28, 0x43	; 67
 354:	d9 f0       	breq	.+54     	; 0x38c <DIO_toggle+0x62>
 356:	c4 34       	cpi	r28, 0x44	; 68
 358:	29 f1       	breq	.+74     	; 0x3a4 <DIO_toggle+0x7a>
 35a:	34 c0       	rjmp	.+104    	; 0x3c4 <DIO_toggle+0x9a>
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
 35c:	2b b3       	in	r18, 0x1b	; 27
 35e:	81 e0       	ldi	r24, 0x01	; 1
 360:	90 e0       	ldi	r25, 0x00	; 0
 362:	02 c0       	rjmp	.+4      	; 0x368 <DIO_toggle+0x3e>
 364:	88 0f       	add	r24, r24
 366:	99 1f       	adc	r25, r25
 368:	da 95       	dec	r29
 36a:	e2 f7       	brpl	.-8      	; 0x364 <DIO_toggle+0x3a>
 36c:	82 27       	eor	r24, r18
 36e:	8b bb       	out	0x1b, r24	; 27
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
 370:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
 372:	29 c0       	rjmp	.+82     	; 0x3c6 <DIO_toggle+0x9c>
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
 374:	28 b3       	in	r18, 0x18	; 24
 376:	81 e0       	ldi	r24, 0x01	; 1
 378:	90 e0       	ldi	r25, 0x00	; 0
 37a:	02 c0       	rjmp	.+4      	; 0x380 <DIO_toggle+0x56>
 37c:	88 0f       	add	r24, r24
 37e:	99 1f       	adc	r25, r25
 380:	da 95       	dec	r29
 382:	e2 f7       	brpl	.-8      	; 0x37c <DIO_toggle+0x52>
 384:	82 27       	eor	r24, r18
 386:	88 bb       	out	0x18, r24	; 24
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
 388:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
 38a:	1d c0       	rjmp	.+58     	; 0x3c6 <DIO_toggle+0x9c>
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
 38c:	25 b3       	in	r18, 0x15	; 21
 38e:	81 e0       	ldi	r24, 0x01	; 1
 390:	90 e0       	ldi	r25, 0x00	; 0
 392:	02 c0       	rjmp	.+4      	; 0x398 <DIO_toggle+0x6e>
 394:	88 0f       	add	r24, r24
 396:	99 1f       	adc	r25, r25
 398:	da 95       	dec	r29
 39a:	e2 f7       	brpl	.-8      	; 0x394 <DIO_toggle+0x6a>
 39c:	82 27       	eor	r24, r18
 39e:	85 bb       	out	0x15, r24	; 21
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
 3a0:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
 3a2:	11 c0       	rjmp	.+34     	; 0x3c6 <DIO_toggle+0x9c>
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
 3a4:	22 b3       	in	r18, 0x12	; 18
 3a6:	81 e0       	ldi	r24, 0x01	; 1
 3a8:	90 e0       	ldi	r25, 0x00	; 0
 3aa:	02 c0       	rjmp	.+4      	; 0x3b0 <DIO_toggle+0x86>
 3ac:	88 0f       	add	r24, r24
 3ae:	99 1f       	adc	r25, r25
 3b0:	da 95       	dec	r29
 3b2:	e2 f7       	brpl	.-8      	; 0x3ac <DIO_toggle+0x82>
 3b4:	82 27       	eor	r24, r18
 3b6:	82 bb       	out	0x12, r24	; 18
				break;
		}
	return DIO_OK;
 3b8:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
 3ba:	05 c0       	rjmp	.+10     	; 0x3c6 <DIO_toggle+0x9c>

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
 3bc:	81 e0       	ldi	r24, 0x01	; 1
 3be:	03 c0       	rjmp	.+6      	; 0x3c6 <DIO_toggle+0x9c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
 3c0:	82 e0       	ldi	r24, 0x02	; 2
 3c2:	01 c0       	rjmp	.+2      	; 0x3c6 <DIO_toggle+0x9c>
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
 3c4:	80 e0       	ldi	r24, 0x00	; 0
 3c6:	df 91       	pop	r29
 3c8:	cf 91       	pop	r28
 3ca:	08 95       	ret

000003cc <callFunWhenBufferReady>:

void remote_login_prompt(void) {
  println_msg("Welcome to the Smart Home System!");
  println_msg("To proceed, please login.");
  print_msg("Enter your user name:\t");
  request_user_input(userName_prompt_handler, 13);
 3cc:	e0 91 99 00 	lds	r30, 0x0099	; 0x800099 <requesting_function>
 3d0:	f0 91 9a 00 	lds	r31, 0x009A	; 0x80009a <requesting_function+0x1>
 3d4:	09 95       	icall
 3d6:	08 95       	ret

000003d8 <__vector_13>:
  }

// Handles the user input asynchronously.
ISR(USART_RXC_vect) {
 3d8:	1f 92       	push	r1
 3da:	0f 92       	push	r0
 3dc:	0f b6       	in	r0, 0x3f	; 63
 3de:	0f 92       	push	r0
 3e0:	11 24       	eor	r1, r1
 3e2:	2f 93       	push	r18
 3e4:	3f 93       	push	r19
 3e6:	4f 93       	push	r20
 3e8:	5f 93       	push	r21
 3ea:	6f 93       	push	r22
 3ec:	7f 93       	push	r23
 3ee:	8f 93       	push	r24
 3f0:	9f 93       	push	r25
 3f2:	af 93       	push	r26
 3f4:	bf 93       	push	r27
 3f6:	ef 93       	push	r30
 3f8:	ff 93       	push	r31
  // Read the UDR to clear the RXC pin
  udr_temp = UDR;
 3fa:	8c b1       	in	r24, 0x0c	; 12
 3fc:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <udr_temp>
  // If no input requested, ignore the input. No input requested is indicated by msg length of zero
  if (msg_length == 0) return;
 400:	90 91 70 00 	lds	r25, 0x0070	; 0x800070 <msg_length>
 404:	99 23       	and	r25, r25
 406:	09 f4       	brne	.+2      	; 0x40a <__EEPROM_REGION_LENGTH__+0xa>
 408:	3f c0       	rjmp	.+126    	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>

  // If the msg length is reached without the input being terminated by null, then it's wrong input
  // If the input is invalid, reset the buffer pointer, set the invalid input flag, call the function responsible for handling the input, and keep ignoring the incoming data till null is reached
  if (dump_invalid_data) {
 40a:	20 91 94 00 	lds	r18, 0x0094	; 0x800094 <dump_invalid_data>
 40e:	22 23       	and	r18, r18
 410:	49 f0       	breq	.+18     	; 0x424 <__EEPROM_REGION_LENGTH__+0x24>
    if (udr_temp == 0) {
 412:	81 11       	cpse	r24, r1
 414:	39 c0       	rjmp	.+114    	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
      dump_invalid_data = false;
 416:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <dump_invalid_data>
      invalid_user_input = false;
 41a:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <invalid_user_input>
      msg_buffer_pointer = 0;
 41e:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
 422:	32 c0       	rjmp	.+100    	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
      }
    return;
    }

  msg_buffer[msg_buffer_pointer] = udr_temp;
 424:	e0 91 60 00 	lds	r30, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 428:	ae 2f       	mov	r26, r30
 42a:	b0 e0       	ldi	r27, 0x00	; 0
 42c:	af 59       	subi	r26, 0x9F	; 159
 42e:	bf 4f       	sbci	r27, 0xFF	; 255
 430:	8c 93       	st	X, r24
  msg_buffer_pointer++;
 432:	ef 5f       	subi	r30, 0xFF	; 255
 434:	e0 93 60 00 	sts	0x0060, r30	; 0x800060 <__DATA_REGION_ORIGIN__>

  // Msg is empty
  // Ignore null msgs
  if (msg_buffer_pointer == 1) {
 438:	e1 30       	cpi	r30, 0x01	; 1
 43a:	39 f4       	brne	.+14     	; 0x44a <__EEPROM_REGION_LENGTH__+0x4a>
    if (msg_buffer[0] == 0) {
 43c:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <msg_buffer>
 440:	81 11       	cpse	r24, r1
 442:	03 c0       	rjmp	.+6      	; 0x44a <__EEPROM_REGION_LENGTH__+0x4a>
      msg_buffer_pointer = 0;
 444:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
      return;
 448:	1f c0       	rjmp	.+62     	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
      }
    }

  // Msg is longer than required
  if (msg_buffer_pointer == msg_length) {
 44a:	9e 13       	cpse	r25, r30
 44c:	0f c0       	rjmp	.+30     	; 0x46c <__EEPROM_REGION_LENGTH__+0x6c>
    if (msg_buffer[msg_buffer_pointer - 1] != 0) {
 44e:	f0 e0       	ldi	r31, 0x00	; 0
 450:	e0 5a       	subi	r30, 0xA0	; 160
 452:	ff 4f       	sbci	r31, 0xFF	; 255
 454:	80 81       	ld	r24, Z
 456:	88 23       	and	r24, r24
 458:	49 f0       	breq	.+18     	; 0x46c <__EEPROM_REGION_LENGTH__+0x6c>
      invalid_user_input = true;
 45a:	81 e0       	ldi	r24, 0x01	; 1
 45c:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <invalid_user_input>
      dump_invalid_data = true;
 460:	80 93 94 00 	sts	0x0094, r24	; 0x800094 <dump_invalid_data>
      msg_buffer_pointer = 0;
 464:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
      callFunWhenBufferReady();
 468:	0e 94 e6 01 	call	0x3cc	; 0x3cc <callFunWhenBufferReady>
      }
    }

  // Msg has ended and is within the required length
  if (udr_temp == 0) {
 46c:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <udr_temp>
 470:	81 11       	cpse	r24, r1
 472:	0a c0       	rjmp	.+20     	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
    if (msg_buffer_pointer <= msg_length) {
 474:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 478:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <msg_length>
 47c:	89 17       	cp	r24, r25
 47e:	20 f0       	brcs	.+8      	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
      callFunWhenBufferReady();
 480:	0e 94 e6 01 	call	0x3cc	; 0x3cc <callFunWhenBufferReady>
      msg_buffer_pointer = 0;
 484:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
      }
    }
  }
 488:	ff 91       	pop	r31
 48a:	ef 91       	pop	r30
 48c:	bf 91       	pop	r27
 48e:	af 91       	pop	r26
 490:	9f 91       	pop	r25
 492:	8f 91       	pop	r24
 494:	7f 91       	pop	r23
 496:	6f 91       	pop	r22
 498:	5f 91       	pop	r21
 49a:	4f 91       	pop	r20
 49c:	3f 91       	pop	r19
 49e:	2f 91       	pop	r18
 4a0:	0f 90       	pop	r0
 4a2:	0f be       	out	0x3f, r0	; 63
 4a4:	0f 90       	pop	r0
 4a6:	1f 90       	pop	r1
 4a8:	18 95       	reti

000004aa <_exit>:
 4aa:	f8 94       	cli

000004ac <__stop_program>:
 4ac:	ff cf       	rjmp	.-2      	; 0x4ac <__stop_program>
