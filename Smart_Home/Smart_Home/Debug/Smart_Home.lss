
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003404  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000746  00800060  00003404  00003498  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000b6  008007a6  008007a6  00003bde  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003bde  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00003c3c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005a8  00000000  00000000  00003c78  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000654f  00000000  00000000  00004220  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001883  00000000  00000000  0000a76f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004057  00000000  00000000  0000bff2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000df0  00000000  00000000  0001004c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000014a3  00000000  00000000  00010e3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000035ce  00000000  00000000  000122df  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000478  00000000  00000000  000158ad  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__ctors_end>
       4:	0c 94 3b 12 	jmp	0x2476	; 0x2476 <__vector_1>
       8:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
       c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      10:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      14:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      18:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      1c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      20:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      24:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      28:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      2c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      30:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      34:	0c 94 b6 11 	jmp	0x236c	; 0x236c <__vector_13>
      38:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      3c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      40:	0c 94 5f 12 	jmp	0x24be	; 0x24be <__vector_16>
      44:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      48:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      4c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      50:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      54:	41 06       	cpc	r4, r17
      56:	55 06       	cpc	r5, r21
      58:	55 06       	cpc	r5, r21
      5a:	55 06       	cpc	r5, r21
      5c:	55 06       	cpc	r5, r21
      5e:	55 06       	cpc	r5, r21
      60:	55 06       	cpc	r5, r21
      62:	55 06       	cpc	r5, r21
      64:	57 06       	cpc	r5, r23
      66:	55 06       	cpc	r5, r21
      68:	55 06       	cpc	r5, r21
      6a:	55 06       	cpc	r5, r21
      6c:	55 06       	cpc	r5, r21
      6e:	55 06       	cpc	r5, r21
      70:	55 06       	cpc	r5, r21
      72:	55 06       	cpc	r5, r21
      74:	43 06       	cpc	r4, r19
      76:	55 06       	cpc	r5, r21
      78:	55 06       	cpc	r5, r21
      7a:	55 06       	cpc	r5, r21
      7c:	55 06       	cpc	r5, r21
      7e:	55 06       	cpc	r5, r21
      80:	55 06       	cpc	r5, r21
      82:	55 06       	cpc	r5, r21
      84:	45 06       	cpc	r4, r21
      86:	55 06       	cpc	r5, r21
      88:	55 06       	cpc	r5, r21
      8a:	55 06       	cpc	r5, r21
      8c:	55 06       	cpc	r5, r21
      8e:	55 06       	cpc	r5, r21
      90:	55 06       	cpc	r5, r21
      92:	55 06       	cpc	r5, r21
      94:	47 06       	cpc	r4, r23
      96:	55 06       	cpc	r5, r21
      98:	55 06       	cpc	r5, r21
      9a:	55 06       	cpc	r5, r21
      9c:	55 06       	cpc	r5, r21
      9e:	55 06       	cpc	r5, r21
      a0:	55 06       	cpc	r5, r21
      a2:	55 06       	cpc	r5, r21
      a4:	49 06       	cpc	r4, r25
      a6:	55 06       	cpc	r5, r21
      a8:	55 06       	cpc	r5, r21
      aa:	55 06       	cpc	r5, r21
      ac:	55 06       	cpc	r5, r21
      ae:	55 06       	cpc	r5, r21
      b0:	55 06       	cpc	r5, r21
      b2:	55 06       	cpc	r5, r21
      b4:	4b 06       	cpc	r4, r27
      b6:	55 06       	cpc	r5, r21
      b8:	55 06       	cpc	r5, r21
      ba:	55 06       	cpc	r5, r21
      bc:	55 06       	cpc	r5, r21
      be:	55 06       	cpc	r5, r21
      c0:	55 06       	cpc	r5, r21
      c2:	55 06       	cpc	r5, r21
      c4:	4d 06       	cpc	r4, r29
      c6:	55 06       	cpc	r5, r21
      c8:	55 06       	cpc	r5, r21
      ca:	55 06       	cpc	r5, r21
      cc:	55 06       	cpc	r5, r21
      ce:	55 06       	cpc	r5, r21
      d0:	55 06       	cpc	r5, r21
      d2:	55 06       	cpc	r5, r21
      d4:	4f 06       	cpc	r4, r31
      d6:	55 06       	cpc	r5, r21
      d8:	55 06       	cpc	r5, r21
      da:	55 06       	cpc	r5, r21
      dc:	55 06       	cpc	r5, r21
      de:	55 06       	cpc	r5, r21
      e0:	55 06       	cpc	r5, r21
      e2:	55 06       	cpc	r5, r21
      e4:	51 06       	cpc	r5, r17
      e6:	55 06       	cpc	r5, r21
      e8:	55 06       	cpc	r5, r21
      ea:	55 06       	cpc	r5, r21
      ec:	55 06       	cpc	r5, r21
      ee:	55 06       	cpc	r5, r21
      f0:	55 06       	cpc	r5, r21
      f2:	55 06       	cpc	r5, r21
      f4:	53 06       	cpc	r5, r19
      f6:	8a 0a       	sbc	r8, r26
      f8:	91 0a       	sbc	r9, r17
      fa:	98 0a       	sbc	r9, r24
      fc:	9f 0a       	sbc	r9, r31
      fe:	a6 0a       	sbc	r10, r22
     100:	ad 0a       	sbc	r10, r29
     102:	b4 0a       	sbc	r11, r20
     104:	bb 0a       	sbc	r11, r27
     106:	c2 0a       	sbc	r12, r18
     108:	c9 0a       	sbc	r12, r25

0000010a <__ctors_end>:
     10a:	11 24       	eor	r1, r1
     10c:	1f be       	out	0x3f, r1	; 63
     10e:	cf e5       	ldi	r28, 0x5F	; 95
     110:	d8 e0       	ldi	r29, 0x08	; 8
     112:	de bf       	out	0x3e, r29	; 62
     114:	cd bf       	out	0x3d, r28	; 61

00000116 <__do_copy_data>:
     116:	17 e0       	ldi	r17, 0x07	; 7
     118:	a0 e6       	ldi	r26, 0x60	; 96
     11a:	b0 e0       	ldi	r27, 0x00	; 0
     11c:	e4 e0       	ldi	r30, 0x04	; 4
     11e:	f4 e3       	ldi	r31, 0x34	; 52
     120:	02 c0       	rjmp	.+4      	; 0x126 <__do_copy_data+0x10>
     122:	05 90       	lpm	r0, Z+
     124:	0d 92       	st	X+, r0
     126:	a6 3a       	cpi	r26, 0xA6	; 166
     128:	b1 07       	cpc	r27, r17
     12a:	d9 f7       	brne	.-10     	; 0x122 <__do_copy_data+0xc>

0000012c <__do_clear_bss>:
     12c:	28 e0       	ldi	r18, 0x08	; 8
     12e:	a6 ea       	ldi	r26, 0xA6	; 166
     130:	b7 e0       	ldi	r27, 0x07	; 7
     132:	01 c0       	rjmp	.+2      	; 0x136 <.do_clear_bss_start>

00000134 <.do_clear_bss_loop>:
     134:	1d 92       	st	X+, r1

00000136 <.do_clear_bss_start>:
     136:	ac 35       	cpi	r26, 0x5C	; 92
     138:	b2 07       	cpc	r27, r18
     13a:	e1 f7       	brne	.-8      	; 0x134 <.do_clear_bss_loop>
     13c:	0e 94 35 04 	call	0x86a	; 0x86a <main>
     140:	0c 94 00 1a 	jmp	0x3400	; 0x3400 <_exit>

00000144 <__bad_interrupt>:
     144:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000148 <Buzzer_init>:
 */

#include "buzzer.h"

 // Initialize the buzzer
EN_BuzzerError_t Buzzer_init(u8 buzzerPort, u8 buzzerPin) {
     148:	98 2f       	mov	r25, r24
     14a:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(buzzerPin, buzzerPort, OUT) == DIO_OK) {
     14c:	41 e0       	ldi	r20, 0x01	; 1
     14e:	69 2f       	mov	r22, r25
     150:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
     154:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that the buzzer initialization failed
  return BUZZER_ERROR_INIT;
     156:	81 e0       	ldi	r24, 0x01	; 1
  }
     158:	08 95       	ret

0000015a <Buzzer_on>:

// Turn on the buzzer
EN_BuzzerError_t Buzzer_on(u8 buzzerPort, u8 buzzerPin) {
     15a:	98 2f       	mov	r25, r24
     15c:	86 2f       	mov	r24, r22
  if (DIO_write(buzzerPin, buzzerPort, HIGH) == DIO_OK) {
     15e:	41 e0       	ldi	r20, 0x01	; 1
     160:	69 2f       	mov	r22, r25
     162:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
     166:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that attempting to turn on the buzzer has failed
  return BUZZER_ERROR_ON;
     168:	82 e0       	ldi	r24, 0x02	; 2
  }
     16a:	08 95       	ret

0000016c <EEPROM_init>:
 */

#include "eeprom.h"

void EEPROM_init() {
  I2C_init();
     16c:	0e 94 59 06 	call	0xcb2	; 0xcb2 <I2C_init>
     170:	08 95       	ret

00000172 <EEPROM_read_byte>:
  }

void EEPROM_read_byte(u8 page, u8 address, s8* data) {
     172:	0f 93       	push	r16
     174:	1f 93       	push	r17
     176:	cf 93       	push	r28
     178:	df 93       	push	r29
     17a:	c8 2f       	mov	r28, r24
     17c:	d6 2f       	mov	r29, r22
     17e:	8a 01       	movw	r16, r20
  I2C_start();
     180:	0e 94 5d 06 	call	0xcba	; 0xcba <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     184:	cc 0f       	add	r28, r28
     186:	80 ea       	ldi	r24, 0xA0	; 160
     188:	8c 0f       	add	r24, r28
     18a:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  I2C_write(address);
     18e:	8d 2f       	mov	r24, r29
     190:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  I2C_start();
     194:	0e 94 5d 06 	call	0xcba	; 0xcba <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     198:	81 ea       	ldi	r24, 0xA1	; 161
     19a:	8c 0f       	add	r24, r28
     19c:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  // read_Ack will halt the reading here, because it will send the next byte, which will not be received and wait for ack, which will not be sent. 
  // Nack must be sent after the arrival of the last requested byte. It's used basically to indicate that no further data transmission is required and then the stop condition is sent
  I2C_read_Nack(data);
     1a0:	c8 01       	movw	r24, r16
     1a2:	0e 94 79 06 	call	0xcf2	; 0xcf2 <I2C_read_Nack>
  I2C_stop();
     1a6:	0e 94 84 06 	call	0xd08	; 0xd08 <I2C_stop>
  }
     1aa:	df 91       	pop	r29
     1ac:	cf 91       	pop	r28
     1ae:	1f 91       	pop	r17
     1b0:	0f 91       	pop	r16
     1b2:	08 95       	ret

000001b4 <EEPROM_read_block>:

void EEPROM_read_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     1b4:	ef 92       	push	r14
     1b6:	ff 92       	push	r15
     1b8:	0f 93       	push	r16
     1ba:	1f 93       	push	r17
     1bc:	cf 93       	push	r28
     1be:	df 93       	push	r29
     1c0:	c8 2f       	mov	r28, r24
     1c2:	d6 2f       	mov	r29, r22
     1c4:	7a 01       	movw	r14, r20
     1c6:	89 01       	movw	r16, r18
  u16 i;
  for (i = 0;i < bytes_number;i++) {
    EEPROM_read_byte(page, address + i, &data[i]);
    }
#elif READ_BLOCK_METHOD == MULTIBYTE
  I2C_start();
     1c8:	0e 94 5d 06 	call	0xcba	; 0xcba <I2C_start>
  I2C_write(0xA0 + (page << 1));
     1cc:	cc 0f       	add	r28, r28
     1ce:	80 ea       	ldi	r24, 0xA0	; 160
     1d0:	8c 0f       	add	r24, r28
     1d2:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  I2C_write(address);
     1d6:	8d 2f       	mov	r24, r29
     1d8:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  I2C_start();
     1dc:	0e 94 5d 06 	call	0xcba	; 0xcba <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     1e0:	81 ea       	ldi	r24, 0xA1	; 161
     1e2:	8c 0f       	add	r24, r28
     1e4:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1e8:	c0 e0       	ldi	r28, 0x00	; 0
     1ea:	d0 e0       	ldi	r29, 0x00	; 0
     1ec:	06 c0       	rjmp	.+12     	; 0x1fa <EEPROM_read_block+0x46>
    I2C_read_Ack(&data[i]);
     1ee:	c8 01       	movw	r24, r16
     1f0:	8c 0f       	add	r24, r28
     1f2:	9d 1f       	adc	r25, r29
     1f4:	0e 94 6e 06 	call	0xcdc	; 0xcdc <I2C_read_Ack>
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  I2C_start();
  I2C_write(0xA0 + (page << 1) + 1);
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1f8:	21 96       	adiw	r28, 0x01	; 1
     1fa:	c7 01       	movw	r24, r14
     1fc:	01 97       	sbiw	r24, 0x01	; 1
     1fe:	c8 17       	cp	r28, r24
     200:	d9 07       	cpc	r29, r25
     202:	a8 f3       	brcs	.-22     	; 0x1ee <EEPROM_read_block+0x3a>
    I2C_read_Ack(&data[i]);
    }
  I2C_read_Nack(&data[i]);
     204:	c8 01       	movw	r24, r16
     206:	8c 0f       	add	r24, r28
     208:	9d 1f       	adc	r25, r29
     20a:	0e 94 79 06 	call	0xcf2	; 0xcf2 <I2C_read_Nack>
  I2C_stop();
     20e:	0e 94 84 06 	call	0xd08	; 0xd08 <I2C_stop>
#endif
  }
     212:	df 91       	pop	r29
     214:	cf 91       	pop	r28
     216:	1f 91       	pop	r17
     218:	0f 91       	pop	r16
     21a:	ff 90       	pop	r15
     21c:	ef 90       	pop	r14
     21e:	08 95       	ret

00000220 <EEPROM_write_byte>:

void EEPROM_write_byte(u8 page, u8 address, s8 data) {
     220:	1f 93       	push	r17
     222:	cf 93       	push	r28
     224:	df 93       	push	r29
     226:	c8 2f       	mov	r28, r24
     228:	16 2f       	mov	r17, r22
     22a:	d4 2f       	mov	r29, r20
  I2C_start();
     22c:	0e 94 5d 06 	call	0xcba	; 0xcba <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     230:	8c 2f       	mov	r24, r28
     232:	88 0f       	add	r24, r24
     234:	80 56       	subi	r24, 0x60	; 96
     236:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  I2C_write(address);
     23a:	81 2f       	mov	r24, r17
     23c:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  I2C_write(data);
     240:	8d 2f       	mov	r24, r29
     242:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  I2C_stop();
     246:	0e 94 84 06 	call	0xd08	; 0xd08 <I2C_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     24a:	8f e3       	ldi	r24, 0x3F	; 63
     24c:	9c e9       	ldi	r25, 0x9C	; 156
     24e:	01 97       	sbiw	r24, 0x01	; 1
     250:	f1 f7       	brne	.-4      	; 0x24e <EEPROM_write_byte+0x2e>
     252:	00 c0       	rjmp	.+0      	; 0x254 <EEPROM_write_byte+0x34>
     254:	00 00       	nop

#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
  }
     256:	df 91       	pop	r29
     258:	cf 91       	pop	r28
     25a:	1f 91       	pop	r17
     25c:	08 95       	ret

0000025e <EEPROM_write_block>:

// bytes_number must be within page size (256 bytes)
void EEPROM_write_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     25e:	6f 92       	push	r6
     260:	7f 92       	push	r7
     262:	8f 92       	push	r8
     264:	9f 92       	push	r9
     266:	af 92       	push	r10
     268:	bf 92       	push	r11
     26a:	cf 92       	push	r12
     26c:	df 92       	push	r13
     26e:	ef 92       	push	r14
     270:	ff 92       	push	r15
     272:	0f 93       	push	r16
     274:	1f 93       	push	r17
     276:	cf 93       	push	r28
     278:	df 93       	push	r29
     27a:	78 2e       	mov	r7, r24
     27c:	66 2e       	mov	r6, r22
     27e:	6a 01       	movw	r12, r20
     280:	89 01       	movw	r16, r18
  //! If data is required to be written in the first 16 bytes starting from byte 10 for example, the data will be stored starting from bytes 10, 
  //! and if the data exceeds the row limit ** IT WILL ROLL OVER AND OVERWRITE THE ROW **. Therefore, in a single multibyte write cycle, we can't write more than 16 bytes at maximum if starting from the first byte in the row
  //! or the remaining bytes till the end of the row from the starting position. The remaining bytes must be written in another write cycle to avoind the roll over problem.

  u16 dataIndex, blockNumber, i;
  u16 first_block_size = 16 - (address % 16);
     282:	86 2f       	mov	r24, r22
     284:	8f 70       	andi	r24, 0x0F	; 15
     286:	20 e1       	ldi	r18, 0x10	; 16
     288:	30 e0       	ldi	r19, 0x00	; 0
     28a:	79 01       	movw	r14, r18
     28c:	e8 1a       	sub	r14, r24
     28e:	f1 08       	sbc	r15, r1
  if (16 - (address % 16) > bytes_number) first_block_size = bytes_number;
     290:	4e 15       	cp	r20, r14
     292:	5f 05       	cpc	r21, r15
     294:	08 f4       	brcc	.+2      	; 0x298 <EEPROM_write_block+0x3a>
     296:	7a 01       	movw	r14, r20

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
     298:	0e 94 5d 06 	call	0xcba	; 0xcba <I2C_start>
  I2C_write(0xA0 + (page << 1));
     29c:	87 2d       	mov	r24, r7
     29e:	88 0f       	add	r24, r24
     2a0:	0f 2e       	mov	r0, r31
     2a2:	f0 ea       	ldi	r31, 0xA0	; 160
     2a4:	7f 2e       	mov	r7, r31
     2a6:	f0 2d       	mov	r31, r0
     2a8:	78 0e       	add	r7, r24
     2aa:	87 2d       	mov	r24, r7
     2ac:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  I2C_write(address);
     2b0:	86 2d       	mov	r24, r6
     2b2:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2b6:	c0 e0       	ldi	r28, 0x00	; 0
     2b8:	d0 e0       	ldi	r29, 0x00	; 0
     2ba:	07 c0       	rjmp	.+14     	; 0x2ca <EEPROM_write_block+0x6c>
    I2C_write(data[dataIndex]);
     2bc:	f8 01       	movw	r30, r16
     2be:	ec 0f       	add	r30, r28
     2c0:	fd 1f       	adc	r31, r29
     2c2:	80 81       	ld	r24, Z
     2c4:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2c8:	21 96       	adiw	r28, 0x01	; 1
     2ca:	ce 15       	cp	r28, r14
     2cc:	df 05       	cpc	r29, r15
     2ce:	b0 f3       	brcs	.-20     	; 0x2bc <EEPROM_write_block+0x5e>
    I2C_write(data[dataIndex]);
    }
  I2C_stop();
     2d0:	0e 94 84 06 	call	0xd08	; 0xd08 <I2C_stop>
     2d4:	8f e3       	ldi	r24, 0x3F	; 63
     2d6:	9c e9       	ldi	r25, 0x9C	; 156
     2d8:	01 97       	sbiw	r24, 0x01	; 1
     2da:	f1 f7       	brne	.-4      	; 0x2d8 <EEPROM_write_block+0x7a>
     2dc:	00 c0       	rjmp	.+0      	; 0x2de <EEPROM_write_block+0x80>
     2de:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif

  // Return if the data fits in the row (data fits in a single row or the remaining part of it after the address)
  if (first_block_size == bytes_number) return;
     2e0:	ec 14       	cp	r14, r12
     2e2:	fd 04       	cpc	r15, r13
     2e4:	09 f4       	brne	.+2      	; 0x2e8 <EEPROM_write_block+0x8a>
     2e6:	61 c0       	rjmp	.+194    	; 0x3aa <EEPROM_write_block+0x14c>

  u16 last_block_size = (address + bytes_number) % 16;
     2e8:	56 01       	movw	r10, r12
     2ea:	a6 0c       	add	r10, r6
     2ec:	b1 1c       	adc	r11, r1
     2ee:	9f e0       	ldi	r25, 0x0F	; 15
     2f0:	a9 22       	and	r10, r25
     2f2:	bb 24       	eor	r11, r11
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
     2f4:	ce 18       	sub	r12, r14
     2f6:	df 08       	sbc	r13, r15
     2f8:	ca 18       	sub	r12, r10
     2fa:	db 08       	sbc	r13, r11
     2fc:	d6 94       	lsr	r13
     2fe:	c7 94       	ror	r12
     300:	d6 94       	lsr	r13
     302:	c7 94       	ror	r12
     304:	d6 94       	lsr	r13
     306:	c7 94       	ror	r12
     308:	d6 94       	lsr	r13
     30a:	c7 94       	ror	r12
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     30c:	e1 2c       	mov	r14, r1
     30e:	f1 2c       	mov	r15, r1
     310:	27 c0       	rjmp	.+78     	; 0x360 <EEPROM_write_block+0x102>
    I2C_start();
     312:	0e 94 5d 06 	call	0xcba	; 0xcba <I2C_start>
    I2C_write(0xA0 + (page << 1));
     316:	87 2d       	mov	r24, r7
     318:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
    I2C_write(address + dataIndex);
     31c:	8c 2f       	mov	r24, r28
     31e:	86 0d       	add	r24, r6
     320:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
    for (i = 0;i < 16;i++) {
     324:	81 2c       	mov	r8, r1
     326:	91 2c       	mov	r9, r1
     328:	0b c0       	rjmp	.+22     	; 0x340 <EEPROM_write_block+0xe2>
      I2C_write(data[dataIndex + i]);
     32a:	fe 01       	movw	r30, r28
     32c:	e8 0d       	add	r30, r8
     32e:	f9 1d       	adc	r31, r9
     330:	e0 0f       	add	r30, r16
     332:	f1 1f       	adc	r31, r17
     334:	80 81       	ld	r24, Z
     336:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
    I2C_start();
    I2C_write(0xA0 + (page << 1));
    I2C_write(address + dataIndex);
    for (i = 0;i < 16;i++) {
     33a:	8f ef       	ldi	r24, 0xFF	; 255
     33c:	88 1a       	sub	r8, r24
     33e:	98 0a       	sbc	r9, r24
     340:	90 e1       	ldi	r25, 0x10	; 16
     342:	89 16       	cp	r8, r25
     344:	91 04       	cpc	r9, r1
     346:	88 f3       	brcs	.-30     	; 0x32a <EEPROM_write_block+0xcc>
      I2C_write(data[dataIndex + i]);
      }
    dataIndex += 16;
     348:	60 96       	adiw	r28, 0x10	; 16
    I2C_stop();
     34a:	0e 94 84 06 	call	0xd08	; 0xd08 <I2C_stop>
     34e:	8f e3       	ldi	r24, 0x3F	; 63
     350:	9c e9       	ldi	r25, 0x9C	; 156
     352:	01 97       	sbiw	r24, 0x01	; 1
     354:	f1 f7       	brne	.-4      	; 0x352 <EEPROM_write_block+0xf4>
     356:	00 c0       	rjmp	.+0      	; 0x358 <EEPROM_write_block+0xfa>
     358:	00 00       	nop
  if (first_block_size == bytes_number) return;

  u16 last_block_size = (address + bytes_number) % 16;
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     35a:	9f ef       	ldi	r25, 0xFF	; 255
     35c:	e9 1a       	sub	r14, r25
     35e:	f9 0a       	sbc	r15, r25
     360:	ec 14       	cp	r14, r12
     362:	fd 04       	cpc	r15, r13
     364:	b0 f2       	brcs	.-84     	; 0x312 <EEPROM_write_block+0xb4>
    _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
    }

  // Write the last part of the data
  I2C_start();
     366:	0e 94 5d 06 	call	0xcba	; 0xcba <I2C_start>
  I2C_write(0xA0 + (page << 1));
     36a:	87 2d       	mov	r24, r7
     36c:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  I2C_write(address + dataIndex);
     370:	8c 2f       	mov	r24, r28
     372:	86 0d       	add	r24, r6
     374:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>
  for (i = 0;i < last_block_size;i++) {
     378:	e1 2c       	mov	r14, r1
     37a:	f1 2c       	mov	r15, r1
     37c:	0b c0       	rjmp	.+22     	; 0x394 <EEPROM_write_block+0x136>
    I2C_write(data[dataIndex + i]);
     37e:	fe 01       	movw	r30, r28
     380:	ee 0d       	add	r30, r14
     382:	ff 1d       	adc	r31, r15
     384:	e0 0f       	add	r30, r16
     386:	f1 1f       	adc	r31, r17
     388:	80 81       	ld	r24, Z
     38a:	0e 94 65 06 	call	0xcca	; 0xcca <I2C_write>

  // Write the last part of the data
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address + dataIndex);
  for (i = 0;i < last_block_size;i++) {
     38e:	8f ef       	ldi	r24, 0xFF	; 255
     390:	e8 1a       	sub	r14, r24
     392:	f8 0a       	sbc	r15, r24
     394:	ea 14       	cp	r14, r10
     396:	fb 04       	cpc	r15, r11
     398:	90 f3       	brcs	.-28     	; 0x37e <EEPROM_write_block+0x120>
    I2C_write(data[dataIndex + i]);
    }
  I2C_stop();
     39a:	0e 94 84 06 	call	0xd08	; 0xd08 <I2C_stop>
     39e:	8f e3       	ldi	r24, 0x3F	; 63
     3a0:	9c e9       	ldi	r25, 0x9C	; 156
     3a2:	01 97       	sbiw	r24, 0x01	; 1
     3a4:	f1 f7       	brne	.-4      	; 0x3a2 <EEPROM_write_block+0x144>
     3a6:	00 c0       	rjmp	.+0      	; 0x3a8 <EEPROM_write_block+0x14a>
     3a8:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
#endif
     3aa:	df 91       	pop	r29
     3ac:	cf 91       	pop	r28
     3ae:	1f 91       	pop	r17
     3b0:	0f 91       	pop	r16
     3b2:	ff 90       	pop	r15
     3b4:	ef 90       	pop	r14
     3b6:	df 90       	pop	r13
     3b8:	cf 90       	pop	r12
     3ba:	bf 90       	pop	r11
     3bc:	af 90       	pop	r10
     3be:	9f 90       	pop	r9
     3c0:	8f 90       	pop	r8
     3c2:	7f 90       	pop	r7
     3c4:	6f 90       	pop	r6
     3c6:	08 95       	ret

000003c8 <BT_sendChar>:
  DIO_init(HC_05_STATUS_PIN, HC_05_STATUS_PORT, IN);
  UART_init(baudRate);
  }

void BT_sendChar(s8 data) {
  UART_sendChar(data);
     3c8:	0e 94 6d 09 	call	0x12da	; 0x12da <UART_sendChar>
     3cc:	08 95       	ret

000003ce <BT_sendString>:
  }

void BT_sendString(s8* str) {
  UART_sendString(str);
     3ce:	0e 94 73 09 	call	0x12e6	; 0x12e6 <UART_sendString>
     3d2:	08 95       	ret

000003d4 <Keypad_init>:

#include "keypad.h"

EN_KeypadStatusCode_t Keypad_init(void) {
  // Set rows as outputs
  DIO_init(KEYPAD_R0_PIN, KEYPAD_PORT, OUT);
     3d4:	41 e0       	ldi	r20, 0x01	; 1
     3d6:	62 e4       	ldi	r22, 0x42	; 66
     3d8:	80 e0       	ldi	r24, 0x00	; 0
     3da:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  DIO_init(KEYPAD_R1_PIN, KEYPAD_PORT, OUT);
     3de:	41 e0       	ldi	r20, 0x01	; 1
     3e0:	62 e4       	ldi	r22, 0x42	; 66
     3e2:	81 e0       	ldi	r24, 0x01	; 1
     3e4:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  DIO_init(KEYPAD_R2_PIN, KEYPAD_PORT, OUT);
     3e8:	41 e0       	ldi	r20, 0x01	; 1
     3ea:	62 e4       	ldi	r22, 0x42	; 66
     3ec:	82 e0       	ldi	r24, 0x02	; 2
     3ee:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  DIO_init(KEYPAD_R3_PIN, KEYPAD_PORT, OUT);
     3f2:	41 e0       	ldi	r20, 0x01	; 1
     3f4:	62 e4       	ldi	r22, 0x42	; 66
     3f6:	83 e0       	ldi	r24, 0x03	; 3
     3f8:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  // Set all high
  DIO_write(KEYPAD_R0_PIN, KEYPAD_PORT, HIGH);
     3fc:	41 e0       	ldi	r20, 0x01	; 1
     3fe:	62 e4       	ldi	r22, 0x42	; 66
     400:	80 e0       	ldi	r24, 0x00	; 0
     402:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  DIO_write(KEYPAD_R1_PIN, KEYPAD_PORT, HIGH);
     406:	41 e0       	ldi	r20, 0x01	; 1
     408:	62 e4       	ldi	r22, 0x42	; 66
     40a:	81 e0       	ldi	r24, 0x01	; 1
     40c:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  DIO_write(KEYPAD_R2_PIN, KEYPAD_PORT, HIGH);
     410:	41 e0       	ldi	r20, 0x01	; 1
     412:	62 e4       	ldi	r22, 0x42	; 66
     414:	82 e0       	ldi	r24, 0x02	; 2
     416:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  DIO_write(KEYPAD_R3_PIN, KEYPAD_PORT, HIGH);
     41a:	41 e0       	ldi	r20, 0x01	; 1
     41c:	62 e4       	ldi	r22, 0x42	; 66
     41e:	83 e0       	ldi	r24, 0x03	; 3
     420:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  // Set columns as inputs
  DIO_init(KEYPAD_C0_PIN, KEYPAD_PORT, IN);
     424:	40 e0       	ldi	r20, 0x00	; 0
     426:	62 e4       	ldi	r22, 0x42	; 66
     428:	84 e0       	ldi	r24, 0x04	; 4
     42a:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  DIO_init(KEYPAD_C1_PIN, KEYPAD_PORT, IN);
     42e:	40 e0       	ldi	r20, 0x00	; 0
     430:	62 e4       	ldi	r22, 0x42	; 66
     432:	85 e0       	ldi	r24, 0x05	; 5
     434:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  DIO_init(KEYPAD_C2_PIN, KEYPAD_PORT, IN);
     438:	40 e0       	ldi	r20, 0x00	; 0
     43a:	62 e4       	ldi	r22, 0x42	; 66
     43c:	86 e0       	ldi	r24, 0x06	; 6
     43e:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  DIO_init(KEYPAD_C3_PIN, KEYPAD_PORT, IN);
     442:	40 e0       	ldi	r20, 0x00	; 0
     444:	62 e4       	ldi	r22, 0x42	; 66
     446:	87 e0       	ldi	r24, 0x07	; 7
     448:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  // Activate the pull up resistors
  DIO_write(KEYPAD_C0_PIN, KEYPAD_PORT, HIGH);
     44c:	41 e0       	ldi	r20, 0x01	; 1
     44e:	62 e4       	ldi	r22, 0x42	; 66
     450:	84 e0       	ldi	r24, 0x04	; 4
     452:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  DIO_write(KEYPAD_C1_PIN, KEYPAD_PORT, HIGH);
     456:	41 e0       	ldi	r20, 0x01	; 1
     458:	62 e4       	ldi	r22, 0x42	; 66
     45a:	85 e0       	ldi	r24, 0x05	; 5
     45c:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  DIO_write(KEYPAD_C2_PIN, KEYPAD_PORT, HIGH);
     460:	41 e0       	ldi	r20, 0x01	; 1
     462:	62 e4       	ldi	r22, 0x42	; 66
     464:	86 e0       	ldi	r24, 0x06	; 6
     466:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  DIO_write(KEYPAD_C3_PIN, KEYPAD_PORT, HIGH);
     46a:	41 e0       	ldi	r20, 0x01	; 1
     46c:	62 e4       	ldi	r22, 0x42	; 66
     46e:	87 e0       	ldi	r24, 0x07	; 7
     470:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>

  return KEYPAD_INIT_OK;
  }
     474:	80 e0       	ldi	r24, 0x00	; 0
     476:	08 95       	ret

00000478 <toggle_row>:

void toggle_row(u8 row) {
  switch (row) {
     478:	81 30       	cpi	r24, 0x01	; 1
     47a:	59 f0       	breq	.+22     	; 0x492 <toggle_row+0x1a>
     47c:	28 f0       	brcs	.+10     	; 0x488 <toggle_row+0x10>
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	69 f0       	breq	.+26     	; 0x49c <toggle_row+0x24>
     482:	83 30       	cpi	r24, 0x03	; 3
     484:	81 f0       	breq	.+32     	; 0x4a6 <toggle_row+0x2e>
     486:	08 95       	ret
      case 0:
        DIO_toggle(KEYPAD_R0_PIN, KEYPAD_PORT);
     488:	62 e4       	ldi	r22, 0x42	; 66
     48a:	80 e0       	ldi	r24, 0x00	; 0
     48c:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <DIO_toggle>
        break;
     490:	08 95       	ret
      case 1:
        DIO_toggle(KEYPAD_R1_PIN, KEYPAD_PORT);
     492:	62 e4       	ldi	r22, 0x42	; 66
     494:	81 e0       	ldi	r24, 0x01	; 1
     496:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <DIO_toggle>
        break;
     49a:	08 95       	ret
      case 2:
        DIO_toggle(KEYPAD_R2_PIN, KEYPAD_PORT);
     49c:	62 e4       	ldi	r22, 0x42	; 66
     49e:	82 e0       	ldi	r24, 0x02	; 2
     4a0:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <DIO_toggle>
        break;
     4a4:	08 95       	ret
      case 3:
        DIO_toggle(KEYPAD_R3_PIN, KEYPAD_PORT);
     4a6:	62 e4       	ldi	r22, 0x42	; 66
     4a8:	83 e0       	ldi	r24, 0x03	; 3
     4aa:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <DIO_toggle>
     4ae:	08 95       	ret

000004b0 <check_col>:
        break;
    }
  }

void check_col(u8 col, u8* res) {
  switch (col) {
     4b0:	81 30       	cpi	r24, 0x01	; 1
     4b2:	61 f0       	breq	.+24     	; 0x4cc <check_col+0x1c>
     4b4:	28 f0       	brcs	.+10     	; 0x4c0 <check_col+0x10>
     4b6:	82 30       	cpi	r24, 0x02	; 2
     4b8:	79 f0       	breq	.+30     	; 0x4d8 <check_col+0x28>
     4ba:	83 30       	cpi	r24, 0x03	; 3
     4bc:	99 f0       	breq	.+38     	; 0x4e4 <check_col+0x34>
     4be:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_C0_PIN, KEYPAD_PORT, res);
     4c0:	ab 01       	movw	r20, r22
     4c2:	62 e4       	ldi	r22, 0x42	; 66
     4c4:	84 e0       	ldi	r24, 0x04	; 4
     4c6:	0e 94 8c 05 	call	0xb18	; 0xb18 <DIO_Read>
        break;
     4ca:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_C1_PIN, KEYPAD_PORT, res);
     4cc:	ab 01       	movw	r20, r22
     4ce:	62 e4       	ldi	r22, 0x42	; 66
     4d0:	85 e0       	ldi	r24, 0x05	; 5
     4d2:	0e 94 8c 05 	call	0xb18	; 0xb18 <DIO_Read>
        break;
     4d6:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_C2_PIN, KEYPAD_PORT, res);
     4d8:	ab 01       	movw	r20, r22
     4da:	62 e4       	ldi	r22, 0x42	; 66
     4dc:	86 e0       	ldi	r24, 0x06	; 6
     4de:	0e 94 8c 05 	call	0xb18	; 0xb18 <DIO_Read>
        break;
     4e2:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_C3_PIN, KEYPAD_PORT, res);
     4e4:	ab 01       	movw	r20, r22
     4e6:	62 e4       	ldi	r22, 0x42	; 66
     4e8:	87 e0       	ldi	r24, 0x07	; 7
     4ea:	0e 94 8c 05 	call	0xb18	; 0xb18 <DIO_Read>
     4ee:	08 95       	ret

000004f0 <check_row>:
        break;
    }
  }

void check_row(u8 row, u8* res) {
  switch (row) {
     4f0:	81 30       	cpi	r24, 0x01	; 1
     4f2:	61 f0       	breq	.+24     	; 0x50c <check_row+0x1c>
     4f4:	28 f0       	brcs	.+10     	; 0x500 <check_row+0x10>
     4f6:	82 30       	cpi	r24, 0x02	; 2
     4f8:	79 f0       	breq	.+30     	; 0x518 <check_row+0x28>
     4fa:	83 30       	cpi	r24, 0x03	; 3
     4fc:	99 f0       	breq	.+38     	; 0x524 <check_row+0x34>
     4fe:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_R0_PIN, KEYPAD_PORT, res);
     500:	ab 01       	movw	r20, r22
     502:	62 e4       	ldi	r22, 0x42	; 66
     504:	80 e0       	ldi	r24, 0x00	; 0
     506:	0e 94 8c 05 	call	0xb18	; 0xb18 <DIO_Read>
        break;
     50a:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_R1_PIN, KEYPAD_PORT, res);
     50c:	ab 01       	movw	r20, r22
     50e:	62 e4       	ldi	r22, 0x42	; 66
     510:	81 e0       	ldi	r24, 0x01	; 1
     512:	0e 94 8c 05 	call	0xb18	; 0xb18 <DIO_Read>
        break;
     516:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_R2_PIN, KEYPAD_PORT, res);
     518:	ab 01       	movw	r20, r22
     51a:	62 e4       	ldi	r22, 0x42	; 66
     51c:	82 e0       	ldi	r24, 0x02	; 2
     51e:	0e 94 8c 05 	call	0xb18	; 0xb18 <DIO_Read>
        break;
     522:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_R3_PIN, KEYPAD_PORT, res);
     524:	ab 01       	movw	r20, r22
     526:	62 e4       	ldi	r22, 0x42	; 66
     528:	83 e0       	ldi	r24, 0x03	; 3
     52a:	0e 94 8c 05 	call	0xb18	; 0xb18 <DIO_Read>
     52e:	08 95       	ret

00000530 <Keypad_getPressedKey>:
        break;
    }
  }

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
     530:	ef 92       	push	r14
     532:	ff 92       	push	r15
     534:	0f 93       	push	r16
     536:	1f 93       	push	r17
     538:	cf 93       	push	r28
     53a:	df 93       	push	r29
     53c:	cd b7       	in	r28, 0x3d	; 61
     53e:	de b7       	in	r29, 0x3e	; 62
     540:	62 97       	sbiw	r28, 0x12	; 18
     542:	0f b6       	in	r0, 0x3f	; 63
     544:	f8 94       	cli
     546:	de bf       	out	0x3e, r29	; 62
     548:	0f be       	out	0x3f, r0	; 63
     54a:	cd bf       	out	0x3d, r28	; 61
     54c:	7c 01       	movw	r14, r24
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
     54e:	80 e1       	ldi	r24, 0x10	; 16
     550:	e0 e6       	ldi	r30, 0x60	; 96
     552:	f0 e0       	ldi	r31, 0x00	; 0
     554:	de 01       	movw	r26, r28
     556:	11 96       	adiw	r26, 0x01	; 1
     558:	01 90       	ld	r0, Z+
     55a:	0d 92       	st	X+, r0
     55c:	8a 95       	dec	r24
     55e:	e1 f7       	brne	.-8      	; 0x558 <Keypad_getPressedKey+0x28>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     560:	00 e0       	ldi	r16, 0x00	; 0
     562:	1c c0       	rjmp	.+56     	; 0x59c <Keypad_getPressedKey+0x6c>
    check_row(row, &row_state);
     564:	be 01       	movw	r22, r28
     566:	6e 5e       	subi	r22, 0xEE	; 238
     568:	7f 4f       	sbci	r23, 0xFF	; 255
     56a:	80 2f       	mov	r24, r16
     56c:	0e 94 78 02 	call	0x4f0	; 0x4f0 <check_row>
    if (row_state == LOW) {
     570:	8a 89       	ldd	r24, Y+18	; 0x12
     572:	88 23       	and	r24, r24
     574:	61 f0       	breq	.+24     	; 0x58e <Keypad_getPressedKey+0x5e>
     576:	11 c0       	rjmp	.+34     	; 0x59a <Keypad_getPressedKey+0x6a>
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
     578:	be 01       	movw	r22, r28
     57a:	6f 5e       	subi	r22, 0xEF	; 239
     57c:	7f 4f       	sbci	r23, 0xFF	; 255
     57e:	81 2f       	mov	r24, r17
     580:	0e 94 58 02 	call	0x4b0	; 0x4b0 <check_col>
        if (col_state == LOW) {
     584:	89 89       	ldd	r24, Y+17	; 0x11
     586:	88 23       	and	r24, r24
     588:	c9 f1       	breq	.+114    	; 0x5fc <Keypad_getPressedKey+0xcc>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
     58a:	1f 5f       	subi	r17, 0xFF	; 255
     58c:	01 c0       	rjmp	.+2      	; 0x590 <Keypad_getPressedKey+0x60>
     58e:	10 e0       	ldi	r17, 0x00	; 0
     590:	14 30       	cpi	r17, 0x04	; 4
     592:	90 f3       	brcs	.-28     	; 0x578 <Keypad_getPressedKey+0x48>
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
          }
        }
      toggle_row(row);
     594:	80 2f       	mov	r24, r16
     596:	0e 94 3c 02 	call	0x478	; 0x478 <toggle_row>

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     59a:	0f 5f       	subi	r16, 0xFF	; 255
     59c:	04 30       	cpi	r16, 0x04	; 4
     59e:	10 f3       	brcs	.-60     	; 0x564 <Keypad_getPressedKey+0x34>
     5a0:	00 e0       	ldi	r16, 0x00	; 0
     5a2:	28 c0       	rjmp	.+80     	; 0x5f4 <Keypad_getPressedKey+0xc4>
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
     5a4:	80 2f       	mov	r24, r16
     5a6:	0e 94 3c 02 	call	0x478	; 0x478 <toggle_row>
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     5aa:	10 e0       	ldi	r17, 0x00	; 0
     5ac:	1d c0       	rjmp	.+58     	; 0x5e8 <Keypad_getPressedKey+0xb8>
      check_col(col, &col_state);
     5ae:	be 01       	movw	r22, r28
     5b0:	6f 5e       	subi	r22, 0xEF	; 239
     5b2:	7f 4f       	sbci	r23, 0xFF	; 255
     5b4:	81 2f       	mov	r24, r17
     5b6:	0e 94 58 02 	call	0x4b0	; 0x4b0 <check_col>
      if (col_state == LOW) {
     5ba:	89 89       	ldd	r24, Y+17	; 0x11
     5bc:	81 11       	cpse	r24, r1
     5be:	13 c0       	rjmp	.+38     	; 0x5e6 <Keypad_getPressedKey+0xb6>
        // while (col_state == LOW) {  // Wait until the key is released (busy waiting - halts the system)
        //   check_col(col, &col_state);
        //   }
        *key = keys[row][col];
     5c0:	e0 2f       	mov	r30, r16
     5c2:	f0 e0       	ldi	r31, 0x00	; 0
     5c4:	ee 0f       	add	r30, r30
     5c6:	ff 1f       	adc	r31, r31
     5c8:	ee 0f       	add	r30, r30
     5ca:	ff 1f       	adc	r31, r31
     5cc:	81 e0       	ldi	r24, 0x01	; 1
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	8c 0f       	add	r24, r28
     5d2:	9d 1f       	adc	r25, r29
     5d4:	e8 0f       	add	r30, r24
     5d6:	f9 1f       	adc	r31, r25
     5d8:	e1 0f       	add	r30, r17
     5da:	f1 1d       	adc	r31, r1
     5dc:	80 81       	ld	r24, Z
     5de:	f7 01       	movw	r30, r14
     5e0:	80 83       	st	Z, r24
        return KEY_PRESSED;
     5e2:	81 e0       	ldi	r24, 0x01	; 1
     5e4:	0c c0       	rjmp	.+24     	; 0x5fe <Keypad_getPressedKey+0xce>
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     5e6:	1f 5f       	subi	r17, 0xFF	; 255
     5e8:	14 30       	cpi	r17, 0x04	; 4
     5ea:	08 f3       	brcs	.-62     	; 0x5ae <Keypad_getPressedKey+0x7e>
        //   }
        *key = keys[row][col];
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
     5ec:	80 2f       	mov	r24, r16
     5ee:	0e 94 3c 02 	call	0x478	; 0x478 <toggle_row>
          }
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
     5f2:	0f 5f       	subi	r16, 0xFF	; 255
     5f4:	04 30       	cpi	r16, 0x04	; 4
     5f6:	b0 f2       	brcs	.-84     	; 0x5a4 <Keypad_getPressedKey+0x74>
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     5f8:	82 e0       	ldi	r24, 0x02	; 2
     5fa:	01 c0       	rjmp	.+2      	; 0x5fe <Keypad_getPressedKey+0xce>
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
     5fc:	82 e0       	ldi	r24, 0x02	; 2
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     5fe:	62 96       	adiw	r28, 0x12	; 18
     600:	0f b6       	in	r0, 0x3f	; 63
     602:	f8 94       	cli
     604:	de bf       	out	0x3e, r29	; 62
     606:	0f be       	out	0x3f, r0	; 63
     608:	cd bf       	out	0x3d, r28	; 61
     60a:	df 91       	pop	r29
     60c:	cf 91       	pop	r28
     60e:	1f 91       	pop	r17
     610:	0f 91       	pop	r16
     612:	ff 90       	pop	r15
     614:	ef 90       	pop	r14
     616:	08 95       	ret

00000618 <LCD_sendEnablePulse>:
#include "lcd.h"

 // TODO: implement the eight bit mode

void LCD_sendEnablePulse(void) {
  DIO_write(EN, LCD_CTRL_PORT, HIGH);
     618:	41 e0       	ldi	r20, 0x01	; 1
     61a:	61 e4       	ldi	r22, 0x41	; 65
     61c:	86 e0       	ldi	r24, 0x06	; 6
     61e:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     622:	8a e1       	ldi	r24, 0x1A	; 26
     624:	8a 95       	dec	r24
     626:	f1 f7       	brne	.-4      	; 0x624 <LCD_sendEnablePulse+0xc>
     628:	00 c0       	rjmp	.+0      	; 0x62a <LCD_sendEnablePulse+0x12>
  _delay_us(5);
  DIO_write(EN, LCD_CTRL_PORT, LOW);
     62a:	40 e0       	ldi	r20, 0x00	; 0
     62c:	61 e4       	ldi	r22, 0x41	; 65
     62e:	86 e0       	ldi	r24, 0x06	; 6
     630:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
     634:	08 95       	ret

00000636 <LCD_write_4bits>:
  }

void LCD_write_4bits(u8 data) {
     636:	cf 93       	push	r28
     638:	c8 2f       	mov	r28, r24
  DIO_write(LCD_DATA_PIN4, LCD_DATA_PORT, read_bit(data, 0));
     63a:	48 2f       	mov	r20, r24
     63c:	41 70       	andi	r20, 0x01	; 1
     63e:	61 e4       	ldi	r22, 0x41	; 65
     640:	80 e0       	ldi	r24, 0x00	; 0
     642:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  DIO_write(LCD_DATA_PIN5, LCD_DATA_PORT, read_bit(data, 1));
     646:	c1 fb       	bst	r28, 1
     648:	44 27       	eor	r20, r20
     64a:	40 f9       	bld	r20, 0
     64c:	61 e4       	ldi	r22, 0x41	; 65
     64e:	81 e0       	ldi	r24, 0x01	; 1
     650:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  DIO_write(LCD_DATA_PIN6, LCD_DATA_PORT, read_bit(data, 2));
     654:	c2 fb       	bst	r28, 2
     656:	44 27       	eor	r20, r20
     658:	40 f9       	bld	r20, 0
     65a:	61 e4       	ldi	r22, 0x41	; 65
     65c:	82 e0       	ldi	r24, 0x02	; 2
     65e:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  DIO_write(LCD_DATA_PIN7, LCD_DATA_PORT, read_bit(data, 3));
     662:	c3 fb       	bst	r28, 3
     664:	44 27       	eor	r20, r20
     666:	40 f9       	bld	r20, 0
     668:	61 e4       	ldi	r22, 0x41	; 65
     66a:	83 e0       	ldi	r24, 0x03	; 3
     66c:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  }
     670:	cf 91       	pop	r28
     672:	08 95       	ret

00000674 <LCD_sendData>:

void LCD_sendData(u8 data) {
     674:	cf 93       	push	r28
     676:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(data >> 4);
     678:	82 95       	swap	r24
     67a:	8f 70       	andi	r24, 0x0F	; 15
     67c:	0e 94 1b 03 	call	0x636	; 0x636 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, HIGH); // To indicate that this data
     680:	41 e0       	ldi	r20, 0x01	; 1
     682:	61 e4       	ldi	r22, 0x41	; 65
     684:	84 e0       	ldi	r24, 0x04	; 4
     686:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>

  LCD_sendEnablePulse();
     68a:	0e 94 0c 03 	call	0x618	; 0x618 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the data to be sent

  LCD_write_4bits(data);
     68e:	8c 2f       	mov	r24, r28
     690:	0e 94 1b 03 	call	0x636	; 0x636 <LCD_write_4bits>

  LCD_sendEnablePulse();
     694:	0e 94 0c 03 	call	0x618	; 0x618 <LCD_sendEnablePulse>
     698:	85 e0       	ldi	r24, 0x05	; 5
     69a:	8a 95       	dec	r24
     69c:	f1 f7       	brne	.-4      	; 0x69a <LCD_sendData+0x26>
     69e:	00 00       	nop

  _delay_us(1); // wait for the data to be processed
#else

#endif
  }
     6a0:	cf 91       	pop	r28
     6a2:	08 95       	ret

000006a4 <LCD_sendCommand>:

void LCD_sendCommand(u8 cmd) {
     6a4:	cf 93       	push	r28
     6a6:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(cmd >> 4);
     6a8:	82 95       	swap	r24
     6aa:	8f 70       	andi	r24, 0x0F	; 15
     6ac:	0e 94 1b 03 	call	0x636	; 0x636 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, LOW); // To indicate that this a command
     6b0:	40 e0       	ldi	r20, 0x00	; 0
     6b2:	61 e4       	ldi	r22, 0x41	; 65
     6b4:	84 e0       	ldi	r24, 0x04	; 4
     6b6:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>

  LCD_sendEnablePulse();
     6ba:	0e 94 0c 03 	call	0x618	; 0x618 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the command to be sent

  LCD_write_4bits(cmd);
     6be:	8c 2f       	mov	r24, r28
     6c0:	0e 94 1b 03 	call	0x636	; 0x636 <LCD_write_4bits>

  LCD_sendEnablePulse();
     6c4:	0e 94 0c 03 	call	0x618	; 0x618 <LCD_sendEnablePulse>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6c8:	8f ed       	ldi	r24, 0xDF	; 223
     6ca:	9e e2       	ldi	r25, 0x2E	; 46
     6cc:	01 97       	sbiw	r24, 0x01	; 1
     6ce:	f1 f7       	brne	.-4      	; 0x6cc <LCD_sendCommand+0x28>
     6d0:	00 c0       	rjmp	.+0      	; 0x6d2 <LCD_sendCommand+0x2e>
     6d2:	00 00       	nop

  _delay_ms(3); // wait for the command to be executed
#else

#endif
  }
     6d4:	cf 91       	pop	r28
     6d6:	08 95       	ret

000006d8 <LCD_clear_screen>:

void LCD_clear_screen() {
  LCD_sendCommand(0x01);
     6d8:	81 e0       	ldi	r24, 0x01	; 1
     6da:	0e 94 52 03 	call	0x6a4	; 0x6a4 <LCD_sendCommand>
     6de:	08 95       	ret

000006e0 <LCD_init>:
     6e0:	2f ef       	ldi	r18, 0xFF	; 255
     6e2:	89 ef       	ldi	r24, 0xF9	; 249
     6e4:	90 e0       	ldi	r25, 0x00	; 0
     6e6:	21 50       	subi	r18, 0x01	; 1
     6e8:	80 40       	sbci	r24, 0x00	; 0
     6ea:	90 40       	sbci	r25, 0x00	; 0
     6ec:	e1 f7       	brne	.-8      	; 0x6e6 <LCD_init+0x6>
     6ee:	00 c0       	rjmp	.+0      	; 0x6f0 <LCD_init+0x10>
     6f0:	00 00       	nop

void LCD_init(void) {
  _delay_ms(20); // wait for the LCD to start up.

#if LCD_MODE == FOUR_BIT_MODE
  DIO_init(LCD_DATA_PIN4, LCD_DATA_PORT, OUT);
     6f2:	41 e0       	ldi	r20, 0x01	; 1
     6f4:	61 e4       	ldi	r22, 0x41	; 65
     6f6:	80 e0       	ldi	r24, 0x00	; 0
     6f8:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  DIO_init(LCD_DATA_PIN5, LCD_DATA_PORT, OUT);
     6fc:	41 e0       	ldi	r20, 0x01	; 1
     6fe:	61 e4       	ldi	r22, 0x41	; 65
     700:	81 e0       	ldi	r24, 0x01	; 1
     702:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  DIO_init(LCD_DATA_PIN6, LCD_DATA_PORT, OUT);
     706:	41 e0       	ldi	r20, 0x01	; 1
     708:	61 e4       	ldi	r22, 0x41	; 65
     70a:	82 e0       	ldi	r24, 0x02	; 2
     70c:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  DIO_init(LCD_DATA_PIN7, LCD_DATA_PORT, OUT);
     710:	41 e0       	ldi	r20, 0x01	; 1
     712:	61 e4       	ldi	r22, 0x41	; 65
     714:	83 e0       	ldi	r24, 0x03	; 3
     716:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>

  DIO_init(RS, LCD_CTRL_PORT, OUT);
     71a:	41 e0       	ldi	r20, 0x01	; 1
     71c:	61 e4       	ldi	r22, 0x41	; 65
     71e:	84 e0       	ldi	r24, 0x04	; 4
     720:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  DIO_init(RW, LCD_CTRL_PORT, OUT);
     724:	41 e0       	ldi	r20, 0x01	; 1
     726:	61 e4       	ldi	r22, 0x41	; 65
     728:	85 e0       	ldi	r24, 0x05	; 5
     72a:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  DIO_init(EN, LCD_CTRL_PORT, OUT);
     72e:	41 e0       	ldi	r20, 0x01	; 1
     730:	61 e4       	ldi	r22, 0x41	; 65
     732:	86 e0       	ldi	r24, 0x06	; 6
     734:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>

  DIO_write(RW, LCD_CTRL_PORT, LOW);
     738:	40 e0       	ldi	r20, 0x00	; 0
     73a:	61 e4       	ldi	r22, 0x41	; 65
     73c:	85 e0       	ldi	r24, 0x05	; 5
     73e:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>

  LCD_sendCommand(0x02);  // return home 
     742:	82 e0       	ldi	r24, 0x02	; 2
     744:	0e 94 52 03 	call	0x6a4	; 0x6a4 <LCD_sendCommand>
  LCD_sendCommand(0x28);  // 2 line  and 4 bit mode
     748:	88 e2       	ldi	r24, 0x28	; 40
     74a:	0e 94 52 03 	call	0x6a4	; 0x6a4 <LCD_sendCommand>
  LCD_sendCommand(0x0C);  // display on 
     74e:	8c e0       	ldi	r24, 0x0C	; 12
     750:	0e 94 52 03 	call	0x6a4	; 0x6a4 <LCD_sendCommand>
  LCD_sendCommand(0x06);  // auto increment 
     754:	86 e0       	ldi	r24, 0x06	; 6
     756:	0e 94 52 03 	call	0x6a4	; 0x6a4 <LCD_sendCommand>
  LCD_clear_screen();
     75a:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
     75e:	08 95       	ret

00000760 <LCD_write_string>:
#else

#endif
  }

void LCD_write_string(s8* str) {
     760:	cf 92       	push	r12
     762:	df 92       	push	r13
     764:	ef 92       	push	r14
     766:	ff 92       	push	r15
     768:	cf 93       	push	r28
     76a:	df 93       	push	r29
     76c:	ec 01       	movw	r28, r24
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     76e:	c1 2c       	mov	r12, r1
     770:	d1 2c       	mov	r13, r1
     772:	76 01       	movw	r14, r12
     774:	07 c0       	rjmp	.+14     	; 0x784 <LCD_write_string+0x24>
    LCD_sendData(str[i]);
     776:	0e 94 3a 03 	call	0x674	; 0x674 <LCD_sendData>
#endif
  }

void LCD_write_string(s8* str) {
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     77a:	8f ef       	ldi	r24, 0xFF	; 255
     77c:	c8 1a       	sub	r12, r24
     77e:	d8 0a       	sbc	r13, r24
     780:	e8 0a       	sbc	r14, r24
     782:	f8 0a       	sbc	r15, r24
     784:	fe 01       	movw	r30, r28
     786:	ec 0d       	add	r30, r12
     788:	fd 1d       	adc	r31, r13
     78a:	80 81       	ld	r24, Z
     78c:	81 11       	cpse	r24, r1
     78e:	f3 cf       	rjmp	.-26     	; 0x776 <LCD_write_string+0x16>
    LCD_sendData(str[i]);
    }
  }
     790:	df 91       	pop	r29
     792:	cf 91       	pop	r28
     794:	ff 90       	pop	r15
     796:	ef 90       	pop	r14
     798:	df 90       	pop	r13
     79a:	cf 90       	pop	r12
     79c:	08 95       	ret

0000079e <LCD_move_cursor_xy>:

void LCD_move_cursor_xy(u8 x, u8 y) {
  switch (y) {
     79e:	66 23       	and	r22, r22
     7a0:	19 f0       	breq	.+6      	; 0x7a8 <LCD_move_cursor_xy+0xa>
     7a2:	61 30       	cpi	r22, 0x01	; 1
     7a4:	29 f0       	breq	.+10     	; 0x7b0 <LCD_move_cursor_xy+0x12>
     7a6:	08 95       	ret
      case 0:
        LCD_sendCommand(0x80 + x);
     7a8:	80 58       	subi	r24, 0x80	; 128
     7aa:	0e 94 52 03 	call	0x6a4	; 0x6a4 <LCD_sendCommand>
        break;
     7ae:	08 95       	ret
      case 1:
        LCD_sendCommand(0xC0 + x);
     7b0:	80 54       	subi	r24, 0x40	; 64
     7b2:	0e 94 52 03 	call	0x6a4	; 0x6a4 <LCD_sendCommand>
     7b6:	08 95       	ret

000007b8 <LCD_write_string_xy>:
        break;
    }
  }

void LCD_write_string_xy(u8 x, u8 y, s8* str) {
     7b8:	cf 93       	push	r28
     7ba:	df 93       	push	r29
     7bc:	ea 01       	movw	r28, r20
  LCD_move_cursor_xy(x, y);
     7be:	0e 94 cf 03 	call	0x79e	; 0x79e <LCD_move_cursor_xy>
  LCD_write_string(str);
     7c2:	ce 01       	movw	r24, r28
     7c4:	0e 94 b0 03 	call	0x760	; 0x760 <LCD_write_string>
  // TODO: Input validation
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	08 95       	ret

000007ce <LED_init>:
 */

#include "led.h"

 // Initialize the LED
EN_ledError_t LED_init(u8 ledPort, u8 ledPin) {
     7ce:	98 2f       	mov	r25, r24
     7d0:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(ledPin, ledPort, OUT) == DIO_OK) {
     7d2:	41 e0       	ldi	r20, 0x01	; 1
     7d4:	69 2f       	mov	r22, r25
     7d6:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
     7da:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that the led initialization failed
  return LED_ERROR_INIT;
     7dc:	81 e0       	ldi	r24, 0x01	; 1
  }
     7de:	08 95       	ret

000007e0 <LED_on>:

// Turn on the LED
EN_ledError_t LED_on(u8 ledPort, u8 ledPin) {
     7e0:	98 2f       	mov	r25, r24
     7e2:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, HIGH) == DIO_OK) {
     7e4:	41 e0       	ldi	r20, 0x01	; 1
     7e6:	69 2f       	mov	r22, r25
     7e8:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
     7ec:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn on the led has failed
  return LED_ERROR_ON;
     7ee:	82 e0       	ldi	r24, 0x02	; 2
  }
     7f0:	08 95       	ret

000007f2 <LED_off>:

// Turn off the LED
EN_ledError_t LED_off(u8 ledPort, u8 ledPin) {
     7f2:	98 2f       	mov	r25, r24
     7f4:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, LOW) == DIO_OK) {
     7f6:	40 e0       	ldi	r20, 0x00	; 0
     7f8:	69 2f       	mov	r22, r25
     7fa:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
     7fe:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn off the led has failed
  return LED_ERROR_OFF;
     800:	83 e0       	ldi	r24, 0x03	; 3
  }
     802:	08 95       	ret

00000804 <LED_toggle>:

// Toggle the LED
EN_ledError_t LED_toggle(u8 ledPort, u8 ledPin) {
     804:	98 2f       	mov	r25, r24
     806:	86 2f       	mov	r24, r22
  if (DIO_toggle(ledPin, ledPort) == DIO_OK) {
     808:	69 2f       	mov	r22, r25
     80a:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <DIO_toggle>
     80e:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to toggle the led has failed
  return LED_ERROR_TOGGLE;
     810:	84 e0       	ldi	r24, 0x04	; 4
     812:	08 95       	ret

00000814 <Servo_init>:

#include "servo.h"

 // Initialized the servo
void Servo_init() {
  DIO_init(SERVO_PIN, SERVO_PORT, OUT);
     814:	41 e0       	ldi	r20, 0x01	; 1
     816:	64 e4       	ldi	r22, 0x44	; 68
     818:	85 e0       	ldi	r24, 0x05	; 5
     81a:	0e 94 58 04 	call	0x8b0	; 0x8b0 <DIO_init>
  PWM_init(SERVO_PWM_PIN, (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS), PWM_PHASE_CORRECT);
     81e:	22 e0       	ldi	r18, 0x02	; 2
     820:	4d ec       	ldi	r20, 0xCD	; 205
     822:	5c ec       	ldi	r21, 0xCC	; 204
     824:	6c ec       	ldi	r22, 0xCC	; 204
     826:	7c e3       	ldi	r23, 0x3C	; 60
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	0e 94 87 08 	call	0x110e	; 0x110e <PWM_init>
  Timer_start(TIMER_1, 8);
     82e:	68 e0       	ldi	r22, 0x08	; 8
     830:	70 e0       	ldi	r23, 0x00	; 0
     832:	81 e0       	ldi	r24, 0x01	; 1
     834:	0e 94 17 08 	call	0x102e	; 0x102e <Timer_start>
     838:	08 95       	ret

0000083a <Servo_move_to_angle>:
  }

// Moves the servo to a specific angle (relative to the 0 angle position, not the previous one).
void Servo_move_to_angle(u8 angle) {
  PWM_set_DC(SERVO_PWM_PIN, ((double)angle / ((SERVO_MAX_ANGLE - SERVO_MIN_ANGLE) * (SERVO_PULSE_PERIODIC_TIME_mS / (SERVO_MAX_HIGH_PULSE_DURATION_mS - SERVO_MIN_HIGH_PULSE_DURATION_mS)))) + (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS));
     83a:	68 2f       	mov	r22, r24
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	80 e0       	ldi	r24, 0x00	; 0
     840:	90 e0       	ldi	r25, 0x00	; 0
     842:	0e 94 05 16 	call	0x2c0a	; 0x2c0a <__floatunsisf>
     846:	20 e0       	ldi	r18, 0x00	; 0
     848:	30 e0       	ldi	r19, 0x00	; 0
     84a:	41 ee       	ldi	r20, 0xE1	; 225
     84c:	54 e4       	ldi	r21, 0x44	; 68
     84e:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__divsf3>
     852:	2d ec       	ldi	r18, 0xCD	; 205
     854:	3c ec       	ldi	r19, 0xCC	; 204
     856:	4c ec       	ldi	r20, 0xCC	; 204
     858:	5c e3       	ldi	r21, 0x3C	; 60
     85a:	0e 94 f1 14 	call	0x29e2	; 0x29e2 <__addsf3>
     85e:	ab 01       	movw	r20, r22
     860:	bc 01       	movw	r22, r24
     862:	81 e0       	ldi	r24, 0x01	; 1
     864:	0e 94 2e 09 	call	0x125c	; 0x125c <PWM_set_DC>
     868:	08 95       	ret

0000086a <main>:
#include "Application/app.h"
// #include "Services/Local_access/local.h"

int main(void) {
	// Remote_init(9600);
	Lamps_init();
     86a:	0e 94 a2 09 	call	0x1344	; 0x1344 <Lamps_init>
	Door_init();
     86e:	0e 94 94 09 	call	0x1328	; 0x1328 <Door_init>
	Local_access_init();
     872:	0e 94 55 0a 	call	0x14aa	; 0x14aa <Local_access_init>
	// App_init();
	sei();
     876:	78 94       	sei
	// App_start();
	
	while (1) {
		Local_control_input_handler();
     878:	0e 94 38 0c 	call	0x1870	; 0x1870 <Local_control_input_handler>
     87c:	fd cf       	rjmp	.-6      	; 0x878 <main+0xe>

0000087e <isValidPinNumber>:
 */

#include "dio.h"

bool isValidPinNumber(u8 pinNumber) {
	if (pinNumber < 8) {
     87e:	88 30       	cpi	r24, 0x08	; 8
     880:	10 f4       	brcc	.+4      	; 0x886 <isValidPinNumber+0x8>
		return true;
     882:	81 e0       	ldi	r24, 0x01	; 1
     884:	08 95       	ret
		}
	return false;
     886:	80 e0       	ldi	r24, 0x00	; 0
	}
     888:	08 95       	ret

0000088a <isValidPortNumber>:

bool isValidPortNumber(u8 portNumber) {
	if (portNumber == PORT_A || portNumber == PORT_B || portNumber == PORT_C || portNumber == PORT_D) {
     88a:	81 54       	subi	r24, 0x41	; 65
     88c:	84 30       	cpi	r24, 0x04	; 4
     88e:	10 f4       	brcc	.+4      	; 0x894 <isValidPortNumber+0xa>
		return true;
     890:	81 e0       	ldi	r24, 0x01	; 1
     892:	08 95       	ret
		}
	return false;
     894:	80 e0       	ldi	r24, 0x00	; 0
	}
     896:	08 95       	ret

00000898 <isValidDirection>:

bool isValidDirection(u8 direction) {
	if (direction == IN || direction == OUT) {
     898:	82 30       	cpi	r24, 0x02	; 2
     89a:	10 f4       	brcc	.+4      	; 0x8a0 <isValidDirection+0x8>
		return true;
     89c:	81 e0       	ldi	r24, 0x01	; 1
     89e:	08 95       	ret
		}
	return false;
     8a0:	80 e0       	ldi	r24, 0x00	; 0
	}
     8a2:	08 95       	ret

000008a4 <isValidState>:

bool isValidState(u8 state) {
	if (state == HIGH || state == LOW) {
     8a4:	82 30       	cpi	r24, 0x02	; 2
     8a6:	10 f4       	brcc	.+4      	; 0x8ac <isValidState+0x8>
		return true;
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	08 95       	ret
		}
	return false;
     8ac:	80 e0       	ldi	r24, 0x00	; 0
	}
     8ae:	08 95       	ret

000008b0 <DIO_init>:

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
     8b0:	1f 93       	push	r17
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	c8 2f       	mov	r28, r24
     8b8:	d6 2f       	mov	r29, r22
     8ba:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     8bc:	0e 94 3f 04 	call	0x87e	; 0x87e <isValidPinNumber>
     8c0:	88 23       	and	r24, r24
     8c2:	09 f4       	brne	.+2      	; 0x8c6 <DIO_init+0x16>
     8c4:	84 c0       	rjmp	.+264    	; 0x9ce <DIO_init+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     8c6:	8d 2f       	mov	r24, r29
     8c8:	0e 94 45 04 	call	0x88a	; 0x88a <isValidPortNumber>
     8cc:	88 23       	and	r24, r24
     8ce:	09 f4       	brne	.+2      	; 0x8d2 <DIO_init+0x22>
     8d0:	80 c0       	rjmp	.+256    	; 0x9d2 <DIO_init+0x122>
		return WRONG_PORT;
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
     8d2:	81 2f       	mov	r24, r17
     8d4:	0e 94 4c 04 	call	0x898	; 0x898 <isValidDirection>
     8d8:	88 23       	and	r24, r24
     8da:	09 f4       	brne	.+2      	; 0x8de <DIO_init+0x2e>
     8dc:	7c c0       	rjmp	.+248    	; 0x9d6 <DIO_init+0x126>
		return WRONG_DIRECTION;
		}
	switch (portNumber) {
     8de:	d2 34       	cpi	r29, 0x42	; 66
     8e0:	29 f1       	breq	.+74     	; 0x92c <DIO_init+0x7c>
     8e2:	18 f4       	brcc	.+6      	; 0x8ea <DIO_init+0x3a>
     8e4:	d1 34       	cpi	r29, 0x41	; 65
     8e6:	39 f0       	breq	.+14     	; 0x8f6 <DIO_init+0x46>
     8e8:	78 c0       	rjmp	.+240    	; 0x9da <DIO_init+0x12a>
     8ea:	d3 34       	cpi	r29, 0x43	; 67
     8ec:	d1 f1       	breq	.+116    	; 0x962 <DIO_init+0xb2>
     8ee:	d4 34       	cpi	r29, 0x44	; 68
     8f0:	09 f4       	brne	.+2      	; 0x8f4 <DIO_init+0x44>
     8f2:	52 c0       	rjmp	.+164    	; 0x998 <DIO_init+0xe8>
     8f4:	72 c0       	rjmp	.+228    	; 0x9da <DIO_init+0x12a>
			case PORT_A:
				if (direction == OUT) {
     8f6:	11 30       	cpi	r17, 0x01	; 1
     8f8:	61 f4       	brne	.+24     	; 0x912 <DIO_init+0x62>
					set_bit(DDRA, pinNumber);
     8fa:	2a b3       	in	r18, 0x1a	; 26
     8fc:	81 e0       	ldi	r24, 0x01	; 1
     8fe:	90 e0       	ldi	r25, 0x00	; 0
     900:	02 c0       	rjmp	.+4      	; 0x906 <DIO_init+0x56>
     902:	88 0f       	add	r24, r24
     904:	99 1f       	adc	r25, r25
     906:	ca 95       	dec	r28
     908:	e2 f7       	brpl	.-8      	; 0x902 <DIO_init+0x52>
     90a:	82 2b       	or	r24, r18
     90c:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     90e:	80 e0       	ldi	r24, 0x00	; 0
     910:	65 c0       	rjmp	.+202    	; 0x9dc <DIO_init+0x12c>
			case PORT_A:
				if (direction == OUT) {
					set_bit(DDRA, pinNumber);
					}
				else {
					clear_bit(DDRA, pinNumber);
     912:	2a b3       	in	r18, 0x1a	; 26
     914:	81 e0       	ldi	r24, 0x01	; 1
     916:	90 e0       	ldi	r25, 0x00	; 0
     918:	02 c0       	rjmp	.+4      	; 0x91e <DIO_init+0x6e>
     91a:	88 0f       	add	r24, r24
     91c:	99 1f       	adc	r25, r25
     91e:	ca 95       	dec	r28
     920:	e2 f7       	brpl	.-8      	; 0x91a <DIO_init+0x6a>
     922:	80 95       	com	r24
     924:	82 23       	and	r24, r18
     926:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     928:	80 e0       	ldi	r24, 0x00	; 0
     92a:	58 c0       	rjmp	.+176    	; 0x9dc <DIO_init+0x12c>
				else {
					clear_bit(DDRA, pinNumber);
					}
				break;
			case PORT_B:
				if (direction == OUT) {
     92c:	11 30       	cpi	r17, 0x01	; 1
     92e:	61 f4       	brne	.+24     	; 0x948 <DIO_init+0x98>
					set_bit(DDRB, pinNumber);
     930:	27 b3       	in	r18, 0x17	; 23
     932:	81 e0       	ldi	r24, 0x01	; 1
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	02 c0       	rjmp	.+4      	; 0x93c <DIO_init+0x8c>
     938:	88 0f       	add	r24, r24
     93a:	99 1f       	adc	r25, r25
     93c:	ca 95       	dec	r28
     93e:	e2 f7       	brpl	.-8      	; 0x938 <DIO_init+0x88>
     940:	82 2b       	or	r24, r18
     942:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     944:	80 e0       	ldi	r24, 0x00	; 0
     946:	4a c0       	rjmp	.+148    	; 0x9dc <DIO_init+0x12c>
			case PORT_B:
				if (direction == OUT) {
					set_bit(DDRB, pinNumber);
					}
				else {
					clear_bit(DDRB, pinNumber);
     948:	27 b3       	in	r18, 0x17	; 23
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	90 e0       	ldi	r25, 0x00	; 0
     94e:	02 c0       	rjmp	.+4      	; 0x954 <DIO_init+0xa4>
     950:	88 0f       	add	r24, r24
     952:	99 1f       	adc	r25, r25
     954:	ca 95       	dec	r28
     956:	e2 f7       	brpl	.-8      	; 0x950 <DIO_init+0xa0>
     958:	80 95       	com	r24
     95a:	82 23       	and	r24, r18
     95c:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     95e:	80 e0       	ldi	r24, 0x00	; 0
     960:	3d c0       	rjmp	.+122    	; 0x9dc <DIO_init+0x12c>
				else {
					clear_bit(DDRB, pinNumber);
					}
				break;
			case PORT_C:
				if (direction == OUT) {
     962:	11 30       	cpi	r17, 0x01	; 1
     964:	61 f4       	brne	.+24     	; 0x97e <DIO_init+0xce>
					set_bit(DDRC, pinNumber);
     966:	24 b3       	in	r18, 0x14	; 20
     968:	81 e0       	ldi	r24, 0x01	; 1
     96a:	90 e0       	ldi	r25, 0x00	; 0
     96c:	02 c0       	rjmp	.+4      	; 0x972 <DIO_init+0xc2>
     96e:	88 0f       	add	r24, r24
     970:	99 1f       	adc	r25, r25
     972:	ca 95       	dec	r28
     974:	e2 f7       	brpl	.-8      	; 0x96e <DIO_init+0xbe>
     976:	82 2b       	or	r24, r18
     978:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     97a:	80 e0       	ldi	r24, 0x00	; 0
     97c:	2f c0       	rjmp	.+94     	; 0x9dc <DIO_init+0x12c>
			case PORT_C:
				if (direction == OUT) {
					set_bit(DDRC, pinNumber);
					}
				else {
					clear_bit(DDRC, pinNumber);
     97e:	24 b3       	in	r18, 0x14	; 20
     980:	81 e0       	ldi	r24, 0x01	; 1
     982:	90 e0       	ldi	r25, 0x00	; 0
     984:	02 c0       	rjmp	.+4      	; 0x98a <DIO_init+0xda>
     986:	88 0f       	add	r24, r24
     988:	99 1f       	adc	r25, r25
     98a:	ca 95       	dec	r28
     98c:	e2 f7       	brpl	.-8      	; 0x986 <DIO_init+0xd6>
     98e:	80 95       	com	r24
     990:	82 23       	and	r24, r18
     992:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     994:	80 e0       	ldi	r24, 0x00	; 0
     996:	22 c0       	rjmp	.+68     	; 0x9dc <DIO_init+0x12c>
				else {
					clear_bit(DDRC, pinNumber);
					}
				break;
			case PORT_D:
				if (direction == OUT) {
     998:	11 30       	cpi	r17, 0x01	; 1
     99a:	61 f4       	brne	.+24     	; 0x9b4 <DIO_init+0x104>
					set_bit(DDRD, pinNumber);
     99c:	21 b3       	in	r18, 0x11	; 17
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	90 e0       	ldi	r25, 0x00	; 0
     9a2:	02 c0       	rjmp	.+4      	; 0x9a8 <DIO_init+0xf8>
     9a4:	88 0f       	add	r24, r24
     9a6:	99 1f       	adc	r25, r25
     9a8:	ca 95       	dec	r28
     9aa:	e2 f7       	brpl	.-8      	; 0x9a4 <DIO_init+0xf4>
     9ac:	82 2b       	or	r24, r18
     9ae:	81 bb       	out	0x11, r24	; 17
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     9b0:	80 e0       	ldi	r24, 0x00	; 0
     9b2:	14 c0       	rjmp	.+40     	; 0x9dc <DIO_init+0x12c>
			case PORT_D:
				if (direction == OUT) {
					set_bit(DDRD, pinNumber);
					}
				else {
					clear_bit(DDRD, pinNumber);
     9b4:	21 b3       	in	r18, 0x11	; 17
     9b6:	81 e0       	ldi	r24, 0x01	; 1
     9b8:	90 e0       	ldi	r25, 0x00	; 0
     9ba:	02 c0       	rjmp	.+4      	; 0x9c0 <DIO_init+0x110>
     9bc:	88 0f       	add	r24, r24
     9be:	99 1f       	adc	r25, r25
     9c0:	ca 95       	dec	r28
     9c2:	e2 f7       	brpl	.-8      	; 0x9bc <DIO_init+0x10c>
     9c4:	80 95       	com	r24
     9c6:	82 23       	and	r24, r18
     9c8:	81 bb       	out	0x11, r24	; 17
					}
				break;
		}
	return DIO_OK;
     9ca:	80 e0       	ldi	r24, 0x00	; 0
     9cc:	07 c0       	rjmp	.+14     	; 0x9dc <DIO_init+0x12c>

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     9ce:	81 e0       	ldi	r24, 0x01	; 1
     9d0:	05 c0       	rjmp	.+10     	; 0x9dc <DIO_init+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     9d2:	82 e0       	ldi	r24, 0x02	; 2
     9d4:	03 c0       	rjmp	.+6      	; 0x9dc <DIO_init+0x12c>
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
		return WRONG_DIRECTION;
     9d6:	83 e0       	ldi	r24, 0x03	; 3
     9d8:	01 c0       	rjmp	.+2      	; 0x9dc <DIO_init+0x12c>
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     9da:	80 e0       	ldi	r24, 0x00	; 0
	}
     9dc:	df 91       	pop	r29
     9de:	cf 91       	pop	r28
     9e0:	1f 91       	pop	r17
     9e2:	08 95       	ret

000009e4 <DIO_write>:

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
     9e4:	1f 93       	push	r17
     9e6:	cf 93       	push	r28
     9e8:	df 93       	push	r29
     9ea:	c8 2f       	mov	r28, r24
     9ec:	d6 2f       	mov	r29, r22
     9ee:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     9f0:	0e 94 3f 04 	call	0x87e	; 0x87e <isValidPinNumber>
     9f4:	88 23       	and	r24, r24
     9f6:	09 f4       	brne	.+2      	; 0x9fa <DIO_write+0x16>
     9f8:	84 c0       	rjmp	.+264    	; 0xb02 <DIO_write+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     9fa:	8d 2f       	mov	r24, r29
     9fc:	0e 94 45 04 	call	0x88a	; 0x88a <isValidPortNumber>
     a00:	88 23       	and	r24, r24
     a02:	09 f4       	brne	.+2      	; 0xa06 <DIO_write+0x22>
     a04:	80 c0       	rjmp	.+256    	; 0xb06 <DIO_write+0x122>
		return WRONG_PORT;
		}
	// Validate the pin state
	if (!isValidState(state)) {
     a06:	81 2f       	mov	r24, r17
     a08:	0e 94 52 04 	call	0x8a4	; 0x8a4 <isValidState>
     a0c:	88 23       	and	r24, r24
     a0e:	09 f4       	brne	.+2      	; 0xa12 <DIO_write+0x2e>
     a10:	7c c0       	rjmp	.+248    	; 0xb0a <DIO_write+0x126>
		return WRONG_STATE;
		}
	switch (portNumber) {
     a12:	d2 34       	cpi	r29, 0x42	; 66
     a14:	29 f1       	breq	.+74     	; 0xa60 <DIO_write+0x7c>
     a16:	18 f4       	brcc	.+6      	; 0xa1e <DIO_write+0x3a>
     a18:	d1 34       	cpi	r29, 0x41	; 65
     a1a:	39 f0       	breq	.+14     	; 0xa2a <DIO_write+0x46>
     a1c:	78 c0       	rjmp	.+240    	; 0xb0e <DIO_write+0x12a>
     a1e:	d3 34       	cpi	r29, 0x43	; 67
     a20:	d1 f1       	breq	.+116    	; 0xa96 <DIO_write+0xb2>
     a22:	d4 34       	cpi	r29, 0x44	; 68
     a24:	09 f4       	brne	.+2      	; 0xa28 <DIO_write+0x44>
     a26:	52 c0       	rjmp	.+164    	; 0xacc <DIO_write+0xe8>
     a28:	72 c0       	rjmp	.+228    	; 0xb0e <DIO_write+0x12a>
			case PORT_A:
				if (state == HIGH) {
     a2a:	11 30       	cpi	r17, 0x01	; 1
     a2c:	61 f4       	brne	.+24     	; 0xa46 <DIO_write+0x62>
					set_bit(PORTA, pinNumber);
     a2e:	2b b3       	in	r18, 0x1b	; 27
     a30:	81 e0       	ldi	r24, 0x01	; 1
     a32:	90 e0       	ldi	r25, 0x00	; 0
     a34:	02 c0       	rjmp	.+4      	; 0xa3a <DIO_write+0x56>
     a36:	88 0f       	add	r24, r24
     a38:	99 1f       	adc	r25, r25
     a3a:	ca 95       	dec	r28
     a3c:	e2 f7       	brpl	.-8      	; 0xa36 <DIO_write+0x52>
     a3e:	82 2b       	or	r24, r18
     a40:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a42:	80 e0       	ldi	r24, 0x00	; 0
     a44:	65 c0       	rjmp	.+202    	; 0xb10 <DIO_write+0x12c>
			case PORT_A:
				if (state == HIGH) {
					set_bit(PORTA, pinNumber);
					}
				else {
					clear_bit(PORTA, pinNumber);
     a46:	2b b3       	in	r18, 0x1b	; 27
     a48:	81 e0       	ldi	r24, 0x01	; 1
     a4a:	90 e0       	ldi	r25, 0x00	; 0
     a4c:	02 c0       	rjmp	.+4      	; 0xa52 <DIO_write+0x6e>
     a4e:	88 0f       	add	r24, r24
     a50:	99 1f       	adc	r25, r25
     a52:	ca 95       	dec	r28
     a54:	e2 f7       	brpl	.-8      	; 0xa4e <DIO_write+0x6a>
     a56:	80 95       	com	r24
     a58:	82 23       	and	r24, r18
     a5a:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	58 c0       	rjmp	.+176    	; 0xb10 <DIO_write+0x12c>
				else {
					clear_bit(PORTA, pinNumber);
					}
				break;
			case PORT_B:
				if (state == HIGH) {
     a60:	11 30       	cpi	r17, 0x01	; 1
     a62:	61 f4       	brne	.+24     	; 0xa7c <DIO_write+0x98>
					set_bit(PORTB, pinNumber);
     a64:	28 b3       	in	r18, 0x18	; 24
     a66:	81 e0       	ldi	r24, 0x01	; 1
     a68:	90 e0       	ldi	r25, 0x00	; 0
     a6a:	02 c0       	rjmp	.+4      	; 0xa70 <DIO_write+0x8c>
     a6c:	88 0f       	add	r24, r24
     a6e:	99 1f       	adc	r25, r25
     a70:	ca 95       	dec	r28
     a72:	e2 f7       	brpl	.-8      	; 0xa6c <DIO_write+0x88>
     a74:	82 2b       	or	r24, r18
     a76:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a78:	80 e0       	ldi	r24, 0x00	; 0
     a7a:	4a c0       	rjmp	.+148    	; 0xb10 <DIO_write+0x12c>
			case PORT_B:
				if (state == HIGH) {
					set_bit(PORTB, pinNumber);
					}
				else {
					clear_bit(PORTB, pinNumber);
     a7c:	28 b3       	in	r18, 0x18	; 24
     a7e:	81 e0       	ldi	r24, 0x01	; 1
     a80:	90 e0       	ldi	r25, 0x00	; 0
     a82:	02 c0       	rjmp	.+4      	; 0xa88 <DIO_write+0xa4>
     a84:	88 0f       	add	r24, r24
     a86:	99 1f       	adc	r25, r25
     a88:	ca 95       	dec	r28
     a8a:	e2 f7       	brpl	.-8      	; 0xa84 <DIO_write+0xa0>
     a8c:	80 95       	com	r24
     a8e:	82 23       	and	r24, r18
     a90:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a92:	80 e0       	ldi	r24, 0x00	; 0
     a94:	3d c0       	rjmp	.+122    	; 0xb10 <DIO_write+0x12c>
				else {
					clear_bit(PORTB, pinNumber);
					}
				break;
			case PORT_C:
				if (state == HIGH) {
     a96:	11 30       	cpi	r17, 0x01	; 1
     a98:	61 f4       	brne	.+24     	; 0xab2 <DIO_write+0xce>
					set_bit(PORTC, pinNumber);
     a9a:	25 b3       	in	r18, 0x15	; 21
     a9c:	81 e0       	ldi	r24, 0x01	; 1
     a9e:	90 e0       	ldi	r25, 0x00	; 0
     aa0:	02 c0       	rjmp	.+4      	; 0xaa6 <DIO_write+0xc2>
     aa2:	88 0f       	add	r24, r24
     aa4:	99 1f       	adc	r25, r25
     aa6:	ca 95       	dec	r28
     aa8:	e2 f7       	brpl	.-8      	; 0xaa2 <DIO_write+0xbe>
     aaa:	82 2b       	or	r24, r18
     aac:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     aae:	80 e0       	ldi	r24, 0x00	; 0
     ab0:	2f c0       	rjmp	.+94     	; 0xb10 <DIO_write+0x12c>
			case PORT_C:
				if (state == HIGH) {
					set_bit(PORTC, pinNumber);
					}
				else {
					clear_bit(PORTC, pinNumber);
     ab2:	25 b3       	in	r18, 0x15	; 21
     ab4:	81 e0       	ldi	r24, 0x01	; 1
     ab6:	90 e0       	ldi	r25, 0x00	; 0
     ab8:	02 c0       	rjmp	.+4      	; 0xabe <DIO_write+0xda>
     aba:	88 0f       	add	r24, r24
     abc:	99 1f       	adc	r25, r25
     abe:	ca 95       	dec	r28
     ac0:	e2 f7       	brpl	.-8      	; 0xaba <DIO_write+0xd6>
     ac2:	80 95       	com	r24
     ac4:	82 23       	and	r24, r18
     ac6:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     ac8:	80 e0       	ldi	r24, 0x00	; 0
     aca:	22 c0       	rjmp	.+68     	; 0xb10 <DIO_write+0x12c>
				else {
					clear_bit(PORTC, pinNumber);
					}
				break;
			case PORT_D:
				if (state == HIGH) {
     acc:	11 30       	cpi	r17, 0x01	; 1
     ace:	61 f4       	brne	.+24     	; 0xae8 <DIO_write+0x104>
					set_bit(PORTD, pinNumber);
     ad0:	22 b3       	in	r18, 0x12	; 18
     ad2:	81 e0       	ldi	r24, 0x01	; 1
     ad4:	90 e0       	ldi	r25, 0x00	; 0
     ad6:	02 c0       	rjmp	.+4      	; 0xadc <DIO_write+0xf8>
     ad8:	88 0f       	add	r24, r24
     ada:	99 1f       	adc	r25, r25
     adc:	ca 95       	dec	r28
     ade:	e2 f7       	brpl	.-8      	; 0xad8 <DIO_write+0xf4>
     ae0:	82 2b       	or	r24, r18
     ae2:	82 bb       	out	0x12, r24	; 18
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     ae4:	80 e0       	ldi	r24, 0x00	; 0
     ae6:	14 c0       	rjmp	.+40     	; 0xb10 <DIO_write+0x12c>
			case PORT_D:
				if (state == HIGH) {
					set_bit(PORTD, pinNumber);
					}
				else {
					clear_bit(PORTD, pinNumber);
     ae8:	22 b3       	in	r18, 0x12	; 18
     aea:	81 e0       	ldi	r24, 0x01	; 1
     aec:	90 e0       	ldi	r25, 0x00	; 0
     aee:	02 c0       	rjmp	.+4      	; 0xaf4 <DIO_write+0x110>
     af0:	88 0f       	add	r24, r24
     af2:	99 1f       	adc	r25, r25
     af4:	ca 95       	dec	r28
     af6:	e2 f7       	brpl	.-8      	; 0xaf0 <DIO_write+0x10c>
     af8:	80 95       	com	r24
     afa:	82 23       	and	r24, r18
     afc:	82 bb       	out	0x12, r24	; 18
					}
				break;
		}
	return DIO_OK;
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	07 c0       	rjmp	.+14     	; 0xb10 <DIO_write+0x12c>

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     b02:	81 e0       	ldi	r24, 0x01	; 1
     b04:	05 c0       	rjmp	.+10     	; 0xb10 <DIO_write+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     b06:	82 e0       	ldi	r24, 0x02	; 2
     b08:	03 c0       	rjmp	.+6      	; 0xb10 <DIO_write+0x12c>
		}
	// Validate the pin state
	if (!isValidState(state)) {
		return WRONG_STATE;
     b0a:	84 e0       	ldi	r24, 0x04	; 4
     b0c:	01 c0       	rjmp	.+2      	; 0xb10 <DIO_write+0x12c>
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     b0e:	80 e0       	ldi	r24, 0x00	; 0
	}
     b10:	df 91       	pop	r29
     b12:	cf 91       	pop	r28
     b14:	1f 91       	pop	r17
     b16:	08 95       	ret

00000b18 <DIO_Read>:

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
     b18:	0f 93       	push	r16
     b1a:	1f 93       	push	r17
     b1c:	cf 93       	push	r28
     b1e:	df 93       	push	r29
     b20:	d8 2f       	mov	r29, r24
     b22:	c6 2f       	mov	r28, r22
     b24:	8a 01       	movw	r16, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     b26:	0e 94 3f 04 	call	0x87e	; 0x87e <isValidPinNumber>
     b2a:	88 23       	and	r24, r24
     b2c:	09 f4       	brne	.+2      	; 0xb30 <DIO_Read+0x18>
     b2e:	40 c0       	rjmp	.+128    	; 0xbb0 <DIO_Read+0x98>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     b30:	8c 2f       	mov	r24, r28
     b32:	0e 94 45 04 	call	0x88a	; 0x88a <isValidPortNumber>
     b36:	88 23       	and	r24, r24
     b38:	e9 f1       	breq	.+122    	; 0xbb4 <DIO_Read+0x9c>
		return WRONG_PORT;
		}
	switch (portNumber) {
     b3a:	c2 34       	cpi	r28, 0x42	; 66
     b3c:	a9 f0       	breq	.+42     	; 0xb68 <DIO_Read+0x50>
     b3e:	18 f4       	brcc	.+6      	; 0xb46 <DIO_Read+0x2e>
     b40:	c1 34       	cpi	r28, 0x41	; 65
     b42:	31 f0       	breq	.+12     	; 0xb50 <DIO_Read+0x38>
     b44:	39 c0       	rjmp	.+114    	; 0xbb8 <DIO_Read+0xa0>
     b46:	c3 34       	cpi	r28, 0x43	; 67
     b48:	d9 f0       	breq	.+54     	; 0xb80 <DIO_Read+0x68>
     b4a:	c4 34       	cpi	r28, 0x44	; 68
     b4c:	29 f1       	breq	.+74     	; 0xb98 <DIO_Read+0x80>
     b4e:	34 c0       	rjmp	.+104    	; 0xbb8 <DIO_Read+0xa0>
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
     b50:	89 b3       	in	r24, 0x19	; 25
     b52:	90 e0       	ldi	r25, 0x00	; 0
     b54:	02 c0       	rjmp	.+4      	; 0xb5a <DIO_Read+0x42>
     b56:	95 95       	asr	r25
     b58:	87 95       	ror	r24
     b5a:	da 95       	dec	r29
     b5c:	e2 f7       	brpl	.-8      	; 0xb56 <DIO_Read+0x3e>
     b5e:	81 70       	andi	r24, 0x01	; 1
     b60:	f8 01       	movw	r30, r16
     b62:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b64:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
     b66:	29 c0       	rjmp	.+82     	; 0xbba <DIO_Read+0xa2>
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
     b68:	86 b3       	in	r24, 0x16	; 22
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	02 c0       	rjmp	.+4      	; 0xb72 <DIO_Read+0x5a>
     b6e:	95 95       	asr	r25
     b70:	87 95       	ror	r24
     b72:	da 95       	dec	r29
     b74:	e2 f7       	brpl	.-8      	; 0xb6e <DIO_Read+0x56>
     b76:	81 70       	andi	r24, 0x01	; 1
     b78:	f8 01       	movw	r30, r16
     b7a:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b7c:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
     b7e:	1d c0       	rjmp	.+58     	; 0xbba <DIO_Read+0xa2>
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
     b80:	83 b3       	in	r24, 0x13	; 19
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	02 c0       	rjmp	.+4      	; 0xb8a <DIO_Read+0x72>
     b86:	95 95       	asr	r25
     b88:	87 95       	ror	r24
     b8a:	da 95       	dec	r29
     b8c:	e2 f7       	brpl	.-8      	; 0xb86 <DIO_Read+0x6e>
     b8e:	81 70       	andi	r24, 0x01	; 1
     b90:	f8 01       	movw	r30, r16
     b92:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b94:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
     b96:	11 c0       	rjmp	.+34     	; 0xbba <DIO_Read+0xa2>
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
     b98:	80 b3       	in	r24, 0x10	; 16
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	02 c0       	rjmp	.+4      	; 0xba2 <DIO_Read+0x8a>
     b9e:	95 95       	asr	r25
     ba0:	87 95       	ror	r24
     ba2:	da 95       	dec	r29
     ba4:	e2 f7       	brpl	.-8      	; 0xb9e <DIO_Read+0x86>
     ba6:	81 70       	andi	r24, 0x01	; 1
     ba8:	f8 01       	movw	r30, r16
     baa:	80 83       	st	Z, r24
				break;
		}
	return DIO_OK;
     bac:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
     bae:	05 c0       	rjmp	.+10     	; 0xbba <DIO_Read+0xa2>

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     bb0:	81 e0       	ldi	r24, 0x01	; 1
     bb2:	03 c0       	rjmp	.+6      	; 0xbba <DIO_Read+0xa2>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     bb4:	82 e0       	ldi	r24, 0x02	; 2
     bb6:	01 c0       	rjmp	.+2      	; 0xbba <DIO_Read+0xa2>
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     bb8:	80 e0       	ldi	r24, 0x00	; 0
	}
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	1f 91       	pop	r17
     bc0:	0f 91       	pop	r16
     bc2:	08 95       	ret

00000bc4 <DIO_toggle>:

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
     bc8:	d8 2f       	mov	r29, r24
     bca:	c6 2f       	mov	r28, r22
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     bcc:	0e 94 3f 04 	call	0x87e	; 0x87e <isValidPinNumber>
     bd0:	88 23       	and	r24, r24
     bd2:	09 f4       	brne	.+2      	; 0xbd6 <DIO_toggle+0x12>
     bd4:	40 c0       	rjmp	.+128    	; 0xc56 <DIO_toggle+0x92>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     bd6:	8c 2f       	mov	r24, r28
     bd8:	0e 94 45 04 	call	0x88a	; 0x88a <isValidPortNumber>
     bdc:	88 23       	and	r24, r24
     bde:	e9 f1       	breq	.+122    	; 0xc5a <DIO_toggle+0x96>
		return WRONG_PORT;
		}
	switch (portNumber) {
     be0:	c2 34       	cpi	r28, 0x42	; 66
     be2:	a9 f0       	breq	.+42     	; 0xc0e <DIO_toggle+0x4a>
     be4:	18 f4       	brcc	.+6      	; 0xbec <DIO_toggle+0x28>
     be6:	c1 34       	cpi	r28, 0x41	; 65
     be8:	31 f0       	breq	.+12     	; 0xbf6 <DIO_toggle+0x32>
     bea:	39 c0       	rjmp	.+114    	; 0xc5e <DIO_toggle+0x9a>
     bec:	c3 34       	cpi	r28, 0x43	; 67
     bee:	d9 f0       	breq	.+54     	; 0xc26 <DIO_toggle+0x62>
     bf0:	c4 34       	cpi	r28, 0x44	; 68
     bf2:	29 f1       	breq	.+74     	; 0xc3e <DIO_toggle+0x7a>
     bf4:	34 c0       	rjmp	.+104    	; 0xc5e <DIO_toggle+0x9a>
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
     bf6:	2b b3       	in	r18, 0x1b	; 27
     bf8:	81 e0       	ldi	r24, 0x01	; 1
     bfa:	90 e0       	ldi	r25, 0x00	; 0
     bfc:	02 c0       	rjmp	.+4      	; 0xc02 <DIO_toggle+0x3e>
     bfe:	88 0f       	add	r24, r24
     c00:	99 1f       	adc	r25, r25
     c02:	da 95       	dec	r29
     c04:	e2 f7       	brpl	.-8      	; 0xbfe <DIO_toggle+0x3a>
     c06:	82 27       	eor	r24, r18
     c08:	8b bb       	out	0x1b, r24	; 27
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     c0a:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
     c0c:	29 c0       	rjmp	.+82     	; 0xc60 <DIO_toggle+0x9c>
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
     c0e:	28 b3       	in	r18, 0x18	; 24
     c10:	81 e0       	ldi	r24, 0x01	; 1
     c12:	90 e0       	ldi	r25, 0x00	; 0
     c14:	02 c0       	rjmp	.+4      	; 0xc1a <DIO_toggle+0x56>
     c16:	88 0f       	add	r24, r24
     c18:	99 1f       	adc	r25, r25
     c1a:	da 95       	dec	r29
     c1c:	e2 f7       	brpl	.-8      	; 0xc16 <DIO_toggle+0x52>
     c1e:	82 27       	eor	r24, r18
     c20:	88 bb       	out	0x18, r24	; 24
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     c22:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
     c24:	1d c0       	rjmp	.+58     	; 0xc60 <DIO_toggle+0x9c>
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
     c26:	25 b3       	in	r18, 0x15	; 21
     c28:	81 e0       	ldi	r24, 0x01	; 1
     c2a:	90 e0       	ldi	r25, 0x00	; 0
     c2c:	02 c0       	rjmp	.+4      	; 0xc32 <DIO_toggle+0x6e>
     c2e:	88 0f       	add	r24, r24
     c30:	99 1f       	adc	r25, r25
     c32:	da 95       	dec	r29
     c34:	e2 f7       	brpl	.-8      	; 0xc2e <DIO_toggle+0x6a>
     c36:	82 27       	eor	r24, r18
     c38:	85 bb       	out	0x15, r24	; 21
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     c3a:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
     c3c:	11 c0       	rjmp	.+34     	; 0xc60 <DIO_toggle+0x9c>
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
     c3e:	22 b3       	in	r18, 0x12	; 18
     c40:	81 e0       	ldi	r24, 0x01	; 1
     c42:	90 e0       	ldi	r25, 0x00	; 0
     c44:	02 c0       	rjmp	.+4      	; 0xc4a <DIO_toggle+0x86>
     c46:	88 0f       	add	r24, r24
     c48:	99 1f       	adc	r25, r25
     c4a:	da 95       	dec	r29
     c4c:	e2 f7       	brpl	.-8      	; 0xc46 <DIO_toggle+0x82>
     c4e:	82 27       	eor	r24, r18
     c50:	82 bb       	out	0x12, r24	; 18
				break;
		}
	return DIO_OK;
     c52:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
     c54:	05 c0       	rjmp	.+10     	; 0xc60 <DIO_toggle+0x9c>

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     c56:	81 e0       	ldi	r24, 0x01	; 1
     c58:	03 c0       	rjmp	.+6      	; 0xc60 <DIO_toggle+0x9c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     c5a:	82 e0       	ldi	r24, 0x02	; 2
     c5c:	01 c0       	rjmp	.+2      	; 0xc60 <DIO_toggle+0x9c>
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     c5e:	80 e0       	ldi	r24, 0x00	; 0
     c60:	df 91       	pop	r29
     c62:	cf 91       	pop	r28
     c64:	08 95       	ret

00000c66 <getCurrentStatus>:

EN_I2CMasterStatusCode_t I2C_repeatedStart() {   // Same as start, just a different name
  TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  while (read_bit(TWCR, TWINT) == 0);
  return getCurrentStatus();
  }
     c66:	81 b1       	in	r24, 0x01	; 1
     c68:	e8 2f       	mov	r30, r24
     c6a:	e8 7f       	andi	r30, 0xF8	; 248
     c6c:	8e 2f       	mov	r24, r30
     c6e:	90 e0       	ldi	r25, 0x00	; 0
     c70:	fc 01       	movw	r30, r24
     c72:	38 97       	sbiw	r30, 0x08	; 8
     c74:	e1 35       	cpi	r30, 0x51	; 81
     c76:	f1 05       	cpc	r31, r1
     c78:	c0 f4       	brcc	.+48     	; 0xcaa <getCurrentStatus+0x44>
     c7a:	e6 5d       	subi	r30, 0xD6	; 214
     c7c:	ff 4f       	sbci	r31, 0xFF	; 255
     c7e:	0c 94 00 17 	jmp	0x2e00	; 0x2e00 <__tablejump2__>
     c82:	80 e0       	ldi	r24, 0x00	; 0
     c84:	08 95       	ret
     c86:	82 e0       	ldi	r24, 0x02	; 2
     c88:	08 95       	ret
     c8a:	83 e0       	ldi	r24, 0x03	; 3
     c8c:	08 95       	ret
     c8e:	84 e0       	ldi	r24, 0x04	; 4
     c90:	08 95       	ret
     c92:	85 e0       	ldi	r24, 0x05	; 5
     c94:	08 95       	ret
     c96:	86 e0       	ldi	r24, 0x06	; 6
     c98:	08 95       	ret
     c9a:	87 e0       	ldi	r24, 0x07	; 7
     c9c:	08 95       	ret
     c9e:	88 e0       	ldi	r24, 0x08	; 8
     ca0:	08 95       	ret
     ca2:	89 e0       	ldi	r24, 0x09	; 9
     ca4:	08 95       	ret
     ca6:	8a e0       	ldi	r24, 0x0A	; 10
     ca8:	08 95       	ret
     caa:	8b e0       	ldi	r24, 0x0B	; 11
     cac:	08 95       	ret
     cae:	81 e0       	ldi	r24, 0x01	; 1
     cb0:	08 95       	ret

00000cb2 <I2C_init>:
     cb2:	11 b8       	out	0x01, r1	; 1
     cb4:	8f ef       	ldi	r24, 0xFF	; 255
     cb6:	80 b9       	out	0x00, r24	; 0
     cb8:	08 95       	ret

00000cba <I2C_start>:
     cba:	84 ea       	ldi	r24, 0xA4	; 164
     cbc:	86 bf       	out	0x36, r24	; 54
     cbe:	06 b6       	in	r0, 0x36	; 54
     cc0:	07 fe       	sbrs	r0, 7
     cc2:	fd cf       	rjmp	.-6      	; 0xcbe <I2C_start+0x4>
     cc4:	0e 94 33 06 	call	0xc66	; 0xc66 <getCurrentStatus>
     cc8:	08 95       	ret

00000cca <I2C_write>:

EN_I2CMasterStatusCode_t I2C_write(u8 data) {
  TWDR = data;
     cca:	83 b9       	out	0x03, r24	; 3
  TWCR = (1 << TWEN) | (1 << TWINT);
     ccc:	84 e8       	ldi	r24, 0x84	; 132
     cce:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWINT) == 0);
     cd0:	06 b6       	in	r0, 0x36	; 54
     cd2:	07 fe       	sbrs	r0, 7
     cd4:	fd cf       	rjmp	.-6      	; 0xcd0 <I2C_write+0x6>
  return getCurrentStatus();
     cd6:	0e 94 33 06 	call	0xc66	; 0xc66 <getCurrentStatus>
  }
     cda:	08 95       	ret

00000cdc <I2C_read_Ack>:

EN_I2CMasterStatusCode_t I2C_read_Ack(u8* data) {
  TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWINT);
     cdc:	24 ec       	ldi	r18, 0xC4	; 196
     cde:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     ce0:	06 b6       	in	r0, 0x36	; 54
     ce2:	07 fe       	sbrs	r0, 7
     ce4:	fd cf       	rjmp	.-6      	; 0xce0 <I2C_read_Ack+0x4>
  *data = TWDR;
     ce6:	23 b1       	in	r18, 0x03	; 3
     ce8:	fc 01       	movw	r30, r24
     cea:	20 83       	st	Z, r18
  return getCurrentStatus();
     cec:	0e 94 33 06 	call	0xc66	; 0xc66 <getCurrentStatus>
  }
     cf0:	08 95       	ret

00000cf2 <I2C_read_Nack>:

EN_I2CMasterStatusCode_t I2C_read_Nack(u8* data) {
  TWCR = (1 << TWEN) | (1 << TWINT);
     cf2:	24 e8       	ldi	r18, 0x84	; 132
     cf4:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     cf6:	06 b6       	in	r0, 0x36	; 54
     cf8:	07 fe       	sbrs	r0, 7
     cfa:	fd cf       	rjmp	.-6      	; 0xcf6 <I2C_read_Nack+0x4>
  *data = TWDR;
     cfc:	23 b1       	in	r18, 0x03	; 3
     cfe:	fc 01       	movw	r30, r24
     d00:	20 83       	st	Z, r18
  return getCurrentStatus();
     d02:	0e 94 33 06 	call	0xc66	; 0xc66 <getCurrentStatus>
  }
     d06:	08 95       	ret

00000d08 <I2C_stop>:

void I2C_stop(void) {
  TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
     d08:	84 e9       	ldi	r24, 0x94	; 148
     d0a:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWSTO));	// Wait until stop condition finishes
     d0c:	06 b6       	in	r0, 0x36	; 54
     d0e:	04 fc       	sbrc	r0, 4
     d10:	fd cf       	rjmp	.-6      	; 0xd0c <I2C_stop+0x4>
  }
     d12:	08 95       	ret

00000d14 <isValidTimer>:
        clear_bit(TCCR2, COM21);
        set_prescalar(TIMER_2, 0);
        break;
    }
  return TIMER_OK;
  }
     d14:	83 30       	cpi	r24, 0x03	; 3
     d16:	10 f4       	brcc	.+4      	; 0xd1c <isValidTimer+0x8>
     d18:	81 e0       	ldi	r24, 0x01	; 1
     d1a:	08 95       	ret
     d1c:	80 e0       	ldi	r24, 0x00	; 0
     d1e:	08 95       	ret

00000d20 <set_prescalar>:
     d20:	1f 93       	push	r17
     d22:	cf 93       	push	r28
     d24:	df 93       	push	r29
     d26:	18 2f       	mov	r17, r24
     d28:	eb 01       	movw	r28, r22
     d2a:	0e 94 8a 06 	call	0xd14	; 0xd14 <isValidTimer>
     d2e:	88 23       	and	r24, r24
     d30:	09 f4       	brne	.+2      	; 0xd34 <set_prescalar+0x14>
     d32:	6a c1       	rjmp	.+724    	; 0x1008 <set_prescalar+0x2e8>
     d34:	11 30       	cpi	r17, 0x01	; 1
     d36:	09 f4       	brne	.+2      	; 0xd3a <set_prescalar+0x1a>
     d38:	6f c0       	rjmp	.+222    	; 0xe18 <set_prescalar+0xf8>
     d3a:	20 f0       	brcs	.+8      	; 0xd44 <set_prescalar+0x24>
     d3c:	12 30       	cpi	r17, 0x02	; 2
     d3e:	09 f4       	brne	.+2      	; 0xd42 <set_prescalar+0x22>
     d40:	d5 c0       	rjmp	.+426    	; 0xeec <set_prescalar+0x1cc>
     d42:	64 c1       	rjmp	.+712    	; 0x100c <set_prescalar+0x2ec>
     d44:	c2 30       	cpi	r28, 0x02	; 2
     d46:	d1 05       	cpc	r29, r1
     d48:	78 f0       	brcs	.+30     	; 0xd68 <set_prescalar+0x48>
     d4a:	c8 30       	cpi	r28, 0x08	; 8
     d4c:	d1 05       	cpc	r29, r1
     d4e:	61 f0       	breq	.+24     	; 0xd68 <set_prescalar+0x48>
     d50:	c0 34       	cpi	r28, 0x40	; 64
     d52:	d1 05       	cpc	r29, r1
     d54:	49 f0       	breq	.+18     	; 0xd68 <set_prescalar+0x48>
     d56:	c1 15       	cp	r28, r1
     d58:	81 e0       	ldi	r24, 0x01	; 1
     d5a:	d8 07       	cpc	r29, r24
     d5c:	29 f0       	breq	.+10     	; 0xd68 <set_prescalar+0x48>
     d5e:	c1 15       	cp	r28, r1
     d60:	84 e0       	ldi	r24, 0x04	; 4
     d62:	d8 07       	cpc	r29, r24
     d64:	09 f0       	breq	.+2      	; 0xd68 <set_prescalar+0x48>
     d66:	54 c1       	rjmp	.+680    	; 0x1010 <set_prescalar+0x2f0>
     d68:	c8 30       	cpi	r28, 0x08	; 8
     d6a:	d1 05       	cpc	r29, r1
     d6c:	49 f1       	breq	.+82     	; 0xdc0 <set_prescalar+0xa0>
     d6e:	28 f4       	brcc	.+10     	; 0xd7a <set_prescalar+0x5a>
     d70:	20 97       	sbiw	r28, 0x00	; 0
     d72:	81 f0       	breq	.+32     	; 0xd94 <set_prescalar+0x74>
     d74:	21 97       	sbiw	r28, 0x01	; 1
     d76:	c9 f0       	breq	.+50     	; 0xdaa <set_prescalar+0x8a>
     d78:	4d c1       	rjmp	.+666    	; 0x1014 <set_prescalar+0x2f4>
     d7a:	c1 15       	cp	r28, r1
     d7c:	81 e0       	ldi	r24, 0x01	; 1
     d7e:	d8 07       	cpc	r29, r24
     d80:	a9 f1       	breq	.+106    	; 0xdec <set_prescalar+0xcc>
     d82:	c1 15       	cp	r28, r1
     d84:	84 e0       	ldi	r24, 0x04	; 4
     d86:	d8 07       	cpc	r29, r24
     d88:	e1 f1       	breq	.+120    	; 0xe02 <set_prescalar+0xe2>
     d8a:	c0 34       	cpi	r28, 0x40	; 64
     d8c:	d1 05       	cpc	r29, r1
     d8e:	09 f0       	breq	.+2      	; 0xd92 <set_prescalar+0x72>
     d90:	41 c1       	rjmp	.+642    	; 0x1014 <set_prescalar+0x2f4>
     d92:	21 c0       	rjmp	.+66     	; 0xdd6 <set_prescalar+0xb6>
     d94:	83 b7       	in	r24, 0x33	; 51
     d96:	8e 7f       	andi	r24, 0xFE	; 254
     d98:	83 bf       	out	0x33, r24	; 51
     d9a:	83 b7       	in	r24, 0x33	; 51
     d9c:	8d 7f       	andi	r24, 0xFD	; 253
     d9e:	83 bf       	out	0x33, r24	; 51
     da0:	83 b7       	in	r24, 0x33	; 51
     da2:	8b 7f       	andi	r24, 0xFB	; 251
     da4:	83 bf       	out	0x33, r24	; 51
     da6:	80 e0       	ldi	r24, 0x00	; 0
     da8:	3e c1       	rjmp	.+636    	; 0x1026 <set_prescalar+0x306>
     daa:	83 b7       	in	r24, 0x33	; 51
     dac:	81 60       	ori	r24, 0x01	; 1
     dae:	83 bf       	out	0x33, r24	; 51
     db0:	83 b7       	in	r24, 0x33	; 51
     db2:	8d 7f       	andi	r24, 0xFD	; 253
     db4:	83 bf       	out	0x33, r24	; 51
     db6:	83 b7       	in	r24, 0x33	; 51
     db8:	8b 7f       	andi	r24, 0xFB	; 251
     dba:	83 bf       	out	0x33, r24	; 51
     dbc:	80 e0       	ldi	r24, 0x00	; 0
     dbe:	33 c1       	rjmp	.+614    	; 0x1026 <set_prescalar+0x306>
     dc0:	83 b7       	in	r24, 0x33	; 51
     dc2:	8e 7f       	andi	r24, 0xFE	; 254
     dc4:	83 bf       	out	0x33, r24	; 51
     dc6:	83 b7       	in	r24, 0x33	; 51
     dc8:	82 60       	ori	r24, 0x02	; 2
     dca:	83 bf       	out	0x33, r24	; 51
     dcc:	83 b7       	in	r24, 0x33	; 51
     dce:	8b 7f       	andi	r24, 0xFB	; 251
     dd0:	83 bf       	out	0x33, r24	; 51
     dd2:	80 e0       	ldi	r24, 0x00	; 0
     dd4:	28 c1       	rjmp	.+592    	; 0x1026 <set_prescalar+0x306>
     dd6:	83 b7       	in	r24, 0x33	; 51
     dd8:	81 60       	ori	r24, 0x01	; 1
     dda:	83 bf       	out	0x33, r24	; 51
     ddc:	83 b7       	in	r24, 0x33	; 51
     dde:	82 60       	ori	r24, 0x02	; 2
     de0:	83 bf       	out	0x33, r24	; 51
     de2:	83 b7       	in	r24, 0x33	; 51
     de4:	8b 7f       	andi	r24, 0xFB	; 251
     de6:	83 bf       	out	0x33, r24	; 51
     de8:	80 e0       	ldi	r24, 0x00	; 0
     dea:	1d c1       	rjmp	.+570    	; 0x1026 <set_prescalar+0x306>
     dec:	83 b7       	in	r24, 0x33	; 51
     dee:	8e 7f       	andi	r24, 0xFE	; 254
     df0:	83 bf       	out	0x33, r24	; 51
     df2:	83 b7       	in	r24, 0x33	; 51
     df4:	8d 7f       	andi	r24, 0xFD	; 253
     df6:	83 bf       	out	0x33, r24	; 51
     df8:	83 b7       	in	r24, 0x33	; 51
     dfa:	84 60       	ori	r24, 0x04	; 4
     dfc:	83 bf       	out	0x33, r24	; 51
     dfe:	80 e0       	ldi	r24, 0x00	; 0
     e00:	12 c1       	rjmp	.+548    	; 0x1026 <set_prescalar+0x306>
     e02:	83 b7       	in	r24, 0x33	; 51
     e04:	81 60       	ori	r24, 0x01	; 1
     e06:	83 bf       	out	0x33, r24	; 51
     e08:	83 b7       	in	r24, 0x33	; 51
     e0a:	8d 7f       	andi	r24, 0xFD	; 253
     e0c:	83 bf       	out	0x33, r24	; 51
     e0e:	83 b7       	in	r24, 0x33	; 51
     e10:	84 60       	ori	r24, 0x04	; 4
     e12:	83 bf       	out	0x33, r24	; 51
     e14:	80 e0       	ldi	r24, 0x00	; 0
     e16:	07 c1       	rjmp	.+526    	; 0x1026 <set_prescalar+0x306>
     e18:	c2 30       	cpi	r28, 0x02	; 2
     e1a:	d1 05       	cpc	r29, r1
     e1c:	78 f0       	brcs	.+30     	; 0xe3c <set_prescalar+0x11c>
     e1e:	c8 30       	cpi	r28, 0x08	; 8
     e20:	d1 05       	cpc	r29, r1
     e22:	61 f0       	breq	.+24     	; 0xe3c <set_prescalar+0x11c>
     e24:	c0 34       	cpi	r28, 0x40	; 64
     e26:	d1 05       	cpc	r29, r1
     e28:	49 f0       	breq	.+18     	; 0xe3c <set_prescalar+0x11c>
     e2a:	c1 15       	cp	r28, r1
     e2c:	81 e0       	ldi	r24, 0x01	; 1
     e2e:	d8 07       	cpc	r29, r24
     e30:	29 f0       	breq	.+10     	; 0xe3c <set_prescalar+0x11c>
     e32:	c1 15       	cp	r28, r1
     e34:	84 e0       	ldi	r24, 0x04	; 4
     e36:	d8 07       	cpc	r29, r24
     e38:	09 f0       	breq	.+2      	; 0xe3c <set_prescalar+0x11c>
     e3a:	ee c0       	rjmp	.+476    	; 0x1018 <set_prescalar+0x2f8>
     e3c:	c8 30       	cpi	r28, 0x08	; 8
     e3e:	d1 05       	cpc	r29, r1
     e40:	49 f1       	breq	.+82     	; 0xe94 <set_prescalar+0x174>
     e42:	28 f4       	brcc	.+10     	; 0xe4e <set_prescalar+0x12e>
     e44:	20 97       	sbiw	r28, 0x00	; 0
     e46:	81 f0       	breq	.+32     	; 0xe68 <set_prescalar+0x148>
     e48:	21 97       	sbiw	r28, 0x01	; 1
     e4a:	c9 f0       	breq	.+50     	; 0xe7e <set_prescalar+0x15e>
     e4c:	e7 c0       	rjmp	.+462    	; 0x101c <set_prescalar+0x2fc>
     e4e:	c1 15       	cp	r28, r1
     e50:	81 e0       	ldi	r24, 0x01	; 1
     e52:	d8 07       	cpc	r29, r24
     e54:	a9 f1       	breq	.+106    	; 0xec0 <set_prescalar+0x1a0>
     e56:	c1 15       	cp	r28, r1
     e58:	84 e0       	ldi	r24, 0x04	; 4
     e5a:	d8 07       	cpc	r29, r24
     e5c:	e1 f1       	breq	.+120    	; 0xed6 <set_prescalar+0x1b6>
     e5e:	c0 34       	cpi	r28, 0x40	; 64
     e60:	d1 05       	cpc	r29, r1
     e62:	09 f0       	breq	.+2      	; 0xe66 <set_prescalar+0x146>
     e64:	db c0       	rjmp	.+438    	; 0x101c <set_prescalar+0x2fc>
     e66:	21 c0       	rjmp	.+66     	; 0xeaa <set_prescalar+0x18a>
     e68:	8e b5       	in	r24, 0x2e	; 46
     e6a:	8e 7f       	andi	r24, 0xFE	; 254
     e6c:	8e bd       	out	0x2e, r24	; 46
     e6e:	8e b5       	in	r24, 0x2e	; 46
     e70:	8d 7f       	andi	r24, 0xFD	; 253
     e72:	8e bd       	out	0x2e, r24	; 46
     e74:	8e b5       	in	r24, 0x2e	; 46
     e76:	8b 7f       	andi	r24, 0xFB	; 251
     e78:	8e bd       	out	0x2e, r24	; 46
     e7a:	80 e0       	ldi	r24, 0x00	; 0
     e7c:	d4 c0       	rjmp	.+424    	; 0x1026 <set_prescalar+0x306>
     e7e:	8e b5       	in	r24, 0x2e	; 46
     e80:	81 60       	ori	r24, 0x01	; 1
     e82:	8e bd       	out	0x2e, r24	; 46
     e84:	8e b5       	in	r24, 0x2e	; 46
     e86:	8d 7f       	andi	r24, 0xFD	; 253
     e88:	8e bd       	out	0x2e, r24	; 46
     e8a:	8e b5       	in	r24, 0x2e	; 46
     e8c:	8b 7f       	andi	r24, 0xFB	; 251
     e8e:	8e bd       	out	0x2e, r24	; 46
     e90:	80 e0       	ldi	r24, 0x00	; 0
     e92:	c9 c0       	rjmp	.+402    	; 0x1026 <set_prescalar+0x306>
     e94:	8e b5       	in	r24, 0x2e	; 46
     e96:	8e 7f       	andi	r24, 0xFE	; 254
     e98:	8e bd       	out	0x2e, r24	; 46
     e9a:	8e b5       	in	r24, 0x2e	; 46
     e9c:	82 60       	ori	r24, 0x02	; 2
     e9e:	8e bd       	out	0x2e, r24	; 46
     ea0:	8e b5       	in	r24, 0x2e	; 46
     ea2:	8b 7f       	andi	r24, 0xFB	; 251
     ea4:	8e bd       	out	0x2e, r24	; 46
     ea6:	80 e0       	ldi	r24, 0x00	; 0
     ea8:	be c0       	rjmp	.+380    	; 0x1026 <set_prescalar+0x306>
     eaa:	8e b5       	in	r24, 0x2e	; 46
     eac:	81 60       	ori	r24, 0x01	; 1
     eae:	8e bd       	out	0x2e, r24	; 46
     eb0:	8e b5       	in	r24, 0x2e	; 46
     eb2:	82 60       	ori	r24, 0x02	; 2
     eb4:	8e bd       	out	0x2e, r24	; 46
     eb6:	8e b5       	in	r24, 0x2e	; 46
     eb8:	8b 7f       	andi	r24, 0xFB	; 251
     eba:	8e bd       	out	0x2e, r24	; 46
     ebc:	80 e0       	ldi	r24, 0x00	; 0
     ebe:	b3 c0       	rjmp	.+358    	; 0x1026 <set_prescalar+0x306>
     ec0:	8e b5       	in	r24, 0x2e	; 46
     ec2:	8e 7f       	andi	r24, 0xFE	; 254
     ec4:	8e bd       	out	0x2e, r24	; 46
     ec6:	8e b5       	in	r24, 0x2e	; 46
     ec8:	8d 7f       	andi	r24, 0xFD	; 253
     eca:	8e bd       	out	0x2e, r24	; 46
     ecc:	8e b5       	in	r24, 0x2e	; 46
     ece:	84 60       	ori	r24, 0x04	; 4
     ed0:	8e bd       	out	0x2e, r24	; 46
     ed2:	80 e0       	ldi	r24, 0x00	; 0
     ed4:	a8 c0       	rjmp	.+336    	; 0x1026 <set_prescalar+0x306>
     ed6:	8e b5       	in	r24, 0x2e	; 46
     ed8:	81 60       	ori	r24, 0x01	; 1
     eda:	8e bd       	out	0x2e, r24	; 46
     edc:	8e b5       	in	r24, 0x2e	; 46
     ede:	8d 7f       	andi	r24, 0xFD	; 253
     ee0:	8e bd       	out	0x2e, r24	; 46
     ee2:	8e b5       	in	r24, 0x2e	; 46
     ee4:	84 60       	ori	r24, 0x04	; 4
     ee6:	8e bd       	out	0x2e, r24	; 46
     ee8:	80 e0       	ldi	r24, 0x00	; 0
     eea:	9d c0       	rjmp	.+314    	; 0x1026 <set_prescalar+0x306>
     eec:	c2 30       	cpi	r28, 0x02	; 2
     eee:	d1 05       	cpc	r29, r1
     ef0:	a8 f0       	brcs	.+42     	; 0xf1c <set_prescalar+0x1fc>
     ef2:	c8 30       	cpi	r28, 0x08	; 8
     ef4:	d1 05       	cpc	r29, r1
     ef6:	91 f0       	breq	.+36     	; 0xf1c <set_prescalar+0x1fc>
     ef8:	c0 32       	cpi	r28, 0x20	; 32
     efa:	d1 05       	cpc	r29, r1
     efc:	79 f0       	breq	.+30     	; 0xf1c <set_prescalar+0x1fc>
     efe:	c0 34       	cpi	r28, 0x40	; 64
     f00:	d1 05       	cpc	r29, r1
     f02:	61 f0       	breq	.+24     	; 0xf1c <set_prescalar+0x1fc>
     f04:	c0 38       	cpi	r28, 0x80	; 128
     f06:	d1 05       	cpc	r29, r1
     f08:	49 f0       	breq	.+18     	; 0xf1c <set_prescalar+0x1fc>
     f0a:	c1 15       	cp	r28, r1
     f0c:	81 e0       	ldi	r24, 0x01	; 1
     f0e:	d8 07       	cpc	r29, r24
     f10:	29 f0       	breq	.+10     	; 0xf1c <set_prescalar+0x1fc>
     f12:	c1 15       	cp	r28, r1
     f14:	84 e0       	ldi	r24, 0x04	; 4
     f16:	d8 07       	cpc	r29, r24
     f18:	09 f0       	breq	.+2      	; 0xf1c <set_prescalar+0x1fc>
     f1a:	82 c0       	rjmp	.+260    	; 0x1020 <set_prescalar+0x300>
     f1c:	c0 32       	cpi	r28, 0x20	; 32
     f1e:	d1 05       	cpc	r29, r1
     f20:	e1 f1       	breq	.+120    	; 0xf9a <set_prescalar+0x27a>
     f22:	38 f4       	brcc	.+14     	; 0xf32 <set_prescalar+0x212>
     f24:	c1 30       	cpi	r28, 0x01	; 1
     f26:	d1 05       	cpc	r29, r1
     f28:	11 f1       	breq	.+68     	; 0xf6e <set_prescalar+0x24e>
     f2a:	b0 f0       	brcs	.+44     	; 0xf58 <set_prescalar+0x238>
     f2c:	28 97       	sbiw	r28, 0x08	; 8
     f2e:	51 f1       	breq	.+84     	; 0xf84 <set_prescalar+0x264>
     f30:	79 c0       	rjmp	.+242    	; 0x1024 <set_prescalar+0x304>
     f32:	c0 38       	cpi	r28, 0x80	; 128
     f34:	d1 05       	cpc	r29, r1
     f36:	09 f4       	brne	.+2      	; 0xf3a <set_prescalar+0x21a>
     f38:	46 c0       	rjmp	.+140    	; 0xfc6 <set_prescalar+0x2a6>
     f3a:	20 f4       	brcc	.+8      	; 0xf44 <set_prescalar+0x224>
     f3c:	c0 34       	cpi	r28, 0x40	; 64
     f3e:	d1 05       	cpc	r29, r1
     f40:	b9 f1       	breq	.+110    	; 0xfb0 <set_prescalar+0x290>
     f42:	70 c0       	rjmp	.+224    	; 0x1024 <set_prescalar+0x304>
     f44:	c1 15       	cp	r28, r1
     f46:	81 e0       	ldi	r24, 0x01	; 1
     f48:	d8 07       	cpc	r29, r24
     f4a:	09 f4       	brne	.+2      	; 0xf4e <set_prescalar+0x22e>
     f4c:	47 c0       	rjmp	.+142    	; 0xfdc <set_prescalar+0x2bc>
     f4e:	c1 15       	cp	r28, r1
     f50:	d4 40       	sbci	r29, 0x04	; 4
     f52:	09 f4       	brne	.+2      	; 0xf56 <set_prescalar+0x236>
     f54:	4e c0       	rjmp	.+156    	; 0xff2 <set_prescalar+0x2d2>
     f56:	66 c0       	rjmp	.+204    	; 0x1024 <set_prescalar+0x304>
     f58:	85 b5       	in	r24, 0x25	; 37
     f5a:	8e 7f       	andi	r24, 0xFE	; 254
     f5c:	85 bd       	out	0x25, r24	; 37
     f5e:	85 b5       	in	r24, 0x25	; 37
     f60:	8d 7f       	andi	r24, 0xFD	; 253
     f62:	85 bd       	out	0x25, r24	; 37
     f64:	85 b5       	in	r24, 0x25	; 37
     f66:	8b 7f       	andi	r24, 0xFB	; 251
     f68:	85 bd       	out	0x25, r24	; 37
     f6a:	80 e0       	ldi	r24, 0x00	; 0
     f6c:	5c c0       	rjmp	.+184    	; 0x1026 <set_prescalar+0x306>
     f6e:	85 b5       	in	r24, 0x25	; 37
     f70:	81 60       	ori	r24, 0x01	; 1
     f72:	85 bd       	out	0x25, r24	; 37
     f74:	85 b5       	in	r24, 0x25	; 37
     f76:	8d 7f       	andi	r24, 0xFD	; 253
     f78:	85 bd       	out	0x25, r24	; 37
     f7a:	85 b5       	in	r24, 0x25	; 37
     f7c:	8b 7f       	andi	r24, 0xFB	; 251
     f7e:	85 bd       	out	0x25, r24	; 37
     f80:	80 e0       	ldi	r24, 0x00	; 0
     f82:	51 c0       	rjmp	.+162    	; 0x1026 <set_prescalar+0x306>
     f84:	85 b5       	in	r24, 0x25	; 37
     f86:	8e 7f       	andi	r24, 0xFE	; 254
     f88:	85 bd       	out	0x25, r24	; 37
     f8a:	85 b5       	in	r24, 0x25	; 37
     f8c:	82 60       	ori	r24, 0x02	; 2
     f8e:	85 bd       	out	0x25, r24	; 37
     f90:	85 b5       	in	r24, 0x25	; 37
     f92:	8b 7f       	andi	r24, 0xFB	; 251
     f94:	85 bd       	out	0x25, r24	; 37
     f96:	80 e0       	ldi	r24, 0x00	; 0
     f98:	46 c0       	rjmp	.+140    	; 0x1026 <set_prescalar+0x306>
     f9a:	85 b5       	in	r24, 0x25	; 37
     f9c:	81 60       	ori	r24, 0x01	; 1
     f9e:	85 bd       	out	0x25, r24	; 37
     fa0:	85 b5       	in	r24, 0x25	; 37
     fa2:	82 60       	ori	r24, 0x02	; 2
     fa4:	85 bd       	out	0x25, r24	; 37
     fa6:	85 b5       	in	r24, 0x25	; 37
     fa8:	8b 7f       	andi	r24, 0xFB	; 251
     faa:	85 bd       	out	0x25, r24	; 37
     fac:	80 e0       	ldi	r24, 0x00	; 0
     fae:	3b c0       	rjmp	.+118    	; 0x1026 <set_prescalar+0x306>
     fb0:	85 b5       	in	r24, 0x25	; 37
     fb2:	8e 7f       	andi	r24, 0xFE	; 254
     fb4:	85 bd       	out	0x25, r24	; 37
     fb6:	85 b5       	in	r24, 0x25	; 37
     fb8:	8d 7f       	andi	r24, 0xFD	; 253
     fba:	85 bd       	out	0x25, r24	; 37
     fbc:	85 b5       	in	r24, 0x25	; 37
     fbe:	84 60       	ori	r24, 0x04	; 4
     fc0:	85 bd       	out	0x25, r24	; 37
     fc2:	80 e0       	ldi	r24, 0x00	; 0
     fc4:	30 c0       	rjmp	.+96     	; 0x1026 <set_prescalar+0x306>
     fc6:	85 b5       	in	r24, 0x25	; 37
     fc8:	81 60       	ori	r24, 0x01	; 1
     fca:	85 bd       	out	0x25, r24	; 37
     fcc:	85 b5       	in	r24, 0x25	; 37
     fce:	8d 7f       	andi	r24, 0xFD	; 253
     fd0:	85 bd       	out	0x25, r24	; 37
     fd2:	85 b5       	in	r24, 0x25	; 37
     fd4:	84 60       	ori	r24, 0x04	; 4
     fd6:	85 bd       	out	0x25, r24	; 37
     fd8:	80 e0       	ldi	r24, 0x00	; 0
     fda:	25 c0       	rjmp	.+74     	; 0x1026 <set_prescalar+0x306>
     fdc:	85 b5       	in	r24, 0x25	; 37
     fde:	8e 7f       	andi	r24, 0xFE	; 254
     fe0:	85 bd       	out	0x25, r24	; 37
     fe2:	85 b5       	in	r24, 0x25	; 37
     fe4:	82 60       	ori	r24, 0x02	; 2
     fe6:	85 bd       	out	0x25, r24	; 37
     fe8:	85 b5       	in	r24, 0x25	; 37
     fea:	84 60       	ori	r24, 0x04	; 4
     fec:	85 bd       	out	0x25, r24	; 37
     fee:	80 e0       	ldi	r24, 0x00	; 0
     ff0:	1a c0       	rjmp	.+52     	; 0x1026 <set_prescalar+0x306>
     ff2:	85 b5       	in	r24, 0x25	; 37
     ff4:	81 60       	ori	r24, 0x01	; 1
     ff6:	85 bd       	out	0x25, r24	; 37
     ff8:	85 b5       	in	r24, 0x25	; 37
     ffa:	82 60       	ori	r24, 0x02	; 2
     ffc:	85 bd       	out	0x25, r24	; 37
     ffe:	85 b5       	in	r24, 0x25	; 37
    1000:	84 60       	ori	r24, 0x04	; 4
    1002:	85 bd       	out	0x25, r24	; 37
    1004:	80 e0       	ldi	r24, 0x00	; 0
    1006:	0f c0       	rjmp	.+30     	; 0x1026 <set_prescalar+0x306>
    1008:	81 e0       	ldi	r24, 0x01	; 1
    100a:	0d c0       	rjmp	.+26     	; 0x1026 <set_prescalar+0x306>
    100c:	80 e0       	ldi	r24, 0x00	; 0
    100e:	0b c0       	rjmp	.+22     	; 0x1026 <set_prescalar+0x306>
    1010:	82 e0       	ldi	r24, 0x02	; 2
    1012:	09 c0       	rjmp	.+18     	; 0x1026 <set_prescalar+0x306>
    1014:	80 e0       	ldi	r24, 0x00	; 0
    1016:	07 c0       	rjmp	.+14     	; 0x1026 <set_prescalar+0x306>
    1018:	82 e0       	ldi	r24, 0x02	; 2
    101a:	05 c0       	rjmp	.+10     	; 0x1026 <set_prescalar+0x306>
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	03 c0       	rjmp	.+6      	; 0x1026 <set_prescalar+0x306>
    1020:	82 e0       	ldi	r24, 0x02	; 2
    1022:	01 c0       	rjmp	.+2      	; 0x1026 <set_prescalar+0x306>
    1024:	80 e0       	ldi	r24, 0x00	; 0
    1026:	df 91       	pop	r29
    1028:	cf 91       	pop	r28
    102a:	1f 91       	pop	r17
    102c:	08 95       	ret

0000102e <Timer_start>:
    102e:	0f 93       	push	r16
    1030:	1f 93       	push	r17
    1032:	cf 93       	push	r28
    1034:	c8 2f       	mov	r28, r24
    1036:	8b 01       	movw	r16, r22
    1038:	0e 94 8a 06 	call	0xd14	; 0xd14 <isValidTimer>
    103c:	88 23       	and	r24, r24
    103e:	31 f0       	breq	.+12     	; 0x104c <Timer_start+0x1e>
    1040:	b8 01       	movw	r22, r16
    1042:	8c 2f       	mov	r24, r28
    1044:	0e 94 90 06 	call	0xd20	; 0xd20 <set_prescalar>
    1048:	80 e0       	ldi	r24, 0x00	; 0
    104a:	01 c0       	rjmp	.+2      	; 0x104e <Timer_start+0x20>
    104c:	81 e0       	ldi	r24, 0x01	; 1
    104e:	cf 91       	pop	r28
    1050:	1f 91       	pop	r17
    1052:	0f 91       	pop	r16
    1054:	08 95       	ret

00001056 <PWM_OCP_disconnect>:

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    1056:	84 30       	cpi	r24, 0x04	; 4
    1058:	40 f5       	brcc	.+80     	; 0x10aa <PWM_OCP_disconnect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    105a:	81 30       	cpi	r24, 0x01	; 1
    105c:	71 f0       	breq	.+28     	; 0x107a <PWM_OCP_disconnect+0x24>
    105e:	28 f0       	brcs	.+10     	; 0x106a <PWM_OCP_disconnect+0x14>
    1060:	82 30       	cpi	r24, 0x02	; 2
    1062:	99 f0       	breq	.+38     	; 0x108a <PWM_OCP_disconnect+0x34>
    1064:	83 30       	cpi	r24, 0x03	; 3
    1066:	c9 f0       	breq	.+50     	; 0x109a <PWM_OCP_disconnect+0x44>
    1068:	22 c0       	rjmp	.+68     	; 0x10ae <PWM_OCP_disconnect+0x58>
      case OC_0:
        clear_bit(TCCR0, COM00);
    106a:	83 b7       	in	r24, 0x33	; 51
    106c:	8f 7e       	andi	r24, 0xEF	; 239
    106e:	83 bf       	out	0x33, r24	; 51
        clear_bit(TCCR0, COM01);
    1070:	83 b7       	in	r24, 0x33	; 51
    1072:	8f 7d       	andi	r24, 0xDF	; 223
    1074:	83 bf       	out	0x33, r24	; 51
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1076:	80 e0       	ldi	r24, 0x00	; 0
    }
  switch (pwmPin) {
      case OC_0:
        clear_bit(TCCR0, COM00);
        clear_bit(TCCR0, COM01);
        break;
    1078:	08 95       	ret
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
    107a:	8f b5       	in	r24, 0x2f	; 47
    107c:	8f 7b       	andi	r24, 0xBF	; 191
    107e:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1A1);
    1080:	8f b5       	in	r24, 0x2f	; 47
    1082:	8f 77       	andi	r24, 0x7F	; 127
    1084:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1086:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR0, COM01);
        break;
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
        clear_bit(TCCR1A, COM1A1);
        break;
    1088:	08 95       	ret
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
    108a:	8f b5       	in	r24, 0x2f	; 47
    108c:	8f 7e       	andi	r24, 0xEF	; 239
    108e:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1B1);
    1090:	8f b5       	in	r24, 0x2f	; 47
    1092:	8f 7d       	andi	r24, 0xDF	; 223
    1094:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1096:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1A1);
        break;
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
        clear_bit(TCCR1A, COM1B1);
        break;
    1098:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
    109a:	85 b5       	in	r24, 0x25	; 37
    109c:	8f 7e       	andi	r24, 0xEF	; 239
    109e:	85 bd       	out	0x25, r24	; 37
        clear_bit(TCCR2, COM21);
    10a0:	85 b5       	in	r24, 0x25	; 37
    10a2:	8f 7d       	andi	r24, 0xDF	; 223
    10a4:	85 bd       	out	0x25, r24	; 37
        break;
    }
  return TIMER_OK;
    10a6:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1B1);
        break;
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    10a8:	08 95       	ret
  }

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    10aa:	87 e0       	ldi	r24, 0x07	; 7
    10ac:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    10ae:	80 e0       	ldi	r24, 0x00	; 0
  }
    10b0:	08 95       	ret

000010b2 <PWM_OCP_connect>:

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    10b2:	84 30       	cpi	r24, 0x04	; 4
    10b4:	40 f5       	brcc	.+80     	; 0x1106 <PWM_OCP_connect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    10b6:	81 30       	cpi	r24, 0x01	; 1
    10b8:	71 f0       	breq	.+28     	; 0x10d6 <PWM_OCP_connect+0x24>
    10ba:	28 f0       	brcs	.+10     	; 0x10c6 <PWM_OCP_connect+0x14>
    10bc:	82 30       	cpi	r24, 0x02	; 2
    10be:	99 f0       	breq	.+38     	; 0x10e6 <PWM_OCP_connect+0x34>
    10c0:	83 30       	cpi	r24, 0x03	; 3
    10c2:	c9 f0       	breq	.+50     	; 0x10f6 <PWM_OCP_connect+0x44>
    10c4:	22 c0       	rjmp	.+68     	; 0x110a <PWM_OCP_connect+0x58>
      case OC_0:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR0, COM00);
    10c6:	83 b7       	in	r24, 0x33	; 51
    10c8:	8f 7e       	andi	r24, 0xEF	; 239
    10ca:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR0, COM01);
    10cc:	83 b7       	in	r24, 0x33	; 51
    10ce:	80 62       	ori	r24, 0x20	; 32
    10d0:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    10d2:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR0, COM01);
#else 
        set_bit(TCCR0, COM00);
        set_bit(TCCR0, COM01);
#endif
        break;
    10d4:	08 95       	ret
      case OC_1A:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1A0);
    10d6:	8f b5       	in	r24, 0x2f	; 47
    10d8:	8f 7b       	andi	r24, 0xBF	; 191
    10da:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1A1);
    10dc:	8f b5       	in	r24, 0x2f	; 47
    10de:	80 68       	ori	r24, 0x80	; 128
    10e0:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    10e2:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1A1);
#else 
        set_bit(TCCR1A, COM1A0);
        set_bit(TCCR1A, COM1A1);
#endif
        break;
    10e4:	08 95       	ret
      case OC_1B:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1B0);
    10e6:	8f b5       	in	r24, 0x2f	; 47
    10e8:	8f 7e       	andi	r24, 0xEF	; 239
    10ea:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1B1);
    10ec:	8f b5       	in	r24, 0x2f	; 47
    10ee:	80 62       	ori	r24, 0x20	; 32
    10f0:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    10f2:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1B1);
#else 
        set_bit(TCCR1A, COM1B0);
        set_bit(TCCR1A, COM1B1);
#endif
        break;
    10f4:	08 95       	ret
      case OC_2:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR2, COM20);
    10f6:	85 b5       	in	r24, 0x25	; 37
    10f8:	8f 7e       	andi	r24, 0xEF	; 239
    10fa:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM21);
    10fc:	85 b5       	in	r24, 0x25	; 37
    10fe:	80 62       	ori	r24, 0x20	; 32
    1100:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    1102:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR2, COM21);
#else 
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    1104:	08 95       	ret
  }

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    1106:	87 e0       	ldi	r24, 0x07	; 7
    1108:	08 95       	ret
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    110a:	80 e0       	ldi	r24, 0x00	; 0
  }
    110c:	08 95       	ret

0000110e <PWM_init>:
  return TIMER_OK;
  }

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
    110e:	cf 92       	push	r12
    1110:	df 92       	push	r13
    1112:	ef 92       	push	r14
    1114:	ff 92       	push	r15
    1116:	cf 93       	push	r28
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    1118:	84 30       	cpi	r24, 0x04	; 4
    111a:	08 f0       	brcs	.+2      	; 0x111e <PWM_init+0x10>
    111c:	96 c0       	rjmp	.+300    	; 0x124a <PWM_init+0x13c>
    return WRONG_PWM_PIN;
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    111e:	9f ef       	ldi	r25, 0xFF	; 255
    1120:	92 0f       	add	r25, r18
    1122:	92 30       	cpi	r25, 0x02	; 2
    1124:	08 f0       	brcs	.+2      	; 0x1128 <PWM_init+0x1a>
    1126:	93 c0       	rjmp	.+294    	; 0x124e <PWM_init+0x140>
    1128:	6a 01       	movw	r12, r20
    112a:	7b 01       	movw	r14, r22
    112c:	c8 2f       	mov	r28, r24
    return WRONG_PWM_MODE;
    }
  switch (pwmPin) {
    112e:	83 30       	cpi	r24, 0x03	; 3
    1130:	18 f4       	brcc	.+6      	; 0x1138 <PWM_init+0x2a>
    1132:	81 30       	cpi	r24, 0x01	; 1
    1134:	28 f0       	brcs	.+10     	; 0x1140 <PWM_init+0x32>
    1136:	22 c0       	rjmp	.+68     	; 0x117c <PWM_init+0x6e>
    1138:	83 30       	cpi	r24, 0x03	; 3
    113a:	09 f4       	brne	.+2      	; 0x113e <PWM_init+0x30>
    113c:	64 c0       	rjmp	.+200    	; 0x1206 <PWM_init+0xf8>
    113e:	80 c0       	rjmp	.+256    	; 0x1240 <PWM_init+0x132>
      case OC_0:
        switch (mode) {
    1140:	21 30       	cpi	r18, 0x01	; 1
    1142:	19 f0       	breq	.+6      	; 0x114a <PWM_init+0x3c>
    1144:	22 30       	cpi	r18, 0x02	; 2
    1146:	41 f0       	breq	.+16     	; 0x1158 <PWM_init+0x4a>
    1148:	0d c0       	rjmp	.+26     	; 0x1164 <PWM_init+0x56>
            case PWM_FAST:
              set_bit(TCCR0, WGM00);
    114a:	83 b7       	in	r24, 0x33	; 51
    114c:	80 64       	ori	r24, 0x40	; 64
    114e:	83 bf       	out	0x33, r24	; 51
              set_bit(TCCR0, WGM01);
    1150:	83 b7       	in	r24, 0x33	; 51
    1152:	88 60       	ori	r24, 0x08	; 8
    1154:	83 bf       	out	0x33, r24	; 51
              break;
    1156:	06 c0       	rjmp	.+12     	; 0x1164 <PWM_init+0x56>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR0, WGM00);
    1158:	83 b7       	in	r24, 0x33	; 51
    115a:	80 64       	ori	r24, 0x40	; 64
    115c:	83 bf       	out	0x33, r24	; 51
              clear_bit(TCCR0, WGM01);
    115e:	83 b7       	in	r24, 0x33	; 51
    1160:	87 7f       	andi	r24, 0xF7	; 247
    1162:	83 bf       	out	0x33, r24	; 51
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR0 = (u8)(dutyCycle * 255);
    1164:	20 e0       	ldi	r18, 0x00	; 0
    1166:	30 e0       	ldi	r19, 0x00	; 0
    1168:	4f e7       	ldi	r20, 0x7F	; 127
    116a:	53 e4       	ldi	r21, 0x43	; 67
    116c:	c7 01       	movw	r24, r14
    116e:	b6 01       	movw	r22, r12
    1170:	0e 94 93 16 	call	0x2d26	; 0x2d26 <__mulsf3>
    1174:	0e 94 d6 15 	call	0x2bac	; 0x2bac <__fixunssfsi>
    1178:	6c bf       	out	0x3c, r22	; 60
        break;
    117a:	62 c0       	rjmp	.+196    	; 0x1240 <PWM_init+0x132>
        //? The fix for this issue is to use ICR1 as TOP instead (mode 14 in fast pwm), thus allowing OCR1A and OCR1B to be used to set the duty cycle while ICR1 is used tyo set the frequency.
        //? Mode 15 can be used at the cost of disabling PWM on OC1A, but we get more glitch-free variable frequency PWM signal on OC1B due to the double buffering of OC1A, which ICR1 doesn't have.
        //? Since I don't need a variable frequency pwm signal, ICR1 will be used as TOP by default and set to MAX.
      case OC_1A:
      case OC_1B:
        switch (mode) {
    117c:	21 30       	cpi	r18, 0x01	; 1
    117e:	19 f0       	breq	.+6      	; 0x1186 <PWM_init+0x78>
    1180:	22 30       	cpi	r18, 0x02	; 2
    1182:	91 f0       	breq	.+36     	; 0x11a8 <PWM_init+0x9a>
    1184:	21 c0       	rjmp	.+66     	; 0x11c8 <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
    1186:	8f b5       	in	r24, 0x2f	; 47
    1188:	8e 7f       	andi	r24, 0xFE	; 254
    118a:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
    118c:	8f b5       	in	r24, 0x2f	; 47
    118e:	82 60       	ori	r24, 0x02	; 2
    1190:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1B, WGM12);
    1192:	8e b5       	in	r24, 0x2e	; 46
    1194:	88 60       	ori	r24, 0x08	; 8
    1196:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
    1198:	8e b5       	in	r24, 0x2e	; 46
    119a:	80 61       	ori	r24, 0x10	; 16
    119c:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
    119e:	80 e2       	ldi	r24, 0x20	; 32
    11a0:	9e e4       	ldi	r25, 0x4E	; 78
    11a2:	97 bd       	out	0x27, r25	; 39
    11a4:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              set_bit(TCCR1B, WGM13);
#endif
              break;
    11a6:	10 c0       	rjmp	.+32     	; 0x11c8 <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              clear_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
    11a8:	8f b5       	in	r24, 0x2f	; 47
    11aa:	8e 7f       	andi	r24, 0xFE	; 254
    11ac:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
    11ae:	8f b5       	in	r24, 0x2f	; 47
    11b0:	82 60       	ori	r24, 0x02	; 2
    11b2:	8f bd       	out	0x2f, r24	; 47
              clear_bit(TCCR1B, WGM12);
    11b4:	8e b5       	in	r24, 0x2e	; 46
    11b6:	87 7f       	andi	r24, 0xF7	; 247
    11b8:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
    11ba:	8e b5       	in	r24, 0x2e	; 46
    11bc:	80 61       	ori	r24, 0x10	; 16
    11be:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
    11c0:	80 e2       	ldi	r24, 0x20	; 32
    11c2:	9e e4       	ldi	r25, 0x4E	; 78
    11c4:	97 bd       	out	0x27, r25	; 39
    11c6:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1B, WGM13);
#endif
              break;
          }
        // Enable the PWM function of the OC pin.
        switch (pwmPin) {
    11c8:	c1 30       	cpi	r28, 0x01	; 1
    11ca:	19 f0       	breq	.+6      	; 0x11d2 <PWM_init+0xc4>
    11cc:	c2 30       	cpi	r28, 0x02	; 2
    11ce:	71 f0       	breq	.+28     	; 0x11ec <PWM_init+0xde>
    11d0:	37 c0       	rjmp	.+110    	; 0x1240 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    11d2:	20 e0       	ldi	r18, 0x00	; 0
    11d4:	30 e4       	ldi	r19, 0x40	; 64
    11d6:	4c e9       	ldi	r20, 0x9C	; 156
    11d8:	56 e4       	ldi	r21, 0x46	; 70
    11da:	c7 01       	movw	r24, r14
    11dc:	b6 01       	movw	r22, r12
    11de:	0e 94 93 16 	call	0x2d26	; 0x2d26 <__mulsf3>
    11e2:	0e 94 d6 15 	call	0x2bac	; 0x2bac <__fixunssfsi>
    11e6:	7b bd       	out	0x2b, r23	; 43
    11e8:	6a bd       	out	0x2a, r22	; 42
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1A = (u16)(dutyCycle * 65535);
#endif
              break;
    11ea:	2a c0       	rjmp	.+84     	; 0x1240 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    11ec:	20 e0       	ldi	r18, 0x00	; 0
    11ee:	30 e4       	ldi	r19, 0x40	; 64
    11f0:	4c e9       	ldi	r20, 0x9C	; 156
    11f2:	56 e4       	ldi	r21, 0x46	; 70
    11f4:	c7 01       	movw	r24, r14
    11f6:	b6 01       	movw	r22, r12
    11f8:	0e 94 93 16 	call	0x2d26	; 0x2d26 <__mulsf3>
    11fc:	0e 94 d6 15 	call	0x2bac	; 0x2bac <__fixunssfsi>
    1200:	79 bd       	out	0x29, r23	; 41
    1202:	68 bd       	out	0x28, r22	; 40
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1B = (u16)(dutyCycle * 65535);
#endif
              break;
    1204:	1d c0       	rjmp	.+58     	; 0x1240 <PWM_init+0x132>
          }
        break;
      case OC_2:
        switch (mode) {
    1206:	21 30       	cpi	r18, 0x01	; 1
    1208:	19 f0       	breq	.+6      	; 0x1210 <PWM_init+0x102>
    120a:	22 30       	cpi	r18, 0x02	; 2
    120c:	41 f0       	breq	.+16     	; 0x121e <PWM_init+0x110>
    120e:	0d c0       	rjmp	.+26     	; 0x122a <PWM_init+0x11c>
            case PWM_FAST:
              set_bit(TCCR2, WGM20);
    1210:	85 b5       	in	r24, 0x25	; 37
    1212:	80 64       	ori	r24, 0x40	; 64
    1214:	85 bd       	out	0x25, r24	; 37
              set_bit(TCCR2, WGM21);
    1216:	85 b5       	in	r24, 0x25	; 37
    1218:	88 60       	ori	r24, 0x08	; 8
    121a:	85 bd       	out	0x25, r24	; 37
              break;
    121c:	06 c0       	rjmp	.+12     	; 0x122a <PWM_init+0x11c>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR2, WGM20);
    121e:	85 b5       	in	r24, 0x25	; 37
    1220:	80 64       	ori	r24, 0x40	; 64
    1222:	85 bd       	out	0x25, r24	; 37
              clear_bit(TCCR2, WGM21);
    1224:	85 b5       	in	r24, 0x25	; 37
    1226:	87 7f       	andi	r24, 0xF7	; 247
    1228:	85 bd       	out	0x25, r24	; 37
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR2 = (u8)(dutyCycle * 255);
    122a:	20 e0       	ldi	r18, 0x00	; 0
    122c:	30 e0       	ldi	r19, 0x00	; 0
    122e:	4f e7       	ldi	r20, 0x7F	; 127
    1230:	53 e4       	ldi	r21, 0x43	; 67
    1232:	c7 01       	movw	r24, r14
    1234:	b6 01       	movw	r22, r12
    1236:	0e 94 93 16 	call	0x2d26	; 0x2d26 <__mulsf3>
    123a:	0e 94 d6 15 	call	0x2bac	; 0x2bac <__fixunssfsi>
    123e:	63 bd       	out	0x23, r22	; 35
        break;
    }
  PWM_OCP_connect(pwmPin);
    1240:	8c 2f       	mov	r24, r28
    1242:	0e 94 59 08 	call	0x10b2	; 0x10b2 <PWM_OCP_connect>
  return TIMER_OK;
    1246:	80 e0       	ldi	r24, 0x00	; 0
    1248:	03 c0       	rjmp	.+6      	; 0x1250 <PWM_init+0x142>

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    124a:	87 e0       	ldi	r24, 0x07	; 7
    124c:	01 c0       	rjmp	.+2      	; 0x1250 <PWM_init+0x142>
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    return WRONG_PWM_MODE;
    124e:	86 e0       	ldi	r24, 0x06	; 6
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  PWM_OCP_connect(pwmPin);
  return TIMER_OK;
  }
    1250:	cf 91       	pop	r28
    1252:	ff 90       	pop	r15
    1254:	ef 90       	pop	r14
    1256:	df 90       	pop	r13
    1258:	cf 90       	pop	r12
    125a:	08 95       	ret

0000125c <PWM_set_DC>:
    }
  return TIMER_OK;
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
    125c:	28 2f       	mov	r18, r24
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    125e:	84 30       	cpi	r24, 0x04	; 4
    1260:	c0 f5       	brcc	.+112    	; 0x12d2 <PWM_set_DC+0x76>
    1262:	cb 01       	movw	r24, r22
    1264:	ba 01       	movw	r22, r20
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    1266:	21 30       	cpi	r18, 0x01	; 1
    1268:	89 f0       	breq	.+34     	; 0x128c <PWM_set_DC+0x30>
    126a:	28 f0       	brcs	.+10     	; 0x1276 <PWM_set_DC+0x1a>
    126c:	22 30       	cpi	r18, 0x02	; 2
    126e:	d1 f0       	breq	.+52     	; 0x12a4 <PWM_set_DC+0x48>
    1270:	23 30       	cpi	r18, 0x03	; 3
    1272:	21 f1       	breq	.+72     	; 0x12bc <PWM_set_DC+0x60>
    1274:	30 c0       	rjmp	.+96     	; 0x12d6 <PWM_set_DC+0x7a>
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
    1276:	20 e0       	ldi	r18, 0x00	; 0
    1278:	30 e0       	ldi	r19, 0x00	; 0
    127a:	4f e7       	ldi	r20, 0x7F	; 127
    127c:	53 e4       	ldi	r21, 0x43	; 67
    127e:	0e 94 93 16 	call	0x2d26	; 0x2d26 <__mulsf3>
    1282:	0e 94 d6 15 	call	0x2bac	; 0x2bac <__fixunssfsi>
    1286:	6c bf       	out	0x3c, r22	; 60
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    1288:	80 e0       	ldi	r24, 0x00	; 0
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
        break;
    128a:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    128c:	20 e0       	ldi	r18, 0x00	; 0
    128e:	30 e4       	ldi	r19, 0x40	; 64
    1290:	4c e9       	ldi	r20, 0x9C	; 156
    1292:	56 e4       	ldi	r21, 0x46	; 70
    1294:	0e 94 93 16 	call	0x2d26	; 0x2d26 <__mulsf3>
    1298:	0e 94 d6 15 	call	0x2bac	; 0x2bac <__fixunssfsi>
    129c:	7b bd       	out	0x2b, r23	; 43
    129e:	6a bd       	out	0x2a, r22	; 42
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    12a0:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1A = (u16)(dutyCycle * 65535);
#endif
        break;
    12a2:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    12a4:	20 e0       	ldi	r18, 0x00	; 0
    12a6:	30 e4       	ldi	r19, 0x40	; 64
    12a8:	4c e9       	ldi	r20, 0x9C	; 156
    12aa:	56 e4       	ldi	r21, 0x46	; 70
    12ac:	0e 94 93 16 	call	0x2d26	; 0x2d26 <__mulsf3>
    12b0:	0e 94 d6 15 	call	0x2bac	; 0x2bac <__fixunssfsi>
    12b4:	79 bd       	out	0x29, r23	; 41
    12b6:	68 bd       	out	0x28, r22	; 40
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    12b8:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
    12ba:	08 95       	ret
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
    12bc:	20 e0       	ldi	r18, 0x00	; 0
    12be:	30 e0       	ldi	r19, 0x00	; 0
    12c0:	4f e7       	ldi	r20, 0x7F	; 127
    12c2:	53 e4       	ldi	r21, 0x43	; 67
    12c4:	0e 94 93 16 	call	0x2d26	; 0x2d26 <__mulsf3>
    12c8:	0e 94 d6 15 	call	0x2bac	; 0x2bac <__fixunssfsi>
    12cc:	63 bd       	out	0x23, r22	; 35
        break;
    }
  return TIMER_OK;
    12ce:	80 e0       	ldi	r24, 0x00	; 0
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    12d0:	08 95       	ret
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    12d2:	87 e0       	ldi	r24, 0x07	; 7
    12d4:	08 95       	ret
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    12d6:	80 e0       	ldi	r24, 0x00	; 0
  }
    12d8:	08 95       	ret

000012da <UART_sendChar>:
  }

// Receive a Char using UART
void UART_receiveChar(s8* x) {
  while (!read_bit(UCSRA, RXC)); // Wait for the data to be received.
  *x = UDR;
    12da:	5d 9b       	sbis	0x0b, 5	; 11
    12dc:	fe cf       	rjmp	.-4      	; 0x12da <UART_sendChar>
    12de:	8c b9       	out	0x0c, r24	; 12
    12e0:	5e 9b       	sbis	0x0b, 6	; 11
    12e2:	fe cf       	rjmp	.-4      	; 0x12e0 <UART_sendChar+0x6>
    12e4:	08 95       	ret

000012e6 <UART_sendString>:
  }

void UART_sendString(s8* str) {
    12e6:	cf 92       	push	r12
    12e8:	df 92       	push	r13
    12ea:	ef 92       	push	r14
    12ec:	ff 92       	push	r15
    12ee:	cf 93       	push	r28
    12f0:	df 93       	push	r29
    12f2:	ec 01       	movw	r28, r24
  u32 i = 0;
    12f4:	c1 2c       	mov	r12, r1
    12f6:	d1 2c       	mov	r13, r1
    12f8:	76 01       	movw	r14, r12
  while (str[i] != 0) {
    12fa:	07 c0       	rjmp	.+14     	; 0x130a <UART_sendString+0x24>
    UART_sendChar(str[i]);
    12fc:	0e 94 6d 09 	call	0x12da	; 0x12da <UART_sendChar>
    i++;
    1300:	8f ef       	ldi	r24, 0xFF	; 255
    1302:	c8 1a       	sub	r12, r24
    1304:	d8 0a       	sbc	r13, r24
    1306:	e8 0a       	sbc	r14, r24
    1308:	f8 0a       	sbc	r15, r24
  *x = UDR;
  }

void UART_sendString(s8* str) {
  u32 i = 0;
  while (str[i] != 0) {
    130a:	fe 01       	movw	r30, r28
    130c:	ec 0d       	add	r30, r12
    130e:	fd 1d       	adc	r31, r13
    1310:	80 81       	ld	r24, Z
    1312:	81 11       	cpse	r24, r1
    1314:	f3 cf       	rjmp	.-26     	; 0x12fc <UART_sendString+0x16>
    UART_sendChar(str[i]);
    i++;
    }
  UART_sendChar(0); // Send null to terminate the string
    1316:	0e 94 6d 09 	call	0x12da	; 0x12da <UART_sendChar>
  }
    131a:	df 91       	pop	r29
    131c:	cf 91       	pop	r28
    131e:	ff 90       	pop	r15
    1320:	ef 90       	pop	r14
    1322:	df 90       	pop	r13
    1324:	cf 90       	pop	r12
    1326:	08 95       	ret

00001328 <Door_init>:

#include "door.h"

 // Initialize the servo for the door
void Door_init(void) {
  Servo_init();
    1328:	0e 94 0a 04 	call	0x814	; 0x814 <Servo_init>
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    132c:	80 e0       	ldi	r24, 0x00	; 0
    132e:	0e 94 1d 04 	call	0x83a	; 0x83a <Servo_move_to_angle>
    1332:	08 95       	ret

00001334 <Door_open>:
  }

// Open the door by moving the servo to the open angle
void Door_open(void) {
  Servo_move_to_angle(DOOR_OPEN_ANGLE);
    1334:	84 eb       	ldi	r24, 0xB4	; 180
    1336:	0e 94 1d 04 	call	0x83a	; 0x83a <Servo_move_to_angle>
    133a:	08 95       	ret

0000133c <Door_close>:
  }

// Close the door by moving the servo to the close angle
void Door_close(void) {
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    133c:	80 e0       	ldi	r24, 0x00	; 0
    133e:	0e 94 1d 04 	call	0x83a	; 0x83a <Servo_move_to_angle>
    1342:	08 95       	ret

00001344 <Lamps_init>:

#include "lights.h"

 // Initializes all six lamps
void Lamps_init(void) {
  LED_init(LAMP_1_PORT, LAMP_1_PIN);
    1344:	62 e0       	ldi	r22, 0x02	; 2
    1346:	83 e4       	ldi	r24, 0x43	; 67
    1348:	0e 94 e7 03 	call	0x7ce	; 0x7ce <LED_init>
  LED_init(LAMP_2_PORT, LAMP_2_PIN);
    134c:	63 e0       	ldi	r22, 0x03	; 3
    134e:	83 e4       	ldi	r24, 0x43	; 67
    1350:	0e 94 e7 03 	call	0x7ce	; 0x7ce <LED_init>
  LED_init(LAMP_3_PORT, LAMP_3_PIN);
    1354:	64 e0       	ldi	r22, 0x04	; 4
    1356:	83 e4       	ldi	r24, 0x43	; 67
    1358:	0e 94 e7 03 	call	0x7ce	; 0x7ce <LED_init>
  LED_init(LAMP_4_PORT, LAMP_4_PIN);
    135c:	65 e0       	ldi	r22, 0x05	; 5
    135e:	83 e4       	ldi	r24, 0x43	; 67
    1360:	0e 94 e7 03 	call	0x7ce	; 0x7ce <LED_init>
  LED_init(LAMP_5_PORT, LAMP_5_PIN);
    1364:	66 e0       	ldi	r22, 0x06	; 6
    1366:	83 e4       	ldi	r24, 0x43	; 67
    1368:	0e 94 e7 03 	call	0x7ce	; 0x7ce <LED_init>
  LED_init(LAMP_6_DIMMABLE_PORT, LAMP_6_DIMMABLE_PIN);
    136c:	67 e0       	ldi	r22, 0x07	; 7
    136e:	84 e4       	ldi	r24, 0x44	; 68
    1370:	0e 94 e7 03 	call	0x7ce	; 0x7ce <LED_init>
  // Initialize the pwm pin which lamp6 is on for brightness control
  PWM_init(LAMP_6_DIMMABLE_PWM_PIN, 0, PWM_FAST);
    1374:	21 e0       	ldi	r18, 0x01	; 1
    1376:	40 e0       	ldi	r20, 0x00	; 0
    1378:	50 e0       	ldi	r21, 0x00	; 0
    137a:	ba 01       	movw	r22, r20
    137c:	83 e0       	ldi	r24, 0x03	; 3
    137e:	0e 94 87 08 	call	0x110e	; 0x110e <PWM_init>

  Timer_start(TIMER_2, LAMP_6_DIMMABLE_PRESCALAR);
    1382:	60 e0       	ldi	r22, 0x00	; 0
    1384:	71 e0       	ldi	r23, 0x01	; 1
    1386:	82 e0       	ldi	r24, 0x02	; 2
    1388:	0e 94 17 08 	call	0x102e	; 0x102e <Timer_start>
    138c:	08 95       	ret

0000138e <Lamp_on>:
  }

// Turn on a lamp
void Lamp_on(u8 lampNumber) {
  switch (lampNumber) {
    138e:	83 30       	cpi	r24, 0x03	; 3
    1390:	b1 f0       	breq	.+44     	; 0x13be <Lamp_on+0x30>
    1392:	28 f4       	brcc	.+10     	; 0x139e <Lamp_on+0x10>
    1394:	81 30       	cpi	r24, 0x01	; 1
    1396:	49 f0       	breq	.+18     	; 0x13aa <Lamp_on+0x1c>
    1398:	82 30       	cpi	r24, 0x02	; 2
    139a:	61 f0       	breq	.+24     	; 0x13b4 <Lamp_on+0x26>
    139c:	08 95       	ret
    139e:	85 30       	cpi	r24, 0x05	; 5
    13a0:	c1 f0       	breq	.+48     	; 0x13d2 <Lamp_on+0x44>
    13a2:	90 f0       	brcs	.+36     	; 0x13c8 <Lamp_on+0x3a>
    13a4:	86 30       	cpi	r24, 0x06	; 6
    13a6:	d1 f0       	breq	.+52     	; 0x13dc <Lamp_on+0x4e>
    13a8:	08 95       	ret
      case LAMP_1:
        LED_on(LAMP_1_PORT, LAMP_1_PIN);
    13aa:	62 e0       	ldi	r22, 0x02	; 2
    13ac:	83 e4       	ldi	r24, 0x43	; 67
    13ae:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <LED_on>
        break;
    13b2:	08 95       	ret
      case LAMP_2:
        LED_on(LAMP_2_PORT, LAMP_2_PIN);
    13b4:	63 e0       	ldi	r22, 0x03	; 3
    13b6:	83 e4       	ldi	r24, 0x43	; 67
    13b8:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <LED_on>
        break;
    13bc:	08 95       	ret
      case LAMP_3:
        LED_on(LAMP_3_PORT, LAMP_3_PIN);
    13be:	64 e0       	ldi	r22, 0x04	; 4
    13c0:	83 e4       	ldi	r24, 0x43	; 67
    13c2:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <LED_on>
        break;
    13c6:	08 95       	ret
      case LAMP_4:
        LED_on(LAMP_4_PORT, LAMP_4_PIN);
    13c8:	65 e0       	ldi	r22, 0x05	; 5
    13ca:	83 e4       	ldi	r24, 0x43	; 67
    13cc:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <LED_on>
        break;
    13d0:	08 95       	ret
      case LAMP_5:
        LED_on(LAMP_5_PORT, LAMP_5_PIN);
    13d2:	66 e0       	ldi	r22, 0x06	; 6
    13d4:	83 e4       	ldi	r24, 0x43	; 67
    13d6:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <LED_on>
        break;
    13da:	08 95       	ret
      case LAMP_6:
        PWM_OCP_connect(LAMP_6_DIMMABLE_PWM_PIN);
    13dc:	83 e0       	ldi	r24, 0x03	; 3
    13de:	0e 94 59 08 	call	0x10b2	; 0x10b2 <PWM_OCP_connect>
    13e2:	08 95       	ret

000013e4 <Lamp_off>:
    }
  }

// Turn off a lamp
void Lamp_off(u8 lampNumber) {
  switch (lampNumber) {
    13e4:	83 30       	cpi	r24, 0x03	; 3
    13e6:	b1 f0       	breq	.+44     	; 0x1414 <Lamp_off+0x30>
    13e8:	28 f4       	brcc	.+10     	; 0x13f4 <Lamp_off+0x10>
    13ea:	81 30       	cpi	r24, 0x01	; 1
    13ec:	49 f0       	breq	.+18     	; 0x1400 <Lamp_off+0x1c>
    13ee:	82 30       	cpi	r24, 0x02	; 2
    13f0:	61 f0       	breq	.+24     	; 0x140a <Lamp_off+0x26>
    13f2:	08 95       	ret
    13f4:	85 30       	cpi	r24, 0x05	; 5
    13f6:	c1 f0       	breq	.+48     	; 0x1428 <Lamp_off+0x44>
    13f8:	90 f0       	brcs	.+36     	; 0x141e <Lamp_off+0x3a>
    13fa:	86 30       	cpi	r24, 0x06	; 6
    13fc:	d1 f0       	breq	.+52     	; 0x1432 <Lamp_off+0x4e>
    13fe:	08 95       	ret
      case LAMP_1:
        LED_off(LAMP_1_PORT, LAMP_1_PIN);
    1400:	62 e0       	ldi	r22, 0x02	; 2
    1402:	83 e4       	ldi	r24, 0x43	; 67
    1404:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LED_off>
        break;
    1408:	08 95       	ret
      case LAMP_2:
        LED_off(LAMP_2_PORT, LAMP_2_PIN);
    140a:	63 e0       	ldi	r22, 0x03	; 3
    140c:	83 e4       	ldi	r24, 0x43	; 67
    140e:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LED_off>
        break;
    1412:	08 95       	ret
      case LAMP_3:
        LED_off(LAMP_3_PORT, LAMP_3_PIN);
    1414:	64 e0       	ldi	r22, 0x04	; 4
    1416:	83 e4       	ldi	r24, 0x43	; 67
    1418:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LED_off>
        break;
    141c:	08 95       	ret
      case LAMP_4:
        LED_off(LAMP_4_PORT, LAMP_4_PIN);
    141e:	65 e0       	ldi	r22, 0x05	; 5
    1420:	83 e4       	ldi	r24, 0x43	; 67
    1422:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LED_off>
        break;
    1426:	08 95       	ret
      case LAMP_5:
        LED_off(LAMP_5_PORT, LAMP_5_PIN);
    1428:	66 e0       	ldi	r22, 0x06	; 6
    142a:	83 e4       	ldi	r24, 0x43	; 67
    142c:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LED_off>
        break;
    1430:	08 95       	ret
      case LAMP_6:
        PWM_OCP_disconnect(LAMP_6_DIMMABLE_PWM_PIN);
    1432:	83 e0       	ldi	r24, 0x03	; 3
    1434:	0e 94 2b 08 	call	0x1056	; 0x1056 <PWM_OCP_disconnect>
    1438:	08 95       	ret

0000143a <Lamp_toggle>:
    }
  }

// Toggle a lamp
void Lamp_toggle(u8 lampNumber) {
  switch (lampNumber) {
    143a:	83 30       	cpi	r24, 0x03	; 3
    143c:	b1 f0       	breq	.+44     	; 0x146a <Lamp_toggle+0x30>
    143e:	28 f4       	brcc	.+10     	; 0x144a <Lamp_toggle+0x10>
    1440:	81 30       	cpi	r24, 0x01	; 1
    1442:	49 f0       	breq	.+18     	; 0x1456 <Lamp_toggle+0x1c>
    1444:	82 30       	cpi	r24, 0x02	; 2
    1446:	61 f0       	breq	.+24     	; 0x1460 <Lamp_toggle+0x26>
    1448:	08 95       	ret
    144a:	85 30       	cpi	r24, 0x05	; 5
    144c:	c1 f0       	breq	.+48     	; 0x147e <Lamp_toggle+0x44>
    144e:	90 f0       	brcs	.+36     	; 0x1474 <Lamp_toggle+0x3a>
    1450:	86 30       	cpi	r24, 0x06	; 6
    1452:	d1 f0       	breq	.+52     	; 0x1488 <Lamp_toggle+0x4e>
    1454:	08 95       	ret
      case LAMP_1:
        LED_toggle(LAMP_1_PORT, LAMP_1_PIN);
    1456:	62 e0       	ldi	r22, 0x02	; 2
    1458:	83 e4       	ldi	r24, 0x43	; 67
    145a:	0e 94 02 04 	call	0x804	; 0x804 <LED_toggle>
        break;
    145e:	08 95       	ret
      case LAMP_2:
        LED_toggle(LAMP_2_PORT, LAMP_2_PIN);
    1460:	63 e0       	ldi	r22, 0x03	; 3
    1462:	83 e4       	ldi	r24, 0x43	; 67
    1464:	0e 94 02 04 	call	0x804	; 0x804 <LED_toggle>
        break;
    1468:	08 95       	ret
      case LAMP_3:
        LED_toggle(LAMP_3_PORT, LAMP_3_PIN);
    146a:	64 e0       	ldi	r22, 0x04	; 4
    146c:	83 e4       	ldi	r24, 0x43	; 67
    146e:	0e 94 02 04 	call	0x804	; 0x804 <LED_toggle>
        break;
    1472:	08 95       	ret
      case LAMP_4:
        LED_toggle(LAMP_4_PORT, LAMP_4_PIN);
    1474:	65 e0       	ldi	r22, 0x05	; 5
    1476:	83 e4       	ldi	r24, 0x43	; 67
    1478:	0e 94 02 04 	call	0x804	; 0x804 <LED_toggle>
        break;
    147c:	08 95       	ret
      case LAMP_5:
        LED_toggle(LAMP_5_PORT, LAMP_5_PIN);
    147e:	66 e0       	ldi	r22, 0x06	; 6
    1480:	83 e4       	ldi	r24, 0x43	; 67
    1482:	0e 94 02 04 	call	0x804	; 0x804 <LED_toggle>
        break;
    1486:	08 95       	ret
      case LAMP_6:
        if (read_bit(TCCR2, COM21)) { // OC pin is connected and lamp6 is on
    1488:	05 b4       	in	r0, 0x25	; 37
    148a:	05 fe       	sbrs	r0, 5
    148c:	04 c0       	rjmp	.+8      	; 0x1496 <Lamp_toggle+0x5c>
          Lamp_off(6);
    148e:	86 e0       	ldi	r24, 0x06	; 6
    1490:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <Lamp_off>
    1494:	08 95       	ret
          }
        else {
          Lamp_on(6);
    1496:	86 e0       	ldi	r24, 0x06	; 6
    1498:	0e 94 c7 09 	call	0x138e	; 0x138e <Lamp_on>
    149c:	08 95       	ret

0000149e <Lamp_dimmable_set_brightness>:
        break;
    }
  }

// Adjust the brightness of the dimmable lamp
void Lamp_dimmable_set_brightness(double brightness) {
    149e:	ab 01       	movw	r20, r22
    14a0:	bc 01       	movw	r22, r24
  PWM_set_DC(LAMP_6_DIMMABLE_PWM_PIN, brightness);
    14a2:	83 e0       	ldi	r24, 0x03	; 3
    14a4:	0e 94 2e 09 	call	0x125c	; 0x125c <PWM_set_DC>
    14a8:	08 95       	ret

000014aa <Local_access_init>:

ST_User_t local_user;

// Initialize the local control system
void Local_access_init(void) {
  LCD_init();
    14aa:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_init>
  Keypad_init();
    14ae:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <Keypad_init>
  User_DB_init();
    14b2:	0e 94 9f 12 	call	0x253e	; 0x253e <User_DB_init>
    14b6:	08 95       	ret

000014b8 <Get_running_devices>:
  }

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
    14b8:	cf 93       	push	r28
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    14ba:	c0 e0       	ldi	r28, 0x00	; 0
    14bc:	0a c0       	rjmp	.+20     	; 0x14d2 <Get_running_devices+0x1a>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
    14be:	4c 2f       	mov	r20, r28
    14c0:	50 e0       	ldi	r21, 0x00	; 0
    14c2:	45 52       	subi	r20, 0x25	; 37
    14c4:	58 4f       	sbci	r21, 0xF8	; 248
    14c6:	63 e4       	ldi	r22, 0x43	; 67
    14c8:	82 e0       	ldi	r24, 0x02	; 2
    14ca:	8c 0f       	add	r24, r28
    14cc:	0e 94 8c 05 	call	0xb18	; 0xb18 <DIO_Read>

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    14d0:	cf 5f       	subi	r28, 0xFF	; 255
    14d2:	c5 30       	cpi	r28, 0x05	; 5
    14d4:	a0 f3       	brcs	.-24     	; 0x14be <Get_running_devices+0x6>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
    }
  // Check the dimmable lamp
  running_devices[5] = read_bit(TCCR2, COM21); // To see if the OC pins are connected
    14d6:	85 b5       	in	r24, 0x25	; 37
    14d8:	85 fb       	bst	r24, 5
    14da:	88 27       	eor	r24, r24
    14dc:	80 f9       	bld	r24, 0
    14de:	80 93 e0 07 	sts	0x07E0, r24	; 0x8007e0 <running_devices+0x5>
  // Check the AC
  DIO_Read(7, PORT_D, &running_devices[6]);
    14e2:	41 ee       	ldi	r20, 0xE1	; 225
    14e4:	57 e0       	ldi	r21, 0x07	; 7
    14e6:	64 e4       	ldi	r22, 0x44	; 68
    14e8:	87 e0       	ldi	r24, 0x07	; 7
    14ea:	0e 94 8c 05 	call	0xb18	; 0xb18 <DIO_Read>
  // The value in OCR2 determine the brightness of the led
  dimmer_brightness = OCR2;
    14ee:	83 b5       	in	r24, 0x23	; 35
    14f0:	90 e0       	ldi	r25, 0x00	; 0
    14f2:	90 93 d9 07 	sts	0x07D9, r25	; 0x8007d9 <dimmer_brightness+0x1>
    14f6:	80 93 d8 07 	sts	0x07D8, r24	; 0x8007d8 <dimmer_brightness>
  }
    14fa:	cf 91       	pop	r28
    14fc:	08 95       	ret

000014fe <Show_bottom_options_menu>:

// Shows the bottom line options on the LCD
void Show_bottom_options_menu(u8 menu) {
  switch (menu) {
    14fe:	90 e0       	ldi	r25, 0x00	; 0
    1500:	fc 01       	movw	r30, r24
    1502:	31 97       	sbiw	r30, 0x01	; 1
    1504:	ea 30       	cpi	r30, 0x0A	; 10
    1506:	f1 05       	cpc	r31, r1
    1508:	08 f0       	brcs	.+2      	; 0x150c <Show_bottom_options_menu+0xe>
    150a:	49 c0       	rjmp	.+146    	; 0x159e <Show_bottom_options_menu+0xa0>
    150c:	e5 58       	subi	r30, 0x85	; 133
    150e:	ff 4f       	sbci	r31, 0xFF	; 255
    1510:	0c 94 00 17 	jmp	0x2e00	; 0x2e00 <__tablejump2__>
      case 1:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_1);
    1514:	40 e7       	ldi	r20, 0x70	; 112
    1516:	50 e0       	ldi	r21, 0x00	; 0
    1518:	61 e0       	ldi	r22, 0x01	; 1
    151a:	80 e0       	ldi	r24, 0x00	; 0
    151c:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
        break;
    1520:	08 95       	ret
      case 2:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_2);
    1522:	41 e8       	ldi	r20, 0x81	; 129
    1524:	50 e0       	ldi	r21, 0x00	; 0
    1526:	61 e0       	ldi	r22, 0x01	; 1
    1528:	80 e0       	ldi	r24, 0x00	; 0
    152a:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
        break;
    152e:	08 95       	ret
      case 3:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_3);
    1530:	42 e9       	ldi	r20, 0x92	; 146
    1532:	50 e0       	ldi	r21, 0x00	; 0
    1534:	61 e0       	ldi	r22, 0x01	; 1
    1536:	80 e0       	ldi	r24, 0x00	; 0
    1538:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
        break;
    153c:	08 95       	ret
      case 4:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_4);
    153e:	43 ea       	ldi	r20, 0xA3	; 163
    1540:	50 e0       	ldi	r21, 0x00	; 0
    1542:	61 e0       	ldi	r22, 0x01	; 1
    1544:	80 e0       	ldi	r24, 0x00	; 0
    1546:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
        break;
    154a:	08 95       	ret
      case 5:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_5);
    154c:	44 eb       	ldi	r20, 0xB4	; 180
    154e:	50 e0       	ldi	r21, 0x00	; 0
    1550:	61 e0       	ldi	r22, 0x01	; 1
    1552:	80 e0       	ldi	r24, 0x00	; 0
    1554:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
        break;
    1558:	08 95       	ret
      case 6:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_6);
    155a:	45 ec       	ldi	r20, 0xC5	; 197
    155c:	50 e0       	ldi	r21, 0x00	; 0
    155e:	61 e0       	ldi	r22, 0x01	; 1
    1560:	80 e0       	ldi	r24, 0x00	; 0
    1562:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
        break;
    1566:	08 95       	ret
      case 7:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_7);
    1568:	46 ed       	ldi	r20, 0xD6	; 214
    156a:	50 e0       	ldi	r21, 0x00	; 0
    156c:	61 e0       	ldi	r22, 0x01	; 1
    156e:	80 e0       	ldi	r24, 0x00	; 0
    1570:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
        break;
    1574:	08 95       	ret
      case 8:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_8);
    1576:	47 ee       	ldi	r20, 0xE7	; 231
    1578:	50 e0       	ldi	r21, 0x00	; 0
    157a:	61 e0       	ldi	r22, 0x01	; 1
    157c:	80 e0       	ldi	r24, 0x00	; 0
    157e:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
        break;
    1582:	08 95       	ret
      case 9:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_9);
    1584:	48 ef       	ldi	r20, 0xF8	; 248
    1586:	50 e0       	ldi	r21, 0x00	; 0
    1588:	61 e0       	ldi	r22, 0x01	; 1
    158a:	80 e0       	ldi	r24, 0x00	; 0
    158c:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
        break;
    1590:	08 95       	ret
      case 10:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_10);
    1592:	49 e0       	ldi	r20, 0x09	; 9
    1594:	51 e0       	ldi	r21, 0x01	; 1
    1596:	61 e0       	ldi	r22, 0x01	; 1
    1598:	80 e0       	ldi	r24, 0x00	; 0
    159a:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
    159e:	08 95       	ret

000015a0 <Show_side_options_menu>:
    }
  }

// Shows the side options list on the LCD
void Show_side_options_menu(void) {
  LCD_write_string_xy(12, 0, BACKSPACE_OPTION);
    15a0:	4a e1       	ldi	r20, 0x1A	; 26
    15a2:	51 e0       	ldi	r21, 0x01	; 1
    15a4:	60 e0       	ldi	r22, 0x00	; 0
    15a6:	8c e0       	ldi	r24, 0x0C	; 12
    15a8:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
  LCD_write_string_xy(12, 1, ENTER_OPTION);
    15ac:	4f e1       	ldi	r20, 0x1F	; 31
    15ae:	51 e0       	ldi	r21, 0x01	; 1
    15b0:	61 e0       	ldi	r22, 0x01	; 1
    15b2:	8c e0       	ldi	r24, 0x0C	; 12
    15b4:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
    15b8:	08 95       	ret

000015ba <Show_running_devices>:
  }

// Shows the currently running devices with the appropriate control menu appended (Screen controls and login- no device controls)
void Show_running_devices(u8 screen) {
    15ba:	ef 92       	push	r14
    15bc:	ff 92       	push	r15
    15be:	1f 93       	push	r17
    15c0:	cf 93       	push	r28
    15c2:	df 93       	push	r29
    15c4:	00 d0       	rcall	.+0      	; 0x15c6 <Show_running_devices+0xc>
    15c6:	00 d0       	rcall	.+0      	; 0x15c8 <Show_running_devices+0xe>
    15c8:	cd b7       	in	r28, 0x3d	; 61
    15ca:	de b7       	in	r29, 0x3e	; 62
    15cc:	18 2f       	mov	r17, r24
  // Do nothing if the correct screen is shown.
  // if (screen == running_devices_screen) return;
  LCD_clear_screen();
    15ce:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
  // Write device name
  switch (screen) {
    15d2:	17 30       	cpi	r17, 0x07	; 7
    15d4:	39 f4       	brne	.+14     	; 0x15e4 <Show_running_devices+0x2a>
      case 7:
        LCD_write_string_xy(0, 0, "AC: ");
    15d6:	44 e2       	ldi	r20, 0x24	; 36
    15d8:	51 e0       	ldi	r21, 0x01	; 1
    15da:	60 e0       	ldi	r22, 0x00	; 0
    15dc:	80 e0       	ldi	r24, 0x00	; 0
    15de:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
        break;
    15e2:	0e c0       	rjmp	.+28     	; 0x1600 <Show_running_devices+0x46>
      default:
        LCD_write_string_xy(0, 0, "Lamp");
    15e4:	49 e2       	ldi	r20, 0x29	; 41
    15e6:	51 e0       	ldi	r21, 0x01	; 1
    15e8:	60 e0       	ldi	r22, 0x00	; 0
    15ea:	80 e0       	ldi	r24, 0x00	; 0
    15ec:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
        LCD_sendData(screen + 48);
    15f0:	80 e3       	ldi	r24, 0x30	; 48
    15f2:	81 0f       	add	r24, r17
    15f4:	0e 94 3a 03 	call	0x674	; 0x674 <LCD_sendData>
        LCD_write_string(":  ");
    15f8:	8e e2       	ldi	r24, 0x2E	; 46
    15fa:	91 e0       	ldi	r25, 0x01	; 1
    15fc:	0e 94 b0 03 	call	0x760	; 0x760 <LCD_write_string>
        break;
    }
  if (screen == 6) {
    1600:	16 30       	cpi	r17, 0x06	; 6
    1602:	49 f5       	brne	.+82     	; 0x1656 <Show_running_devices+0x9c>
    s8 brightness[4];
    sprintf(brightness, "%d%%", (u8)((double)dimmer_brightness / 2.55));
    1604:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1608:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    160c:	07 2e       	mov	r0, r23
    160e:	00 0c       	add	r0, r0
    1610:	88 0b       	sbc	r24, r24
    1612:	99 0b       	sbc	r25, r25
    1614:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <__floatsisf>
    1618:	23 e3       	ldi	r18, 0x33	; 51
    161a:	33 e3       	ldi	r19, 0x33	; 51
    161c:	43 e2       	ldi	r20, 0x23	; 35
    161e:	50 e4       	ldi	r21, 0x40	; 64
    1620:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__divsf3>
    1624:	0e 94 d6 15 	call	0x2bac	; 0x2bac <__fixunssfsi>
    1628:	1f 92       	push	r1
    162a:	6f 93       	push	r22
    162c:	82 e3       	ldi	r24, 0x32	; 50
    162e:	91 e0       	ldi	r25, 0x01	; 1
    1630:	9f 93       	push	r25
    1632:	8f 93       	push	r24
    1634:	ce 01       	movw	r24, r28
    1636:	01 96       	adiw	r24, 0x01	; 1
    1638:	7c 01       	movw	r14, r24
    163a:	9f 93       	push	r25
    163c:	8f 93       	push	r24
    163e:	0e 94 16 17 	call	0x2e2c	; 0x2e2c <sprintf>
    LCD_write_string(brightness);
    1642:	c7 01       	movw	r24, r14
    1644:	0e 94 b0 03 	call	0x760	; 0x760 <LCD_write_string>
    1648:	0f 90       	pop	r0
    164a:	0f 90       	pop	r0
    164c:	0f 90       	pop	r0
    164e:	0f 90       	pop	r0
    1650:	0f 90       	pop	r0
    1652:	0f 90       	pop	r0
    1654:	10 c0       	rjmp	.+32     	; 0x1676 <Show_running_devices+0xbc>
    }
  else {// Write the device state
    if (running_devices[screen - 1])
    1656:	e1 2f       	mov	r30, r17
    1658:	f0 e0       	ldi	r31, 0x00	; 0
    165a:	e6 52       	subi	r30, 0x26	; 38
    165c:	f8 4f       	sbci	r31, 0xF8	; 248
    165e:	80 81       	ld	r24, Z
    1660:	88 23       	and	r24, r24
    1662:	29 f0       	breq	.+10     	; 0x166e <Show_running_devices+0xb4>
      LCD_write_string("On");
    1664:	87 e3       	ldi	r24, 0x37	; 55
    1666:	91 e0       	ldi	r25, 0x01	; 1
    1668:	0e 94 b0 03 	call	0x760	; 0x760 <LCD_write_string>
    166c:	04 c0       	rjmp	.+8      	; 0x1676 <Show_running_devices+0xbc>
    else
      LCD_write_string("Off");
    166e:	8a e3       	ldi	r24, 0x3A	; 58
    1670:	91 e0       	ldi	r25, 0x01	; 1
    1672:	0e 94 b0 03 	call	0x760	; 0x760 <LCD_write_string>
    }
  // Show the options menu
  switch (screen) {
    1676:	11 30       	cpi	r17, 0x01	; 1
    1678:	19 f0       	breq	.+6      	; 0x1680 <Show_running_devices+0xc6>
    167a:	17 30       	cpi	r17, 0x07	; 7
    167c:	29 f0       	breq	.+10     	; 0x1688 <Show_running_devices+0xce>
    167e:	08 c0       	rjmp	.+16     	; 0x1690 <Show_running_devices+0xd6>
      case 1:
        Show_bottom_options_menu(3);
    1680:	83 e0       	ldi	r24, 0x03	; 3
    1682:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <Show_bottom_options_menu>
        break;
    1686:	07 c0       	rjmp	.+14     	; 0x1696 <Show_running_devices+0xdc>
      case 7:
        Show_bottom_options_menu(2);
    1688:	82 e0       	ldi	r24, 0x02	; 2
    168a:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <Show_bottom_options_menu>
        break;
    168e:	03 c0       	rjmp	.+6      	; 0x1696 <Show_running_devices+0xdc>
      default:
        Show_bottom_options_menu(1);
    1690:	81 e0       	ldi	r24, 0x01	; 1
    1692:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <Show_bottom_options_menu>
        break;
    }
  }
    1696:	0f 90       	pop	r0
    1698:	0f 90       	pop	r0
    169a:	0f 90       	pop	r0
    169c:	0f 90       	pop	r0
    169e:	df 91       	pop	r29
    16a0:	cf 91       	pop	r28
    16a2:	1f 91       	pop	r17
    16a4:	ff 90       	pop	r15
    16a6:	ef 90       	pop	r14
    16a8:	08 95       	ret

000016aa <Show_devices_controls>:

// Shows the currently running devices with the appropriate control menu appended (Devices' controls)
void Show_devices_controls(u8 screen) {
    16aa:	ef 92       	push	r14
    16ac:	ff 92       	push	r15
    16ae:	1f 93       	push	r17
    16b0:	cf 93       	push	r28
    16b2:	df 93       	push	r29
    16b4:	00 d0       	rcall	.+0      	; 0x16b6 <Show_devices_controls+0xc>
    16b6:	00 d0       	rcall	.+0      	; 0x16b8 <Show_devices_controls+0xe>
    16b8:	cd b7       	in	r28, 0x3d	; 61
    16ba:	de b7       	in	r29, 0x3e	; 62
    16bc:	18 2f       	mov	r17, r24
  // Do nothing if the correct screen is shown.
  // if (screen == control_devices_screen) return;
  LCD_clear_screen();
    16be:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
  LCD_write_string_xy(0, 0, "Lamp");
    16c2:	49 e2       	ldi	r20, 0x29	; 41
    16c4:	51 e0       	ldi	r21, 0x01	; 1
    16c6:	60 e0       	ldi	r22, 0x00	; 0
    16c8:	80 e0       	ldi	r24, 0x00	; 0
    16ca:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
  LCD_sendData(screen + 48);
    16ce:	80 e3       	ldi	r24, 0x30	; 48
    16d0:	81 0f       	add	r24, r17
    16d2:	0e 94 3a 03 	call	0x674	; 0x674 <LCD_sendData>
  LCD_write_string(":  ");
    16d6:	8e e2       	ldi	r24, 0x2E	; 46
    16d8:	91 e0       	ldi	r25, 0x01	; 1
    16da:	0e 94 b0 03 	call	0x760	; 0x760 <LCD_write_string>

  if (screen < 6) {
    16de:	16 30       	cpi	r17, 0x06	; 6
    16e0:	88 f4       	brcc	.+34     	; 0x1704 <Show_devices_controls+0x5a>
    // Write the device state
    if (running_devices[screen - 1])
    16e2:	e1 2f       	mov	r30, r17
    16e4:	f0 e0       	ldi	r31, 0x00	; 0
    16e6:	e6 52       	subi	r30, 0x26	; 38
    16e8:	f8 4f       	sbci	r31, 0xF8	; 248
    16ea:	80 81       	ld	r24, Z
    16ec:	88 23       	and	r24, r24
    16ee:	29 f0       	breq	.+10     	; 0x16fa <Show_devices_controls+0x50>
      LCD_write_string("On");
    16f0:	87 e3       	ldi	r24, 0x37	; 55
    16f2:	91 e0       	ldi	r25, 0x01	; 1
    16f4:	0e 94 b0 03 	call	0x760	; 0x760 <LCD_write_string>
    16f8:	38 c0       	rjmp	.+112    	; 0x176a <Show_devices_controls+0xc0>
    else
      LCD_write_string("Off");
    16fa:	8a e3       	ldi	r24, 0x3A	; 58
    16fc:	91 e0       	ldi	r25, 0x01	; 1
    16fe:	0e 94 b0 03 	call	0x760	; 0x760 <LCD_write_string>
    1702:	33 c0       	rjmp	.+102    	; 0x176a <Show_devices_controls+0xc0>
    }
  else if (screen == 6) { // Dimmer
    1704:	16 30       	cpi	r17, 0x06	; 6
    1706:	49 f5       	brne	.+82     	; 0x175a <Show_devices_controls+0xb0>
    s8 brightness[4];
    sprintf(brightness, "%d%%", (u8)((double)dimmer_brightness / 2.55));
    1708:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    170c:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1710:	07 2e       	mov	r0, r23
    1712:	00 0c       	add	r0, r0
    1714:	88 0b       	sbc	r24, r24
    1716:	99 0b       	sbc	r25, r25
    1718:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <__floatsisf>
    171c:	23 e3       	ldi	r18, 0x33	; 51
    171e:	33 e3       	ldi	r19, 0x33	; 51
    1720:	43 e2       	ldi	r20, 0x23	; 35
    1722:	50 e4       	ldi	r21, 0x40	; 64
    1724:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__divsf3>
    1728:	0e 94 d6 15 	call	0x2bac	; 0x2bac <__fixunssfsi>
    172c:	1f 92       	push	r1
    172e:	6f 93       	push	r22
    1730:	82 e3       	ldi	r24, 0x32	; 50
    1732:	91 e0       	ldi	r25, 0x01	; 1
    1734:	9f 93       	push	r25
    1736:	8f 93       	push	r24
    1738:	ce 01       	movw	r24, r28
    173a:	01 96       	adiw	r24, 0x01	; 1
    173c:	7c 01       	movw	r14, r24
    173e:	9f 93       	push	r25
    1740:	8f 93       	push	r24
    1742:	0e 94 16 17 	call	0x2e2c	; 0x2e2c <sprintf>
    LCD_write_string(brightness);
    1746:	c7 01       	movw	r24, r14
    1748:	0e 94 b0 03 	call	0x760	; 0x760 <LCD_write_string>
    174c:	0f 90       	pop	r0
    174e:	0f 90       	pop	r0
    1750:	0f 90       	pop	r0
    1752:	0f 90       	pop	r0
    1754:	0f 90       	pop	r0
    1756:	0f 90       	pop	r0
    1758:	08 c0       	rjmp	.+16     	; 0x176a <Show_devices_controls+0xc0>
    }
  else {  // Logout screen
    LCD_clear_screen();
    175a:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
    LCD_write_string_xy(4, 0, "Log out?");
    175e:	4e e3       	ldi	r20, 0x3E	; 62
    1760:	51 e0       	ldi	r21, 0x01	; 1
    1762:	60 e0       	ldi	r22, 0x00	; 0
    1764:	84 e0       	ldi	r24, 0x04	; 4
    1766:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
    }
  // Show the options menu
  switch (screen) {
    176a:	16 30       	cpi	r17, 0x06	; 6
    176c:	81 f0       	breq	.+32     	; 0x178e <Show_devices_controls+0xe4>
    176e:	17 30       	cpi	r17, 0x07	; 7
    1770:	91 f0       	breq	.+36     	; 0x1796 <Show_devices_controls+0xec>
    1772:	11 30       	cpi	r17, 0x01	; 1
    1774:	a1 f4       	brne	.+40     	; 0x179e <Show_devices_controls+0xf4>
      case 1:
        if (running_devices[0])
    1776:	80 91 db 07 	lds	r24, 0x07DB	; 0x8007db <running_devices>
    177a:	88 23       	and	r24, r24
    177c:	21 f0       	breq	.+8      	; 0x1786 <Show_devices_controls+0xdc>
          Show_bottom_options_menu(8);
    177e:	88 e0       	ldi	r24, 0x08	; 8
    1780:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <Show_bottom_options_menu>
    1784:	1a c0       	rjmp	.+52     	; 0x17ba <Show_devices_controls+0x110>
        else
          Show_bottom_options_menu(7);
    1786:	87 e0       	ldi	r24, 0x07	; 7
    1788:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <Show_bottom_options_menu>
    178c:	16 c0       	rjmp	.+44     	; 0x17ba <Show_devices_controls+0x110>
        break;
      case 6:
        Show_bottom_options_menu(9);
    178e:	89 e0       	ldi	r24, 0x09	; 9
    1790:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <Show_bottom_options_menu>
        break;
    1794:	12 c0       	rjmp	.+36     	; 0x17ba <Show_devices_controls+0x110>
      case 7:
        Show_bottom_options_menu(10);
    1796:	8a e0       	ldi	r24, 0x0A	; 10
    1798:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <Show_bottom_options_menu>
        break;
    179c:	0e c0       	rjmp	.+28     	; 0x17ba <Show_devices_controls+0x110>
      default:
        if (running_devices[screen - 1])
    179e:	e1 2f       	mov	r30, r17
    17a0:	f0 e0       	ldi	r31, 0x00	; 0
    17a2:	e6 52       	subi	r30, 0x26	; 38
    17a4:	f8 4f       	sbci	r31, 0xF8	; 248
    17a6:	80 81       	ld	r24, Z
    17a8:	88 23       	and	r24, r24
    17aa:	21 f0       	breq	.+8      	; 0x17b4 <Show_devices_controls+0x10a>
          Show_bottom_options_menu(6);
    17ac:	86 e0       	ldi	r24, 0x06	; 6
    17ae:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <Show_bottom_options_menu>
    17b2:	03 c0       	rjmp	.+6      	; 0x17ba <Show_devices_controls+0x110>
        else
          Show_bottom_options_menu(5);
    17b4:	85 e0       	ldi	r24, 0x05	; 5
    17b6:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <Show_bottom_options_menu>
        break;
    }
  }
    17ba:	0f 90       	pop	r0
    17bc:	0f 90       	pop	r0
    17be:	0f 90       	pop	r0
    17c0:	0f 90       	pop	r0
    17c2:	df 91       	pop	r29
    17c4:	cf 91       	pop	r28
    17c6:	1f 91       	pop	r17
    17c8:	ff 90       	pop	r15
    17ca:	ef 90       	pop	r14
    17cc:	08 95       	ret

000017ce <invalid_local_login_attempt>:

// Handles setting the alarm and halting the system when the user enters invalid credentials during login
void invalid_local_login_attempt(void) {
  invalid_trails++;
    17ce:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <invalid_trails>
    17d2:	8f 5f       	subi	r24, 0xFF	; 255
    17d4:	80 93 aa 07 	sts	0x07AA, r24	; 0x8007aa <invalid_trails>
  if (invalid_trails < 3) {
    17d8:	83 30       	cpi	r24, 0x03	; 3
    17da:	00 f5       	brcc	.+64     	; 0x181c <invalid_local_login_attempt+0x4e>
    LCD_clear_screen();
    17dc:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
    LCD_move_cursor_xy(3, 0);
    17e0:	60 e0       	ldi	r22, 0x00	; 0
    17e2:	83 e0       	ldi	r24, 0x03	; 3
    17e4:	0e 94 cf 03 	call	0x79e	; 0x79e <LCD_move_cursor_xy>
    LCD_sendData((3 - invalid_trails) + 48);
    17e8:	90 91 aa 07 	lds	r25, 0x07AA	; 0x8007aa <invalid_trails>
    17ec:	83 e3       	ldi	r24, 0x33	; 51
    17ee:	89 1b       	sub	r24, r25
    17f0:	0e 94 3a 03 	call	0x674	; 0x674 <LCD_sendData>
    LCD_write_string(" attempts");
    17f4:	87 e4       	ldi	r24, 0x47	; 71
    17f6:	91 e0       	ldi	r25, 0x01	; 1
    17f8:	0e 94 b0 03 	call	0x760	; 0x760 <LCD_write_string>
    LCD_write_string_xy(3, 1, "remaining !");
    17fc:	41 e5       	ldi	r20, 0x51	; 81
    17fe:	51 e0       	ldi	r21, 0x01	; 1
    1800:	61 e0       	ldi	r22, 0x01	; 1
    1802:	83 e0       	ldi	r24, 0x03	; 3
    1804:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
    1808:	2f ef       	ldi	r18, 0xFF	; 255
    180a:	83 ed       	ldi	r24, 0xD3	; 211
    180c:	90 e3       	ldi	r25, 0x30	; 48
    180e:	21 50       	subi	r18, 0x01	; 1
    1810:	80 40       	sbci	r24, 0x00	; 0
    1812:	90 40       	sbci	r25, 0x00	; 0
    1814:	e1 f7       	brne	.-8      	; 0x180e <invalid_local_login_attempt+0x40>
    1816:	00 c0       	rjmp	.+0      	; 0x1818 <invalid_local_login_attempt+0x4a>
    1818:	00 00       	nop
    181a:	08 95       	ret
    _delay_ms(1000);
    return;
    }
  LCD_clear_screen();
    181c:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
  LCD_write_string_xy(4, 0, "Too many");
    1820:	4d e5       	ldi	r20, 0x5D	; 93
    1822:	51 e0       	ldi	r21, 0x01	; 1
    1824:	60 e0       	ldi	r22, 0x00	; 0
    1826:	84 e0       	ldi	r24, 0x04	; 4
    1828:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
  LCD_write_string_xy(0, 1, "wrong attempts!");
    182c:	46 e6       	ldi	r20, 0x66	; 102
    182e:	51 e0       	ldi	r21, 0x01	; 1
    1830:	61 e0       	ldi	r22, 0x01	; 1
    1832:	80 e0       	ldi	r24, 0x00	; 0
    1834:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
    1838:	2f ef       	ldi	r18, 0xFF	; 255
    183a:	83 ed       	ldi	r24, 0xD3	; 211
    183c:	90 e3       	ldi	r25, 0x30	; 48
    183e:	21 50       	subi	r18, 0x01	; 1
    1840:	80 40       	sbci	r24, 0x00	; 0
    1842:	90 40       	sbci	r25, 0x00	; 0
    1844:	e1 f7       	brne	.-8      	; 0x183e <invalid_local_login_attempt+0x70>
    1846:	00 c0       	rjmp	.+0      	; 0x1848 <invalid_local_login_attempt+0x7a>
    1848:	00 00       	nop
  _delay_ms(1000);
  LCD_clear_screen();
    184a:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
  LCD_write_string_xy(3, 0, "- System -");
    184e:	46 e7       	ldi	r20, 0x76	; 118
    1850:	51 e0       	ldi	r21, 0x01	; 1
    1852:	60 e0       	ldi	r22, 0x00	; 0
    1854:	83 e0       	ldi	r24, 0x03	; 3
    1856:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
  LCD_write_string_xy(2, 1, "- Suspended -");
    185a:	41 e8       	ldi	r20, 0x81	; 129
    185c:	51 e0       	ldi	r21, 0x01	; 1
    185e:	61 e0       	ldi	r22, 0x01	; 1
    1860:	82 e0       	ldi	r24, 0x02	; 2
    1862:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
  Alarm_set();
    1866:	0e 94 d5 13 	call	0x27aa	; 0x27aa <Alarm_set>
  run_system = false;
    186a:	10 92 a9 07 	sts	0x07A9, r1	; 0x8007a9 <run_system>
    186e:	08 95       	ret

00001870 <Local_control_input_handler>:
  }

// Used in the super loop for getting the user input and handling it.
void Local_control_input_handler(void) {
    1870:	1f 93       	push	r17
    1872:	cf 93       	push	r28
    1874:	df 93       	push	r29
    1876:	1f 92       	push	r1
    1878:	cd b7       	in	r28, 0x3d	; 61
    187a:	de b7       	in	r29, 0x3e	; 62
  u8 pressed_key;
  EN_KeypadStatusCode_t keypad_stat = Keypad_getPressedKey(&pressed_key);
    187c:	ce 01       	movw	r24, r28
    187e:	01 96       	adiw	r24, 0x01	; 1
    1880:	0e 94 98 02 	call	0x530	; 0x530 <Keypad_getPressedKey>
    1884:	18 2f       	mov	r17, r24
  switch (local_control_running_task) {
    1886:	80 91 ab 07 	lds	r24, 0x07AB	; 0x8007ab <local_control_running_task>
    188a:	81 30       	cpi	r24, 0x01	; 1
    188c:	a9 f1       	breq	.+106    	; 0x18f8 <Local_control_input_handler+0x88>
    188e:	20 f0       	brcs	.+8      	; 0x1898 <Local_control_input_handler+0x28>
    1890:	82 30       	cpi	r24, 0x02	; 2
    1892:	09 f4       	brne	.+2      	; 0x1896 <Local_control_input_handler+0x26>
    1894:	48 c1       	rjmp	.+656    	; 0x1b26 <Local_control_input_handler+0x2b6>
    1896:	30 c2       	rjmp	.+1120   	; 0x1cf8 <Local_control_input_handler+0x488>
    // Show running devices
      case 0:
        Get_running_devices();
    1898:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <Get_running_devices>
        if (running_devices_screen == 0) {  // First run
    189c:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    18a0:	81 11       	cpse	r24, r1
    18a2:	08 c0       	rjmp	.+16     	; 0x18b4 <Local_control_input_handler+0x44>
          Show_running_devices(1);
    18a4:	81 e0       	ldi	r24, 0x01	; 1
    18a6:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <Show_running_devices>
          running_devices_screen++;
    18aa:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    18ae:	8f 5f       	subi	r24, 0xFF	; 255
    18b0:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <running_devices_screen>
          }
        if (keypad_stat == NO_KEY_PRESSED) return;
    18b4:	12 30       	cpi	r17, 0x02	; 2
    18b6:	09 f4       	brne	.+2      	; 0x18ba <Local_control_input_handler+0x4a>
    18b8:	1f c2       	rjmp	.+1086   	; 0x1cf8 <Local_control_input_handler+0x488>
        switch (pressed_key) {
    18ba:	89 81       	ldd	r24, Y+1	; 0x01
    18bc:	82 33       	cpi	r24, 0x32	; 50
    18be:	61 f0       	breq	.+24     	; 0x18d8 <Local_control_input_handler+0x68>
    18c0:	83 33       	cpi	r24, 0x33	; 51
    18c2:	71 f0       	breq	.+28     	; 0x18e0 <Local_control_input_handler+0x70>
    18c4:	81 33       	cpi	r24, 0x31	; 49
    18c6:	99 f4       	brne	.+38     	; 0x18ee <Local_control_input_handler+0x7e>
            case '1':
              if (running_devices_screen > 1) running_devices_screen--;
    18c8:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    18cc:	82 30       	cpi	r24, 0x02	; 2
    18ce:	78 f0       	brcs	.+30     	; 0x18ee <Local_control_input_handler+0x7e>
    18d0:	81 50       	subi	r24, 0x01	; 1
    18d2:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <running_devices_screen>
    18d6:	0b c0       	rjmp	.+22     	; 0x18ee <Local_control_input_handler+0x7e>
              break;
            case '2':
              local_control_running_task = 1;
    18d8:	81 e0       	ldi	r24, 0x01	; 1
    18da:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <local_control_running_task>
              break;
    18de:	07 c0       	rjmp	.+14     	; 0x18ee <Local_control_input_handler+0x7e>
            case '3':
              if (running_devices_screen < 7) running_devices_screen++;
    18e0:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    18e4:	87 30       	cpi	r24, 0x07	; 7
    18e6:	18 f4       	brcc	.+6      	; 0x18ee <Local_control_input_handler+0x7e>
    18e8:	8f 5f       	subi	r24, 0xFF	; 255
    18ea:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <running_devices_screen>
              break;
          }
        Show_running_devices(running_devices_screen);
    18ee:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    18f2:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <Show_running_devices>
        break;
    18f6:	00 c2       	rjmp	.+1024   	; 0x1cf8 <Local_control_input_handler+0x488>
        // Logging in
      case 1:
        switch (login_stage) {
    18f8:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <login_stage>
    18fc:	88 23       	and	r24, r24
    18fe:	21 f0       	breq	.+8      	; 0x1908 <Local_control_input_handler+0x98>
    1900:	81 30       	cpi	r24, 0x01	; 1
    1902:	09 f4       	brne	.+2      	; 0x1906 <Local_control_input_handler+0x96>
    1904:	73 c0       	rjmp	.+230    	; 0x19ec <Local_control_input_handler+0x17c>
    1906:	f8 c1       	rjmp	.+1008   	; 0x1cf8 <Local_control_input_handler+0x488>
          // Entering the user code
            case 0:
              if (!login_stage_started) {
    1908:	80 91 e2 07 	lds	r24, 0x07E2	; 0x8007e2 <login_stage_started>
    190c:	81 11       	cpse	r24, r1
    190e:	13 c0       	rjmp	.+38     	; 0x1936 <Local_control_input_handler+0xc6>
                LCD_clear_screen();
    1910:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
                Show_side_options_menu();
    1914:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "User Code:");
    1918:	4f e8       	ldi	r20, 0x8F	; 143
    191a:	51 e0       	ldi	r21, 0x01	; 1
    191c:	60 e0       	ldi	r22, 0x00	; 0
    191e:	80 e0       	ldi	r24, 0x00	; 0
    1920:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    1924:	61 e0       	ldi	r22, 0x01	; 1
    1926:	80 e0       	ldi	r24, 0x00	; 0
    1928:	0e 94 cf 03 	call	0x79e	; 0x79e <LCD_move_cursor_xy>
                login_stage_started = true;
    192c:	81 e0       	ldi	r24, 0x01	; 1
    192e:	80 93 e2 07 	sts	0x07E2, r24	; 0x8007e2 <login_stage_started>
                input_buffer_pointer = 0;
    1932:	10 92 ac 07 	sts	0x07AC, r1	; 0x8007ac <input_buffer_pointer>
                }
              if (keypad_stat == NO_KEY_PRESSED) return;
    1936:	12 30       	cpi	r17, 0x02	; 2
    1938:	09 f4       	brne	.+2      	; 0x193c <Local_control_input_handler+0xcc>
    193a:	de c1       	rjmp	.+956    	; 0x1cf8 <Local_control_input_handler+0x488>
              if (pressed_key == '-') { // Delete last input number
    193c:	89 81       	ldd	r24, Y+1	; 0x01
    193e:	8d 32       	cpi	r24, 0x2D	; 45
    1940:	a1 f4       	brne	.+40     	; 0x196a <Local_control_input_handler+0xfa>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    1942:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1946:	88 23       	and	r24, r24
    1948:	19 f0       	breq	.+6      	; 0x1950 <Local_control_input_handler+0xe0>
    194a:	81 50       	subi	r24, 0x01	; 1
    194c:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    1950:	40 e3       	ldi	r20, 0x30	; 48
    1952:	51 e0       	ldi	r21, 0x01	; 1
    1954:	61 e0       	ldi	r22, 0x01	; 1
    1956:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    195a:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    195e:	61 e0       	ldi	r22, 0x01	; 1
    1960:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1964:	0e 94 cf 03 	call	0x79e	; 0x79e <LCD_move_cursor_xy>
    1968:	c7 c1       	rjmp	.+910    	; 0x1cf8 <Local_control_input_handler+0x488>
                }
              else if (pressed_key == '=') {
    196a:	8d 33       	cpi	r24, 0x3D	; 61
    196c:	39 f5       	brne	.+78     	; 0x19bc <Local_control_input_handler+0x14c>
                input_buffer[input_buffer_pointer] = 0;
    196e:	e0 91 ac 07 	lds	r30, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1972:	f0 e0       	ldi	r31, 0x00	; 0
    1974:	e3 53       	subi	r30, 0x33	; 51
    1976:	f8 4f       	sbci	r31, 0xF8	; 248
    1978:	10 82       	st	Z, r1
                // Validate user code
                EN_UserStatusCode_t codeExists = getUserByCode(input_buffer, &local_user);
    197a:	6d ea       	ldi	r22, 0xAD	; 173
    197c:	77 e0       	ldi	r23, 0x07	; 7
    197e:	8d ec       	ldi	r24, 0xCD	; 205
    1980:	97 e0       	ldi	r25, 0x07	; 7
    1982:	0e 94 3c 13 	call	0x2678	; 0x2678 <getUserByCode>
                if (codeExists == USER_FOUND) {
    1986:	82 30       	cpi	r24, 0x02	; 2
    1988:	31 f4       	brne	.+12     	; 0x1996 <Local_control_input_handler+0x126>
                  login_stage_started = false;
    198a:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
                  login_stage = 1;
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	80 93 e3 07 	sts	0x07E3, r24	; 0x8007e3 <login_stage>
    1994:	b1 c1       	rjmp	.+866    	; 0x1cf8 <Local_control_input_handler+0x488>
                  }
                else {
                  LCD_clear_screen();
    1996:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    199a:	4a e9       	ldi	r20, 0x9A	; 154
    199c:	51 e0       	ldi	r21, 0x01	; 1
    199e:	60 e0       	ldi	r22, 0x00	; 0
    19a0:	85 e0       	ldi	r24, 0x05	; 5
    19a2:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
                  LCD_write_string_xy(2, 1, "User Code !");
    19a6:	40 ea       	ldi	r20, 0xA0	; 160
    19a8:	51 e0       	ldi	r21, 0x01	; 1
    19aa:	61 e0       	ldi	r22, 0x01	; 1
    19ac:	82 e0       	ldi	r24, 0x02	; 2
    19ae:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
                  invalid_local_login_attempt();
    19b2:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <invalid_local_login_attempt>
                  login_stage_started = false;
    19b6:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
    19ba:	9e c1       	rjmp	.+828    	; 0x1cf8 <Local_control_input_handler+0x488>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    19bc:	90 ed       	ldi	r25, 0xD0	; 208
    19be:	98 0f       	add	r25, r24
    19c0:	9a 30       	cpi	r25, 0x0A	; 10
    19c2:	08 f0       	brcs	.+2      	; 0x19c6 <Local_control_input_handler+0x156>
    19c4:	99 c1       	rjmp	.+818    	; 0x1cf8 <Local_control_input_handler+0x488>
                if (input_buffer_pointer < 6) {
    19c6:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <input_buffer_pointer>
    19ca:	96 30       	cpi	r25, 0x06	; 6
    19cc:	08 f0       	brcs	.+2      	; 0x19d0 <Local_control_input_handler+0x160>
    19ce:	94 c1       	rjmp	.+808    	; 0x1cf8 <Local_control_input_handler+0x488>
                  // Echo the input on the LCD
                  LCD_sendData(pressed_key);
    19d0:	0e 94 3a 03 	call	0x674	; 0x674 <LCD_sendData>
                  input_buffer[input_buffer_pointer] = pressed_key;
    19d4:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    19d8:	e8 2f       	mov	r30, r24
    19da:	f0 e0       	ldi	r31, 0x00	; 0
    19dc:	e3 53       	subi	r30, 0x33	; 51
    19de:	f8 4f       	sbci	r31, 0xF8	; 248
    19e0:	99 81       	ldd	r25, Y+1	; 0x01
    19e2:	90 83       	st	Z, r25
                  input_buffer_pointer++;
    19e4:	8f 5f       	subi	r24, 0xFF	; 255
    19e6:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
    19ea:	86 c1       	rjmp	.+780    	; 0x1cf8 <Local_control_input_handler+0x488>
                  }
                }
              break;
              //  Entering the password
            case 1:
              if (!login_stage_started) {
    19ec:	80 91 e2 07 	lds	r24, 0x07E2	; 0x8007e2 <login_stage_started>
    19f0:	81 11       	cpse	r24, r1
    19f2:	13 c0       	rjmp	.+38     	; 0x1a1a <Local_control_input_handler+0x1aa>
                LCD_clear_screen();
    19f4:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
                Show_side_options_menu();
    19f8:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "Password:");
    19fc:	4c ea       	ldi	r20, 0xAC	; 172
    19fe:	51 e0       	ldi	r21, 0x01	; 1
    1a00:	60 e0       	ldi	r22, 0x00	; 0
    1a02:	80 e0       	ldi	r24, 0x00	; 0
    1a04:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    1a08:	61 e0       	ldi	r22, 0x01	; 1
    1a0a:	80 e0       	ldi	r24, 0x00	; 0
    1a0c:	0e 94 cf 03 	call	0x79e	; 0x79e <LCD_move_cursor_xy>
                login_stage_started = true;
    1a10:	81 e0       	ldi	r24, 0x01	; 1
    1a12:	80 93 e2 07 	sts	0x07E2, r24	; 0x8007e2 <login_stage_started>
                input_buffer_pointer = 0;
    1a16:	10 92 ac 07 	sts	0x07AC, r1	; 0x8007ac <input_buffer_pointer>
                }
              if (pressed_key == '-') { // Delete last input number
    1a1a:	89 81       	ldd	r24, Y+1	; 0x01
    1a1c:	8d 32       	cpi	r24, 0x2D	; 45
    1a1e:	a1 f4       	brne	.+40     	; 0x1a48 <Local_control_input_handler+0x1d8>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    1a20:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1a24:	88 23       	and	r24, r24
    1a26:	19 f0       	breq	.+6      	; 0x1a2e <Local_control_input_handler+0x1be>
    1a28:	81 50       	subi	r24, 0x01	; 1
    1a2a:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    1a2e:	40 e3       	ldi	r20, 0x30	; 48
    1a30:	51 e0       	ldi	r21, 0x01	; 1
    1a32:	61 e0       	ldi	r22, 0x01	; 1
    1a34:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1a38:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    1a3c:	61 e0       	ldi	r22, 0x01	; 1
    1a3e:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1a42:	0e 94 cf 03 	call	0x79e	; 0x79e <LCD_move_cursor_xy>
    1a46:	58 c1       	rjmp	.+688    	; 0x1cf8 <Local_control_input_handler+0x488>
                }
              else if (pressed_key == '=') {
    1a48:	8d 33       	cpi	r24, 0x3D	; 61
    1a4a:	09 f0       	breq	.+2      	; 0x1a4e <Local_control_input_handler+0x1de>
    1a4c:	54 c0       	rjmp	.+168    	; 0x1af6 <Local_control_input_handler+0x286>
                input_buffer[input_buffer_pointer] = 0;
    1a4e:	e0 91 ac 07 	lds	r30, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1a52:	f0 e0       	ldi	r31, 0x00	; 0
    1a54:	e3 53       	subi	r30, 0x33	; 51
    1a56:	f8 4f       	sbci	r31, 0xF8	; 248
    1a58:	10 82       	st	Z, r1
                // Validate user password
                if (strcmp(input_buffer, local_user.password) == 0) { // Password is correct
    1a5a:	62 ec       	ldi	r22, 0xC2	; 194
    1a5c:	77 e0       	ldi	r23, 0x07	; 7
    1a5e:	8d ec       	ldi	r24, 0xCD	; 205
    1a60:	97 e0       	ldi	r25, 0x07	; 7
    1a62:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <strcmp>
    1a66:	89 2b       	or	r24, r25
    1a68:	99 f5       	brne	.+102    	; 0x1ad0 <Local_control_input_handler+0x260>
                  login_stage_started = false;
    1a6a:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
                  login_stage = 0;
    1a6e:	10 92 e3 07 	sts	0x07E3, r1	; 0x8007e3 <login_stage>
                  local_control_running_task = 2;
    1a72:	82 e0       	ldi	r24, 0x02	; 2
    1a74:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <local_control_running_task>
                  local_user_loggedin = true;
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <__data_end>
                  LCD_clear_screen();
    1a7e:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
                  LCD_write_string_xy(4, 0, "Welcome");
    1a82:	46 eb       	ldi	r20, 0xB6	; 182
    1a84:	51 e0       	ldi	r21, 0x01	; 1
    1a86:	60 e0       	ldi	r22, 0x00	; 0
    1a88:	84 e0       	ldi	r24, 0x04	; 4
    1a8a:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
                  LCD_write_string_xy((16 - strlen(local_user.name)) / 2 - 1, 1, local_user.name);
    1a8e:	ee ea       	ldi	r30, 0xAE	; 174
    1a90:	f7 e0       	ldi	r31, 0x07	; 7
    1a92:	01 90       	ld	r0, Z+
    1a94:	00 20       	and	r0, r0
    1a96:	e9 f7       	brne	.-6      	; 0x1a92 <Local_control_input_handler+0x222>
    1a98:	9f 01       	movw	r18, r30
    1a9a:	2f 5a       	subi	r18, 0xAF	; 175
    1a9c:	37 40       	sbci	r19, 0x07	; 7
    1a9e:	80 e1       	ldi	r24, 0x10	; 16
    1aa0:	90 e0       	ldi	r25, 0x00	; 0
    1aa2:	82 1b       	sub	r24, r18
    1aa4:	93 0b       	sbc	r25, r19
    1aa6:	96 95       	lsr	r25
    1aa8:	87 95       	ror	r24
    1aaa:	4e ea       	ldi	r20, 0xAE	; 174
    1aac:	57 e0       	ldi	r21, 0x07	; 7
    1aae:	61 e0       	ldi	r22, 0x01	; 1
    1ab0:	81 50       	subi	r24, 0x01	; 1
    1ab2:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
                  LCD_sendData('!');
    1ab6:	81 e2       	ldi	r24, 0x21	; 33
    1ab8:	0e 94 3a 03 	call	0x674	; 0x674 <LCD_sendData>
    1abc:	2f ef       	ldi	r18, 0xFF	; 255
    1abe:	83 ed       	ldi	r24, 0xD3	; 211
    1ac0:	90 e3       	ldi	r25, 0x30	; 48
    1ac2:	21 50       	subi	r18, 0x01	; 1
    1ac4:	80 40       	sbci	r24, 0x00	; 0
    1ac6:	90 40       	sbci	r25, 0x00	; 0
    1ac8:	e1 f7       	brne	.-8      	; 0x1ac2 <Local_control_input_handler+0x252>
    1aca:	00 c0       	rjmp	.+0      	; 0x1acc <Local_control_input_handler+0x25c>
    1acc:	00 00       	nop
    1ace:	14 c1       	rjmp	.+552    	; 0x1cf8 <Local_control_input_handler+0x488>
                  _delay_ms(1000);
                  }
                else {
                  LCD_clear_screen();
    1ad0:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    1ad4:	4a e9       	ldi	r20, 0x9A	; 154
    1ad6:	51 e0       	ldi	r21, 0x01	; 1
    1ad8:	60 e0       	ldi	r22, 0x00	; 0
    1ada:	85 e0       	ldi	r24, 0x05	; 5
    1adc:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
                  LCD_write_string_xy(3, 1, "Password !");
    1ae0:	4e eb       	ldi	r20, 0xBE	; 190
    1ae2:	51 e0       	ldi	r21, 0x01	; 1
    1ae4:	61 e0       	ldi	r22, 0x01	; 1
    1ae6:	83 e0       	ldi	r24, 0x03	; 3
    1ae8:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
                  login_stage_started = false;
    1aec:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
                  invalid_local_login_attempt();
    1af0:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <invalid_local_login_attempt>
    1af4:	01 c1       	rjmp	.+514    	; 0x1cf8 <Local_control_input_handler+0x488>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    1af6:	90 ed       	ldi	r25, 0xD0	; 208
    1af8:	98 0f       	add	r25, r24
    1afa:	9a 30       	cpi	r25, 0x0A	; 10
    1afc:	08 f0       	brcs	.+2      	; 0x1b00 <Local_control_input_handler+0x290>
    1afe:	fc c0       	rjmp	.+504    	; 0x1cf8 <Local_control_input_handler+0x488>
                // Limit the input length
                if (input_buffer_pointer < 10) {
    1b00:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1b04:	9a 30       	cpi	r25, 0x0A	; 10
    1b06:	08 f0       	brcs	.+2      	; 0x1b0a <Local_control_input_handler+0x29a>
    1b08:	f7 c0       	rjmp	.+494    	; 0x1cf8 <Local_control_input_handler+0x488>
                  // Echo the input on the LCD
                  LCD_sendData(pressed_key);
    1b0a:	0e 94 3a 03 	call	0x674	; 0x674 <LCD_sendData>
                  input_buffer[input_buffer_pointer] = pressed_key;
    1b0e:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1b12:	e8 2f       	mov	r30, r24
    1b14:	f0 e0       	ldi	r31, 0x00	; 0
    1b16:	e3 53       	subi	r30, 0x33	; 51
    1b18:	f8 4f       	sbci	r31, 0xF8	; 248
    1b1a:	99 81       	ldd	r25, Y+1	; 0x01
    1b1c:	90 83       	st	Z, r25
                  input_buffer_pointer++;
    1b1e:	8f 5f       	subi	r24, 0xFF	; 255
    1b20:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
    1b24:	e9 c0       	rjmp	.+466    	; 0x1cf8 <Local_control_input_handler+0x488>
              break;
          }
        break;
        // Devices control
      case 2:
        if (remote_user_loggedin && !local_control_permission_granted) {
    1b26:	80 91 a8 07 	lds	r24, 0x07A8	; 0x8007a8 <remote_user_loggedin>
    1b2a:	88 23       	and	r24, r24
    1b2c:	99 f0       	breq	.+38     	; 0x1b54 <Local_control_input_handler+0x2e4>
    1b2e:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <local_control_permission_granted>
    1b32:	81 11       	cpse	r24, r1
    1b34:	0f c0       	rjmp	.+30     	; 0x1b54 <Local_control_input_handler+0x2e4>
          LCD_clear_screen();
    1b36:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
          LCD_write_string_xy(0, 0, "Admin Permission");
    1b3a:	49 ec       	ldi	r20, 0xC9	; 201
    1b3c:	51 e0       	ldi	r21, 0x01	; 1
    1b3e:	60 e0       	ldi	r22, 0x00	; 0
    1b40:	80 e0       	ldi	r24, 0x00	; 0
    1b42:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
          LCD_write_string_xy(3, 1, "Required !");
    1b46:	4a ed       	ldi	r20, 0xDA	; 218
    1b48:	51 e0       	ldi	r21, 0x01	; 1
    1b4a:	61 e0       	ldi	r22, 0x01	; 1
    1b4c:	83 e0       	ldi	r24, 0x03	; 3
    1b4e:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
    1b52:	d2 c0       	rjmp	.+420    	; 0x1cf8 <Local_control_input_handler+0x488>
          //~ Controls can be added to allow the user to go back and view the running devices if needed.
          }
        else {
          Get_running_devices();
    1b54:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <Get_running_devices>
          if (control_devices_screen == 0) {  // First run
    1b58:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1b5c:	81 11       	cpse	r24, r1
    1b5e:	08 c0       	rjmp	.+16     	; 0x1b70 <Local_control_input_handler+0x300>
            Show_devices_controls(1);
    1b60:	81 e0       	ldi	r24, 0x01	; 1
    1b62:	0e 94 55 0b 	call	0x16aa	; 0x16aa <Show_devices_controls>
            control_devices_screen++;
    1b66:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1b6a:	8f 5f       	subi	r24, 0xFF	; 255
    1b6c:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
            }
          if (keypad_stat == NO_KEY_PRESSED) return;
    1b70:	12 30       	cpi	r17, 0x02	; 2
    1b72:	09 f4       	brne	.+2      	; 0x1b76 <Local_control_input_handler+0x306>
    1b74:	c1 c0       	rjmp	.+386    	; 0x1cf8 <Local_control_input_handler+0x488>
          switch (pressed_key) {
    1b76:	89 81       	ldd	r24, Y+1	; 0x01
    1b78:	82 33       	cpi	r24, 0x32	; 50
    1b7a:	a1 f0       	breq	.+40     	; 0x1ba4 <Local_control_input_handler+0x334>
    1b7c:	18 f4       	brcc	.+6      	; 0x1b84 <Local_control_input_handler+0x314>
    1b7e:	81 33       	cpi	r24, 0x31	; 49
    1b80:	41 f0       	breq	.+16     	; 0x1b92 <Local_control_input_handler+0x322>
    1b82:	b6 c0       	rjmp	.+364    	; 0x1cf0 <Local_control_input_handler+0x480>
    1b84:	83 33       	cpi	r24, 0x33	; 51
    1b86:	09 f4       	brne	.+2      	; 0x1b8a <Local_control_input_handler+0x31a>
    1b88:	73 c0       	rjmp	.+230    	; 0x1c70 <Local_control_input_handler+0x400>
    1b8a:	84 33       	cpi	r24, 0x34	; 52
    1b8c:	09 f4       	brne	.+2      	; 0x1b90 <Local_control_input_handler+0x320>
    1b8e:	a9 c0       	rjmp	.+338    	; 0x1ce2 <Local_control_input_handler+0x472>
    1b90:	af c0       	rjmp	.+350    	; 0x1cf0 <Local_control_input_handler+0x480>
              case '1':
                if (control_devices_screen > 1) control_devices_screen--;
    1b92:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1b96:	82 30       	cpi	r24, 0x02	; 2
    1b98:	08 f4       	brcc	.+2      	; 0x1b9c <Local_control_input_handler+0x32c>
    1b9a:	aa c0       	rjmp	.+340    	; 0x1cf0 <Local_control_input_handler+0x480>
    1b9c:	81 50       	subi	r24, 0x01	; 1
    1b9e:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
    1ba2:	a6 c0       	rjmp	.+332    	; 0x1cf0 <Local_control_input_handler+0x480>
                break;
              case '2':
                switch (control_devices_screen) {
    1ba4:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1ba8:	86 30       	cpi	r24, 0x06	; 6
    1baa:	19 f0       	breq	.+6      	; 0x1bb2 <Local_control_input_handler+0x342>
    1bac:	87 30       	cpi	r24, 0x07	; 7
    1bae:	a1 f1       	breq	.+104    	; 0x1c18 <Local_control_input_handler+0x3a8>
    1bb0:	53 c0       	rjmp	.+166    	; 0x1c58 <Local_control_input_handler+0x3e8>
                    case 6:
                      // Increment the brightness
                      // Floor the brightness
                      dimmer_brightness += ((double)LAMP_6_BRIGHTNESS_PERCENTAGE_STEP * 2.55);
    1bb2:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1bb6:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1bba:	07 2e       	mov	r0, r23
    1bbc:	00 0c       	add	r0, r0
    1bbe:	88 0b       	sbc	r24, r24
    1bc0:	99 0b       	sbc	r25, r25
    1bc2:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <__floatsisf>
    1bc6:	20 e0       	ldi	r18, 0x00	; 0
    1bc8:	30 e0       	ldi	r19, 0x00	; 0
    1bca:	4c e4       	ldi	r20, 0x4C	; 76
    1bcc:	52 e4       	ldi	r21, 0x42	; 66
    1bce:	0e 94 f1 14 	call	0x29e2	; 0x29e2 <__addsf3>
    1bd2:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <__fixsfsi>
    1bd6:	70 93 d9 07 	sts	0x07D9, r23	; 0x8007d9 <dimmer_brightness+0x1>
    1bda:	60 93 d8 07 	sts	0x07D8, r22	; 0x8007d8 <dimmer_brightness>
                      if (dimmer_brightness > 255) dimmer_brightness = 255;
    1bde:	6f 3f       	cpi	r22, 0xFF	; 255
    1be0:	71 05       	cpc	r23, r1
    1be2:	39 f0       	breq	.+14     	; 0x1bf2 <Local_control_input_handler+0x382>
    1be4:	34 f0       	brlt	.+12     	; 0x1bf2 <Local_control_input_handler+0x382>
    1be6:	8f ef       	ldi	r24, 0xFF	; 255
    1be8:	90 e0       	ldi	r25, 0x00	; 0
    1bea:	90 93 d9 07 	sts	0x07D9, r25	; 0x8007d9 <dimmer_brightness+0x1>
    1bee:	80 93 d8 07 	sts	0x07D8, r24	; 0x8007d8 <dimmer_brightness>
                      Lamp_dimmable_set_brightness(((double)dimmer_brightness / 255.0));
    1bf2:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1bf6:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1bfa:	07 2e       	mov	r0, r23
    1bfc:	00 0c       	add	r0, r0
    1bfe:	88 0b       	sbc	r24, r24
    1c00:	99 0b       	sbc	r25, r25
    1c02:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <__floatsisf>
    1c06:	20 e0       	ldi	r18, 0x00	; 0
    1c08:	30 e0       	ldi	r19, 0x00	; 0
    1c0a:	4f e7       	ldi	r20, 0x7F	; 127
    1c0c:	53 e4       	ldi	r21, 0x43	; 67
    1c0e:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__divsf3>
    1c12:	0e 94 4f 0a 	call	0x149e	; 0x149e <Lamp_dimmable_set_brightness>
                      break;
    1c16:	6c c0       	rjmp	.+216    	; 0x1cf0 <Local_control_input_handler+0x480>
                    case 7:
                      // Logout
                      local_user_loggedin = false;
    1c18:	10 92 a6 07 	sts	0x07A6, r1	; 0x8007a6 <__data_end>
                      control_devices_screen = 0;
    1c1c:	10 92 da 07 	sts	0x07DA, r1	; 0x8007da <control_devices_screen>
                      running_devices_screen = 0;
    1c20:	10 92 e4 07 	sts	0x07E4, r1	; 0x8007e4 <running_devices_screen>
                      local_control_running_task = 0;
    1c24:	10 92 ab 07 	sts	0x07AB, r1	; 0x8007ab <local_control_running_task>
                      LCD_clear_screen();
    1c28:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <LCD_clear_screen>
                      LCD_write_string_xy(1, 0, "logging out...");
    1c2c:	45 ee       	ldi	r20, 0xE5	; 229
    1c2e:	51 e0       	ldi	r21, 0x01	; 1
    1c30:	60 e0       	ldi	r22, 0x00	; 0
    1c32:	81 e0       	ldi	r24, 0x01	; 1
    1c34:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
                      LCD_write_string_xy(4, 1, "Good Bye!");
    1c38:	44 ef       	ldi	r20, 0xF4	; 244
    1c3a:	51 e0       	ldi	r21, 0x01	; 1
    1c3c:	61 e0       	ldi	r22, 0x01	; 1
    1c3e:	84 e0       	ldi	r24, 0x04	; 4
    1c40:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <LCD_write_string_xy>
    1c44:	2f ef       	ldi	r18, 0xFF	; 255
    1c46:	83 ed       	ldi	r24, 0xD3	; 211
    1c48:	90 e3       	ldi	r25, 0x30	; 48
    1c4a:	21 50       	subi	r18, 0x01	; 1
    1c4c:	80 40       	sbci	r24, 0x00	; 0
    1c4e:	90 40       	sbci	r25, 0x00	; 0
    1c50:	e1 f7       	brne	.-8      	; 0x1c4a <Local_control_input_handler+0x3da>
    1c52:	00 c0       	rjmp	.+0      	; 0x1c54 <Local_control_input_handler+0x3e4>
    1c54:	00 00       	nop
    1c56:	4c c0       	rjmp	.+152    	; 0x1cf0 <Local_control_input_handler+0x480>
                      _delay_ms(1000);
                      break;
                    default:
                      Lamp_toggle(control_devices_screen);
    1c58:	0e 94 1d 0a 	call	0x143a	; 0x143a <Lamp_toggle>
                      running_devices[control_devices_screen - 1] = !running_devices[control_devices_screen - 1];
    1c5c:	e0 91 da 07 	lds	r30, 0x07DA	; 0x8007da <control_devices_screen>
    1c60:	f0 e0       	ldi	r31, 0x00	; 0
    1c62:	e6 52       	subi	r30, 0x26	; 38
    1c64:	f8 4f       	sbci	r31, 0xF8	; 248
    1c66:	90 81       	ld	r25, Z
    1c68:	81 e0       	ldi	r24, 0x01	; 1
    1c6a:	89 27       	eor	r24, r25
    1c6c:	80 83       	st	Z, r24
                      break;
    1c6e:	40 c0       	rjmp	.+128    	; 0x1cf0 <Local_control_input_handler+0x480>
                  }
                break;
              case '3':
                switch (control_devices_screen) {
    1c70:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1c74:	86 30       	cpi	r24, 0x06	; 6
    1c76:	79 f5       	brne	.+94     	; 0x1cd6 <Local_control_input_handler+0x466>
                    case 6:
                      // Decrement the brightness
                      // Ceil the brightness
                      dimmer_brightness -= ((double)LAMP_6_BRIGHTNESS_PERCENTAGE_STEP * 2.55);
    1c78:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1c7c:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1c80:	07 2e       	mov	r0, r23
    1c82:	00 0c       	add	r0, r0
    1c84:	88 0b       	sbc	r24, r24
    1c86:	99 0b       	sbc	r25, r25
    1c88:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <__floatsisf>
    1c8c:	20 e0       	ldi	r18, 0x00	; 0
    1c8e:	30 e0       	ldi	r19, 0x00	; 0
    1c90:	4c e4       	ldi	r20, 0x4C	; 76
    1c92:	52 e4       	ldi	r21, 0x42	; 66
    1c94:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <__subsf3>
    1c98:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <__fixsfsi>
    1c9c:	70 93 d9 07 	sts	0x07D9, r23	; 0x8007d9 <dimmer_brightness+0x1>
    1ca0:	60 93 d8 07 	sts	0x07D8, r22	; 0x8007d8 <dimmer_brightness>
                      if (dimmer_brightness < 0) dimmer_brightness = 0;
    1ca4:	77 23       	and	r23, r23
    1ca6:	24 f4       	brge	.+8      	; 0x1cb0 <Local_control_input_handler+0x440>
    1ca8:	10 92 d9 07 	sts	0x07D9, r1	; 0x8007d9 <dimmer_brightness+0x1>
    1cac:	10 92 d8 07 	sts	0x07D8, r1	; 0x8007d8 <dimmer_brightness>
                      Lamp_dimmable_set_brightness(((double)dimmer_brightness / 255.0));
    1cb0:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1cb4:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1cb8:	07 2e       	mov	r0, r23
    1cba:	00 0c       	add	r0, r0
    1cbc:	88 0b       	sbc	r24, r24
    1cbe:	99 0b       	sbc	r25, r25
    1cc0:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <__floatsisf>
    1cc4:	20 e0       	ldi	r18, 0x00	; 0
    1cc6:	30 e0       	ldi	r19, 0x00	; 0
    1cc8:	4f e7       	ldi	r20, 0x7F	; 127
    1cca:	53 e4       	ldi	r21, 0x43	; 67
    1ccc:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__divsf3>
    1cd0:	0e 94 4f 0a 	call	0x149e	; 0x149e <Lamp_dimmable_set_brightness>
                      break;
    1cd4:	0d c0       	rjmp	.+26     	; 0x1cf0 <Local_control_input_handler+0x480>
                    default:
                      if (control_devices_screen < 7) control_devices_screen++;
    1cd6:	87 30       	cpi	r24, 0x07	; 7
    1cd8:	58 f4       	brcc	.+22     	; 0x1cf0 <Local_control_input_handler+0x480>
    1cda:	8f 5f       	subi	r24, 0xFF	; 255
    1cdc:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
    1ce0:	07 c0       	rjmp	.+14     	; 0x1cf0 <Local_control_input_handler+0x480>
                      break;
                  }
                break;
              case '4':
                // Moving to logout screen
                if (control_devices_screen == 6) control_devices_screen++;
    1ce2:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1ce6:	86 30       	cpi	r24, 0x06	; 6
    1ce8:	19 f4       	brne	.+6      	; 0x1cf0 <Local_control_input_handler+0x480>
    1cea:	8f 5f       	subi	r24, 0xFF	; 255
    1cec:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
                break;
            }
          Show_devices_controls(control_devices_screen);
    1cf0:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1cf4:	0e 94 55 0b 	call	0x16aa	; 0x16aa <Show_devices_controls>
          }
        break;
    }
    1cf8:	0f 90       	pop	r0
    1cfa:	df 91       	pop	r29
    1cfc:	cf 91       	pop	r28
    1cfe:	1f 91       	pop	r17
    1d00:	08 95       	ret

00001d02 <println_msg>:
  UART_RXC_INT_init();
  }

void println_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    1d02:	0e 94 e7 01 	call	0x3ce	; 0x3ce <BT_sendString>
  // Send CRLF - carriage return + new line
  BT_sendString("\r\n");
    1d06:	8e ef       	ldi	r24, 0xFE	; 254
    1d08:	91 e0       	ldi	r25, 0x01	; 1
    1d0a:	0e 94 e7 01 	call	0x3ce	; 0x3ce <BT_sendString>
    1d0e:	08 95       	ret

00001d10 <print_msg>:
  }

void print_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    1d10:	0e 94 e7 01 	call	0x3ce	; 0x3ce <BT_sendString>
    1d14:	08 95       	ret

00001d16 <callFunWhenBufferReady>:
  }

void callFunWhenBufferReady(void) {
  requesting_function();
    1d16:	e0 91 59 08 	lds	r30, 0x0859	; 0x800859 <requesting_function>
    1d1a:	f0 91 5a 08 	lds	r31, 0x085A	; 0x80085a <requesting_function+0x1>
    1d1e:	09 95       	icall
    1d20:	08 95       	ret

00001d22 <request_user_input>:
  }

void request_user_input(void (*requestingFunction)(void), u8 msgLength, bool numericalInputOnly) {
  requesting_function = requestingFunction;
    1d22:	90 93 5a 08 	sts	0x085A, r25	; 0x80085a <requesting_function+0x1>
    1d26:	80 93 59 08 	sts	0x0859, r24	; 0x800859 <requesting_function>
  msg_length = msgLength;
    1d2a:	60 93 36 08 	sts	0x0836, r22	; 0x800836 <msg_length>
  numerical_input_mode = numericalInputOnly;
    1d2e:	40 93 e6 07 	sts	0x07E6, r20	; 0x8007e6 <numerical_input_mode>
    1d32:	08 95       	ret

00001d34 <get_lamp_state>:
  }

void get_lamp_state(u8 lamp, u8* state) {
    1d34:	ab 01       	movw	r20, r22
  DIO_Read(lamp + 2, PORT_C, state);
    1d36:	63 e4       	ldi	r22, 0x43	; 67
    1d38:	8e 5f       	subi	r24, 0xFE	; 254
    1d3a:	0e 94 8c 05 	call	0xb18	; 0xb18 <DIO_Read>
    1d3e:	08 95       	ret

00001d40 <print_remote_control_menu>:
    initial_options_menu();
    }
  }

void print_remote_control_menu(void) {
  println_msg("Select one of the following devices to control:\t");
    1d40:	81 e0       	ldi	r24, 0x01	; 1
    1d42:	92 e0       	ldi	r25, 0x02	; 2
    1d44:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
  println_msg("[1] Lamp 1");
    1d48:	82 e3       	ldi	r24, 0x32	; 50
    1d4a:	92 e0       	ldi	r25, 0x02	; 2
    1d4c:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
  println_msg("[2] Lamp 2");
    1d50:	8d e3       	ldi	r24, 0x3D	; 61
    1d52:	92 e0       	ldi	r25, 0x02	; 2
    1d54:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
  println_msg("[3] Lamp 3");
    1d58:	88 e4       	ldi	r24, 0x48	; 72
    1d5a:	92 e0       	ldi	r25, 0x02	; 2
    1d5c:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
  println_msg("[4] Lamp 4");
    1d60:	83 e5       	ldi	r24, 0x53	; 83
    1d62:	92 e0       	ldi	r25, 0x02	; 2
    1d64:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
  println_msg("[5] Lamp 5");
    1d68:	8e e5       	ldi	r24, 0x5E	; 94
    1d6a:	92 e0       	ldi	r25, 0x02	; 2
    1d6c:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
  println_msg("[6] Lamp 6 (dimmable)");
    1d70:	89 e6       	ldi	r24, 0x69	; 105
    1d72:	92 e0       	ldi	r25, 0x02	; 2
    1d74:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
  if (remote_user.isAdmin) {
    1d78:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    1d7c:	88 23       	and	r24, r24
    1d7e:	49 f0       	breq	.+18     	; 0x1d92 <print_remote_control_menu+0x52>
    println_msg("[7] The Door");
    1d80:	8f e7       	ldi	r24, 0x7F	; 127
    1d82:	92 e0       	ldi	r25, 0x02	; 2
    1d84:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    println_msg("[8] Go back to main menu");
    1d88:	8c e8       	ldi	r24, 0x8C	; 140
    1d8a:	92 e0       	ldi	r25, 0x02	; 2
    1d8c:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    1d90:	08 95       	ret
    }
  else {
    println_msg("[7] Go back to main menu");
    1d92:	85 ea       	ldi	r24, 0xA5	; 165
    1d94:	92 e0       	ldi	r25, 0x02	; 2
    1d96:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    1d9a:	08 95       	ret

00001d9c <print_initial_options_menu>:
      }
    }
  }

void print_initial_options_menu(void) {
  if (remote_user.isAdmin) {
    1d9c:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    1da0:	88 23       	and	r24, r24
    1da2:	e9 f0       	breq	.+58     	; 0x1dde <print_initial_options_menu+0x42>
    println_msg("Select one of the following options(by entering its number):\t");
    1da4:	8e eb       	ldi	r24, 0xBE	; 190
    1da6:	92 e0       	ldi	r25, 0x02	; 2
    1da8:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    println_msg("[1] Add user\t");
    1dac:	8c ef       	ldi	r24, 0xFC	; 252
    1dae:	92 e0       	ldi	r25, 0x02	; 2
    1db0:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    println_msg("[2] Delete user\t");
    1db4:	8a e0       	ldi	r24, 0x0A	; 10
    1db6:	93 e0       	ldi	r25, 0x03	; 3
    1db8:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    println_msg("[3] Control a device\t");
    1dbc:	8b e1       	ldi	r24, 0x1B	; 27
    1dbe:	93 e0       	ldi	r25, 0x03	; 3
    1dc0:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    println_msg("[4] Log out\t");
    1dc4:	81 e3       	ldi	r24, 0x31	; 49
    1dc6:	93 e0       	ldi	r25, 0x03	; 3
    1dc8:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    if (local_user_loggedin) {
    1dcc:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <__data_end>
    1dd0:	88 23       	and	r24, r24
    1dd2:	89 f0       	breq	.+34     	; 0x1df6 <print_initial_options_menu+0x5a>
      println_msg("[5] Allow local user control\t");
    1dd4:	8e e3       	ldi	r24, 0x3E	; 62
    1dd6:	93 e0       	ldi	r25, 0x03	; 3
    1dd8:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    1ddc:	08 95       	ret
      }
    }
  else {
    println_msg("Select one of the following options(by entering its number):\t");
    1dde:	8e eb       	ldi	r24, 0xBE	; 190
    1de0:	92 e0       	ldi	r25, 0x02	; 2
    1de2:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    println_msg("[1] Control a device\t");
    1de6:	8c e5       	ldi	r24, 0x5C	; 92
    1de8:	93 e0       	ldi	r25, 0x03	; 3
    1dea:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    println_msg("[2] Log out\t");
    1dee:	82 e7       	ldi	r24, 0x72	; 114
    1df0:	93 e0       	ldi	r25, 0x03	; 3
    1df2:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    1df6:	08 95       	ret

00001df8 <grant_local_control_permission>:
    }
  }

void grant_local_control_permission(void) {
  local_control_permission_granted = true;
    1df8:	81 e0       	ldi	r24, 0x01	; 1
    1dfa:	80 93 a7 07 	sts	0x07A7, r24	; 0x8007a7 <local_control_permission_granted>
    1dfe:	08 95       	ret

00001e00 <logout>:
      }
    }
  }

void logout(void) {
  remote_user_loggedin = false;
    1e00:	10 92 a8 07 	sts	0x07A8, r1	; 0x8007a8 <remote_user_loggedin>
  println_msg("To login again you have to disconnect and reconnect to the BT module...");
    1e04:	8f e7       	ldi	r24, 0x7F	; 127
    1e06:	93 e0       	ldi	r25, 0x03	; 3
    1e08:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
  println_msg("You have successfully logged out...");
    1e0c:	87 ec       	ldi	r24, 0xC7	; 199
    1e0e:	93 e0       	ldi	r25, 0x03	; 3
    1e10:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
  msg_length = 0;
    1e14:	10 92 36 08 	sts	0x0836, r1	; 0x800836 <msg_length>
    1e18:	08 95       	ret

00001e1a <initial_options_menu>:
void grant_local_control_permission(void) {
  local_control_permission_granted = true;
  }

void initial_options_menu(void) {
  if (!user_input_accepted) {
    1e1a:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    1e1e:	81 11       	cpse	r24, r1
    1e20:	0c c0       	rjmp	.+24     	; 0x1e3a <initial_options_menu+0x20>
    print_initial_options_menu();
    1e22:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <print_initial_options_menu>
    request_user_input(initial_options_menu, 2, true);
    1e26:	41 e0       	ldi	r20, 0x01	; 1
    1e28:	62 e0       	ldi	r22, 0x02	; 2
    1e2a:	8d e0       	ldi	r24, 0x0D	; 13
    1e2c:	9f e0       	ldi	r25, 0x0F	; 15
    1e2e:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
    user_input_accepted = true;
    1e32:	81 e0       	ldi	r24, 0x01	; 1
    1e34:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    1e38:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    1e3a:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (remote_user.isAdmin) {
    1e3e:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    1e42:	88 23       	and	r24, r24
    1e44:	49 f1       	breq	.+82     	; 0x1e98 <initial_options_menu+0x7e>
      u8 option = msg_buffer[0];
    1e46:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <msg_buffer>
      if (option < '1' || option > '5') {
    1e4a:	9f ec       	ldi	r25, 0xCF	; 207
    1e4c:	98 0f       	add	r25, r24
    1e4e:	95 30       	cpi	r25, 0x05	; 5
    1e50:	38 f0       	brcs	.+14     	; 0x1e60 <initial_options_menu+0x46>
        println_msg("Invalid option!\t");
    1e52:	8b ee       	ldi	r24, 0xEB	; 235
    1e54:	93 e0       	ldi	r25, 0x03	; 3
    1e56:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
        initial_options_menu();
    1e5a:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <initial_options_menu>
    1e5e:	08 95       	ret
        }
      else {
        switch (option) {
    1e60:	83 33       	cpi	r24, 0x33	; 51
    1e62:	89 f0       	breq	.+34     	; 0x1e86 <initial_options_menu+0x6c>
    1e64:	28 f4       	brcc	.+10     	; 0x1e70 <initial_options_menu+0x56>
    1e66:	81 33       	cpi	r24, 0x31	; 49
    1e68:	41 f0       	breq	.+16     	; 0x1e7a <initial_options_menu+0x60>
    1e6a:	82 33       	cpi	r24, 0x32	; 50
    1e6c:	49 f0       	breq	.+18     	; 0x1e80 <initial_options_menu+0x66>
    1e6e:	08 95       	ret
    1e70:	84 33       	cpi	r24, 0x34	; 52
    1e72:	61 f0       	breq	.+24     	; 0x1e8c <initial_options_menu+0x72>
    1e74:	85 33       	cpi	r24, 0x35	; 53
    1e76:	69 f0       	breq	.+26     	; 0x1e92 <initial_options_menu+0x78>
    1e78:	08 95       	ret
            case '1':
              add_user_prompt();
    1e7a:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <add_user_prompt>
              break;
    1e7e:	08 95       	ret
            case '2':
              delete_user_prompt();
    1e80:	0e 94 64 0f 	call	0x1ec8	; 0x1ec8 <delete_user_prompt>
              break;
    1e84:	08 95       	ret
            case '3':
              remote_control();
    1e86:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <remote_control>
              break;
    1e8a:	08 95       	ret
            case '4':
              logout();
    1e8c:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <logout>
              break;
    1e90:	08 95       	ret
            case '5':
              grant_local_control_permission();
    1e92:	0e 94 fc 0e 	call	0x1df8	; 0x1df8 <grant_local_control_permission>
              break;
    1e96:	08 95       	ret
          }
        }
      }
    else {
      u8 option = msg_buffer[0];
    1e98:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <msg_buffer>
      if (option < '1' || option > '2') {
    1e9c:	9f ec       	ldi	r25, 0xCF	; 207
    1e9e:	98 0f       	add	r25, r24
    1ea0:	92 30       	cpi	r25, 0x02	; 2
    1ea2:	38 f0       	brcs	.+14     	; 0x1eb2 <initial_options_menu+0x98>
        println_msg("Invalid option!\t");
    1ea4:	8b ee       	ldi	r24, 0xEB	; 235
    1ea6:	93 e0       	ldi	r25, 0x03	; 3
    1ea8:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
        initial_options_menu();
    1eac:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <initial_options_menu>
    1eb0:	08 95       	ret
        }
      else {
        switch (option) {
    1eb2:	81 33       	cpi	r24, 0x31	; 49
    1eb4:	19 f0       	breq	.+6      	; 0x1ebc <initial_options_menu+0xa2>
    1eb6:	82 33       	cpi	r24, 0x32	; 50
    1eb8:	21 f0       	breq	.+8      	; 0x1ec2 <initial_options_menu+0xa8>
    1eba:	08 95       	ret
            case '1':
              remote_control();
    1ebc:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <remote_control>
              break;
    1ec0:	08 95       	ret
            case '2':
              logout();
    1ec2:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <logout>
    1ec6:	08 95       	ret

00001ec8 <delete_user_prompt>:
void get_lamp_state(u8 lamp, u8* state) {
  DIO_Read(lamp + 2, PORT_C, state);
  }

void delete_user_prompt(void) {
  if (!user_input_accepted) {
    1ec8:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    1ecc:	81 11       	cpse	r24, r1
    1ece:	0e c0       	rjmp	.+28     	; 0x1eec <delete_user_prompt+0x24>
    print_msg("Enter the user name of the user you want to delete: ");
    1ed0:	8c ef       	ldi	r24, 0xFC	; 252
    1ed2:	93 e0       	ldi	r25, 0x03	; 3
    1ed4:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <print_msg>
    request_user_input(delete_user_prompt, 13, false);
    1ed8:	40 e0       	ldi	r20, 0x00	; 0
    1eda:	6d e0       	ldi	r22, 0x0D	; 13
    1edc:	84 e6       	ldi	r24, 0x64	; 100
    1ede:	9f e0       	ldi	r25, 0x0F	; 15
    1ee0:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
    user_input_accepted = true;
    1ee4:	81 e0       	ldi	r24, 0x01	; 1
    1ee6:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    1eea:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    1eec:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    1ef0:	67 e0       	ldi	r22, 0x07	; 7
    1ef2:	78 e0       	ldi	r23, 0x08	; 8
    1ef4:	87 e2       	ldi	r24, 0x27	; 39
    1ef6:	98 e0       	ldi	r25, 0x08	; 8
    1ef8:	0e 94 a3 12 	call	0x2546	; 0x2546 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    1efc:	83 30       	cpi	r24, 0x03	; 3
    1efe:	29 f4       	brne	.+10     	; 0x1f0a <delete_user_prompt+0x42>
      println_msg("\rError! User not found. Returning to the main menu...");
    1f00:	81 e3       	ldi	r24, 0x31	; 49
    1f02:	94 e0       	ldi	r25, 0x04	; 4
    1f04:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    1f08:	08 c0       	rjmp	.+16     	; 0x1f1a <delete_user_prompt+0x52>
      }
    else {
      // Delete the user
      delete_user(&temp_user);
    1f0a:	87 e0       	ldi	r24, 0x07	; 7
    1f0c:	98 e0       	ldi	r25, 0x08	; 8
    1f0e:	0e 94 7d 14 	call	0x28fa	; 0x28fa <delete_user>
      println_msg("The user has been deleted successfully!\t");
    1f12:	87 e6       	ldi	r24, 0x67	; 103
    1f14:	94 e0       	ldi	r25, 0x04	; 4
    1f16:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
      }
    initial_options_menu();
    1f1a:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <initial_options_menu>
    1f1e:	08 95       	ret

00001f20 <remote_control>:
    }
  remote_control();
  }

// Prints the state of the device and prompts the user if he wants to change it.
void remote_control(void) {
    1f20:	0f 93       	push	r16
    1f22:	1f 93       	push	r17
    1f24:	cf 93       	push	r28
    1f26:	df 93       	push	r29
    1f28:	1f 92       	push	r1
    1f2a:	cd b7       	in	r28, 0x3d	; 61
    1f2c:	de b7       	in	r29, 0x3e	; 62
  if (!user_input_accepted) {
    1f2e:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    1f32:	81 11       	cpse	r24, r1
    1f34:	0c c0       	rjmp	.+24     	; 0x1f4e <remote_control+0x2e>
    print_remote_control_menu();
    1f36:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <print_remote_control_menu>
    request_user_input(remote_control, 2, true);
    1f3a:	41 e0       	ldi	r20, 0x01	; 1
    1f3c:	62 e0       	ldi	r22, 0x02	; 2
    1f3e:	80 e9       	ldi	r24, 0x90	; 144
    1f40:	9f e0       	ldi	r25, 0x0F	; 15
    1f42:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
    user_input_accepted = true;
    1f46:	81 e0       	ldi	r24, 0x01	; 1
    1f48:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    1f4c:	4b c0       	rjmp	.+150    	; 0x1fe4 <remote_control+0xc4>
    }
  else {
    user_input_accepted = false;
    1f4e:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    u8 option = msg_buffer[0];
    1f52:	10 91 27 08 	lds	r17, 0x0827	; 0x800827 <msg_buffer>
    if ((!remote_user.isAdmin && option > '7') || option < '1' || option > '8') {
    1f56:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    1f5a:	81 11       	cpse	r24, r1
    1f5c:	02 c0       	rjmp	.+4      	; 0x1f62 <remote_control+0x42>
    1f5e:	18 33       	cpi	r17, 0x38	; 56
    1f60:	20 f4       	brcc	.+8      	; 0x1f6a <remote_control+0x4a>
    1f62:	11 33       	cpi	r17, 0x31	; 49
    1f64:	10 f0       	brcs	.+4      	; 0x1f6a <remote_control+0x4a>
    1f66:	19 33       	cpi	r17, 0x39	; 57
    1f68:	38 f0       	brcs	.+14     	; 0x1f78 <remote_control+0x58>
      println_msg("Invalid option!\t");
    1f6a:	8b ee       	ldi	r24, 0xEB	; 235
    1f6c:	93 e0       	ldi	r25, 0x03	; 3
    1f6e:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
      remote_control();
    1f72:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <remote_control>
    1f76:	36 c0       	rjmp	.+108    	; 0x1fe4 <remote_control+0xc4>
      }
    else {
      u8 state;
      get_lamp_state(option - 48, &state);
    1f78:	be 01       	movw	r22, r28
    1f7a:	6f 5f       	subi	r22, 0xFF	; 255
    1f7c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f7e:	00 ed       	ldi	r16, 0xD0	; 208
    1f80:	01 0f       	add	r16, r17
    1f82:	80 2f       	mov	r24, r16
    1f84:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <get_lamp_state>
      device_number = option - 48;
    1f88:	00 93 38 08 	sts	0x0838, r16	; 0x800838 <device_number>
      switch (option) {
    1f8c:	17 33       	cpi	r17, 0x37	; 55
    1f8e:	79 f0       	breq	.+30     	; 0x1fae <remote_control+0x8e>
    1f90:	18 33       	cpi	r17, 0x38	; 56
    1f92:	f9 f0       	breq	.+62     	; 0x1fd2 <remote_control+0xb2>
    1f94:	16 33       	cpi	r17, 0x36	; 54
    1f96:	01 f5       	brne	.+64     	; 0x1fd8 <remote_control+0xb8>
          case '6':
            print_msg("Enter the brightness level for the lamp(from 0(off) to 9(max)): ");
    1f98:	80 e9       	ldi	r24, 0x90	; 144
    1f9a:	94 e0       	ldi	r25, 0x04	; 4
    1f9c:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <print_msg>
            request_user_input(control_device, 2, true);
    1fa0:	41 e0       	ldi	r20, 0x01	; 1
    1fa2:	62 e0       	ldi	r22, 0x02	; 2
    1fa4:	88 ef       	ldi	r24, 0xF8	; 248
    1fa6:	9f e0       	ldi	r25, 0x0F	; 15
    1fa8:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
            break;
    1fac:	1b c0       	rjmp	.+54     	; 0x1fe4 <remote_control+0xc4>
          case '7':
            if (remote_user.isAdmin) {
    1fae:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    1fb2:	88 23       	and	r24, r24
    1fb4:	59 f0       	breq	.+22     	; 0x1fcc <remote_control+0xac>
              println_msg("Enter 1 to open the door and 0 to close it: ");
    1fb6:	81 ed       	ldi	r24, 0xD1	; 209
    1fb8:	94 e0       	ldi	r25, 0x04	; 4
    1fba:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
              request_user_input(control_device, 2, true);
    1fbe:	41 e0       	ldi	r20, 0x01	; 1
    1fc0:	62 e0       	ldi	r22, 0x02	; 2
    1fc2:	88 ef       	ldi	r24, 0xF8	; 248
    1fc4:	9f e0       	ldi	r25, 0x0F	; 15
    1fc6:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
    1fca:	0c c0       	rjmp	.+24     	; 0x1fe4 <remote_control+0xc4>
              }
            else {
              initial_options_menu();
    1fcc:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <initial_options_menu>
    1fd0:	09 c0       	rjmp	.+18     	; 0x1fe4 <remote_control+0xc4>
              }
            break;
          case '8':
            initial_options_menu();
    1fd2:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <initial_options_menu>
            break;
    1fd6:	06 c0       	rjmp	.+12     	; 0x1fe4 <remote_control+0xc4>
            // else {
            //   print_msg("Lamp ");
            //   // BT_sendChar(device_number);
            //   println_msg(" is off. Turn it on? (Y/N)");
            //   }
            request_user_input(control_device, 2, false);
    1fd8:	40 e0       	ldi	r20, 0x00	; 0
    1fda:	62 e0       	ldi	r22, 0x02	; 2
    1fdc:	88 ef       	ldi	r24, 0xF8	; 248
    1fde:	9f e0       	ldi	r25, 0x0F	; 15
    1fe0:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
            break;
        }
      }
    }
  }
    1fe4:	0f 90       	pop	r0
    1fe6:	df 91       	pop	r29
    1fe8:	cf 91       	pop	r28
    1fea:	1f 91       	pop	r17
    1fec:	0f 91       	pop	r16
    1fee:	08 95       	ret

00001ff0 <control_device>:
    println_msg("[7] Go back to main menu");
    }
  }

void control_device(void) {
  u8 option = msg_buffer[0];
    1ff0:	60 91 27 08 	lds	r22, 0x0827	; 0x800827 <msg_buffer>
  switch (device_number) {
    1ff4:	80 91 38 08 	lds	r24, 0x0838	; 0x800838 <device_number>
    1ff8:	86 30       	cpi	r24, 0x06	; 6
    1ffa:	19 f0       	breq	.+6      	; 0x2002 <control_device+0x12>
    1ffc:	87 30       	cpi	r24, 0x07	; 7
    1ffe:	d9 f0       	breq	.+54     	; 0x2036 <control_device+0x46>
    2000:	33 c0       	rjmp	.+102    	; 0x2068 <control_device+0x78>
      case 6:
        if (option < '0' || option > '9') {
    2002:	60 53       	subi	r22, 0x30	; 48
    2004:	6a 30       	cpi	r22, 0x0A	; 10
    2006:	28 f0       	brcs	.+10     	; 0x2012 <control_device+0x22>
          println_msg("\r\nInvalid input!!\t");
    2008:	8e ef       	ldi	r24, 0xFE	; 254
    200a:	94 e0       	ldi	r25, 0x04	; 4
    200c:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    2010:	37 c0       	rjmp	.+110    	; 0x2080 <control_device+0x90>
          }
        else {
          option -= 48; // Convert to int
          Lamp_dimmable_set_brightness((double)option / 9.0);
    2012:	70 e0       	ldi	r23, 0x00	; 0
    2014:	80 e0       	ldi	r24, 0x00	; 0
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	0e 94 05 16 	call	0x2c0a	; 0x2c0a <__floatunsisf>
    201c:	20 e0       	ldi	r18, 0x00	; 0
    201e:	30 e0       	ldi	r19, 0x00	; 0
    2020:	40 e1       	ldi	r20, 0x10	; 16
    2022:	51 e4       	ldi	r21, 0x41	; 65
    2024:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__divsf3>
    2028:	0e 94 4f 0a 	call	0x149e	; 0x149e <Lamp_dimmable_set_brightness>
          println_msg("The brightness has been adjusted!");
    202c:	81 e1       	ldi	r24, 0x11	; 17
    202e:	95 e0       	ldi	r25, 0x05	; 5
    2030:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    2034:	25 c0       	rjmp	.+74     	; 0x2080 <control_device+0x90>
          }
        break;
      case 7:
        if (option != '0' && option != '1') {
    2036:	80 ed       	ldi	r24, 0xD0	; 208
    2038:	86 0f       	add	r24, r22
    203a:	82 30       	cpi	r24, 0x02	; 2
    203c:	28 f0       	brcs	.+10     	; 0x2048 <control_device+0x58>
          println_msg("\r\nInvalid input!!\t");
    203e:	8e ef       	ldi	r24, 0xFE	; 254
    2040:	94 e0       	ldi	r25, 0x04	; 4
    2042:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    2046:	1c c0       	rjmp	.+56     	; 0x2080 <control_device+0x90>
          }
        else {
          if (option == '0') {
    2048:	60 33       	cpi	r22, 0x30	; 48
    204a:	39 f4       	brne	.+14     	; 0x205a <control_device+0x6a>
            Door_close();
    204c:	0e 94 9e 09 	call	0x133c	; 0x133c <Door_close>
            println_msg("The Door is closed now.");
    2050:	83 e3       	ldi	r24, 0x33	; 51
    2052:	95 e0       	ldi	r25, 0x05	; 5
    2054:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    2058:	13 c0       	rjmp	.+38     	; 0x2080 <control_device+0x90>
            }
          else {
            Door_open();
    205a:	0e 94 9a 09 	call	0x1334	; 0x1334 <Door_open>
            println_msg("The Door is open now.");
    205e:	8b e4       	ldi	r24, 0x4B	; 75
    2060:	95 e0       	ldi	r25, 0x05	; 5
    2062:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    2066:	0c c0       	rjmp	.+24     	; 0x2080 <control_device+0x90>
            }
          }
        break;
      default:
        if (option != 'Y' && option != 'y' && option != 'n' && option != 'N') {
    2068:	69 35       	cpi	r22, 0x59	; 89
    206a:	51 f0       	breq	.+20     	; 0x2080 <control_device+0x90>
    206c:	69 37       	cpi	r22, 0x79	; 121
    206e:	41 f0       	breq	.+16     	; 0x2080 <control_device+0x90>
    2070:	6e 36       	cpi	r22, 0x6E	; 110
    2072:	31 f0       	breq	.+12     	; 0x2080 <control_device+0x90>
    2074:	6e 34       	cpi	r22, 0x4E	; 78
    2076:	21 f0       	breq	.+8      	; 0x2080 <control_device+0x90>
          println_msg("\r\nInvalid input!!\t");
    2078:	8e ef       	ldi	r24, 0xFE	; 254
    207a:	94 e0       	ldi	r25, 0x04	; 4
    207c:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
          //   println_msg("The Lamp is now off!");
          //   }
          }
        break;
    }
  remote_control();
    2080:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <remote_control>
    2084:	08 95       	ret

00002086 <add_user_isAdmin_prompt>:
  println_msg("You have successfully logged out...");
  msg_length = 0;
  }

void add_user_isAdmin_prompt(void) {
  if (!user_input_accepted) {
    2086:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    208a:	81 11       	cpse	r24, r1
    208c:	0e c0       	rjmp	.+28     	; 0x20aa <add_user_isAdmin_prompt+0x24>
    println_msg("Do you want to make the new user an admin? (y/n) ");
    208e:	81 e6       	ldi	r24, 0x61	; 97
    2090:	95 e0       	ldi	r25, 0x05	; 5
    2092:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    request_user_input(add_user_isAdmin_prompt, 2, false);
    2096:	40 e0       	ldi	r20, 0x00	; 0
    2098:	62 e0       	ldi	r22, 0x02	; 2
    209a:	83 e4       	ldi	r24, 0x43	; 67
    209c:	90 e1       	ldi	r25, 0x10	; 16
    209e:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
    user_input_accepted = true;
    20a2:	81 e0       	ldi	r24, 0x01	; 1
    20a4:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    20a8:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    20aa:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    new_user.isAdmin = (msg_buffer[0] == 'y' || msg_buffer[0] == 'Y');
    20ae:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <msg_buffer>
    20b2:	89 37       	cpi	r24, 0x79	; 121
    20b4:	21 f0       	breq	.+8      	; 0x20be <add_user_isAdmin_prompt+0x38>
    20b6:	89 35       	cpi	r24, 0x59	; 89
    20b8:	21 f4       	brne	.+8      	; 0x20c2 <add_user_isAdmin_prompt+0x3c>
    20ba:	81 e0       	ldi	r24, 0x01	; 1
    20bc:	03 c0       	rjmp	.+6      	; 0x20c4 <add_user_isAdmin_prompt+0x3e>
    20be:	81 e0       	ldi	r24, 0x01	; 1
    20c0:	01 c0       	rjmp	.+2      	; 0x20c4 <add_user_isAdmin_prompt+0x3e>
    20c2:	80 e0       	ldi	r24, 0x00	; 0
    20c4:	80 93 39 08 	sts	0x0839, r24	; 0x800839 <new_user>
    add_user(&new_user);
    20c8:	89 e3       	ldi	r24, 0x39	; 57
    20ca:	98 e0       	ldi	r25, 0x08	; 8
    20cc:	0e 94 42 14 	call	0x2884	; 0x2884 <add_user>
    println_msg("User has been added successfully!");
    20d0:	83 e9       	ldi	r24, 0x93	; 147
    20d2:	95 e0       	ldi	r25, 0x05	; 5
    20d4:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    // Return to the main menu
    initial_options_menu();
    20d8:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <initial_options_menu>
    20dc:	08 95       	ret

000020de <add_user_password_prompt>:
    }
  }

void add_user_password_prompt(void) {
  if (!user_input_accepted) {
    20de:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    20e2:	81 11       	cpse	r24, r1
    20e4:	0e c0       	rjmp	.+28     	; 0x2102 <add_user_password_prompt+0x24>
    println_msg("Enter the new user's password(The password can only consist of numbers and 4 digits at least, 10 at max): ");
    20e6:	85 eb       	ldi	r24, 0xB5	; 181
    20e8:	95 e0       	ldi	r25, 0x05	; 5
    20ea:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    request_user_input(add_user_password_prompt, 11, true);
    20ee:	41 e0       	ldi	r20, 0x01	; 1
    20f0:	6b e0       	ldi	r22, 0x0B	; 11
    20f2:	8f e6       	ldi	r24, 0x6F	; 111
    20f4:	90 e1       	ldi	r25, 0x10	; 16
    20f6:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
    user_input_accepted = true;
    20fa:	81 e0       	ldi	r24, 0x01	; 1
    20fc:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    2100:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    2102:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (strlen(msg_buffer) < 4) {
    2106:	e7 e2       	ldi	r30, 0x27	; 39
    2108:	f8 e0       	ldi	r31, 0x08	; 8
    210a:	01 90       	ld	r0, Z+
    210c:	00 20       	and	r0, r0
    210e:	e9 f7       	brne	.-6      	; 0x210a <add_user_password_prompt+0x2c>
    2110:	31 97       	sbiw	r30, 0x01	; 1
    2112:	e7 52       	subi	r30, 0x27	; 39
    2114:	f8 40       	sbci	r31, 0x08	; 8
    2116:	34 97       	sbiw	r30, 0x04	; 4
    2118:	38 f4       	brcc	.+14     	; 0x2128 <add_user_password_prompt+0x4a>
      println_msg("Password too short!!\t");
    211a:	80 e2       	ldi	r24, 0x20	; 32
    211c:	96 e0       	ldi	r25, 0x06	; 6
    211e:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
      add_user_password_prompt();
    2122:	0e 94 6f 10 	call	0x20de	; 0x20de <add_user_password_prompt>
    2126:	08 95       	ret
      }
    else {
      strcpy(new_user.password, msg_buffer);
    2128:	67 e2       	ldi	r22, 0x27	; 39
    212a:	78 e0       	ldi	r23, 0x08	; 8
    212c:	8e e4       	ldi	r24, 0x4E	; 78
    212e:	98 e0       	ldi	r25, 0x08	; 8
    2130:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <strcpy>
      add_user_isAdmin_prompt();
    2134:	0e 94 43 10 	call	0x2086	; 0x2086 <add_user_isAdmin_prompt>
    2138:	08 95       	ret

0000213a <add_user_code_prompt>:
      }
    }
  }

void add_user_code_prompt(void) {
  if (!user_input_accepted) {
    213a:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    213e:	81 11       	cpse	r24, r1
    2140:	0e c0       	rjmp	.+28     	; 0x215e <add_user_code_prompt+0x24>
    print_msg("Enter the new user's code(must be a unique six digit code): ");
    2142:	86 e3       	ldi	r24, 0x36	; 54
    2144:	96 e0       	ldi	r25, 0x06	; 6
    2146:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <print_msg>
    request_user_input(add_user_code_prompt, 7, true);
    214a:	41 e0       	ldi	r20, 0x01	; 1
    214c:	67 e0       	ldi	r22, 0x07	; 7
    214e:	8d e9       	ldi	r24, 0x9D	; 157
    2150:	90 e1       	ldi	r25, 0x10	; 16
    2152:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
    user_input_accepted = true;
    2156:	81 e0       	ldi	r24, 0x01	; 1
    2158:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    215c:	08 95       	ret
    }
  else {// Validating the length of the user code. It can't be more than 6 digits by the input limitations. But the input can be smaller
    user_input_accepted = false;
    215e:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (strlen(msg_buffer) != 6) {
    2162:	e7 e2       	ldi	r30, 0x27	; 39
    2164:	f8 e0       	ldi	r31, 0x08	; 8
    2166:	01 90       	ld	r0, Z+
    2168:	00 20       	and	r0, r0
    216a:	e9 f7       	brne	.-6      	; 0x2166 <add_user_code_prompt+0x2c>
    216c:	ee 52       	subi	r30, 0x2E	; 46
    216e:	f8 40       	sbci	r31, 0x08	; 8
    2170:	39 f0       	breq	.+14     	; 0x2180 <add_user_code_prompt+0x46>
      println_msg("User code too short!");
    2172:	83 e7       	ldi	r24, 0x73	; 115
    2174:	96 e0       	ldi	r25, 0x06	; 6
    2176:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
      add_user_code_prompt();
    217a:	0e 94 9d 10 	call	0x213a	; 0x213a <add_user_code_prompt>
    217e:	08 95       	ret
      }
    else {
      EN_UserStatusCode_t userExists = getUserByCode(msg_buffer, &temp_user);
    2180:	67 e0       	ldi	r22, 0x07	; 7
    2182:	78 e0       	ldi	r23, 0x08	; 8
    2184:	87 e2       	ldi	r24, 0x27	; 39
    2186:	98 e0       	ldi	r25, 0x08	; 8
    2188:	0e 94 3c 13 	call	0x2678	; 0x2678 <getUserByCode>
      if (userExists == USER_NOT_FOUND) {
    218c:	83 30       	cpi	r24, 0x03	; 3
    218e:	49 f4       	brne	.+18     	; 0x21a2 <add_user_code_prompt+0x68>
        strcpy(new_user.code, msg_buffer);
    2190:	67 e2       	ldi	r22, 0x27	; 39
    2192:	78 e0       	ldi	r23, 0x08	; 8
    2194:	87 e4       	ldi	r24, 0x47	; 71
    2196:	98 e0       	ldi	r25, 0x08	; 8
    2198:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <strcpy>
        add_user_password_prompt();
    219c:	0e 94 6f 10 	call	0x20de	; 0x20de <add_user_password_prompt>
    21a0:	08 95       	ret
        }
      else {
        println_msg("\rThe user code already exists!\t");
    21a2:	88 e8       	ldi	r24, 0x88	; 136
    21a4:	96 e0       	ldi	r25, 0x06	; 6
    21a6:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
        add_user_code_prompt();
    21aa:	0e 94 9d 10 	call	0x213a	; 0x213a <add_user_code_prompt>
    21ae:	08 95       	ret

000021b0 <add_user_prompt>:
      }
    }
  }

void add_user_prompt(void) {
  if (!user_input_accepted) {
    21b0:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    21b4:	81 11       	cpse	r24, r1
    21b6:	0e c0       	rjmp	.+28     	; 0x21d4 <add_user_prompt+0x24>
    print_msg("Enter the new user's name: ");
    21b8:	88 ea       	ldi	r24, 0xA8	; 168
    21ba:	96 e0       	ldi	r25, 0x06	; 6
    21bc:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <print_msg>
    request_user_input(add_user_prompt, 13, false);
    21c0:	40 e0       	ldi	r20, 0x00	; 0
    21c2:	6d e0       	ldi	r22, 0x0D	; 13
    21c4:	88 ed       	ldi	r24, 0xD8	; 216
    21c6:	90 e1       	ldi	r25, 0x10	; 16
    21c8:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
    user_input_accepted = true;
    21cc:	81 e0       	ldi	r24, 0x01	; 1
    21ce:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    21d2:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    21d4:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    21d8:	67 e0       	ldi	r22, 0x07	; 7
    21da:	78 e0       	ldi	r23, 0x08	; 8
    21dc:	87 e2       	ldi	r24, 0x27	; 39
    21de:	98 e0       	ldi	r25, 0x08	; 8
    21e0:	0e 94 a3 12 	call	0x2546	; 0x2546 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    21e4:	83 30       	cpi	r24, 0x03	; 3
    21e6:	49 f4       	brne	.+18     	; 0x21fa <add_user_prompt+0x4a>
      strcpy(new_user.name, msg_buffer);
    21e8:	67 e2       	ldi	r22, 0x27	; 39
    21ea:	78 e0       	ldi	r23, 0x08	; 8
    21ec:	8a e3       	ldi	r24, 0x3A	; 58
    21ee:	98 e0       	ldi	r25, 0x08	; 8
    21f0:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <strcpy>
      add_user_code_prompt();
    21f4:	0e 94 9d 10 	call	0x213a	; 0x213a <add_user_code_prompt>
    21f8:	08 95       	ret
      }
    else {
      // Prompt the user to enter the user code
      println_msg("\rThe user already exists!\t");
    21fa:	84 ec       	ldi	r24, 0xC4	; 196
    21fc:	96 e0       	ldi	r25, 0x06	; 6
    21fe:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
      //! Return to the main menu
      initial_options_menu();
    2202:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <initial_options_menu>
    2206:	08 95       	ret

00002208 <invalid_remote_login_attempt>:
  // // Show the options menu
  // initial_options_menu();
  // }
  }

void invalid_remote_login_attempt(void) {
    2208:	0f 93       	push	r16
    220a:	1f 93       	push	r17
    220c:	cf 93       	push	r28
    220e:	df 93       	push	r29
    2210:	cd b7       	in	r28, 0x3d	; 61
    2212:	de b7       	in	r29, 0x3e	; 62
    2214:	e2 97       	sbiw	r28, 0x32	; 50
    2216:	0f b6       	in	r0, 0x3f	; 63
    2218:	f8 94       	cli
    221a:	de bf       	out	0x3e, r29	; 62
    221c:	0f be       	out	0x3f, r0	; 63
    221e:	cd bf       	out	0x3d, r28	; 61
  invalid_trails++;
    2220:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <invalid_trails>
    2224:	8f 5f       	subi	r24, 0xFF	; 255
    2226:	80 93 aa 07 	sts	0x07AA, r24	; 0x8007aa <invalid_trails>
  s8 msg[50];
  if (invalid_trails < 3) {
    222a:	83 30       	cpi	r24, 0x03	; 3
    222c:	e8 f4       	brcc	.+58     	; 0x2268 <invalid_remote_login_attempt+0x60>
    sprintf(msg, "Invalid login attempt! \r\n%d attempts remaining.", 3 - invalid_trails);
    222e:	23 e0       	ldi	r18, 0x03	; 3
    2230:	30 e0       	ldi	r19, 0x00	; 0
    2232:	a9 01       	movw	r20, r18
    2234:	48 1b       	sub	r20, r24
    2236:	51 09       	sbc	r21, r1
    2238:	ca 01       	movw	r24, r20
    223a:	9f 93       	push	r25
    223c:	4f 93       	push	r20
    223e:	8f ed       	ldi	r24, 0xDF	; 223
    2240:	96 e0       	ldi	r25, 0x06	; 6
    2242:	9f 93       	push	r25
    2244:	8f 93       	push	r24
    2246:	8e 01       	movw	r16, r28
    2248:	0f 5f       	subi	r16, 0xFF	; 255
    224a:	1f 4f       	sbci	r17, 0xFF	; 255
    224c:	1f 93       	push	r17
    224e:	0f 93       	push	r16
    2250:	0e 94 16 17 	call	0x2e2c	; 0x2e2c <sprintf>
    println_msg(msg);
    2254:	c8 01       	movw	r24, r16
    2256:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
    return;
    225a:	0f 90       	pop	r0
    225c:	0f 90       	pop	r0
    225e:	0f 90       	pop	r0
    2260:	0f 90       	pop	r0
    2262:	0f 90       	pop	r0
    2264:	0f 90       	pop	r0
    2266:	11 c0       	rjmp	.+34     	; 0x228a <invalid_remote_login_attempt+0x82>
    }
  strcpy(msg, "Too many login attempts! \r--- System Suspended! ---");
    2268:	84 e3       	ldi	r24, 0x34	; 52
    226a:	ef e0       	ldi	r30, 0x0F	; 15
    226c:	f7 e0       	ldi	r31, 0x07	; 7
    226e:	de 01       	movw	r26, r28
    2270:	11 96       	adiw	r26, 0x01	; 1
    2272:	01 90       	ld	r0, Z+
    2274:	0d 92       	st	X+, r0
    2276:	8a 95       	dec	r24
    2278:	e1 f7       	brne	.-8      	; 0x2272 <invalid_remote_login_attempt+0x6a>
  println_msg(msg);
    227a:	ce 01       	movw	r24, r28
    227c:	01 96       	adiw	r24, 0x01	; 1
    227e:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
  Alarm_set();
    2282:	0e 94 d5 13 	call	0x27aa	; 0x27aa <Alarm_set>
  run_system = false;
    2286:	10 92 a9 07 	sts	0x07A9, r1	; 0x8007a9 <run_system>
  }
    228a:	e2 96       	adiw	r28, 0x32	; 50
    228c:	0f b6       	in	r0, 0x3f	; 63
    228e:	f8 94       	cli
    2290:	de bf       	out	0x3e, r29	; 62
    2292:	0f be       	out	0x3f, r0	; 63
    2294:	cd bf       	out	0x3d, r28	; 61
    2296:	df 91       	pop	r29
    2298:	cf 91       	pop	r28
    229a:	1f 91       	pop	r17
    229c:	0f 91       	pop	r16
    229e:	08 95       	ret

000022a0 <userPassword_prompt_handler>:
      }
    }
  }

void userPassword_prompt_handler(void) {
  if (!user_input_accepted) {
    22a0:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    22a4:	81 11       	cpse	r24, r1
    22a6:	0e c0       	rjmp	.+28     	; 0x22c4 <userPassword_prompt_handler+0x24>
    print_msg("Enter your password:\t");
    22a8:	83 e4       	ldi	r24, 0x43	; 67
    22aa:	97 e0       	ldi	r25, 0x07	; 7
    22ac:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <print_msg>
    request_user_input(userPassword_prompt_handler, 11, true);
    22b0:	41 e0       	ldi	r20, 0x01	; 1
    22b2:	6b e0       	ldi	r22, 0x0B	; 11
    22b4:	80 e5       	ldi	r24, 0x50	; 80
    22b6:	91 e1       	ldi	r25, 0x11	; 17
    22b8:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
    user_input_accepted = true;
    22bc:	81 e0       	ldi	r24, 0x01	; 1
    22be:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    22c2:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    22c4:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (strcmp(remote_user.password, msg_buffer)) { // Wrong password
    22c8:	67 e2       	ldi	r22, 0x27	; 39
    22ca:	78 e0       	ldi	r23, 0x08	; 8
    22cc:	8c ef       	ldi	r24, 0xFC	; 252
    22ce:	97 e0       	ldi	r25, 0x07	; 7
    22d0:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <strcmp>
    22d4:	89 2b       	or	r24, r25
    22d6:	49 f0       	breq	.+18     	; 0x22ea <userPassword_prompt_handler+0x4a>
      println_msg("Wrong password!");
    22d8:	89 e5       	ldi	r24, 0x59	; 89
    22da:	97 e0       	ldi	r25, 0x07	; 7
    22dc:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
      invalid_remote_login_attempt();
    22e0:	0e 94 04 11 	call	0x2208	; 0x2208 <invalid_remote_login_attempt>
      userPassword_prompt_handler();
    22e4:	0e 94 50 11 	call	0x22a0	; 0x22a0 <userPassword_prompt_handler>
    22e8:	08 95       	ret
      }
    else {
      remote_user_loggedin = true;
    22ea:	81 e0       	ldi	r24, 0x01	; 1
    22ec:	80 93 a8 07 	sts	0x07A8, r24	; 0x8007a8 <remote_user_loggedin>
      print_msg("Welcome ");
    22f0:	89 e6       	ldi	r24, 0x69	; 105
    22f2:	97 e0       	ldi	r25, 0x07	; 7
    22f4:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <print_msg>
      print_msg(remote_user.name);
    22f8:	88 ee       	ldi	r24, 0xE8	; 232
    22fa:	97 e0       	ldi	r25, 0x07	; 7
    22fc:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <print_msg>
      println_msg("!");
    2300:	83 ee       	ldi	r24, 0xE3	; 227
    2302:	91 e0       	ldi	r25, 0x01	; 1
    2304:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
      // Show the options menu
      initial_options_menu();
    2308:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <initial_options_menu>
    230c:	08 95       	ret

0000230e <userName_prompt_handler>:
    }
  }

void userName_prompt_handler(void) {
  // Request user input for the first time and in case of wrong input
  if (!user_input_accepted) {
    230e:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    2312:	81 11       	cpse	r24, r1
    2314:	0e c0       	rjmp	.+28     	; 0x2332 <userName_prompt_handler+0x24>
    print_msg("Enter your user name:\t");
    2316:	82 e7       	ldi	r24, 0x72	; 114
    2318:	97 e0       	ldi	r25, 0x07	; 7
    231a:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <print_msg>
    request_user_input(userName_prompt_handler, 13, false);
    231e:	40 e0       	ldi	r20, 0x00	; 0
    2320:	6d e0       	ldi	r22, 0x0D	; 13
    2322:	87 e8       	ldi	r24, 0x87	; 135
    2324:	91 e1       	ldi	r25, 0x11	; 17
    2326:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <request_user_input>
    user_input_accepted = true;
    232a:	81 e0       	ldi	r24, 0x01	; 1
    232c:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    2330:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &remote_user);
    2332:	67 ee       	ldi	r22, 0xE7	; 231
    2334:	77 e0       	ldi	r23, 0x07	; 7
    2336:	87 e2       	ldi	r24, 0x27	; 39
    2338:	98 e0       	ldi	r25, 0x08	; 8
    233a:	0e 94 a3 12 	call	0x2546	; 0x2546 <getUserByName>
    user_input_accepted = false;
    233e:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (userExists == USER_NOT_FOUND) {
    2342:	83 30       	cpi	r24, 0x03	; 3
    2344:	49 f4       	brne	.+18     	; 0x2358 <userName_prompt_handler+0x4a>
      println_msg("User doesn't exist!");
    2346:	89 e8       	ldi	r24, 0x89	; 137
    2348:	97 e0       	ldi	r25, 0x07	; 7
    234a:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
      invalid_remote_login_attempt();
    234e:	0e 94 04 11 	call	0x2208	; 0x2208 <invalid_remote_login_attempt>
      userName_prompt_handler();
    2352:	0e 94 87 11 	call	0x230e	; 0x230e <userName_prompt_handler>
    2356:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      userPassword_prompt_handler();
    2358:	0e 94 50 11 	call	0x22a0	; 0x22a0 <userPassword_prompt_handler>
    235c:	08 95       	ret

0000235e <remote_login_prompt>:
  }

void remote_login_prompt(void) {
  //! for some reason this part causes a compilation error related to .bss section in memory!!!! 
  // if (!remote_user_loggedin) {
  println_msg("Welcome!");
    235e:	8d e9       	ldi	r24, 0x9D	; 157
    2360:	97 e0       	ldi	r25, 0x07	; 7
    2362:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <println_msg>
  // println_msg("Welcome to the Smart Home System!");
  // println_msg("To proceed, please login.");
  userName_prompt_handler();
    2366:	0e 94 87 11 	call	0x230e	; 0x230e <userName_prompt_handler>
    236a:	08 95       	ret

0000236c <__vector_13>:
  Alarm_set();
  run_system = false;
  }

// Handles the user input asynchronously.
ISR(USART_RXC_vect) {
    236c:	1f 92       	push	r1
    236e:	0f 92       	push	r0
    2370:	0f b6       	in	r0, 0x3f	; 63
    2372:	0f 92       	push	r0
    2374:	11 24       	eor	r1, r1
    2376:	2f 93       	push	r18
    2378:	3f 93       	push	r19
    237a:	4f 93       	push	r20
    237c:	5f 93       	push	r21
    237e:	6f 93       	push	r22
    2380:	7f 93       	push	r23
    2382:	8f 93       	push	r24
    2384:	9f 93       	push	r25
    2386:	af 93       	push	r26
    2388:	bf 93       	push	r27
    238a:	ef 93       	push	r30
    238c:	ff 93       	push	r31
#if UART_COMMUNICATION_INTERFACE ==  PROTEUS_VIRTUAL_TERMINAL
  // Read the UDR to clear the RXC bit
  udr_temp = UDR;
    238e:	8c b1       	in	r24, 0x0c	; 12
    2390:	80 93 37 08 	sts	0x0837, r24	; 0x800837 <udr_temp>

  // If no input requested, ignore the input. No input requested is indicated by msg length of zero
  if (msg_length == 0) return;
    2394:	90 91 36 08 	lds	r25, 0x0836	; 0x800836 <msg_length>
    2398:	99 23       	and	r25, r25
    239a:	09 f4       	brne	.+2      	; 0x239e <__vector_13+0x32>
    239c:	5b c0       	rjmp	.+182    	; 0x2454 <__vector_13+0xe8>

  // Accept numbers only in the numerical input mode
  if (numerical_input_mode) {
    239e:	90 91 e6 07 	lds	r25, 0x07E6	; 0x8007e6 <numerical_input_mode>
    23a2:	99 23       	and	r25, r25
    23a4:	59 f0       	breq	.+22     	; 0x23bc <__vector_13+0x50>
    if (!((udr_temp >= '0' && udr_temp <= '9') || udr_temp == '\b' || udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER || udr_temp == '\n')) {
    23a6:	90 ed       	ldi	r25, 0xD0	; 208
    23a8:	98 0f       	add	r25, r24
    23aa:	9a 30       	cpi	r25, 0x0A	; 10
    23ac:	38 f0       	brcs	.+14     	; 0x23bc <__vector_13+0x50>
    23ae:	88 30       	cpi	r24, 0x08	; 8
    23b0:	29 f0       	breq	.+10     	; 0x23bc <__vector_13+0x50>
    23b2:	8d 30       	cpi	r24, 0x0D	; 13
    23b4:	19 f0       	breq	.+6      	; 0x23bc <__vector_13+0x50>
    23b6:	8a 30       	cpi	r24, 0x0A	; 10
    23b8:	09 f0       	breq	.+2      	; 0x23bc <__vector_13+0x50>
    23ba:	4c c0       	rjmp	.+152    	; 0x2454 <__vector_13+0xe8>
      return;
      }
    }

  // Handling backspaces
  if (udr_temp == '\b') {
    23bc:	88 30       	cpi	r24, 0x08	; 8
    23be:	59 f4       	brne	.+22     	; 0x23d6 <__vector_13+0x6a>
    if (msg_buffer_pointer > 0) {
    23c0:	90 91 e5 07 	lds	r25, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    23c4:	99 23       	and	r25, r25
    23c6:	09 f4       	brne	.+2      	; 0x23ca <__vector_13+0x5e>
    23c8:	45 c0       	rjmp	.+138    	; 0x2454 <__vector_13+0xe8>
      msg_buffer_pointer--;
    23ca:	91 50       	subi	r25, 0x01	; 1
    23cc:	90 93 e5 07 	sts	0x07E5, r25	; 0x8007e5 <msg_buffer_pointer>
      BT_sendChar(udr_temp);
    23d0:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <BT_sendChar>
    23d4:	3f c0       	rjmp	.+126    	; 0x2454 <__vector_13+0xe8>
      }
    return;
    }

  msg_buffer[msg_buffer_pointer] = udr_temp;
    23d6:	90 91 e5 07 	lds	r25, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    23da:	e9 2f       	mov	r30, r25
    23dc:	f0 e0       	ldi	r31, 0x00	; 0
    23de:	e9 5d       	subi	r30, 0xD9	; 217
    23e0:	f7 4f       	sbci	r31, 0xF7	; 247
    23e2:	80 83       	st	Z, r24
  msg_buffer_pointer++;
    23e4:	9f 5f       	subi	r25, 0xFF	; 255
    23e6:	90 93 e5 07 	sts	0x07E5, r25	; 0x8007e5 <msg_buffer_pointer>

  // Msg is empty
  // Ignore null msgs
  if (msg_buffer_pointer == 1) {
    23ea:	91 30       	cpi	r25, 0x01	; 1
    23ec:	39 f4       	brne	.+14     	; 0x23fc <__vector_13+0x90>
    if (msg_buffer[0] == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    23ee:	90 91 27 08 	lds	r25, 0x0827	; 0x800827 <msg_buffer>
    23f2:	9d 30       	cpi	r25, 0x0D	; 13
    23f4:	19 f4       	brne	.+6      	; 0x23fc <__vector_13+0x90>
      msg_buffer_pointer = 0;
    23f6:	10 92 e5 07 	sts	0x07E5, r1	; 0x8007e5 <msg_buffer_pointer>
      return;
    23fa:	2c c0       	rjmp	.+88     	; 0x2454 <__vector_13+0xe8>
      }
    }

  // Echo the sent char on the terminal
  //! Proteus virtual terminal doesn't send a line feed char (ASCII code: 10). Instead it sends a carriage return (ASCII code: 13).
  if (udr_temp != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER)
    23fc:	8d 30       	cpi	r24, 0x0D	; 13
    23fe:	11 f0       	breq	.+4      	; 0x2404 <__vector_13+0x98>
    BT_sendChar(udr_temp);
    2400:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <BT_sendChar>

  // Msg is longer than required
  // Delete the last input char. Don't allow the user to enter longer input than the maximum required
  if (msg_buffer_pointer == msg_length) {
    2404:	80 91 e5 07 	lds	r24, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    2408:	90 91 36 08 	lds	r25, 0x0836	; 0x800836 <msg_length>
    240c:	89 13       	cpse	r24, r25
    240e:	0d c0       	rjmp	.+26     	; 0x242a <__vector_13+0xbe>
    if (msg_buffer[msg_buffer_pointer - 1] != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    2410:	e8 2f       	mov	r30, r24
    2412:	f0 e0       	ldi	r31, 0x00	; 0
    2414:	ea 5d       	subi	r30, 0xDA	; 218
    2416:	f7 4f       	sbci	r31, 0xF7	; 247
    2418:	90 81       	ld	r25, Z
    241a:	9d 30       	cpi	r25, 0x0D	; 13
    241c:	31 f0       	breq	.+12     	; 0x242a <__vector_13+0xbe>
      msg_buffer_pointer--;
    241e:	81 50       	subi	r24, 0x01	; 1
    2420:	80 93 e5 07 	sts	0x07E5, r24	; 0x8007e5 <msg_buffer_pointer>
      BT_sendChar('\b');
    2424:	88 e0       	ldi	r24, 0x08	; 8
    2426:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <BT_sendChar>
      }
    }

  // Msg has ended and is within the required length
  if (udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    242a:	80 91 37 08 	lds	r24, 0x0837	; 0x800837 <udr_temp>
    242e:	8d 30       	cpi	r24, 0x0D	; 13
    2430:	89 f4       	brne	.+34     	; 0x2454 <__vector_13+0xe8>
    if (msg_buffer_pointer <= msg_length) {
    2432:	e0 91 e5 07 	lds	r30, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    2436:	80 91 36 08 	lds	r24, 0x0836	; 0x800836 <msg_length>
    243a:	8e 17       	cp	r24, r30
    243c:	58 f0       	brcs	.+22     	; 0x2454 <__vector_13+0xe8>
      // Replace the carriage return with null to terminate the string correctly
      msg_buffer[msg_buffer_pointer - 1] = '\0';
    243e:	f0 e0       	ldi	r31, 0x00	; 0
    2440:	ea 5d       	subi	r30, 0xDA	; 218
    2442:	f7 4f       	sbci	r31, 0xF7	; 247
    2444:	10 82       	st	Z, r1
      BT_sendChar('\r');
    2446:	8d e0       	ldi	r24, 0x0D	; 13
    2448:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <BT_sendChar>
      callFunWhenBufferReady();
    244c:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <callFunWhenBufferReady>
      msg_buffer_pointer = 0;
    2450:	10 92 e5 07 	sts	0x07E5, r1	; 0x8007e5 <msg_buffer_pointer>
      callFunWhenBufferReady();
      msg_buffer_pointer = 0;
      }
    }
#endif
  }
    2454:	ff 91       	pop	r31
    2456:	ef 91       	pop	r30
    2458:	bf 91       	pop	r27
    245a:	af 91       	pop	r26
    245c:	9f 91       	pop	r25
    245e:	8f 91       	pop	r24
    2460:	7f 91       	pop	r23
    2462:	6f 91       	pop	r22
    2464:	5f 91       	pop	r21
    2466:	4f 91       	pop	r20
    2468:	3f 91       	pop	r19
    246a:	2f 91       	pop	r18
    246c:	0f 90       	pop	r0
    246e:	0f be       	out	0x3f, r0	; 63
    2470:	0f 90       	pop	r0
    2472:	1f 90       	pop	r1
    2474:	18 95       	reti

00002476 <__vector_1>:

ISR(INT0_vect) {
    2476:	1f 92       	push	r1
    2478:	0f 92       	push	r0
    247a:	0f b6       	in	r0, 0x3f	; 63
    247c:	0f 92       	push	r0
    247e:	11 24       	eor	r1, r1
    2480:	2f 93       	push	r18
    2482:	3f 93       	push	r19
    2484:	4f 93       	push	r20
    2486:	5f 93       	push	r21
    2488:	6f 93       	push	r22
    248a:	7f 93       	push	r23
    248c:	8f 93       	push	r24
    248e:	9f 93       	push	r25
    2490:	af 93       	push	r26
    2492:	bf 93       	push	r27
    2494:	ef 93       	push	r30
    2496:	ff 93       	push	r31
  // Initialize communication with the user
  // Request user login credentials
  remote_login_prompt();
    2498:	0e 94 af 11 	call	0x235e	; 0x235e <remote_login_prompt>
  }
    249c:	ff 91       	pop	r31
    249e:	ef 91       	pop	r30
    24a0:	bf 91       	pop	r27
    24a2:	af 91       	pop	r26
    24a4:	9f 91       	pop	r25
    24a6:	8f 91       	pop	r24
    24a8:	7f 91       	pop	r23
    24aa:	6f 91       	pop	r22
    24ac:	5f 91       	pop	r21
    24ae:	4f 91       	pop	r20
    24b0:	3f 91       	pop	r19
    24b2:	2f 91       	pop	r18
    24b4:	0f 90       	pop	r0
    24b6:	0f be       	out	0x3f, r0	; 63
    24b8:	0f 90       	pop	r0
    24ba:	1f 90       	pop	r1
    24bc:	18 95       	reti

000024be <__vector_16>:
#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_BY_ACTIVATING_TIMER0_OVF_INT
// To reset the TOV0 flag. Alternatively, it can be reset in the ADC complete interrupt.
ISR(TIMER0_OVF_vect) {}
#endif

ISR(ADC_vect) {
    24be:	1f 92       	push	r1
    24c0:	0f 92       	push	r0
    24c2:	0f b6       	in	r0, 0x3f	; 63
    24c4:	0f 92       	push	r0
    24c6:	11 24       	eor	r1, r1
    24c8:	2f 93       	push	r18
    24ca:	3f 93       	push	r19
    24cc:	4f 93       	push	r20
    24ce:	5f 93       	push	r21
    24d0:	6f 93       	push	r22
    24d2:	7f 93       	push	r23
    24d4:	8f 93       	push	r24
    24d6:	9f 93       	push	r25
    24d8:	af 93       	push	r26
    24da:	bf 93       	push	r27
    24dc:	cf 93       	push	r28
    24de:	df 93       	push	r29
    24e0:	ef 93       	push	r30
    24e2:	ff 93       	push	r31
  u16 temperature;
  temperature = ADCL + (ADCH << 8);
    24e4:	84 b1       	in	r24, 0x04	; 4
    24e6:	c5 b1       	in	r28, 0x05	; 5
    24e8:	d0 e0       	ldi	r29, 0x00	; 0
    24ea:	dc 2f       	mov	r29, r28
    24ec:	cc 27       	eor	r28, r28
    24ee:	c8 0f       	add	r28, r24
    24f0:	d1 1d       	adc	r29, r1
  // Since the ADC is set to use the internal VREF of 2.56 V, the resolution of the ADC is 2.5 mV. This resolution allows to measure the temperature
  // out of the LM35 with a resolution of 0.25 degree celsius, since each 10mV  increment on the LM35 output is 1 degree C.
  // If the temperature is higher than the maximum specified temperature, turn on the AC.
  if (temperature > AMBIENT_HIGH_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, HIGH);
    24f2:	c1 37       	cpi	r28, 0x71	; 113
    24f4:	d1 05       	cpc	r29, r1
    24f6:	28 f0       	brcs	.+10     	; 0x2502 <__vector_16+0x44>
    24f8:	41 e0       	ldi	r20, 0x01	; 1
    24fa:	63 e4       	ldi	r22, 0x43	; 67
    24fc:	87 e0       	ldi	r24, 0x07	; 7
    24fe:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>
  // If the temperature became below the minimum specified temperature turn off the AC.
  if (temperature < AMBIENT_LOW_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, LOW);
    2502:	c4 35       	cpi	r28, 0x54	; 84
    2504:	d1 05       	cpc	r29, r1
    2506:	28 f4       	brcc	.+10     	; 0x2512 <__vector_16+0x54>
    2508:	40 e0       	ldi	r20, 0x00	; 0
    250a:	63 e4       	ldi	r22, 0x43	; 67
    250c:	87 e0       	ldi	r24, 0x07	; 7
    250e:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <DIO_write>

#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_VIA_ADC_COMPLETE_INTERRUPT
  // Since the ADC is configured in auto trigger mode with timer 0 overflow as the trigger, 
  // The overflow interrupt flag bit must be cleared by software if timer 0 overflow interrupt isn't used. 
  // Otherwise the triggering won't work and the ADC will halt.
  set_bit(TIFR, TOV0);
    2512:	88 b7       	in	r24, 0x38	; 56
    2514:	81 60       	ori	r24, 0x01	; 1
    2516:	88 bf       	out	0x38, r24	; 56
#endif
    2518:	ff 91       	pop	r31
    251a:	ef 91       	pop	r30
    251c:	df 91       	pop	r29
    251e:	cf 91       	pop	r28
    2520:	bf 91       	pop	r27
    2522:	af 91       	pop	r26
    2524:	9f 91       	pop	r25
    2526:	8f 91       	pop	r24
    2528:	7f 91       	pop	r23
    252a:	6f 91       	pop	r22
    252c:	5f 91       	pop	r21
    252e:	4f 91       	pop	r20
    2530:	3f 91       	pop	r19
    2532:	2f 91       	pop	r18
    2534:	0f 90       	pop	r0
    2536:	0f be       	out	0x3f, r0	; 63
    2538:	0f 90       	pop	r0
    253a:	1f 90       	pop	r1
    253c:	18 95       	reti

0000253e <User_DB_init>:
    return getUserByName(user_code_or_name, user);
    }
  else {
    return getUserByCode(user_code_or_name, user);
    }
  }
    253e:	0e 94 b6 00 	call	0x16c	; 0x16c <EEPROM_init>
    2542:	88 e0       	ldi	r24, 0x08	; 8
    2544:	08 95       	ret

00002546 <getUserByName>:
    2546:	9f 92       	push	r9
    2548:	af 92       	push	r10
    254a:	bf 92       	push	r11
    254c:	cf 92       	push	r12
    254e:	df 92       	push	r13
    2550:	ef 92       	push	r14
    2552:	ff 92       	push	r15
    2554:	0f 93       	push	r16
    2556:	1f 93       	push	r17
    2558:	cf 93       	push	r28
    255a:	df 93       	push	r29
    255c:	cd b7       	in	r28, 0x3d	; 61
    255e:	de b7       	in	r29, 0x3e	; 62
    2560:	6d 97       	sbiw	r28, 0x1d	; 29
    2562:	0f b6       	in	r0, 0x3f	; 63
    2564:	f8 94       	cli
    2566:	de bf       	out	0x3e, r29	; 62
    2568:	0f be       	out	0x3f, r0	; 63
    256a:	cd bf       	out	0x3d, r28	; 61
    256c:	7c 01       	movw	r14, r24
    256e:	6b 01       	movw	r12, r22
    2570:	91 2c       	mov	r9, r1
    2572:	6b c0       	rjmp	.+214    	; 0x264a <getUserByName+0x104>
    2574:	ae 01       	movw	r20, r28
    2576:	4f 5f       	subi	r20, 0xFF	; 255
    2578:	5f 4f       	sbci	r21, 0xFF	; 255
    257a:	60 e0       	ldi	r22, 0x00	; 0
    257c:	89 2d       	mov	r24, r9
    257e:	0e 94 b9 00 	call	0x172	; 0x172 <EEPROM_read_byte>
    2582:	ae 01       	movw	r20, r28
    2584:	4e 5f       	subi	r20, 0xFE	; 254
    2586:	5f 4f       	sbci	r21, 0xFF	; 255
    2588:	61 e0       	ldi	r22, 0x01	; 1
    258a:	89 2d       	mov	r24, r9
    258c:	0e 94 b9 00 	call	0x172	; 0x172 <EEPROM_read_byte>
    2590:	b1 2c       	mov	r11, r1
    2592:	56 c0       	rjmp	.+172    	; 0x2640 <getUserByName+0xfa>
    2594:	89 81       	ldd	r24, Y+1	; 0x01
    2596:	90 e0       	ldi	r25, 0x00	; 0
    2598:	0b 2c       	mov	r0, r11
    259a:	02 c0       	rjmp	.+4      	; 0x25a0 <getUserByName+0x5a>
    259c:	95 95       	asr	r25
    259e:	87 95       	ror	r24
    25a0:	0a 94       	dec	r0
    25a2:	e2 f7       	brpl	.-8      	; 0x259c <getUserByName+0x56>
    25a4:	80 ff       	sbrs	r24, 0
    25a6:	4b c0       	rjmp	.+150    	; 0x263e <getUserByName+0xf8>
    25a8:	6f e1       	ldi	r22, 0x1F	; 31
    25aa:	b6 9e       	mul	r11, r22
    25ac:	a0 2c       	mov	r10, r0
    25ae:	11 24       	eor	r1, r1
    25b0:	68 e0       	ldi	r22, 0x08	; 8
    25b2:	6a 0d       	add	r22, r10
    25b4:	9e 01       	movw	r18, r28
    25b6:	2d 5f       	subi	r18, 0xFD	; 253
    25b8:	3f 4f       	sbci	r19, 0xFF	; 255
    25ba:	4d e0       	ldi	r20, 0x0D	; 13
    25bc:	50 e0       	ldi	r21, 0x00	; 0
    25be:	89 2d       	mov	r24, r9
    25c0:	0e 94 da 00 	call	0x1b4	; 0x1b4 <EEPROM_read_block>
    25c4:	be 01       	movw	r22, r28
    25c6:	6d 5f       	subi	r22, 0xFD	; 253
    25c8:	7f 4f       	sbci	r23, 0xFF	; 255
    25ca:	c7 01       	movw	r24, r14
    25cc:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <strcmp>
    25d0:	89 2b       	or	r24, r25
    25d2:	a9 f5       	brne	.+106    	; 0x263e <getUserByName+0xf8>
    25d4:	65 e1       	ldi	r22, 0x15	; 21
    25d6:	6a 0d       	add	r22, r10
    25d8:	9e 01       	movw	r18, r28
    25da:	20 5f       	subi	r18, 0xF0	; 240
    25dc:	3f 4f       	sbci	r19, 0xFF	; 255
    25de:	47 e0       	ldi	r20, 0x07	; 7
    25e0:	50 e0       	ldi	r21, 0x00	; 0
    25e2:	89 2d       	mov	r24, r9
    25e4:	0e 94 da 00 	call	0x1b4	; 0x1b4 <EEPROM_read_block>
    25e8:	6c e1       	ldi	r22, 0x1C	; 28
    25ea:	6a 0d       	add	r22, r10
    25ec:	9e 01       	movw	r18, r28
    25ee:	29 5e       	subi	r18, 0xE9	; 233
    25f0:	3f 4f       	sbci	r19, 0xFF	; 255
    25f2:	47 e0       	ldi	r20, 0x07	; 7
    25f4:	50 e0       	ldi	r21, 0x00	; 0
    25f6:	89 2d       	mov	r24, r9
    25f8:	0e 94 da 00 	call	0x1b4	; 0x1b4 <EEPROM_read_block>
    25fc:	8a 81       	ldd	r24, Y+2	; 0x02
    25fe:	90 e0       	ldi	r25, 0x00	; 0
    2600:	02 c0       	rjmp	.+4      	; 0x2606 <getUserByName+0xc0>
    2602:	95 95       	asr	r25
    2604:	87 95       	ror	r24
    2606:	ba 94       	dec	r11
    2608:	e2 f7       	brpl	.-8      	; 0x2602 <getUserByName+0xbc>
    260a:	98 2f       	mov	r25, r24
    260c:	91 70       	andi	r25, 0x01	; 1
    260e:	f6 01       	movw	r30, r12
    2610:	91 93       	st	Z+, r25
    2612:	be 01       	movw	r22, r28
    2614:	6d 5f       	subi	r22, 0xFD	; 253
    2616:	7f 4f       	sbci	r23, 0xFF	; 255
    2618:	cf 01       	movw	r24, r30
    261a:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <strcpy>
    261e:	be 01       	movw	r22, r28
    2620:	60 5f       	subi	r22, 0xF0	; 240
    2622:	7f 4f       	sbci	r23, 0xFF	; 255
    2624:	c6 01       	movw	r24, r12
    2626:	0e 96       	adiw	r24, 0x0e	; 14
    2628:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <strcpy>
    262c:	be 01       	movw	r22, r28
    262e:	69 5e       	subi	r22, 0xE9	; 233
    2630:	7f 4f       	sbci	r23, 0xFF	; 255
    2632:	c6 01       	movw	r24, r12
    2634:	45 96       	adiw	r24, 0x15	; 21
    2636:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <strcpy>
    263a:	82 e0       	ldi	r24, 0x02	; 2
    263c:	0b c0       	rjmp	.+22     	; 0x2654 <getUserByName+0x10e>
    263e:	b3 94       	inc	r11
    2640:	87 e0       	ldi	r24, 0x07	; 7
    2642:	8b 15       	cp	r24, r11
    2644:	08 f0       	brcs	.+2      	; 0x2648 <getUserByName+0x102>
    2646:	a6 cf       	rjmp	.-180    	; 0x2594 <getUserByName+0x4e>
    2648:	93 94       	inc	r9
    264a:	87 e0       	ldi	r24, 0x07	; 7
    264c:	89 15       	cp	r24, r9
    264e:	08 f0       	brcs	.+2      	; 0x2652 <getUserByName+0x10c>
    2650:	91 cf       	rjmp	.-222    	; 0x2574 <getUserByName+0x2e>
    2652:	83 e0       	ldi	r24, 0x03	; 3
    2654:	6d 96       	adiw	r28, 0x1d	; 29
    2656:	0f b6       	in	r0, 0x3f	; 63
    2658:	f8 94       	cli
    265a:	de bf       	out	0x3e, r29	; 62
    265c:	0f be       	out	0x3f, r0	; 63
    265e:	cd bf       	out	0x3d, r28	; 61
    2660:	df 91       	pop	r29
    2662:	cf 91       	pop	r28
    2664:	1f 91       	pop	r17
    2666:	0f 91       	pop	r16
    2668:	ff 90       	pop	r15
    266a:	ef 90       	pop	r14
    266c:	df 90       	pop	r13
    266e:	cf 90       	pop	r12
    2670:	bf 90       	pop	r11
    2672:	af 90       	pop	r10
    2674:	9f 90       	pop	r9
    2676:	08 95       	ret

00002678 <getUserByCode>:
    2678:	9f 92       	push	r9
    267a:	af 92       	push	r10
    267c:	bf 92       	push	r11
    267e:	cf 92       	push	r12
    2680:	df 92       	push	r13
    2682:	ef 92       	push	r14
    2684:	ff 92       	push	r15
    2686:	0f 93       	push	r16
    2688:	1f 93       	push	r17
    268a:	cf 93       	push	r28
    268c:	df 93       	push	r29
    268e:	cd b7       	in	r28, 0x3d	; 61
    2690:	de b7       	in	r29, 0x3e	; 62
    2692:	6d 97       	sbiw	r28, 0x1d	; 29
    2694:	0f b6       	in	r0, 0x3f	; 63
    2696:	f8 94       	cli
    2698:	de bf       	out	0x3e, r29	; 62
    269a:	0f be       	out	0x3f, r0	; 63
    269c:	cd bf       	out	0x3d, r28	; 61
    269e:	7c 01       	movw	r14, r24
    26a0:	6b 01       	movw	r12, r22
    26a2:	91 2c       	mov	r9, r1
    26a4:	6b c0       	rjmp	.+214    	; 0x277c <getUserByCode+0x104>
    26a6:	ae 01       	movw	r20, r28
    26a8:	4f 5f       	subi	r20, 0xFF	; 255
    26aa:	5f 4f       	sbci	r21, 0xFF	; 255
    26ac:	60 e0       	ldi	r22, 0x00	; 0
    26ae:	89 2d       	mov	r24, r9
    26b0:	0e 94 b9 00 	call	0x172	; 0x172 <EEPROM_read_byte>
    26b4:	ae 01       	movw	r20, r28
    26b6:	4e 5f       	subi	r20, 0xFE	; 254
    26b8:	5f 4f       	sbci	r21, 0xFF	; 255
    26ba:	61 e0       	ldi	r22, 0x01	; 1
    26bc:	89 2d       	mov	r24, r9
    26be:	0e 94 b9 00 	call	0x172	; 0x172 <EEPROM_read_byte>
    26c2:	b1 2c       	mov	r11, r1
    26c4:	56 c0       	rjmp	.+172    	; 0x2772 <getUserByCode+0xfa>
    26c6:	89 81       	ldd	r24, Y+1	; 0x01
    26c8:	90 e0       	ldi	r25, 0x00	; 0
    26ca:	0b 2c       	mov	r0, r11
    26cc:	02 c0       	rjmp	.+4      	; 0x26d2 <getUserByCode+0x5a>
    26ce:	95 95       	asr	r25
    26d0:	87 95       	ror	r24
    26d2:	0a 94       	dec	r0
    26d4:	e2 f7       	brpl	.-8      	; 0x26ce <getUserByCode+0x56>
    26d6:	80 ff       	sbrs	r24, 0
    26d8:	4b c0       	rjmp	.+150    	; 0x2770 <getUserByCode+0xf8>
    26da:	6f e1       	ldi	r22, 0x1F	; 31
    26dc:	b6 9e       	mul	r11, r22
    26de:	a0 2c       	mov	r10, r0
    26e0:	11 24       	eor	r1, r1
    26e2:	65 e1       	ldi	r22, 0x15	; 21
    26e4:	6a 0d       	add	r22, r10
    26e6:	9e 01       	movw	r18, r28
    26e8:	20 5f       	subi	r18, 0xF0	; 240
    26ea:	3f 4f       	sbci	r19, 0xFF	; 255
    26ec:	47 e0       	ldi	r20, 0x07	; 7
    26ee:	50 e0       	ldi	r21, 0x00	; 0
    26f0:	89 2d       	mov	r24, r9
    26f2:	0e 94 da 00 	call	0x1b4	; 0x1b4 <EEPROM_read_block>
    26f6:	be 01       	movw	r22, r28
    26f8:	60 5f       	subi	r22, 0xF0	; 240
    26fa:	7f 4f       	sbci	r23, 0xFF	; 255
    26fc:	c7 01       	movw	r24, r14
    26fe:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <strcmp>
    2702:	89 2b       	or	r24, r25
    2704:	a9 f5       	brne	.+106    	; 0x2770 <getUserByCode+0xf8>
    2706:	68 e0       	ldi	r22, 0x08	; 8
    2708:	6a 0d       	add	r22, r10
    270a:	9e 01       	movw	r18, r28
    270c:	2d 5f       	subi	r18, 0xFD	; 253
    270e:	3f 4f       	sbci	r19, 0xFF	; 255
    2710:	4d e0       	ldi	r20, 0x0D	; 13
    2712:	50 e0       	ldi	r21, 0x00	; 0
    2714:	89 2d       	mov	r24, r9
    2716:	0e 94 da 00 	call	0x1b4	; 0x1b4 <EEPROM_read_block>
    271a:	6c e1       	ldi	r22, 0x1C	; 28
    271c:	6a 0d       	add	r22, r10
    271e:	9e 01       	movw	r18, r28
    2720:	29 5e       	subi	r18, 0xE9	; 233
    2722:	3f 4f       	sbci	r19, 0xFF	; 255
    2724:	47 e0       	ldi	r20, 0x07	; 7
    2726:	50 e0       	ldi	r21, 0x00	; 0
    2728:	89 2d       	mov	r24, r9
    272a:	0e 94 da 00 	call	0x1b4	; 0x1b4 <EEPROM_read_block>
    272e:	8a 81       	ldd	r24, Y+2	; 0x02
    2730:	90 e0       	ldi	r25, 0x00	; 0
    2732:	02 c0       	rjmp	.+4      	; 0x2738 <getUserByCode+0xc0>
    2734:	95 95       	asr	r25
    2736:	87 95       	ror	r24
    2738:	ba 94       	dec	r11
    273a:	e2 f7       	brpl	.-8      	; 0x2734 <getUserByCode+0xbc>
    273c:	98 2f       	mov	r25, r24
    273e:	91 70       	andi	r25, 0x01	; 1
    2740:	f6 01       	movw	r30, r12
    2742:	91 93       	st	Z+, r25
    2744:	be 01       	movw	r22, r28
    2746:	6d 5f       	subi	r22, 0xFD	; 253
    2748:	7f 4f       	sbci	r23, 0xFF	; 255
    274a:	cf 01       	movw	r24, r30
    274c:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <strcpy>
    2750:	be 01       	movw	r22, r28
    2752:	60 5f       	subi	r22, 0xF0	; 240
    2754:	7f 4f       	sbci	r23, 0xFF	; 255
    2756:	c6 01       	movw	r24, r12
    2758:	0e 96       	adiw	r24, 0x0e	; 14
    275a:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <strcpy>
    275e:	be 01       	movw	r22, r28
    2760:	69 5e       	subi	r22, 0xE9	; 233
    2762:	7f 4f       	sbci	r23, 0xFF	; 255
    2764:	c6 01       	movw	r24, r12
    2766:	45 96       	adiw	r24, 0x15	; 21
    2768:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <strcpy>
    276c:	82 e0       	ldi	r24, 0x02	; 2
    276e:	0b c0       	rjmp	.+22     	; 0x2786 <getUserByCode+0x10e>
    2770:	b3 94       	inc	r11
    2772:	87 e0       	ldi	r24, 0x07	; 7
    2774:	8b 15       	cp	r24, r11
    2776:	08 f0       	brcs	.+2      	; 0x277a <getUserByCode+0x102>
    2778:	a6 cf       	rjmp	.-180    	; 0x26c6 <getUserByCode+0x4e>
    277a:	93 94       	inc	r9
    277c:	87 e0       	ldi	r24, 0x07	; 7
    277e:	89 15       	cp	r24, r9
    2780:	08 f0       	brcs	.+2      	; 0x2784 <getUserByCode+0x10c>
    2782:	91 cf       	rjmp	.-222    	; 0x26a6 <getUserByCode+0x2e>
    2784:	83 e0       	ldi	r24, 0x03	; 3
    2786:	6d 96       	adiw	r28, 0x1d	; 29
    2788:	0f b6       	in	r0, 0x3f	; 63
    278a:	f8 94       	cli
    278c:	de bf       	out	0x3e, r29	; 62
    278e:	0f be       	out	0x3f, r0	; 63
    2790:	cd bf       	out	0x3d, r28	; 61
    2792:	df 91       	pop	r29
    2794:	cf 91       	pop	r28
    2796:	1f 91       	pop	r17
    2798:	0f 91       	pop	r16
    279a:	ff 90       	pop	r15
    279c:	ef 90       	pop	r14
    279e:	df 90       	pop	r13
    27a0:	cf 90       	pop	r12
    27a2:	bf 90       	pop	r11
    27a4:	af 90       	pop	r10
    27a6:	9f 90       	pop	r9
    27a8:	08 95       	ret

000027aa <Alarm_set>:

void Alarm_set(void) {
  Buzzer_init(BUZZER_PORT, BUZZER_PIN);
    27aa:	66 e0       	ldi	r22, 0x06	; 6
    27ac:	84 e4       	ldi	r24, 0x44	; 68
    27ae:	0e 94 a4 00 	call	0x148	; 0x148 <Buzzer_init>
  Buzzer_on(BUZZER_PORT, BUZZER_PIN);
    27b2:	66 e0       	ldi	r22, 0x06	; 6
    27b4:	84 e4       	ldi	r24, 0x44	; 68
    27b6:	0e 94 ad 00 	call	0x15a	; 0x15a <Buzzer_on>
    27ba:	08 95       	ret

000027bc <write_user>:
  }

void write_user(u8 userBlockIndex, ST_User_t* user) {
    27bc:	ef 92       	push	r14
    27be:	ff 92       	push	r15
    27c0:	0f 93       	push	r16
    27c2:	1f 93       	push	r17
    27c4:	cf 93       	push	r28
    27c6:	df 93       	push	r29
    27c8:	00 d0       	rcall	.+0      	; 0x27ca <write_user+0xe>
    27ca:	cd b7       	in	r28, 0x3d	; 61
    27cc:	de b7       	in	r29, 0x3e	; 62
    27ce:	7b 01       	movw	r14, r22
  // Get the user block location (page - index)
  u8 page = userBlockIndex / 8;
    27d0:	08 2f       	mov	r16, r24
    27d2:	06 95       	lsr	r16
    27d4:	06 95       	lsr	r16
    27d6:	06 95       	lsr	r16
  u8 blockNumber = userBlockIndex % 8;
    27d8:	18 2f       	mov	r17, r24
    27da:	17 70       	andi	r17, 0x07	; 7
  // Read and update the block status (reserve the block). And update the user authority level flag if the user is admin
  u8 usersBlockStatus, usersAuthorityLevel;
  EEPROM_read_byte(page, 0, &usersBlockStatus);
    27dc:	ae 01       	movw	r20, r28
    27de:	4f 5f       	subi	r20, 0xFF	; 255
    27e0:	5f 4f       	sbci	r21, 0xFF	; 255
    27e2:	60 e0       	ldi	r22, 0x00	; 0
    27e4:	80 2f       	mov	r24, r16
    27e6:	0e 94 b9 00 	call	0x172	; 0x172 <EEPROM_read_byte>
  EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    27ea:	ae 01       	movw	r20, r28
    27ec:	4e 5f       	subi	r20, 0xFE	; 254
    27ee:	5f 4f       	sbci	r21, 0xFF	; 255
    27f0:	61 e0       	ldi	r22, 0x01	; 1
    27f2:	80 2f       	mov	r24, r16
    27f4:	0e 94 b9 00 	call	0x172	; 0x172 <EEPROM_read_byte>
  set_bit(usersBlockStatus, blockNumber);
    27f8:	81 e0       	ldi	r24, 0x01	; 1
    27fa:	90 e0       	ldi	r25, 0x00	; 0
    27fc:	01 2e       	mov	r0, r17
    27fe:	02 c0       	rjmp	.+4      	; 0x2804 <write_user+0x48>
    2800:	88 0f       	add	r24, r24
    2802:	99 1f       	adc	r25, r25
    2804:	0a 94       	dec	r0
    2806:	e2 f7       	brpl	.-8      	; 0x2800 <write_user+0x44>
    2808:	49 81       	ldd	r20, Y+1	; 0x01
    280a:	48 2b       	or	r20, r24
    280c:	49 83       	std	Y+1, r20	; 0x01
  if (user->isAdmin) set_bit(usersAuthorityLevel, blockNumber);
    280e:	f7 01       	movw	r30, r14
    2810:	20 81       	ld	r18, Z
    2812:	22 23       	and	r18, r18
    2814:	19 f0       	breq	.+6      	; 0x281c <write_user+0x60>
    2816:	9a 81       	ldd	r25, Y+2	; 0x02
    2818:	89 2b       	or	r24, r25
    281a:	8a 83       	std	Y+2, r24	; 0x02
  EEPROM_write_byte(page, 0, usersBlockStatus);
    281c:	60 e0       	ldi	r22, 0x00	; 0
    281e:	80 2f       	mov	r24, r16
    2820:	0e 94 10 01 	call	0x220	; 0x220 <EEPROM_write_byte>
  EEPROM_write_byte(page, 1, usersAuthorityLevel);
    2824:	4a 81       	ldd	r20, Y+2	; 0x02
    2826:	61 e0       	ldi	r22, 0x01	; 1
    2828:	80 2f       	mov	r24, r16
    282a:	0e 94 10 01 	call	0x220	; 0x220 <EEPROM_write_byte>
  // Write the user data
  EEPROM_write_block(page, 8 + 31 * blockNumber, 13, user->name);
    282e:	97 01       	movw	r18, r14
    2830:	2f 5f       	subi	r18, 0xFF	; 255
    2832:	3f 4f       	sbci	r19, 0xFF	; 255
    2834:	6f e1       	ldi	r22, 0x1F	; 31
    2836:	16 9f       	mul	r17, r22
    2838:	10 2d       	mov	r17, r0
    283a:	11 24       	eor	r1, r1
    283c:	68 e0       	ldi	r22, 0x08	; 8
    283e:	61 0f       	add	r22, r17
    2840:	4d e0       	ldi	r20, 0x0D	; 13
    2842:	50 e0       	ldi	r21, 0x00	; 0
    2844:	80 2f       	mov	r24, r16
    2846:	0e 94 2f 01 	call	0x25e	; 0x25e <EEPROM_write_block>
  EEPROM_write_block(page, 21 + 31 * blockNumber, 7, user->code);
    284a:	97 01       	movw	r18, r14
    284c:	22 5f       	subi	r18, 0xF2	; 242
    284e:	3f 4f       	sbci	r19, 0xFF	; 255
    2850:	65 e1       	ldi	r22, 0x15	; 21
    2852:	61 0f       	add	r22, r17
    2854:	47 e0       	ldi	r20, 0x07	; 7
    2856:	50 e0       	ldi	r21, 0x00	; 0
    2858:	80 2f       	mov	r24, r16
    285a:	0e 94 2f 01 	call	0x25e	; 0x25e <EEPROM_write_block>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
    285e:	97 01       	movw	r18, r14
    2860:	2b 5e       	subi	r18, 0xEB	; 235
    2862:	3f 4f       	sbci	r19, 0xFF	; 255
    2864:	6c e1       	ldi	r22, 0x1C	; 28
    2866:	61 0f       	add	r22, r17
    2868:	4b e0       	ldi	r20, 0x0B	; 11
    286a:	50 e0       	ldi	r21, 0x00	; 0
    286c:	80 2f       	mov	r24, r16
    286e:	0e 94 2f 01 	call	0x25e	; 0x25e <EEPROM_write_block>
  }
    2872:	0f 90       	pop	r0
    2874:	0f 90       	pop	r0
    2876:	df 91       	pop	r29
    2878:	cf 91       	pop	r28
    287a:	1f 91       	pop	r17
    287c:	0f 91       	pop	r16
    287e:	ff 90       	pop	r15
    2880:	ef 90       	pop	r14
    2882:	08 95       	ret

00002884 <add_user>:

EN_UserStatusCode_t add_user(ST_User_t* user) {
    2884:	ef 92       	push	r14
    2886:	ff 92       	push	r15
    2888:	1f 93       	push	r17
    288a:	cf 93       	push	r28
    288c:	df 93       	push	r29
    288e:	1f 92       	push	r1
    2890:	cd b7       	in	r28, 0x3d	; 61
    2892:	de b7       	in	r29, 0x3e	; 62
    2894:	7c 01       	movw	r14, r24
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    2896:	10 e0       	ldi	r17, 0x00	; 0
    2898:	1a c0       	rjmp	.+52     	; 0x28ce <add_user+0x4a>
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    289a:	ae 01       	movw	r20, r28
    289c:	4f 5f       	subi	r20, 0xFF	; 255
    289e:	5f 4f       	sbci	r21, 0xFF	; 255
    28a0:	60 e0       	ldi	r22, 0x00	; 0
    28a2:	81 2f       	mov	r24, r17
    28a4:	0e 94 b9 00 	call	0x172	; 0x172 <EEPROM_read_byte>
    if (usersBlockStatus != 0xFF) {
    28a8:	99 81       	ldd	r25, Y+1	; 0x01
    28aa:	9f 3f       	cpi	r25, 0xFF	; 255
    28ac:	79 f0       	breq	.+30     	; 0x28cc <add_user+0x48>
    28ae:	02 c0       	rjmp	.+4      	; 0x28b4 <add_user+0x30>
      // Find the block number in the page
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
    28b0:	8f 5f       	subi	r24, 0xFF	; 255
    28b2:	01 c0       	rjmp	.+2      	; 0x28b6 <add_user+0x32>
    28b4:	80 e0       	ldi	r24, 0x00	; 0
    28b6:	29 2f       	mov	r18, r25
    28b8:	30 e0       	ldi	r19, 0x00	; 0
    28ba:	08 2e       	mov	r0, r24
    28bc:	02 c0       	rjmp	.+4      	; 0x28c2 <add_user+0x3e>
    28be:	35 95       	asr	r19
    28c0:	27 95       	ror	r18
    28c2:	0a 94       	dec	r0
    28c4:	e2 f7       	brpl	.-8      	; 0x28be <add_user+0x3a>
    28c6:	20 fd       	sbrc	r18, 0
    28c8:	f3 cf       	rjmp	.-26     	; 0x28b0 <add_user+0x2c>
    28ca:	04 c0       	rjmp	.+8      	; 0x28d4 <add_user+0x50>
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    28cc:	1f 5f       	subi	r17, 0xFF	; 255
    28ce:	18 30       	cpi	r17, 0x08	; 8
    28d0:	20 f3       	brcs	.-56     	; 0x289a <add_user+0x16>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
    28d2:	80 e0       	ldi	r24, 0x00	; 0
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    28d4:	18 30       	cpi	r17, 0x08	; 8
    28d6:	49 f0       	breq	.+18     	; 0x28ea <add_user+0x66>
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
    28d8:	11 0f       	add	r17, r17
    28da:	11 0f       	add	r17, r17
    28dc:	11 0f       	add	r17, r17
  write_user(availableUserBlockIndex, user);
    28de:	b7 01       	movw	r22, r14
    28e0:	81 0f       	add	r24, r17
    28e2:	0e 94 de 13 	call	0x27bc	; 0x27bc <write_user>
  return USER_ADDED_SUCCESSFULLY;
    28e6:	8a e0       	ldi	r24, 0x0A	; 10
    28e8:	01 c0       	rjmp	.+2      	; 0x28ec <add_user+0x68>
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    28ea:	8c e0       	ldi	r24, 0x0C	; 12
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
  write_user(availableUserBlockIndex, user);
  return USER_ADDED_SUCCESSFULLY;
  }
    28ec:	0f 90       	pop	r0
    28ee:	df 91       	pop	r29
    28f0:	cf 91       	pop	r28
    28f2:	1f 91       	pop	r17
    28f4:	ff 90       	pop	r15
    28f6:	ef 90       	pop	r14
    28f8:	08 95       	ret

000028fa <delete_user>:

EN_UserStatusCode_t delete_user(ST_User_t* user) {
    28fa:	cf 92       	push	r12
    28fc:	df 92       	push	r13
    28fe:	ef 92       	push	r14
    2900:	ff 92       	push	r15
    2902:	0f 93       	push	r16
    2904:	1f 93       	push	r17
    2906:	cf 93       	push	r28
    2908:	df 93       	push	r29
    290a:	cd b7       	in	r28, 0x3d	; 61
    290c:	de b7       	in	r29, 0x3e	; 62
    290e:	29 97       	sbiw	r28, 0x09	; 9
    2910:	0f b6       	in	r0, 0x3f	; 63
    2912:	f8 94       	cli
    2914:	de bf       	out	0x3e, r29	; 62
    2916:	0f be       	out	0x3f, r0	; 63
    2918:	cd bf       	out	0x3d, r28	; 61
    291a:	6c 01       	movw	r12, r24
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    291c:	00 e0       	ldi	r16, 0x00	; 0
    291e:	4d c0       	rjmp	.+154    	; 0x29ba <delete_user+0xc0>
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    2920:	ae 01       	movw	r20, r28
    2922:	4f 5f       	subi	r20, 0xFF	; 255
    2924:	5f 4f       	sbci	r21, 0xFF	; 255
    2926:	60 e0       	ldi	r22, 0x00	; 0
    2928:	80 2f       	mov	r24, r16
    292a:	0e 94 b9 00 	call	0x172	; 0x172 <EEPROM_read_byte>
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    292e:	ae 01       	movw	r20, r28
    2930:	4e 5f       	subi	r20, 0xFE	; 254
    2932:	5f 4f       	sbci	r21, 0xFF	; 255
    2934:	61 e0       	ldi	r22, 0x01	; 1
    2936:	80 2f       	mov	r24, r16
    2938:	0e 94 b9 00 	call	0x172	; 0x172 <EEPROM_read_byte>
    for (userIndex = 0; userIndex < 8;userIndex++) {
    293c:	10 e0       	ldi	r17, 0x00	; 0
    293e:	3a c0       	rjmp	.+116    	; 0x29b4 <delete_user+0xba>
      if (read_bit(usersBlockStatus, userIndex)) {  // If the user isn't deleted
    2940:	89 81       	ldd	r24, Y+1	; 0x01
    2942:	90 e0       	ldi	r25, 0x00	; 0
    2944:	01 2e       	mov	r0, r17
    2946:	02 c0       	rjmp	.+4      	; 0x294c <delete_user+0x52>
    2948:	95 95       	asr	r25
    294a:	87 95       	ror	r24
    294c:	0a 94       	dec	r0
    294e:	e2 f7       	brpl	.-8      	; 0x2948 <delete_user+0x4e>
    2950:	80 ff       	sbrs	r24, 0
    2952:	2f c0       	rjmp	.+94     	; 0x29b2 <delete_user+0xb8>
        EEPROM_read_block(page, 21 + 31 * userIndex, 7, tempUserCode);
    2954:	6f e1       	ldi	r22, 0x1F	; 31
    2956:	16 9f       	mul	r17, r22
    2958:	60 2d       	mov	r22, r0
    295a:	11 24       	eor	r1, r1
    295c:	6b 5e       	subi	r22, 0xEB	; 235
    295e:	9e 01       	movw	r18, r28
    2960:	2d 5f       	subi	r18, 0xFD	; 253
    2962:	3f 4f       	sbci	r19, 0xFF	; 255
    2964:	47 e0       	ldi	r20, 0x07	; 7
    2966:	50 e0       	ldi	r21, 0x00	; 0
    2968:	80 2f       	mov	r24, r16
    296a:	0e 94 da 00 	call	0x1b4	; 0x1b4 <EEPROM_read_block>
        if (strcmp(user->code, tempUserCode) == 0) { // User has been found
    296e:	be 01       	movw	r22, r28
    2970:	6d 5f       	subi	r22, 0xFD	; 253
    2972:	7f 4f       	sbci	r23, 0xFF	; 255
    2974:	c6 01       	movw	r24, r12
    2976:	0e 96       	adiw	r24, 0x0e	; 14
    2978:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <strcmp>
    297c:	89 2b       	or	r24, r25
    297e:	c9 f4       	brne	.+50     	; 0x29b2 <delete_user+0xb8>
          // Mark it as deleted
          clear_bit(usersBlockStatus, userIndex);
    2980:	81 e0       	ldi	r24, 0x01	; 1
    2982:	90 e0       	ldi	r25, 0x00	; 0
    2984:	02 c0       	rjmp	.+4      	; 0x298a <delete_user+0x90>
    2986:	88 0f       	add	r24, r24
    2988:	99 1f       	adc	r25, r25
    298a:	1a 95       	dec	r17
    298c:	e2 f7       	brpl	.-8      	; 0x2986 <delete_user+0x8c>
    298e:	80 95       	com	r24
    2990:	49 81       	ldd	r20, Y+1	; 0x01
    2992:	48 23       	and	r20, r24
    2994:	49 83       	std	Y+1, r20	; 0x01
          clear_bit(usersAuthorityLevel, userIndex);
    2996:	9a 81       	ldd	r25, Y+2	; 0x02
    2998:	89 23       	and	r24, r25
    299a:	8a 83       	std	Y+2, r24	; 0x02
          EEPROM_write_byte(page, 0, usersBlockStatus);
    299c:	60 e0       	ldi	r22, 0x00	; 0
    299e:	80 2f       	mov	r24, r16
    29a0:	0e 94 10 01 	call	0x220	; 0x220 <EEPROM_write_byte>
          EEPROM_write_byte(page, 1, usersAuthorityLevel);
    29a4:	4a 81       	ldd	r20, Y+2	; 0x02
    29a6:	61 e0       	ldi	r22, 0x01	; 1
    29a8:	80 2f       	mov	r24, r16
    29aa:	0e 94 10 01 	call	0x220	; 0x220 <EEPROM_write_byte>
          return USER_DELETED_SUCCESSFULLY;
    29ae:	8b e0       	ldi	r24, 0x0B	; 11
    29b0:	08 c0       	rjmp	.+16     	; 0x29c2 <delete_user+0xc8>
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    for (userIndex = 0; userIndex < 8;userIndex++) {
    29b2:	1f 5f       	subi	r17, 0xFF	; 255
    29b4:	18 30       	cpi	r17, 0x08	; 8
    29b6:	20 f2       	brcs	.-120    	; 0x2940 <delete_user+0x46>
EN_UserStatusCode_t delete_user(ST_User_t* user) {
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    29b8:	0f 5f       	subi	r16, 0xFF	; 255
    29ba:	08 30       	cpi	r16, 0x08	; 8
    29bc:	08 f4       	brcc	.+2      	; 0x29c0 <delete_user+0xc6>
    29be:	b0 cf       	rjmp	.-160    	; 0x2920 <delete_user+0x26>
          return USER_DELETED_SUCCESSFULLY;
          }
        }
      }
    }
  return USER_NOT_FOUND;
    29c0:	83 e0       	ldi	r24, 0x03	; 3
  }
    29c2:	29 96       	adiw	r28, 0x09	; 9
    29c4:	0f b6       	in	r0, 0x3f	; 63
    29c6:	f8 94       	cli
    29c8:	de bf       	out	0x3e, r29	; 62
    29ca:	0f be       	out	0x3f, r0	; 63
    29cc:	cd bf       	out	0x3d, r28	; 61
    29ce:	df 91       	pop	r29
    29d0:	cf 91       	pop	r28
    29d2:	1f 91       	pop	r17
    29d4:	0f 91       	pop	r16
    29d6:	ff 90       	pop	r15
    29d8:	ef 90       	pop	r14
    29da:	df 90       	pop	r13
    29dc:	cf 90       	pop	r12
    29de:	08 95       	ret

000029e0 <__subsf3>:
    29e0:	50 58       	subi	r21, 0x80	; 128

000029e2 <__addsf3>:
    29e2:	bb 27       	eor	r27, r27
    29e4:	aa 27       	eor	r26, r26
    29e6:	0e 94 08 15 	call	0x2a10	; 0x2a10 <__addsf3x>
    29ea:	0c 94 59 16 	jmp	0x2cb2	; 0x2cb2 <__fp_round>
    29ee:	0e 94 4b 16 	call	0x2c96	; 0x2c96 <__fp_pscA>
    29f2:	38 f0       	brcs	.+14     	; 0x2a02 <__addsf3+0x20>
    29f4:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <__fp_pscB>
    29f8:	20 f0       	brcs	.+8      	; 0x2a02 <__addsf3+0x20>
    29fa:	39 f4       	brne	.+14     	; 0x2a0a <__addsf3+0x28>
    29fc:	9f 3f       	cpi	r25, 0xFF	; 255
    29fe:	19 f4       	brne	.+6      	; 0x2a06 <__addsf3+0x24>
    2a00:	26 f4       	brtc	.+8      	; 0x2a0a <__addsf3+0x28>
    2a02:	0c 94 48 16 	jmp	0x2c90	; 0x2c90 <__fp_nan>
    2a06:	0e f4       	brtc	.+2      	; 0x2a0a <__addsf3+0x28>
    2a08:	e0 95       	com	r30
    2a0a:	e7 fb       	bst	r30, 7
    2a0c:	0c 94 42 16 	jmp	0x2c84	; 0x2c84 <__fp_inf>

00002a10 <__addsf3x>:
    2a10:	e9 2f       	mov	r30, r25
    2a12:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <__fp_split3>
    2a16:	58 f3       	brcs	.-42     	; 0x29ee <__addsf3+0xc>
    2a18:	ba 17       	cp	r27, r26
    2a1a:	62 07       	cpc	r22, r18
    2a1c:	73 07       	cpc	r23, r19
    2a1e:	84 07       	cpc	r24, r20
    2a20:	95 07       	cpc	r25, r21
    2a22:	20 f0       	brcs	.+8      	; 0x2a2c <__addsf3x+0x1c>
    2a24:	79 f4       	brne	.+30     	; 0x2a44 <__addsf3x+0x34>
    2a26:	a6 f5       	brtc	.+104    	; 0x2a90 <__addsf3x+0x80>
    2a28:	0c 94 8c 16 	jmp	0x2d18	; 0x2d18 <__fp_zero>
    2a2c:	0e f4       	brtc	.+2      	; 0x2a30 <__addsf3x+0x20>
    2a2e:	e0 95       	com	r30
    2a30:	0b 2e       	mov	r0, r27
    2a32:	ba 2f       	mov	r27, r26
    2a34:	a0 2d       	mov	r26, r0
    2a36:	0b 01       	movw	r0, r22
    2a38:	b9 01       	movw	r22, r18
    2a3a:	90 01       	movw	r18, r0
    2a3c:	0c 01       	movw	r0, r24
    2a3e:	ca 01       	movw	r24, r20
    2a40:	a0 01       	movw	r20, r0
    2a42:	11 24       	eor	r1, r1
    2a44:	ff 27       	eor	r31, r31
    2a46:	59 1b       	sub	r21, r25
    2a48:	99 f0       	breq	.+38     	; 0x2a70 <__addsf3x+0x60>
    2a4a:	59 3f       	cpi	r21, 0xF9	; 249
    2a4c:	50 f4       	brcc	.+20     	; 0x2a62 <__addsf3x+0x52>
    2a4e:	50 3e       	cpi	r21, 0xE0	; 224
    2a50:	68 f1       	brcs	.+90     	; 0x2aac <__addsf3x+0x9c>
    2a52:	1a 16       	cp	r1, r26
    2a54:	f0 40       	sbci	r31, 0x00	; 0
    2a56:	a2 2f       	mov	r26, r18
    2a58:	23 2f       	mov	r18, r19
    2a5a:	34 2f       	mov	r19, r20
    2a5c:	44 27       	eor	r20, r20
    2a5e:	58 5f       	subi	r21, 0xF8	; 248
    2a60:	f3 cf       	rjmp	.-26     	; 0x2a48 <__addsf3x+0x38>
    2a62:	46 95       	lsr	r20
    2a64:	37 95       	ror	r19
    2a66:	27 95       	ror	r18
    2a68:	a7 95       	ror	r26
    2a6a:	f0 40       	sbci	r31, 0x00	; 0
    2a6c:	53 95       	inc	r21
    2a6e:	c9 f7       	brne	.-14     	; 0x2a62 <__addsf3x+0x52>
    2a70:	7e f4       	brtc	.+30     	; 0x2a90 <__addsf3x+0x80>
    2a72:	1f 16       	cp	r1, r31
    2a74:	ba 0b       	sbc	r27, r26
    2a76:	62 0b       	sbc	r22, r18
    2a78:	73 0b       	sbc	r23, r19
    2a7a:	84 0b       	sbc	r24, r20
    2a7c:	ba f0       	brmi	.+46     	; 0x2aac <__addsf3x+0x9c>
    2a7e:	91 50       	subi	r25, 0x01	; 1
    2a80:	a1 f0       	breq	.+40     	; 0x2aaa <__addsf3x+0x9a>
    2a82:	ff 0f       	add	r31, r31
    2a84:	bb 1f       	adc	r27, r27
    2a86:	66 1f       	adc	r22, r22
    2a88:	77 1f       	adc	r23, r23
    2a8a:	88 1f       	adc	r24, r24
    2a8c:	c2 f7       	brpl	.-16     	; 0x2a7e <__addsf3x+0x6e>
    2a8e:	0e c0       	rjmp	.+28     	; 0x2aac <__addsf3x+0x9c>
    2a90:	ba 0f       	add	r27, r26
    2a92:	62 1f       	adc	r22, r18
    2a94:	73 1f       	adc	r23, r19
    2a96:	84 1f       	adc	r24, r20
    2a98:	48 f4       	brcc	.+18     	; 0x2aac <__addsf3x+0x9c>
    2a9a:	87 95       	ror	r24
    2a9c:	77 95       	ror	r23
    2a9e:	67 95       	ror	r22
    2aa0:	b7 95       	ror	r27
    2aa2:	f7 95       	ror	r31
    2aa4:	9e 3f       	cpi	r25, 0xFE	; 254
    2aa6:	08 f0       	brcs	.+2      	; 0x2aaa <__addsf3x+0x9a>
    2aa8:	b0 cf       	rjmp	.-160    	; 0x2a0a <__addsf3+0x28>
    2aaa:	93 95       	inc	r25
    2aac:	88 0f       	add	r24, r24
    2aae:	08 f0       	brcs	.+2      	; 0x2ab2 <__addsf3x+0xa2>
    2ab0:	99 27       	eor	r25, r25
    2ab2:	ee 0f       	add	r30, r30
    2ab4:	97 95       	ror	r25
    2ab6:	87 95       	ror	r24
    2ab8:	08 95       	ret

00002aba <__divsf3>:
    2aba:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <__divsf3x>
    2abe:	0c 94 59 16 	jmp	0x2cb2	; 0x2cb2 <__fp_round>
    2ac2:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <__fp_pscB>
    2ac6:	58 f0       	brcs	.+22     	; 0x2ade <__divsf3+0x24>
    2ac8:	0e 94 4b 16 	call	0x2c96	; 0x2c96 <__fp_pscA>
    2acc:	40 f0       	brcs	.+16     	; 0x2ade <__divsf3+0x24>
    2ace:	29 f4       	brne	.+10     	; 0x2ada <__divsf3+0x20>
    2ad0:	5f 3f       	cpi	r21, 0xFF	; 255
    2ad2:	29 f0       	breq	.+10     	; 0x2ade <__divsf3+0x24>
    2ad4:	0c 94 42 16 	jmp	0x2c84	; 0x2c84 <__fp_inf>
    2ad8:	51 11       	cpse	r21, r1
    2ada:	0c 94 8d 16 	jmp	0x2d1a	; 0x2d1a <__fp_szero>
    2ade:	0c 94 48 16 	jmp	0x2c90	; 0x2c90 <__fp_nan>

00002ae2 <__divsf3x>:
    2ae2:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <__fp_split3>
    2ae6:	68 f3       	brcs	.-38     	; 0x2ac2 <__divsf3+0x8>

00002ae8 <__divsf3_pse>:
    2ae8:	99 23       	and	r25, r25
    2aea:	b1 f3       	breq	.-20     	; 0x2ad8 <__divsf3+0x1e>
    2aec:	55 23       	and	r21, r21
    2aee:	91 f3       	breq	.-28     	; 0x2ad4 <__divsf3+0x1a>
    2af0:	95 1b       	sub	r25, r21
    2af2:	55 0b       	sbc	r21, r21
    2af4:	bb 27       	eor	r27, r27
    2af6:	aa 27       	eor	r26, r26
    2af8:	62 17       	cp	r22, r18
    2afa:	73 07       	cpc	r23, r19
    2afc:	84 07       	cpc	r24, r20
    2afe:	38 f0       	brcs	.+14     	; 0x2b0e <__divsf3_pse+0x26>
    2b00:	9f 5f       	subi	r25, 0xFF	; 255
    2b02:	5f 4f       	sbci	r21, 0xFF	; 255
    2b04:	22 0f       	add	r18, r18
    2b06:	33 1f       	adc	r19, r19
    2b08:	44 1f       	adc	r20, r20
    2b0a:	aa 1f       	adc	r26, r26
    2b0c:	a9 f3       	breq	.-22     	; 0x2af8 <__divsf3_pse+0x10>
    2b0e:	35 d0       	rcall	.+106    	; 0x2b7a <__divsf3_pse+0x92>
    2b10:	0e 2e       	mov	r0, r30
    2b12:	3a f0       	brmi	.+14     	; 0x2b22 <__divsf3_pse+0x3a>
    2b14:	e0 e8       	ldi	r30, 0x80	; 128
    2b16:	32 d0       	rcall	.+100    	; 0x2b7c <__divsf3_pse+0x94>
    2b18:	91 50       	subi	r25, 0x01	; 1
    2b1a:	50 40       	sbci	r21, 0x00	; 0
    2b1c:	e6 95       	lsr	r30
    2b1e:	00 1c       	adc	r0, r0
    2b20:	ca f7       	brpl	.-14     	; 0x2b14 <__divsf3_pse+0x2c>
    2b22:	2b d0       	rcall	.+86     	; 0x2b7a <__divsf3_pse+0x92>
    2b24:	fe 2f       	mov	r31, r30
    2b26:	29 d0       	rcall	.+82     	; 0x2b7a <__divsf3_pse+0x92>
    2b28:	66 0f       	add	r22, r22
    2b2a:	77 1f       	adc	r23, r23
    2b2c:	88 1f       	adc	r24, r24
    2b2e:	bb 1f       	adc	r27, r27
    2b30:	26 17       	cp	r18, r22
    2b32:	37 07       	cpc	r19, r23
    2b34:	48 07       	cpc	r20, r24
    2b36:	ab 07       	cpc	r26, r27
    2b38:	b0 e8       	ldi	r27, 0x80	; 128
    2b3a:	09 f0       	breq	.+2      	; 0x2b3e <__divsf3_pse+0x56>
    2b3c:	bb 0b       	sbc	r27, r27
    2b3e:	80 2d       	mov	r24, r0
    2b40:	bf 01       	movw	r22, r30
    2b42:	ff 27       	eor	r31, r31
    2b44:	93 58       	subi	r25, 0x83	; 131
    2b46:	5f 4f       	sbci	r21, 0xFF	; 255
    2b48:	3a f0       	brmi	.+14     	; 0x2b58 <__divsf3_pse+0x70>
    2b4a:	9e 3f       	cpi	r25, 0xFE	; 254
    2b4c:	51 05       	cpc	r21, r1
    2b4e:	78 f0       	brcs	.+30     	; 0x2b6e <__divsf3_pse+0x86>
    2b50:	0c 94 42 16 	jmp	0x2c84	; 0x2c84 <__fp_inf>
    2b54:	0c 94 8d 16 	jmp	0x2d1a	; 0x2d1a <__fp_szero>
    2b58:	5f 3f       	cpi	r21, 0xFF	; 255
    2b5a:	e4 f3       	brlt	.-8      	; 0x2b54 <__divsf3_pse+0x6c>
    2b5c:	98 3e       	cpi	r25, 0xE8	; 232
    2b5e:	d4 f3       	brlt	.-12     	; 0x2b54 <__divsf3_pse+0x6c>
    2b60:	86 95       	lsr	r24
    2b62:	77 95       	ror	r23
    2b64:	67 95       	ror	r22
    2b66:	b7 95       	ror	r27
    2b68:	f7 95       	ror	r31
    2b6a:	9f 5f       	subi	r25, 0xFF	; 255
    2b6c:	c9 f7       	brne	.-14     	; 0x2b60 <__divsf3_pse+0x78>
    2b6e:	88 0f       	add	r24, r24
    2b70:	91 1d       	adc	r25, r1
    2b72:	96 95       	lsr	r25
    2b74:	87 95       	ror	r24
    2b76:	97 f9       	bld	r25, 7
    2b78:	08 95       	ret
    2b7a:	e1 e0       	ldi	r30, 0x01	; 1
    2b7c:	66 0f       	add	r22, r22
    2b7e:	77 1f       	adc	r23, r23
    2b80:	88 1f       	adc	r24, r24
    2b82:	bb 1f       	adc	r27, r27
    2b84:	62 17       	cp	r22, r18
    2b86:	73 07       	cpc	r23, r19
    2b88:	84 07       	cpc	r24, r20
    2b8a:	ba 07       	cpc	r27, r26
    2b8c:	20 f0       	brcs	.+8      	; 0x2b96 <__divsf3_pse+0xae>
    2b8e:	62 1b       	sub	r22, r18
    2b90:	73 0b       	sbc	r23, r19
    2b92:	84 0b       	sbc	r24, r20
    2b94:	ba 0b       	sbc	r27, r26
    2b96:	ee 1f       	adc	r30, r30
    2b98:	88 f7       	brcc	.-30     	; 0x2b7c <__divsf3_pse+0x94>
    2b9a:	e0 95       	com	r30
    2b9c:	08 95       	ret

00002b9e <__fixsfsi>:
    2b9e:	0e 94 d6 15 	call	0x2bac	; 0x2bac <__fixunssfsi>
    2ba2:	68 94       	set
    2ba4:	b1 11       	cpse	r27, r1
    2ba6:	0c 94 8d 16 	jmp	0x2d1a	; 0x2d1a <__fp_szero>
    2baa:	08 95       	ret

00002bac <__fixunssfsi>:
    2bac:	0e 94 72 16 	call	0x2ce4	; 0x2ce4 <__fp_splitA>
    2bb0:	88 f0       	brcs	.+34     	; 0x2bd4 <__fixunssfsi+0x28>
    2bb2:	9f 57       	subi	r25, 0x7F	; 127
    2bb4:	98 f0       	brcs	.+38     	; 0x2bdc <__fixunssfsi+0x30>
    2bb6:	b9 2f       	mov	r27, r25
    2bb8:	99 27       	eor	r25, r25
    2bba:	b7 51       	subi	r27, 0x17	; 23
    2bbc:	b0 f0       	brcs	.+44     	; 0x2bea <__fixunssfsi+0x3e>
    2bbe:	e1 f0       	breq	.+56     	; 0x2bf8 <__fixunssfsi+0x4c>
    2bc0:	66 0f       	add	r22, r22
    2bc2:	77 1f       	adc	r23, r23
    2bc4:	88 1f       	adc	r24, r24
    2bc6:	99 1f       	adc	r25, r25
    2bc8:	1a f0       	brmi	.+6      	; 0x2bd0 <__fixunssfsi+0x24>
    2bca:	ba 95       	dec	r27
    2bcc:	c9 f7       	brne	.-14     	; 0x2bc0 <__fixunssfsi+0x14>
    2bce:	14 c0       	rjmp	.+40     	; 0x2bf8 <__fixunssfsi+0x4c>
    2bd0:	b1 30       	cpi	r27, 0x01	; 1
    2bd2:	91 f0       	breq	.+36     	; 0x2bf8 <__fixunssfsi+0x4c>
    2bd4:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <__fp_zero>
    2bd8:	b1 e0       	ldi	r27, 0x01	; 1
    2bda:	08 95       	ret
    2bdc:	0c 94 8c 16 	jmp	0x2d18	; 0x2d18 <__fp_zero>
    2be0:	67 2f       	mov	r22, r23
    2be2:	78 2f       	mov	r23, r24
    2be4:	88 27       	eor	r24, r24
    2be6:	b8 5f       	subi	r27, 0xF8	; 248
    2be8:	39 f0       	breq	.+14     	; 0x2bf8 <__fixunssfsi+0x4c>
    2bea:	b9 3f       	cpi	r27, 0xF9	; 249
    2bec:	cc f3       	brlt	.-14     	; 0x2be0 <__fixunssfsi+0x34>
    2bee:	86 95       	lsr	r24
    2bf0:	77 95       	ror	r23
    2bf2:	67 95       	ror	r22
    2bf4:	b3 95       	inc	r27
    2bf6:	d9 f7       	brne	.-10     	; 0x2bee <__fixunssfsi+0x42>
    2bf8:	3e f4       	brtc	.+14     	; 0x2c08 <__fixunssfsi+0x5c>
    2bfa:	90 95       	com	r25
    2bfc:	80 95       	com	r24
    2bfe:	70 95       	com	r23
    2c00:	61 95       	neg	r22
    2c02:	7f 4f       	sbci	r23, 0xFF	; 255
    2c04:	8f 4f       	sbci	r24, 0xFF	; 255
    2c06:	9f 4f       	sbci	r25, 0xFF	; 255
    2c08:	08 95       	ret

00002c0a <__floatunsisf>:
    2c0a:	e8 94       	clt
    2c0c:	09 c0       	rjmp	.+18     	; 0x2c20 <__floatsisf+0x12>

00002c0e <__floatsisf>:
    2c0e:	97 fb       	bst	r25, 7
    2c10:	3e f4       	brtc	.+14     	; 0x2c20 <__floatsisf+0x12>
    2c12:	90 95       	com	r25
    2c14:	80 95       	com	r24
    2c16:	70 95       	com	r23
    2c18:	61 95       	neg	r22
    2c1a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c1c:	8f 4f       	sbci	r24, 0xFF	; 255
    2c1e:	9f 4f       	sbci	r25, 0xFF	; 255
    2c20:	99 23       	and	r25, r25
    2c22:	a9 f0       	breq	.+42     	; 0x2c4e <__floatsisf+0x40>
    2c24:	f9 2f       	mov	r31, r25
    2c26:	96 e9       	ldi	r25, 0x96	; 150
    2c28:	bb 27       	eor	r27, r27
    2c2a:	93 95       	inc	r25
    2c2c:	f6 95       	lsr	r31
    2c2e:	87 95       	ror	r24
    2c30:	77 95       	ror	r23
    2c32:	67 95       	ror	r22
    2c34:	b7 95       	ror	r27
    2c36:	f1 11       	cpse	r31, r1
    2c38:	f8 cf       	rjmp	.-16     	; 0x2c2a <__floatsisf+0x1c>
    2c3a:	fa f4       	brpl	.+62     	; 0x2c7a <__floatsisf+0x6c>
    2c3c:	bb 0f       	add	r27, r27
    2c3e:	11 f4       	brne	.+4      	; 0x2c44 <__floatsisf+0x36>
    2c40:	60 ff       	sbrs	r22, 0
    2c42:	1b c0       	rjmp	.+54     	; 0x2c7a <__floatsisf+0x6c>
    2c44:	6f 5f       	subi	r22, 0xFF	; 255
    2c46:	7f 4f       	sbci	r23, 0xFF	; 255
    2c48:	8f 4f       	sbci	r24, 0xFF	; 255
    2c4a:	9f 4f       	sbci	r25, 0xFF	; 255
    2c4c:	16 c0       	rjmp	.+44     	; 0x2c7a <__floatsisf+0x6c>
    2c4e:	88 23       	and	r24, r24
    2c50:	11 f0       	breq	.+4      	; 0x2c56 <__floatsisf+0x48>
    2c52:	96 e9       	ldi	r25, 0x96	; 150
    2c54:	11 c0       	rjmp	.+34     	; 0x2c78 <__floatsisf+0x6a>
    2c56:	77 23       	and	r23, r23
    2c58:	21 f0       	breq	.+8      	; 0x2c62 <__floatsisf+0x54>
    2c5a:	9e e8       	ldi	r25, 0x8E	; 142
    2c5c:	87 2f       	mov	r24, r23
    2c5e:	76 2f       	mov	r23, r22
    2c60:	05 c0       	rjmp	.+10     	; 0x2c6c <__floatsisf+0x5e>
    2c62:	66 23       	and	r22, r22
    2c64:	71 f0       	breq	.+28     	; 0x2c82 <__floatsisf+0x74>
    2c66:	96 e8       	ldi	r25, 0x86	; 134
    2c68:	86 2f       	mov	r24, r22
    2c6a:	70 e0       	ldi	r23, 0x00	; 0
    2c6c:	60 e0       	ldi	r22, 0x00	; 0
    2c6e:	2a f0       	brmi	.+10     	; 0x2c7a <__floatsisf+0x6c>
    2c70:	9a 95       	dec	r25
    2c72:	66 0f       	add	r22, r22
    2c74:	77 1f       	adc	r23, r23
    2c76:	88 1f       	adc	r24, r24
    2c78:	da f7       	brpl	.-10     	; 0x2c70 <__floatsisf+0x62>
    2c7a:	88 0f       	add	r24, r24
    2c7c:	96 95       	lsr	r25
    2c7e:	87 95       	ror	r24
    2c80:	97 f9       	bld	r25, 7
    2c82:	08 95       	ret

00002c84 <__fp_inf>:
    2c84:	97 f9       	bld	r25, 7
    2c86:	9f 67       	ori	r25, 0x7F	; 127
    2c88:	80 e8       	ldi	r24, 0x80	; 128
    2c8a:	70 e0       	ldi	r23, 0x00	; 0
    2c8c:	60 e0       	ldi	r22, 0x00	; 0
    2c8e:	08 95       	ret

00002c90 <__fp_nan>:
    2c90:	9f ef       	ldi	r25, 0xFF	; 255
    2c92:	80 ec       	ldi	r24, 0xC0	; 192
    2c94:	08 95       	ret

00002c96 <__fp_pscA>:
    2c96:	00 24       	eor	r0, r0
    2c98:	0a 94       	dec	r0
    2c9a:	16 16       	cp	r1, r22
    2c9c:	17 06       	cpc	r1, r23
    2c9e:	18 06       	cpc	r1, r24
    2ca0:	09 06       	cpc	r0, r25
    2ca2:	08 95       	ret

00002ca4 <__fp_pscB>:
    2ca4:	00 24       	eor	r0, r0
    2ca6:	0a 94       	dec	r0
    2ca8:	12 16       	cp	r1, r18
    2caa:	13 06       	cpc	r1, r19
    2cac:	14 06       	cpc	r1, r20
    2cae:	05 06       	cpc	r0, r21
    2cb0:	08 95       	ret

00002cb2 <__fp_round>:
    2cb2:	09 2e       	mov	r0, r25
    2cb4:	03 94       	inc	r0
    2cb6:	00 0c       	add	r0, r0
    2cb8:	11 f4       	brne	.+4      	; 0x2cbe <__fp_round+0xc>
    2cba:	88 23       	and	r24, r24
    2cbc:	52 f0       	brmi	.+20     	; 0x2cd2 <__fp_round+0x20>
    2cbe:	bb 0f       	add	r27, r27
    2cc0:	40 f4       	brcc	.+16     	; 0x2cd2 <__fp_round+0x20>
    2cc2:	bf 2b       	or	r27, r31
    2cc4:	11 f4       	brne	.+4      	; 0x2cca <__fp_round+0x18>
    2cc6:	60 ff       	sbrs	r22, 0
    2cc8:	04 c0       	rjmp	.+8      	; 0x2cd2 <__fp_round+0x20>
    2cca:	6f 5f       	subi	r22, 0xFF	; 255
    2ccc:	7f 4f       	sbci	r23, 0xFF	; 255
    2cce:	8f 4f       	sbci	r24, 0xFF	; 255
    2cd0:	9f 4f       	sbci	r25, 0xFF	; 255
    2cd2:	08 95       	ret

00002cd4 <__fp_split3>:
    2cd4:	57 fd       	sbrc	r21, 7
    2cd6:	90 58       	subi	r25, 0x80	; 128
    2cd8:	44 0f       	add	r20, r20
    2cda:	55 1f       	adc	r21, r21
    2cdc:	59 f0       	breq	.+22     	; 0x2cf4 <__fp_splitA+0x10>
    2cde:	5f 3f       	cpi	r21, 0xFF	; 255
    2ce0:	71 f0       	breq	.+28     	; 0x2cfe <__fp_splitA+0x1a>
    2ce2:	47 95       	ror	r20

00002ce4 <__fp_splitA>:
    2ce4:	88 0f       	add	r24, r24
    2ce6:	97 fb       	bst	r25, 7
    2ce8:	99 1f       	adc	r25, r25
    2cea:	61 f0       	breq	.+24     	; 0x2d04 <__fp_splitA+0x20>
    2cec:	9f 3f       	cpi	r25, 0xFF	; 255
    2cee:	79 f0       	breq	.+30     	; 0x2d0e <__fp_splitA+0x2a>
    2cf0:	87 95       	ror	r24
    2cf2:	08 95       	ret
    2cf4:	12 16       	cp	r1, r18
    2cf6:	13 06       	cpc	r1, r19
    2cf8:	14 06       	cpc	r1, r20
    2cfa:	55 1f       	adc	r21, r21
    2cfc:	f2 cf       	rjmp	.-28     	; 0x2ce2 <__fp_split3+0xe>
    2cfe:	46 95       	lsr	r20
    2d00:	f1 df       	rcall	.-30     	; 0x2ce4 <__fp_splitA>
    2d02:	08 c0       	rjmp	.+16     	; 0x2d14 <__fp_splitA+0x30>
    2d04:	16 16       	cp	r1, r22
    2d06:	17 06       	cpc	r1, r23
    2d08:	18 06       	cpc	r1, r24
    2d0a:	99 1f       	adc	r25, r25
    2d0c:	f1 cf       	rjmp	.-30     	; 0x2cf0 <__fp_splitA+0xc>
    2d0e:	86 95       	lsr	r24
    2d10:	71 05       	cpc	r23, r1
    2d12:	61 05       	cpc	r22, r1
    2d14:	08 94       	sec
    2d16:	08 95       	ret

00002d18 <__fp_zero>:
    2d18:	e8 94       	clt

00002d1a <__fp_szero>:
    2d1a:	bb 27       	eor	r27, r27
    2d1c:	66 27       	eor	r22, r22
    2d1e:	77 27       	eor	r23, r23
    2d20:	cb 01       	movw	r24, r22
    2d22:	97 f9       	bld	r25, 7
    2d24:	08 95       	ret

00002d26 <__mulsf3>:
    2d26:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <__mulsf3x>
    2d2a:	0c 94 59 16 	jmp	0x2cb2	; 0x2cb2 <__fp_round>
    2d2e:	0e 94 4b 16 	call	0x2c96	; 0x2c96 <__fp_pscA>
    2d32:	38 f0       	brcs	.+14     	; 0x2d42 <__mulsf3+0x1c>
    2d34:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <__fp_pscB>
    2d38:	20 f0       	brcs	.+8      	; 0x2d42 <__mulsf3+0x1c>
    2d3a:	95 23       	and	r25, r21
    2d3c:	11 f0       	breq	.+4      	; 0x2d42 <__mulsf3+0x1c>
    2d3e:	0c 94 42 16 	jmp	0x2c84	; 0x2c84 <__fp_inf>
    2d42:	0c 94 48 16 	jmp	0x2c90	; 0x2c90 <__fp_nan>
    2d46:	11 24       	eor	r1, r1
    2d48:	0c 94 8d 16 	jmp	0x2d1a	; 0x2d1a <__fp_szero>

00002d4c <__mulsf3x>:
    2d4c:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <__fp_split3>
    2d50:	70 f3       	brcs	.-36     	; 0x2d2e <__mulsf3+0x8>

00002d52 <__mulsf3_pse>:
    2d52:	95 9f       	mul	r25, r21
    2d54:	c1 f3       	breq	.-16     	; 0x2d46 <__mulsf3+0x20>
    2d56:	95 0f       	add	r25, r21
    2d58:	50 e0       	ldi	r21, 0x00	; 0
    2d5a:	55 1f       	adc	r21, r21
    2d5c:	62 9f       	mul	r22, r18
    2d5e:	f0 01       	movw	r30, r0
    2d60:	72 9f       	mul	r23, r18
    2d62:	bb 27       	eor	r27, r27
    2d64:	f0 0d       	add	r31, r0
    2d66:	b1 1d       	adc	r27, r1
    2d68:	63 9f       	mul	r22, r19
    2d6a:	aa 27       	eor	r26, r26
    2d6c:	f0 0d       	add	r31, r0
    2d6e:	b1 1d       	adc	r27, r1
    2d70:	aa 1f       	adc	r26, r26
    2d72:	64 9f       	mul	r22, r20
    2d74:	66 27       	eor	r22, r22
    2d76:	b0 0d       	add	r27, r0
    2d78:	a1 1d       	adc	r26, r1
    2d7a:	66 1f       	adc	r22, r22
    2d7c:	82 9f       	mul	r24, r18
    2d7e:	22 27       	eor	r18, r18
    2d80:	b0 0d       	add	r27, r0
    2d82:	a1 1d       	adc	r26, r1
    2d84:	62 1f       	adc	r22, r18
    2d86:	73 9f       	mul	r23, r19
    2d88:	b0 0d       	add	r27, r0
    2d8a:	a1 1d       	adc	r26, r1
    2d8c:	62 1f       	adc	r22, r18
    2d8e:	83 9f       	mul	r24, r19
    2d90:	a0 0d       	add	r26, r0
    2d92:	61 1d       	adc	r22, r1
    2d94:	22 1f       	adc	r18, r18
    2d96:	74 9f       	mul	r23, r20
    2d98:	33 27       	eor	r19, r19
    2d9a:	a0 0d       	add	r26, r0
    2d9c:	61 1d       	adc	r22, r1
    2d9e:	23 1f       	adc	r18, r19
    2da0:	84 9f       	mul	r24, r20
    2da2:	60 0d       	add	r22, r0
    2da4:	21 1d       	adc	r18, r1
    2da6:	82 2f       	mov	r24, r18
    2da8:	76 2f       	mov	r23, r22
    2daa:	6a 2f       	mov	r22, r26
    2dac:	11 24       	eor	r1, r1
    2dae:	9f 57       	subi	r25, 0x7F	; 127
    2db0:	50 40       	sbci	r21, 0x00	; 0
    2db2:	9a f0       	brmi	.+38     	; 0x2dda <__mulsf3_pse+0x88>
    2db4:	f1 f0       	breq	.+60     	; 0x2df2 <__mulsf3_pse+0xa0>
    2db6:	88 23       	and	r24, r24
    2db8:	4a f0       	brmi	.+18     	; 0x2dcc <__mulsf3_pse+0x7a>
    2dba:	ee 0f       	add	r30, r30
    2dbc:	ff 1f       	adc	r31, r31
    2dbe:	bb 1f       	adc	r27, r27
    2dc0:	66 1f       	adc	r22, r22
    2dc2:	77 1f       	adc	r23, r23
    2dc4:	88 1f       	adc	r24, r24
    2dc6:	91 50       	subi	r25, 0x01	; 1
    2dc8:	50 40       	sbci	r21, 0x00	; 0
    2dca:	a9 f7       	brne	.-22     	; 0x2db6 <__mulsf3_pse+0x64>
    2dcc:	9e 3f       	cpi	r25, 0xFE	; 254
    2dce:	51 05       	cpc	r21, r1
    2dd0:	80 f0       	brcs	.+32     	; 0x2df2 <__mulsf3_pse+0xa0>
    2dd2:	0c 94 42 16 	jmp	0x2c84	; 0x2c84 <__fp_inf>
    2dd6:	0c 94 8d 16 	jmp	0x2d1a	; 0x2d1a <__fp_szero>
    2dda:	5f 3f       	cpi	r21, 0xFF	; 255
    2ddc:	e4 f3       	brlt	.-8      	; 0x2dd6 <__mulsf3_pse+0x84>
    2dde:	98 3e       	cpi	r25, 0xE8	; 232
    2de0:	d4 f3       	brlt	.-12     	; 0x2dd6 <__mulsf3_pse+0x84>
    2de2:	86 95       	lsr	r24
    2de4:	77 95       	ror	r23
    2de6:	67 95       	ror	r22
    2de8:	b7 95       	ror	r27
    2dea:	f7 95       	ror	r31
    2dec:	e7 95       	ror	r30
    2dee:	9f 5f       	subi	r25, 0xFF	; 255
    2df0:	c1 f7       	brne	.-16     	; 0x2de2 <__mulsf3_pse+0x90>
    2df2:	fe 2b       	or	r31, r30
    2df4:	88 0f       	add	r24, r24
    2df6:	91 1d       	adc	r25, r1
    2df8:	96 95       	lsr	r25
    2dfa:	87 95       	ror	r24
    2dfc:	97 f9       	bld	r25, 7
    2dfe:	08 95       	ret

00002e00 <__tablejump2__>:
    2e00:	ee 0f       	add	r30, r30
    2e02:	ff 1f       	adc	r31, r31
    2e04:	05 90       	lpm	r0, Z+
    2e06:	f4 91       	lpm	r31, Z
    2e08:	e0 2d       	mov	r30, r0
    2e0a:	09 94       	ijmp

00002e0c <strcmp>:
    2e0c:	fb 01       	movw	r30, r22
    2e0e:	dc 01       	movw	r26, r24
    2e10:	8d 91       	ld	r24, X+
    2e12:	01 90       	ld	r0, Z+
    2e14:	80 19       	sub	r24, r0
    2e16:	01 10       	cpse	r0, r1
    2e18:	d9 f3       	breq	.-10     	; 0x2e10 <strcmp+0x4>
    2e1a:	99 0b       	sbc	r25, r25
    2e1c:	08 95       	ret

00002e1e <strcpy>:
    2e1e:	fb 01       	movw	r30, r22
    2e20:	dc 01       	movw	r26, r24
    2e22:	01 90       	ld	r0, Z+
    2e24:	0d 92       	st	X+, r0
    2e26:	00 20       	and	r0, r0
    2e28:	e1 f7       	brne	.-8      	; 0x2e22 <strcpy+0x4>
    2e2a:	08 95       	ret

00002e2c <sprintf>:
    2e2c:	ae e0       	ldi	r26, 0x0E	; 14
    2e2e:	b0 e0       	ldi	r27, 0x00	; 0
    2e30:	ec e1       	ldi	r30, 0x1C	; 28
    2e32:	f7 e1       	ldi	r31, 0x17	; 23
    2e34:	0c 94 d7 19 	jmp	0x33ae	; 0x33ae <__prologue_saves__+0x1c>
    2e38:	0d 89       	ldd	r16, Y+21	; 0x15
    2e3a:	1e 89       	ldd	r17, Y+22	; 0x16
    2e3c:	86 e0       	ldi	r24, 0x06	; 6
    2e3e:	8c 83       	std	Y+4, r24	; 0x04
    2e40:	1a 83       	std	Y+2, r17	; 0x02
    2e42:	09 83       	std	Y+1, r16	; 0x01
    2e44:	8f ef       	ldi	r24, 0xFF	; 255
    2e46:	9f e7       	ldi	r25, 0x7F	; 127
    2e48:	9e 83       	std	Y+6, r25	; 0x06
    2e4a:	8d 83       	std	Y+5, r24	; 0x05
    2e4c:	ae 01       	movw	r20, r28
    2e4e:	47 5e       	subi	r20, 0xE7	; 231
    2e50:	5f 4f       	sbci	r21, 0xFF	; 255
    2e52:	6f 89       	ldd	r22, Y+23	; 0x17
    2e54:	78 8d       	ldd	r23, Y+24	; 0x18
    2e56:	ce 01       	movw	r24, r28
    2e58:	01 96       	adiw	r24, 0x01	; 1
    2e5a:	0e 94 38 17 	call	0x2e70	; 0x2e70 <vfprintf>
    2e5e:	ef 81       	ldd	r30, Y+7	; 0x07
    2e60:	f8 85       	ldd	r31, Y+8	; 0x08
    2e62:	e0 0f       	add	r30, r16
    2e64:	f1 1f       	adc	r31, r17
    2e66:	10 82       	st	Z, r1
    2e68:	2e 96       	adiw	r28, 0x0e	; 14
    2e6a:	e4 e0       	ldi	r30, 0x04	; 4
    2e6c:	0c 94 f3 19 	jmp	0x33e6	; 0x33e6 <__epilogue_restores__+0x1c>

00002e70 <vfprintf>:
    2e70:	ab e0       	ldi	r26, 0x0B	; 11
    2e72:	b0 e0       	ldi	r27, 0x00	; 0
    2e74:	ee e3       	ldi	r30, 0x3E	; 62
    2e76:	f7 e1       	ldi	r31, 0x17	; 23
    2e78:	0c 94 c9 19 	jmp	0x3392	; 0x3392 <__prologue_saves__>
    2e7c:	6c 01       	movw	r12, r24
    2e7e:	7b 01       	movw	r14, r22
    2e80:	8a 01       	movw	r16, r20
    2e82:	fc 01       	movw	r30, r24
    2e84:	17 82       	std	Z+7, r1	; 0x07
    2e86:	16 82       	std	Z+6, r1	; 0x06
    2e88:	83 81       	ldd	r24, Z+3	; 0x03
    2e8a:	81 ff       	sbrs	r24, 1
    2e8c:	cc c1       	rjmp	.+920    	; 0x3226 <vfprintf+0x3b6>
    2e8e:	ce 01       	movw	r24, r28
    2e90:	01 96       	adiw	r24, 0x01	; 1
    2e92:	3c 01       	movw	r6, r24
    2e94:	f6 01       	movw	r30, r12
    2e96:	93 81       	ldd	r25, Z+3	; 0x03
    2e98:	f7 01       	movw	r30, r14
    2e9a:	93 fd       	sbrc	r25, 3
    2e9c:	85 91       	lpm	r24, Z+
    2e9e:	93 ff       	sbrs	r25, 3
    2ea0:	81 91       	ld	r24, Z+
    2ea2:	7f 01       	movw	r14, r30
    2ea4:	88 23       	and	r24, r24
    2ea6:	09 f4       	brne	.+2      	; 0x2eaa <vfprintf+0x3a>
    2ea8:	ba c1       	rjmp	.+884    	; 0x321e <vfprintf+0x3ae>
    2eaa:	85 32       	cpi	r24, 0x25	; 37
    2eac:	39 f4       	brne	.+14     	; 0x2ebc <vfprintf+0x4c>
    2eae:	93 fd       	sbrc	r25, 3
    2eb0:	85 91       	lpm	r24, Z+
    2eb2:	93 ff       	sbrs	r25, 3
    2eb4:	81 91       	ld	r24, Z+
    2eb6:	7f 01       	movw	r14, r30
    2eb8:	85 32       	cpi	r24, 0x25	; 37
    2eba:	29 f4       	brne	.+10     	; 0x2ec6 <vfprintf+0x56>
    2ebc:	b6 01       	movw	r22, r12
    2ebe:	90 e0       	ldi	r25, 0x00	; 0
    2ec0:	0e 94 2f 19 	call	0x325e	; 0x325e <fputc>
    2ec4:	e7 cf       	rjmp	.-50     	; 0x2e94 <vfprintf+0x24>
    2ec6:	91 2c       	mov	r9, r1
    2ec8:	21 2c       	mov	r2, r1
    2eca:	31 2c       	mov	r3, r1
    2ecc:	ff e1       	ldi	r31, 0x1F	; 31
    2ece:	f3 15       	cp	r31, r3
    2ed0:	d8 f0       	brcs	.+54     	; 0x2f08 <vfprintf+0x98>
    2ed2:	8b 32       	cpi	r24, 0x2B	; 43
    2ed4:	79 f0       	breq	.+30     	; 0x2ef4 <vfprintf+0x84>
    2ed6:	38 f4       	brcc	.+14     	; 0x2ee6 <vfprintf+0x76>
    2ed8:	80 32       	cpi	r24, 0x20	; 32
    2eda:	79 f0       	breq	.+30     	; 0x2efa <vfprintf+0x8a>
    2edc:	83 32       	cpi	r24, 0x23	; 35
    2ede:	a1 f4       	brne	.+40     	; 0x2f08 <vfprintf+0x98>
    2ee0:	23 2d       	mov	r18, r3
    2ee2:	20 61       	ori	r18, 0x10	; 16
    2ee4:	1d c0       	rjmp	.+58     	; 0x2f20 <vfprintf+0xb0>
    2ee6:	8d 32       	cpi	r24, 0x2D	; 45
    2ee8:	61 f0       	breq	.+24     	; 0x2f02 <vfprintf+0x92>
    2eea:	80 33       	cpi	r24, 0x30	; 48
    2eec:	69 f4       	brne	.+26     	; 0x2f08 <vfprintf+0x98>
    2eee:	23 2d       	mov	r18, r3
    2ef0:	21 60       	ori	r18, 0x01	; 1
    2ef2:	16 c0       	rjmp	.+44     	; 0x2f20 <vfprintf+0xb0>
    2ef4:	83 2d       	mov	r24, r3
    2ef6:	82 60       	ori	r24, 0x02	; 2
    2ef8:	38 2e       	mov	r3, r24
    2efa:	e3 2d       	mov	r30, r3
    2efc:	e4 60       	ori	r30, 0x04	; 4
    2efe:	3e 2e       	mov	r3, r30
    2f00:	2a c0       	rjmp	.+84     	; 0x2f56 <vfprintf+0xe6>
    2f02:	f3 2d       	mov	r31, r3
    2f04:	f8 60       	ori	r31, 0x08	; 8
    2f06:	1d c0       	rjmp	.+58     	; 0x2f42 <vfprintf+0xd2>
    2f08:	37 fc       	sbrc	r3, 7
    2f0a:	2d c0       	rjmp	.+90     	; 0x2f66 <vfprintf+0xf6>
    2f0c:	20 ed       	ldi	r18, 0xD0	; 208
    2f0e:	28 0f       	add	r18, r24
    2f10:	2a 30       	cpi	r18, 0x0A	; 10
    2f12:	40 f0       	brcs	.+16     	; 0x2f24 <vfprintf+0xb4>
    2f14:	8e 32       	cpi	r24, 0x2E	; 46
    2f16:	b9 f4       	brne	.+46     	; 0x2f46 <vfprintf+0xd6>
    2f18:	36 fc       	sbrc	r3, 6
    2f1a:	81 c1       	rjmp	.+770    	; 0x321e <vfprintf+0x3ae>
    2f1c:	23 2d       	mov	r18, r3
    2f1e:	20 64       	ori	r18, 0x40	; 64
    2f20:	32 2e       	mov	r3, r18
    2f22:	19 c0       	rjmp	.+50     	; 0x2f56 <vfprintf+0xe6>
    2f24:	36 fe       	sbrs	r3, 6
    2f26:	06 c0       	rjmp	.+12     	; 0x2f34 <vfprintf+0xc4>
    2f28:	8a e0       	ldi	r24, 0x0A	; 10
    2f2a:	98 9e       	mul	r9, r24
    2f2c:	20 0d       	add	r18, r0
    2f2e:	11 24       	eor	r1, r1
    2f30:	92 2e       	mov	r9, r18
    2f32:	11 c0       	rjmp	.+34     	; 0x2f56 <vfprintf+0xe6>
    2f34:	ea e0       	ldi	r30, 0x0A	; 10
    2f36:	2e 9e       	mul	r2, r30
    2f38:	20 0d       	add	r18, r0
    2f3a:	11 24       	eor	r1, r1
    2f3c:	22 2e       	mov	r2, r18
    2f3e:	f3 2d       	mov	r31, r3
    2f40:	f0 62       	ori	r31, 0x20	; 32
    2f42:	3f 2e       	mov	r3, r31
    2f44:	08 c0       	rjmp	.+16     	; 0x2f56 <vfprintf+0xe6>
    2f46:	8c 36       	cpi	r24, 0x6C	; 108
    2f48:	21 f4       	brne	.+8      	; 0x2f52 <vfprintf+0xe2>
    2f4a:	83 2d       	mov	r24, r3
    2f4c:	80 68       	ori	r24, 0x80	; 128
    2f4e:	38 2e       	mov	r3, r24
    2f50:	02 c0       	rjmp	.+4      	; 0x2f56 <vfprintf+0xe6>
    2f52:	88 36       	cpi	r24, 0x68	; 104
    2f54:	41 f4       	brne	.+16     	; 0x2f66 <vfprintf+0xf6>
    2f56:	f7 01       	movw	r30, r14
    2f58:	93 fd       	sbrc	r25, 3
    2f5a:	85 91       	lpm	r24, Z+
    2f5c:	93 ff       	sbrs	r25, 3
    2f5e:	81 91       	ld	r24, Z+
    2f60:	7f 01       	movw	r14, r30
    2f62:	81 11       	cpse	r24, r1
    2f64:	b3 cf       	rjmp	.-154    	; 0x2ecc <vfprintf+0x5c>
    2f66:	98 2f       	mov	r25, r24
    2f68:	9f 7d       	andi	r25, 0xDF	; 223
    2f6a:	95 54       	subi	r25, 0x45	; 69
    2f6c:	93 30       	cpi	r25, 0x03	; 3
    2f6e:	28 f4       	brcc	.+10     	; 0x2f7a <vfprintf+0x10a>
    2f70:	0c 5f       	subi	r16, 0xFC	; 252
    2f72:	1f 4f       	sbci	r17, 0xFF	; 255
    2f74:	9f e3       	ldi	r25, 0x3F	; 63
    2f76:	99 83       	std	Y+1, r25	; 0x01
    2f78:	0d c0       	rjmp	.+26     	; 0x2f94 <vfprintf+0x124>
    2f7a:	83 36       	cpi	r24, 0x63	; 99
    2f7c:	31 f0       	breq	.+12     	; 0x2f8a <vfprintf+0x11a>
    2f7e:	83 37       	cpi	r24, 0x73	; 115
    2f80:	71 f0       	breq	.+28     	; 0x2f9e <vfprintf+0x12e>
    2f82:	83 35       	cpi	r24, 0x53	; 83
    2f84:	09 f0       	breq	.+2      	; 0x2f88 <vfprintf+0x118>
    2f86:	59 c0       	rjmp	.+178    	; 0x303a <vfprintf+0x1ca>
    2f88:	21 c0       	rjmp	.+66     	; 0x2fcc <vfprintf+0x15c>
    2f8a:	f8 01       	movw	r30, r16
    2f8c:	80 81       	ld	r24, Z
    2f8e:	89 83       	std	Y+1, r24	; 0x01
    2f90:	0e 5f       	subi	r16, 0xFE	; 254
    2f92:	1f 4f       	sbci	r17, 0xFF	; 255
    2f94:	88 24       	eor	r8, r8
    2f96:	83 94       	inc	r8
    2f98:	91 2c       	mov	r9, r1
    2f9a:	53 01       	movw	r10, r6
    2f9c:	13 c0       	rjmp	.+38     	; 0x2fc4 <vfprintf+0x154>
    2f9e:	28 01       	movw	r4, r16
    2fa0:	f2 e0       	ldi	r31, 0x02	; 2
    2fa2:	4f 0e       	add	r4, r31
    2fa4:	51 1c       	adc	r5, r1
    2fa6:	f8 01       	movw	r30, r16
    2fa8:	a0 80       	ld	r10, Z
    2faa:	b1 80       	ldd	r11, Z+1	; 0x01
    2fac:	36 fe       	sbrs	r3, 6
    2fae:	03 c0       	rjmp	.+6      	; 0x2fb6 <vfprintf+0x146>
    2fb0:	69 2d       	mov	r22, r9
    2fb2:	70 e0       	ldi	r23, 0x00	; 0
    2fb4:	02 c0       	rjmp	.+4      	; 0x2fba <vfprintf+0x14a>
    2fb6:	6f ef       	ldi	r22, 0xFF	; 255
    2fb8:	7f ef       	ldi	r23, 0xFF	; 255
    2fba:	c5 01       	movw	r24, r10
    2fbc:	0e 94 24 19 	call	0x3248	; 0x3248 <strnlen>
    2fc0:	4c 01       	movw	r8, r24
    2fc2:	82 01       	movw	r16, r4
    2fc4:	f3 2d       	mov	r31, r3
    2fc6:	ff 77       	andi	r31, 0x7F	; 127
    2fc8:	3f 2e       	mov	r3, r31
    2fca:	16 c0       	rjmp	.+44     	; 0x2ff8 <vfprintf+0x188>
    2fcc:	28 01       	movw	r4, r16
    2fce:	22 e0       	ldi	r18, 0x02	; 2
    2fd0:	42 0e       	add	r4, r18
    2fd2:	51 1c       	adc	r5, r1
    2fd4:	f8 01       	movw	r30, r16
    2fd6:	a0 80       	ld	r10, Z
    2fd8:	b1 80       	ldd	r11, Z+1	; 0x01
    2fda:	36 fe       	sbrs	r3, 6
    2fdc:	03 c0       	rjmp	.+6      	; 0x2fe4 <vfprintf+0x174>
    2fde:	69 2d       	mov	r22, r9
    2fe0:	70 e0       	ldi	r23, 0x00	; 0
    2fe2:	02 c0       	rjmp	.+4      	; 0x2fe8 <vfprintf+0x178>
    2fe4:	6f ef       	ldi	r22, 0xFF	; 255
    2fe6:	7f ef       	ldi	r23, 0xFF	; 255
    2fe8:	c5 01       	movw	r24, r10
    2fea:	0e 94 19 19 	call	0x3232	; 0x3232 <strnlen_P>
    2fee:	4c 01       	movw	r8, r24
    2ff0:	f3 2d       	mov	r31, r3
    2ff2:	f0 68       	ori	r31, 0x80	; 128
    2ff4:	3f 2e       	mov	r3, r31
    2ff6:	82 01       	movw	r16, r4
    2ff8:	33 fc       	sbrc	r3, 3
    2ffa:	1b c0       	rjmp	.+54     	; 0x3032 <vfprintf+0x1c2>
    2ffc:	82 2d       	mov	r24, r2
    2ffe:	90 e0       	ldi	r25, 0x00	; 0
    3000:	88 16       	cp	r8, r24
    3002:	99 06       	cpc	r9, r25
    3004:	b0 f4       	brcc	.+44     	; 0x3032 <vfprintf+0x1c2>
    3006:	b6 01       	movw	r22, r12
    3008:	80 e2       	ldi	r24, 0x20	; 32
    300a:	90 e0       	ldi	r25, 0x00	; 0
    300c:	0e 94 2f 19 	call	0x325e	; 0x325e <fputc>
    3010:	2a 94       	dec	r2
    3012:	f4 cf       	rjmp	.-24     	; 0x2ffc <vfprintf+0x18c>
    3014:	f5 01       	movw	r30, r10
    3016:	37 fc       	sbrc	r3, 7
    3018:	85 91       	lpm	r24, Z+
    301a:	37 fe       	sbrs	r3, 7
    301c:	81 91       	ld	r24, Z+
    301e:	5f 01       	movw	r10, r30
    3020:	b6 01       	movw	r22, r12
    3022:	90 e0       	ldi	r25, 0x00	; 0
    3024:	0e 94 2f 19 	call	0x325e	; 0x325e <fputc>
    3028:	21 10       	cpse	r2, r1
    302a:	2a 94       	dec	r2
    302c:	21 e0       	ldi	r18, 0x01	; 1
    302e:	82 1a       	sub	r8, r18
    3030:	91 08       	sbc	r9, r1
    3032:	81 14       	cp	r8, r1
    3034:	91 04       	cpc	r9, r1
    3036:	71 f7       	brne	.-36     	; 0x3014 <vfprintf+0x1a4>
    3038:	e8 c0       	rjmp	.+464    	; 0x320a <vfprintf+0x39a>
    303a:	84 36       	cpi	r24, 0x64	; 100
    303c:	11 f0       	breq	.+4      	; 0x3042 <vfprintf+0x1d2>
    303e:	89 36       	cpi	r24, 0x69	; 105
    3040:	41 f5       	brne	.+80     	; 0x3092 <vfprintf+0x222>
    3042:	f8 01       	movw	r30, r16
    3044:	37 fe       	sbrs	r3, 7
    3046:	07 c0       	rjmp	.+14     	; 0x3056 <vfprintf+0x1e6>
    3048:	60 81       	ld	r22, Z
    304a:	71 81       	ldd	r23, Z+1	; 0x01
    304c:	82 81       	ldd	r24, Z+2	; 0x02
    304e:	93 81       	ldd	r25, Z+3	; 0x03
    3050:	0c 5f       	subi	r16, 0xFC	; 252
    3052:	1f 4f       	sbci	r17, 0xFF	; 255
    3054:	08 c0       	rjmp	.+16     	; 0x3066 <vfprintf+0x1f6>
    3056:	60 81       	ld	r22, Z
    3058:	71 81       	ldd	r23, Z+1	; 0x01
    305a:	07 2e       	mov	r0, r23
    305c:	00 0c       	add	r0, r0
    305e:	88 0b       	sbc	r24, r24
    3060:	99 0b       	sbc	r25, r25
    3062:	0e 5f       	subi	r16, 0xFE	; 254
    3064:	1f 4f       	sbci	r17, 0xFF	; 255
    3066:	f3 2d       	mov	r31, r3
    3068:	ff 76       	andi	r31, 0x6F	; 111
    306a:	3f 2e       	mov	r3, r31
    306c:	97 ff       	sbrs	r25, 7
    306e:	09 c0       	rjmp	.+18     	; 0x3082 <vfprintf+0x212>
    3070:	90 95       	com	r25
    3072:	80 95       	com	r24
    3074:	70 95       	com	r23
    3076:	61 95       	neg	r22
    3078:	7f 4f       	sbci	r23, 0xFF	; 255
    307a:	8f 4f       	sbci	r24, 0xFF	; 255
    307c:	9f 4f       	sbci	r25, 0xFF	; 255
    307e:	f0 68       	ori	r31, 0x80	; 128
    3080:	3f 2e       	mov	r3, r31
    3082:	2a e0       	ldi	r18, 0x0A	; 10
    3084:	30 e0       	ldi	r19, 0x00	; 0
    3086:	a3 01       	movw	r20, r6
    3088:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <__ultoa_invert>
    308c:	88 2e       	mov	r8, r24
    308e:	86 18       	sub	r8, r6
    3090:	45 c0       	rjmp	.+138    	; 0x311c <vfprintf+0x2ac>
    3092:	85 37       	cpi	r24, 0x75	; 117
    3094:	31 f4       	brne	.+12     	; 0x30a2 <vfprintf+0x232>
    3096:	23 2d       	mov	r18, r3
    3098:	2f 7e       	andi	r18, 0xEF	; 239
    309a:	b2 2e       	mov	r11, r18
    309c:	2a e0       	ldi	r18, 0x0A	; 10
    309e:	30 e0       	ldi	r19, 0x00	; 0
    30a0:	25 c0       	rjmp	.+74     	; 0x30ec <vfprintf+0x27c>
    30a2:	93 2d       	mov	r25, r3
    30a4:	99 7f       	andi	r25, 0xF9	; 249
    30a6:	b9 2e       	mov	r11, r25
    30a8:	8f 36       	cpi	r24, 0x6F	; 111
    30aa:	c1 f0       	breq	.+48     	; 0x30dc <vfprintf+0x26c>
    30ac:	18 f4       	brcc	.+6      	; 0x30b4 <vfprintf+0x244>
    30ae:	88 35       	cpi	r24, 0x58	; 88
    30b0:	79 f0       	breq	.+30     	; 0x30d0 <vfprintf+0x260>
    30b2:	b5 c0       	rjmp	.+362    	; 0x321e <vfprintf+0x3ae>
    30b4:	80 37       	cpi	r24, 0x70	; 112
    30b6:	19 f0       	breq	.+6      	; 0x30be <vfprintf+0x24e>
    30b8:	88 37       	cpi	r24, 0x78	; 120
    30ba:	21 f0       	breq	.+8      	; 0x30c4 <vfprintf+0x254>
    30bc:	b0 c0       	rjmp	.+352    	; 0x321e <vfprintf+0x3ae>
    30be:	e9 2f       	mov	r30, r25
    30c0:	e0 61       	ori	r30, 0x10	; 16
    30c2:	be 2e       	mov	r11, r30
    30c4:	b4 fe       	sbrs	r11, 4
    30c6:	0d c0       	rjmp	.+26     	; 0x30e2 <vfprintf+0x272>
    30c8:	fb 2d       	mov	r31, r11
    30ca:	f4 60       	ori	r31, 0x04	; 4
    30cc:	bf 2e       	mov	r11, r31
    30ce:	09 c0       	rjmp	.+18     	; 0x30e2 <vfprintf+0x272>
    30d0:	34 fe       	sbrs	r3, 4
    30d2:	0a c0       	rjmp	.+20     	; 0x30e8 <vfprintf+0x278>
    30d4:	29 2f       	mov	r18, r25
    30d6:	26 60       	ori	r18, 0x06	; 6
    30d8:	b2 2e       	mov	r11, r18
    30da:	06 c0       	rjmp	.+12     	; 0x30e8 <vfprintf+0x278>
    30dc:	28 e0       	ldi	r18, 0x08	; 8
    30de:	30 e0       	ldi	r19, 0x00	; 0
    30e0:	05 c0       	rjmp	.+10     	; 0x30ec <vfprintf+0x27c>
    30e2:	20 e1       	ldi	r18, 0x10	; 16
    30e4:	30 e0       	ldi	r19, 0x00	; 0
    30e6:	02 c0       	rjmp	.+4      	; 0x30ec <vfprintf+0x27c>
    30e8:	20 e1       	ldi	r18, 0x10	; 16
    30ea:	32 e0       	ldi	r19, 0x02	; 2
    30ec:	f8 01       	movw	r30, r16
    30ee:	b7 fe       	sbrs	r11, 7
    30f0:	07 c0       	rjmp	.+14     	; 0x3100 <vfprintf+0x290>
    30f2:	60 81       	ld	r22, Z
    30f4:	71 81       	ldd	r23, Z+1	; 0x01
    30f6:	82 81       	ldd	r24, Z+2	; 0x02
    30f8:	93 81       	ldd	r25, Z+3	; 0x03
    30fa:	0c 5f       	subi	r16, 0xFC	; 252
    30fc:	1f 4f       	sbci	r17, 0xFF	; 255
    30fe:	06 c0       	rjmp	.+12     	; 0x310c <vfprintf+0x29c>
    3100:	60 81       	ld	r22, Z
    3102:	71 81       	ldd	r23, Z+1	; 0x01
    3104:	80 e0       	ldi	r24, 0x00	; 0
    3106:	90 e0       	ldi	r25, 0x00	; 0
    3108:	0e 5f       	subi	r16, 0xFE	; 254
    310a:	1f 4f       	sbci	r17, 0xFF	; 255
    310c:	a3 01       	movw	r20, r6
    310e:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <__ultoa_invert>
    3112:	88 2e       	mov	r8, r24
    3114:	86 18       	sub	r8, r6
    3116:	fb 2d       	mov	r31, r11
    3118:	ff 77       	andi	r31, 0x7F	; 127
    311a:	3f 2e       	mov	r3, r31
    311c:	36 fe       	sbrs	r3, 6
    311e:	0d c0       	rjmp	.+26     	; 0x313a <vfprintf+0x2ca>
    3120:	23 2d       	mov	r18, r3
    3122:	2e 7f       	andi	r18, 0xFE	; 254
    3124:	a2 2e       	mov	r10, r18
    3126:	89 14       	cp	r8, r9
    3128:	58 f4       	brcc	.+22     	; 0x3140 <vfprintf+0x2d0>
    312a:	34 fe       	sbrs	r3, 4
    312c:	0b c0       	rjmp	.+22     	; 0x3144 <vfprintf+0x2d4>
    312e:	32 fc       	sbrc	r3, 2
    3130:	09 c0       	rjmp	.+18     	; 0x3144 <vfprintf+0x2d4>
    3132:	83 2d       	mov	r24, r3
    3134:	8e 7e       	andi	r24, 0xEE	; 238
    3136:	a8 2e       	mov	r10, r24
    3138:	05 c0       	rjmp	.+10     	; 0x3144 <vfprintf+0x2d4>
    313a:	b8 2c       	mov	r11, r8
    313c:	a3 2c       	mov	r10, r3
    313e:	03 c0       	rjmp	.+6      	; 0x3146 <vfprintf+0x2d6>
    3140:	b8 2c       	mov	r11, r8
    3142:	01 c0       	rjmp	.+2      	; 0x3146 <vfprintf+0x2d6>
    3144:	b9 2c       	mov	r11, r9
    3146:	a4 fe       	sbrs	r10, 4
    3148:	0f c0       	rjmp	.+30     	; 0x3168 <vfprintf+0x2f8>
    314a:	fe 01       	movw	r30, r28
    314c:	e8 0d       	add	r30, r8
    314e:	f1 1d       	adc	r31, r1
    3150:	80 81       	ld	r24, Z
    3152:	80 33       	cpi	r24, 0x30	; 48
    3154:	21 f4       	brne	.+8      	; 0x315e <vfprintf+0x2ee>
    3156:	9a 2d       	mov	r25, r10
    3158:	99 7e       	andi	r25, 0xE9	; 233
    315a:	a9 2e       	mov	r10, r25
    315c:	09 c0       	rjmp	.+18     	; 0x3170 <vfprintf+0x300>
    315e:	a2 fe       	sbrs	r10, 2
    3160:	06 c0       	rjmp	.+12     	; 0x316e <vfprintf+0x2fe>
    3162:	b3 94       	inc	r11
    3164:	b3 94       	inc	r11
    3166:	04 c0       	rjmp	.+8      	; 0x3170 <vfprintf+0x300>
    3168:	8a 2d       	mov	r24, r10
    316a:	86 78       	andi	r24, 0x86	; 134
    316c:	09 f0       	breq	.+2      	; 0x3170 <vfprintf+0x300>
    316e:	b3 94       	inc	r11
    3170:	a3 fc       	sbrc	r10, 3
    3172:	11 c0       	rjmp	.+34     	; 0x3196 <vfprintf+0x326>
    3174:	a0 fe       	sbrs	r10, 0
    3176:	06 c0       	rjmp	.+12     	; 0x3184 <vfprintf+0x314>
    3178:	b2 14       	cp	r11, r2
    317a:	88 f4       	brcc	.+34     	; 0x319e <vfprintf+0x32e>
    317c:	28 0c       	add	r2, r8
    317e:	92 2c       	mov	r9, r2
    3180:	9b 18       	sub	r9, r11
    3182:	0e c0       	rjmp	.+28     	; 0x31a0 <vfprintf+0x330>
    3184:	b2 14       	cp	r11, r2
    3186:	60 f4       	brcc	.+24     	; 0x31a0 <vfprintf+0x330>
    3188:	b6 01       	movw	r22, r12
    318a:	80 e2       	ldi	r24, 0x20	; 32
    318c:	90 e0       	ldi	r25, 0x00	; 0
    318e:	0e 94 2f 19 	call	0x325e	; 0x325e <fputc>
    3192:	b3 94       	inc	r11
    3194:	f7 cf       	rjmp	.-18     	; 0x3184 <vfprintf+0x314>
    3196:	b2 14       	cp	r11, r2
    3198:	18 f4       	brcc	.+6      	; 0x31a0 <vfprintf+0x330>
    319a:	2b 18       	sub	r2, r11
    319c:	02 c0       	rjmp	.+4      	; 0x31a2 <vfprintf+0x332>
    319e:	98 2c       	mov	r9, r8
    31a0:	21 2c       	mov	r2, r1
    31a2:	a4 fe       	sbrs	r10, 4
    31a4:	10 c0       	rjmp	.+32     	; 0x31c6 <vfprintf+0x356>
    31a6:	b6 01       	movw	r22, r12
    31a8:	80 e3       	ldi	r24, 0x30	; 48
    31aa:	90 e0       	ldi	r25, 0x00	; 0
    31ac:	0e 94 2f 19 	call	0x325e	; 0x325e <fputc>
    31b0:	a2 fe       	sbrs	r10, 2
    31b2:	17 c0       	rjmp	.+46     	; 0x31e2 <vfprintf+0x372>
    31b4:	a1 fc       	sbrc	r10, 1
    31b6:	03 c0       	rjmp	.+6      	; 0x31be <vfprintf+0x34e>
    31b8:	88 e7       	ldi	r24, 0x78	; 120
    31ba:	90 e0       	ldi	r25, 0x00	; 0
    31bc:	02 c0       	rjmp	.+4      	; 0x31c2 <vfprintf+0x352>
    31be:	88 e5       	ldi	r24, 0x58	; 88
    31c0:	90 e0       	ldi	r25, 0x00	; 0
    31c2:	b6 01       	movw	r22, r12
    31c4:	0c c0       	rjmp	.+24     	; 0x31de <vfprintf+0x36e>
    31c6:	8a 2d       	mov	r24, r10
    31c8:	86 78       	andi	r24, 0x86	; 134
    31ca:	59 f0       	breq	.+22     	; 0x31e2 <vfprintf+0x372>
    31cc:	a1 fe       	sbrs	r10, 1
    31ce:	02 c0       	rjmp	.+4      	; 0x31d4 <vfprintf+0x364>
    31d0:	8b e2       	ldi	r24, 0x2B	; 43
    31d2:	01 c0       	rjmp	.+2      	; 0x31d6 <vfprintf+0x366>
    31d4:	80 e2       	ldi	r24, 0x20	; 32
    31d6:	a7 fc       	sbrc	r10, 7
    31d8:	8d e2       	ldi	r24, 0x2D	; 45
    31da:	b6 01       	movw	r22, r12
    31dc:	90 e0       	ldi	r25, 0x00	; 0
    31de:	0e 94 2f 19 	call	0x325e	; 0x325e <fputc>
    31e2:	89 14       	cp	r8, r9
    31e4:	38 f4       	brcc	.+14     	; 0x31f4 <vfprintf+0x384>
    31e6:	b6 01       	movw	r22, r12
    31e8:	80 e3       	ldi	r24, 0x30	; 48
    31ea:	90 e0       	ldi	r25, 0x00	; 0
    31ec:	0e 94 2f 19 	call	0x325e	; 0x325e <fputc>
    31f0:	9a 94       	dec	r9
    31f2:	f7 cf       	rjmp	.-18     	; 0x31e2 <vfprintf+0x372>
    31f4:	8a 94       	dec	r8
    31f6:	f3 01       	movw	r30, r6
    31f8:	e8 0d       	add	r30, r8
    31fa:	f1 1d       	adc	r31, r1
    31fc:	80 81       	ld	r24, Z
    31fe:	b6 01       	movw	r22, r12
    3200:	90 e0       	ldi	r25, 0x00	; 0
    3202:	0e 94 2f 19 	call	0x325e	; 0x325e <fputc>
    3206:	81 10       	cpse	r8, r1
    3208:	f5 cf       	rjmp	.-22     	; 0x31f4 <vfprintf+0x384>
    320a:	22 20       	and	r2, r2
    320c:	09 f4       	brne	.+2      	; 0x3210 <vfprintf+0x3a0>
    320e:	42 ce       	rjmp	.-892    	; 0x2e94 <vfprintf+0x24>
    3210:	b6 01       	movw	r22, r12
    3212:	80 e2       	ldi	r24, 0x20	; 32
    3214:	90 e0       	ldi	r25, 0x00	; 0
    3216:	0e 94 2f 19 	call	0x325e	; 0x325e <fputc>
    321a:	2a 94       	dec	r2
    321c:	f6 cf       	rjmp	.-20     	; 0x320a <vfprintf+0x39a>
    321e:	f6 01       	movw	r30, r12
    3220:	86 81       	ldd	r24, Z+6	; 0x06
    3222:	97 81       	ldd	r25, Z+7	; 0x07
    3224:	02 c0       	rjmp	.+4      	; 0x322a <vfprintf+0x3ba>
    3226:	8f ef       	ldi	r24, 0xFF	; 255
    3228:	9f ef       	ldi	r25, 0xFF	; 255
    322a:	2b 96       	adiw	r28, 0x0b	; 11
    322c:	e2 e1       	ldi	r30, 0x12	; 18
    322e:	0c 94 e5 19 	jmp	0x33ca	; 0x33ca <__epilogue_restores__>

00003232 <strnlen_P>:
    3232:	fc 01       	movw	r30, r24
    3234:	05 90       	lpm	r0, Z+
    3236:	61 50       	subi	r22, 0x01	; 1
    3238:	70 40       	sbci	r23, 0x00	; 0
    323a:	01 10       	cpse	r0, r1
    323c:	d8 f7       	brcc	.-10     	; 0x3234 <strnlen_P+0x2>
    323e:	80 95       	com	r24
    3240:	90 95       	com	r25
    3242:	8e 0f       	add	r24, r30
    3244:	9f 1f       	adc	r25, r31
    3246:	08 95       	ret

00003248 <strnlen>:
    3248:	fc 01       	movw	r30, r24
    324a:	61 50       	subi	r22, 0x01	; 1
    324c:	70 40       	sbci	r23, 0x00	; 0
    324e:	01 90       	ld	r0, Z+
    3250:	01 10       	cpse	r0, r1
    3252:	d8 f7       	brcc	.-10     	; 0x324a <strnlen+0x2>
    3254:	80 95       	com	r24
    3256:	90 95       	com	r25
    3258:	8e 0f       	add	r24, r30
    325a:	9f 1f       	adc	r25, r31
    325c:	08 95       	ret

0000325e <fputc>:
    325e:	0f 93       	push	r16
    3260:	1f 93       	push	r17
    3262:	cf 93       	push	r28
    3264:	df 93       	push	r29
    3266:	fb 01       	movw	r30, r22
    3268:	23 81       	ldd	r18, Z+3	; 0x03
    326a:	21 fd       	sbrc	r18, 1
    326c:	03 c0       	rjmp	.+6      	; 0x3274 <fputc+0x16>
    326e:	8f ef       	ldi	r24, 0xFF	; 255
    3270:	9f ef       	ldi	r25, 0xFF	; 255
    3272:	2c c0       	rjmp	.+88     	; 0x32cc <fputc+0x6e>
    3274:	22 ff       	sbrs	r18, 2
    3276:	16 c0       	rjmp	.+44     	; 0x32a4 <fputc+0x46>
    3278:	46 81       	ldd	r20, Z+6	; 0x06
    327a:	57 81       	ldd	r21, Z+7	; 0x07
    327c:	24 81       	ldd	r18, Z+4	; 0x04
    327e:	35 81       	ldd	r19, Z+5	; 0x05
    3280:	42 17       	cp	r20, r18
    3282:	53 07       	cpc	r21, r19
    3284:	44 f4       	brge	.+16     	; 0x3296 <fputc+0x38>
    3286:	a0 81       	ld	r26, Z
    3288:	b1 81       	ldd	r27, Z+1	; 0x01
    328a:	9d 01       	movw	r18, r26
    328c:	2f 5f       	subi	r18, 0xFF	; 255
    328e:	3f 4f       	sbci	r19, 0xFF	; 255
    3290:	31 83       	std	Z+1, r19	; 0x01
    3292:	20 83       	st	Z, r18
    3294:	8c 93       	st	X, r24
    3296:	26 81       	ldd	r18, Z+6	; 0x06
    3298:	37 81       	ldd	r19, Z+7	; 0x07
    329a:	2f 5f       	subi	r18, 0xFF	; 255
    329c:	3f 4f       	sbci	r19, 0xFF	; 255
    329e:	37 83       	std	Z+7, r19	; 0x07
    32a0:	26 83       	std	Z+6, r18	; 0x06
    32a2:	14 c0       	rjmp	.+40     	; 0x32cc <fputc+0x6e>
    32a4:	8b 01       	movw	r16, r22
    32a6:	ec 01       	movw	r28, r24
    32a8:	fb 01       	movw	r30, r22
    32aa:	00 84       	ldd	r0, Z+8	; 0x08
    32ac:	f1 85       	ldd	r31, Z+9	; 0x09
    32ae:	e0 2d       	mov	r30, r0
    32b0:	09 95       	icall
    32b2:	89 2b       	or	r24, r25
    32b4:	e1 f6       	brne	.-72     	; 0x326e <fputc+0x10>
    32b6:	d8 01       	movw	r26, r16
    32b8:	16 96       	adiw	r26, 0x06	; 6
    32ba:	8d 91       	ld	r24, X+
    32bc:	9c 91       	ld	r25, X
    32be:	17 97       	sbiw	r26, 0x07	; 7
    32c0:	01 96       	adiw	r24, 0x01	; 1
    32c2:	17 96       	adiw	r26, 0x07	; 7
    32c4:	9c 93       	st	X, r25
    32c6:	8e 93       	st	-X, r24
    32c8:	16 97       	sbiw	r26, 0x06	; 6
    32ca:	ce 01       	movw	r24, r28
    32cc:	df 91       	pop	r29
    32ce:	cf 91       	pop	r28
    32d0:	1f 91       	pop	r17
    32d2:	0f 91       	pop	r16
    32d4:	08 95       	ret

000032d6 <__ultoa_invert>:
    32d6:	fa 01       	movw	r30, r20
    32d8:	aa 27       	eor	r26, r26
    32da:	28 30       	cpi	r18, 0x08	; 8
    32dc:	51 f1       	breq	.+84     	; 0x3332 <__ultoa_invert+0x5c>
    32de:	20 31       	cpi	r18, 0x10	; 16
    32e0:	81 f1       	breq	.+96     	; 0x3342 <__ultoa_invert+0x6c>
    32e2:	e8 94       	clt
    32e4:	6f 93       	push	r22
    32e6:	6e 7f       	andi	r22, 0xFE	; 254
    32e8:	6e 5f       	subi	r22, 0xFE	; 254
    32ea:	7f 4f       	sbci	r23, 0xFF	; 255
    32ec:	8f 4f       	sbci	r24, 0xFF	; 255
    32ee:	9f 4f       	sbci	r25, 0xFF	; 255
    32f0:	af 4f       	sbci	r26, 0xFF	; 255
    32f2:	b1 e0       	ldi	r27, 0x01	; 1
    32f4:	3e d0       	rcall	.+124    	; 0x3372 <__ultoa_invert+0x9c>
    32f6:	b4 e0       	ldi	r27, 0x04	; 4
    32f8:	3c d0       	rcall	.+120    	; 0x3372 <__ultoa_invert+0x9c>
    32fa:	67 0f       	add	r22, r23
    32fc:	78 1f       	adc	r23, r24
    32fe:	89 1f       	adc	r24, r25
    3300:	9a 1f       	adc	r25, r26
    3302:	a1 1d       	adc	r26, r1
    3304:	68 0f       	add	r22, r24
    3306:	79 1f       	adc	r23, r25
    3308:	8a 1f       	adc	r24, r26
    330a:	91 1d       	adc	r25, r1
    330c:	a1 1d       	adc	r26, r1
    330e:	6a 0f       	add	r22, r26
    3310:	71 1d       	adc	r23, r1
    3312:	81 1d       	adc	r24, r1
    3314:	91 1d       	adc	r25, r1
    3316:	a1 1d       	adc	r26, r1
    3318:	20 d0       	rcall	.+64     	; 0x335a <__ultoa_invert+0x84>
    331a:	09 f4       	brne	.+2      	; 0x331e <__ultoa_invert+0x48>
    331c:	68 94       	set
    331e:	3f 91       	pop	r19
    3320:	2a e0       	ldi	r18, 0x0A	; 10
    3322:	26 9f       	mul	r18, r22
    3324:	11 24       	eor	r1, r1
    3326:	30 19       	sub	r19, r0
    3328:	30 5d       	subi	r19, 0xD0	; 208
    332a:	31 93       	st	Z+, r19
    332c:	de f6       	brtc	.-74     	; 0x32e4 <__ultoa_invert+0xe>
    332e:	cf 01       	movw	r24, r30
    3330:	08 95       	ret
    3332:	46 2f       	mov	r20, r22
    3334:	47 70       	andi	r20, 0x07	; 7
    3336:	40 5d       	subi	r20, 0xD0	; 208
    3338:	41 93       	st	Z+, r20
    333a:	b3 e0       	ldi	r27, 0x03	; 3
    333c:	0f d0       	rcall	.+30     	; 0x335c <__ultoa_invert+0x86>
    333e:	c9 f7       	brne	.-14     	; 0x3332 <__ultoa_invert+0x5c>
    3340:	f6 cf       	rjmp	.-20     	; 0x332e <__ultoa_invert+0x58>
    3342:	46 2f       	mov	r20, r22
    3344:	4f 70       	andi	r20, 0x0F	; 15
    3346:	40 5d       	subi	r20, 0xD0	; 208
    3348:	4a 33       	cpi	r20, 0x3A	; 58
    334a:	18 f0       	brcs	.+6      	; 0x3352 <__ultoa_invert+0x7c>
    334c:	49 5d       	subi	r20, 0xD9	; 217
    334e:	31 fd       	sbrc	r19, 1
    3350:	40 52       	subi	r20, 0x20	; 32
    3352:	41 93       	st	Z+, r20
    3354:	02 d0       	rcall	.+4      	; 0x335a <__ultoa_invert+0x84>
    3356:	a9 f7       	brne	.-22     	; 0x3342 <__ultoa_invert+0x6c>
    3358:	ea cf       	rjmp	.-44     	; 0x332e <__ultoa_invert+0x58>
    335a:	b4 e0       	ldi	r27, 0x04	; 4
    335c:	a6 95       	lsr	r26
    335e:	97 95       	ror	r25
    3360:	87 95       	ror	r24
    3362:	77 95       	ror	r23
    3364:	67 95       	ror	r22
    3366:	ba 95       	dec	r27
    3368:	c9 f7       	brne	.-14     	; 0x335c <__ultoa_invert+0x86>
    336a:	00 97       	sbiw	r24, 0x00	; 0
    336c:	61 05       	cpc	r22, r1
    336e:	71 05       	cpc	r23, r1
    3370:	08 95       	ret
    3372:	9b 01       	movw	r18, r22
    3374:	ac 01       	movw	r20, r24
    3376:	0a 2e       	mov	r0, r26
    3378:	06 94       	lsr	r0
    337a:	57 95       	ror	r21
    337c:	47 95       	ror	r20
    337e:	37 95       	ror	r19
    3380:	27 95       	ror	r18
    3382:	ba 95       	dec	r27
    3384:	c9 f7       	brne	.-14     	; 0x3378 <__ultoa_invert+0xa2>
    3386:	62 0f       	add	r22, r18
    3388:	73 1f       	adc	r23, r19
    338a:	84 1f       	adc	r24, r20
    338c:	95 1f       	adc	r25, r21
    338e:	a0 1d       	adc	r26, r0
    3390:	08 95       	ret

00003392 <__prologue_saves__>:
    3392:	2f 92       	push	r2
    3394:	3f 92       	push	r3
    3396:	4f 92       	push	r4
    3398:	5f 92       	push	r5
    339a:	6f 92       	push	r6
    339c:	7f 92       	push	r7
    339e:	8f 92       	push	r8
    33a0:	9f 92       	push	r9
    33a2:	af 92       	push	r10
    33a4:	bf 92       	push	r11
    33a6:	cf 92       	push	r12
    33a8:	df 92       	push	r13
    33aa:	ef 92       	push	r14
    33ac:	ff 92       	push	r15
    33ae:	0f 93       	push	r16
    33b0:	1f 93       	push	r17
    33b2:	cf 93       	push	r28
    33b4:	df 93       	push	r29
    33b6:	cd b7       	in	r28, 0x3d	; 61
    33b8:	de b7       	in	r29, 0x3e	; 62
    33ba:	ca 1b       	sub	r28, r26
    33bc:	db 0b       	sbc	r29, r27
    33be:	0f b6       	in	r0, 0x3f	; 63
    33c0:	f8 94       	cli
    33c2:	de bf       	out	0x3e, r29	; 62
    33c4:	0f be       	out	0x3f, r0	; 63
    33c6:	cd bf       	out	0x3d, r28	; 61
    33c8:	09 94       	ijmp

000033ca <__epilogue_restores__>:
    33ca:	2a 88       	ldd	r2, Y+18	; 0x12
    33cc:	39 88       	ldd	r3, Y+17	; 0x11
    33ce:	48 88       	ldd	r4, Y+16	; 0x10
    33d0:	5f 84       	ldd	r5, Y+15	; 0x0f
    33d2:	6e 84       	ldd	r6, Y+14	; 0x0e
    33d4:	7d 84       	ldd	r7, Y+13	; 0x0d
    33d6:	8c 84       	ldd	r8, Y+12	; 0x0c
    33d8:	9b 84       	ldd	r9, Y+11	; 0x0b
    33da:	aa 84       	ldd	r10, Y+10	; 0x0a
    33dc:	b9 84       	ldd	r11, Y+9	; 0x09
    33de:	c8 84       	ldd	r12, Y+8	; 0x08
    33e0:	df 80       	ldd	r13, Y+7	; 0x07
    33e2:	ee 80       	ldd	r14, Y+6	; 0x06
    33e4:	fd 80       	ldd	r15, Y+5	; 0x05
    33e6:	0c 81       	ldd	r16, Y+4	; 0x04
    33e8:	1b 81       	ldd	r17, Y+3	; 0x03
    33ea:	aa 81       	ldd	r26, Y+2	; 0x02
    33ec:	b9 81       	ldd	r27, Y+1	; 0x01
    33ee:	ce 0f       	add	r28, r30
    33f0:	d1 1d       	adc	r29, r1
    33f2:	0f b6       	in	r0, 0x3f	; 63
    33f4:	f8 94       	cli
    33f6:	de bf       	out	0x3e, r29	; 62
    33f8:	0f be       	out	0x3f, r0	; 63
    33fa:	cd bf       	out	0x3d, r28	; 61
    33fc:	ed 01       	movw	r28, r26
    33fe:	08 95       	ret

00003400 <_exit>:
    3400:	f8 94       	cli

00003402 <__stop_program>:
    3402:	ff cf       	rjmp	.-2      	; 0x3402 <__stop_program>
