
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002a6  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000002fa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  000002fa  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000032c  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 000000d8  00000000  00000000  00000368  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000ed8  00000000  00000000  00000440  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000007f0  00000000  00000000  00001318  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000007db  00000000  00000000  00001b08  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001ec  00000000  00000000  000022e4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000063a  00000000  00000000  000024d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000751  00000000  00000000  00002b0a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000098  00000000  00000000  0000325b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__ctors_end>
   4:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
   8:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
   c:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  10:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  14:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  18:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  1c:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  20:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  24:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  28:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  2c:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  30:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  34:	0c 94 41 01 	jmp	0x282	; 0x282 <__vector_13>
  38:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  3c:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  40:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  44:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  48:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  4c:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  50:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
  54:	f8 00       	.word	0x00f8	; ????
  56:	0c 01       	movw	r0, r24
  58:	0c 01       	movw	r0, r24
  5a:	0c 01       	movw	r0, r24
  5c:	0c 01       	movw	r0, r24
  5e:	0c 01       	movw	r0, r24
  60:	0c 01       	movw	r0, r24
  62:	0c 01       	movw	r0, r24
  64:	0e 01       	movw	r0, r28
  66:	0c 01       	movw	r0, r24
  68:	0c 01       	movw	r0, r24
  6a:	0c 01       	movw	r0, r24
  6c:	0c 01       	movw	r0, r24
  6e:	0c 01       	movw	r0, r24
  70:	0c 01       	movw	r0, r24
  72:	0c 01       	movw	r0, r24
  74:	fa 00       	.word	0x00fa	; ????
  76:	0c 01       	movw	r0, r24
  78:	0c 01       	movw	r0, r24
  7a:	0c 01       	movw	r0, r24
  7c:	0c 01       	movw	r0, r24
  7e:	0c 01       	movw	r0, r24
  80:	0c 01       	movw	r0, r24
  82:	0c 01       	movw	r0, r24
  84:	fc 00       	.word	0x00fc	; ????
  86:	0c 01       	movw	r0, r24
  88:	0c 01       	movw	r0, r24
  8a:	0c 01       	movw	r0, r24
  8c:	0c 01       	movw	r0, r24
  8e:	0c 01       	movw	r0, r24
  90:	0c 01       	movw	r0, r24
  92:	0c 01       	movw	r0, r24
  94:	fe 00       	.word	0x00fe	; ????
  96:	0c 01       	movw	r0, r24
  98:	0c 01       	movw	r0, r24
  9a:	0c 01       	movw	r0, r24
  9c:	0c 01       	movw	r0, r24
  9e:	0c 01       	movw	r0, r24
  a0:	0c 01       	movw	r0, r24
  a2:	0c 01       	movw	r0, r24
  a4:	00 01       	movw	r0, r0
  a6:	0c 01       	movw	r0, r24
  a8:	0c 01       	movw	r0, r24
  aa:	0c 01       	movw	r0, r24
  ac:	0c 01       	movw	r0, r24
  ae:	0c 01       	movw	r0, r24
  b0:	0c 01       	movw	r0, r24
  b2:	0c 01       	movw	r0, r24
  b4:	02 01       	movw	r0, r4
  b6:	0c 01       	movw	r0, r24
  b8:	0c 01       	movw	r0, r24
  ba:	0c 01       	movw	r0, r24
  bc:	0c 01       	movw	r0, r24
  be:	0c 01       	movw	r0, r24
  c0:	0c 01       	movw	r0, r24
  c2:	0c 01       	movw	r0, r24
  c4:	04 01       	movw	r0, r8
  c6:	0c 01       	movw	r0, r24
  c8:	0c 01       	movw	r0, r24
  ca:	0c 01       	movw	r0, r24
  cc:	0c 01       	movw	r0, r24
  ce:	0c 01       	movw	r0, r24
  d0:	0c 01       	movw	r0, r24
  d2:	0c 01       	movw	r0, r24
  d4:	06 01       	movw	r0, r12
  d6:	0c 01       	movw	r0, r24
  d8:	0c 01       	movw	r0, r24
  da:	0c 01       	movw	r0, r24
  dc:	0c 01       	movw	r0, r24
  de:	0c 01       	movw	r0, r24
  e0:	0c 01       	movw	r0, r24
  e2:	0c 01       	movw	r0, r24
  e4:	08 01       	movw	r0, r16
  e6:	0c 01       	movw	r0, r24
  e8:	0c 01       	movw	r0, r24
  ea:	0c 01       	movw	r0, r24
  ec:	0c 01       	movw	r0, r24
  ee:	0c 01       	movw	r0, r24
  f0:	0c 01       	movw	r0, r24
  f2:	0c 01       	movw	r0, r24
  f4:	0a 01       	movw	r0, r20

000000f6 <__ctors_end>:
  f6:	11 24       	eor	r1, r1
  f8:	1f be       	out	0x3f, r1	; 63
  fa:	cf e5       	ldi	r28, 0x5F	; 95
  fc:	d8 e0       	ldi	r29, 0x08	; 8
  fe:	de bf       	out	0x3e, r29	; 62
 100:	cd bf       	out	0x3d, r28	; 61

00000102 <__do_copy_data>:
 102:	10 e0       	ldi	r17, 0x00	; 0
 104:	a0 e6       	ldi	r26, 0x60	; 96
 106:	b0 e0       	ldi	r27, 0x00	; 0
 108:	e6 ea       	ldi	r30, 0xA6	; 166
 10a:	f2 e0       	ldi	r31, 0x02	; 2
 10c:	02 c0       	rjmp	.+4      	; 0x112 <__do_copy_data+0x10>
 10e:	05 90       	lpm	r0, Z+
 110:	0d 92       	st	X+, r0
 112:	a0 36       	cpi	r26, 0x60	; 96
 114:	b1 07       	cpc	r27, r17
 116:	d9 f7       	brne	.-10     	; 0x10e <__do_copy_data+0xc>

00000118 <__do_clear_bss>:
 118:	20 e0       	ldi	r18, 0x00	; 0
 11a:	a0 e6       	ldi	r26, 0x60	; 96
 11c:	b0 e0       	ldi	r27, 0x00	; 0
 11e:	01 c0       	rjmp	.+2      	; 0x122 <.do_clear_bss_start>

00000120 <.do_clear_bss_loop>:
 120:	1d 92       	st	X+, r1

00000122 <.do_clear_bss_start>:
 122:	a0 36       	cpi	r26, 0x60	; 96
 124:	b2 07       	cpc	r27, r18
 126:	e1 f7       	brne	.-8      	; 0x120 <.do_clear_bss_loop>
 128:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <main>
 12c:	0c 94 51 01 	jmp	0x2a2	; 0x2a2 <_exit>

00000130 <__bad_interrupt>:
 130:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000134 <EEPROM_init>:
  I2C_write(0xA0 + (page << 1) + 1);
  // read_Ack will halt the reading here, because it will send the next byte, which will not be received and wait for ack, which will not be sent. 
  // Nack must be sent after the arrival of the last requested byte. It's used basically to indicate that no further data transmission is required and then the stop condition is sent
  I2C_read_Nack(data);
  I2C_stop();
  }
 134:	0e 94 10 01 	call	0x220	; 0x220 <I2C_init>
 138:	08 95       	ret

0000013a <EEPROM_read_block>:

void EEPROM_read_block(uint8_t page, uint8_t address, uint16_t bytes_number, char* data) {
 13a:	ef 92       	push	r14
 13c:	ff 92       	push	r15
 13e:	0f 93       	push	r16
 140:	1f 93       	push	r17
 142:	cf 93       	push	r28
 144:	df 93       	push	r29
 146:	c8 2f       	mov	r28, r24
 148:	d6 2f       	mov	r29, r22
 14a:	7a 01       	movw	r14, r20
 14c:	89 01       	movw	r16, r18
  uint16_t i;
  for (i = 0;i < bytes_number;i++) {
    EEPROM_read_byte(page, address + i, &data[i]);
    }
#elif READ_BLOCK_METHOD == MULTIBYTE
  I2C_start();
 14e:	0e 94 14 01 	call	0x228	; 0x228 <I2C_start>
  I2C_write(0xA0 + (page << 1));
 152:	cc 0f       	add	r28, r28
 154:	80 ea       	ldi	r24, 0xA0	; 160
 156:	8c 0f       	add	r24, r28
 158:	0e 94 1c 01 	call	0x238	; 0x238 <I2C_write>
  I2C_write(address);
 15c:	8d 2f       	mov	r24, r29
 15e:	0e 94 1c 01 	call	0x238	; 0x238 <I2C_write>
  I2C_start();
 162:	0e 94 14 01 	call	0x228	; 0x228 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
 166:	81 ea       	ldi	r24, 0xA1	; 161
 168:	8c 0f       	add	r24, r28
 16a:	0e 94 1c 01 	call	0x238	; 0x238 <I2C_write>
  uint16_t i;
  for (i = 0;i < bytes_number - 1;i++) {
 16e:	c0 e0       	ldi	r28, 0x00	; 0
 170:	d0 e0       	ldi	r29, 0x00	; 0
 172:	06 c0       	rjmp	.+12     	; 0x180 <EEPROM_read_block+0x46>
    I2C_read_Ack(&data[i]);
 174:	c8 01       	movw	r24, r16
 176:	8c 0f       	add	r24, r28
 178:	9d 1f       	adc	r25, r29
 17a:	0e 94 25 01 	call	0x24a	; 0x24a <I2C_read_Ack>
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  I2C_start();
  I2C_write(0xA0 + (page << 1) + 1);
  uint16_t i;
  for (i = 0;i < bytes_number - 1;i++) {
 17e:	21 96       	adiw	r28, 0x01	; 1
 180:	c7 01       	movw	r24, r14
 182:	01 97       	sbiw	r24, 0x01	; 1
 184:	c8 17       	cp	r28, r24
 186:	d9 07       	cpc	r29, r25
 188:	a8 f3       	brcs	.-22     	; 0x174 <EEPROM_read_block+0x3a>
    I2C_read_Ack(&data[i]);
    }
  I2C_read_Nack(&data[i]);
 18a:	c8 01       	movw	r24, r16
 18c:	8c 0f       	add	r24, r28
 18e:	9d 1f       	adc	r25, r29
 190:	0e 94 30 01 	call	0x260	; 0x260 <I2C_read_Nack>
  I2C_stop();
 194:	0e 94 3b 01 	call	0x276	; 0x276 <I2C_stop>
#endif
  }
 198:	df 91       	pop	r29
 19a:	cf 91       	pop	r28
 19c:	1f 91       	pop	r17
 19e:	0f 91       	pop	r16
 1a0:	ff 90       	pop	r15
 1a2:	ef 90       	pop	r14
 1a4:	08 95       	ret

000001a6 <main>:
#include "HAL/Servo/servo.h"
#include "MCAL/ADC/adc.h"
#include "MCAL/Timer/timer.h"
#include "Services/User/user.h"

int main(void) {
 1a6:	cf 93       	push	r28
 1a8:	df 93       	push	r29
 1aa:	cd b7       	in	r28, 0x3d	; 61
 1ac:	de b7       	in	r29, 0x3e	; 62
 1ae:	ca 5c       	subi	r28, 0xCA	; 202
 1b0:	d1 09       	sbc	r29, r1
 1b2:	0f b6       	in	r0, 0x3f	; 63
 1b4:	f8 94       	cli
 1b6:	de bf       	out	0x3e, r29	; 62
 1b8:	0f be       	out	0x3f, r0	; 63
 1ba:	cd bf       	out	0x3d, r28	; 61
	EEPROM_init();
 1bc:	0e 94 9a 00 	call	0x134	; 0x134 <EEPROM_init>
	char x[202];
	EEPROM_read_block(0, 0, 200, x);
 1c0:	9e 01       	movw	r18, r28
 1c2:	2f 5f       	subi	r18, 0xFF	; 255
 1c4:	3f 4f       	sbci	r19, 0xFF	; 255
 1c6:	48 ec       	ldi	r20, 0xC8	; 200
 1c8:	50 e0       	ldi	r21, 0x00	; 0
 1ca:	60 e0       	ldi	r22, 0x00	; 0
 1cc:	80 e0       	ldi	r24, 0x00	; 0
 1ce:	0e 94 9d 00 	call	0x13a	; 0x13a <EEPROM_read_block>
 1d2:	ff cf       	rjmp	.-2      	; 0x1d2 <main+0x2c>

000001d4 <getCurrentStatus>:

EN_I2CMasterStatusCode_t I2C_repeatedStart() {   // Same as start, just a different name
  TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  while (read_bit(TWCR, TWINT) == 0);
  return getCurrentStatus();
  }
 1d4:	81 b1       	in	r24, 0x01	; 1
 1d6:	e8 2f       	mov	r30, r24
 1d8:	e8 7f       	andi	r30, 0xF8	; 248
 1da:	8e 2f       	mov	r24, r30
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	fc 01       	movw	r30, r24
 1e0:	38 97       	sbiw	r30, 0x08	; 8
 1e2:	e1 35       	cpi	r30, 0x51	; 81
 1e4:	f1 05       	cpc	r31, r1
 1e6:	c0 f4       	brcc	.+48     	; 0x218 <getCurrentStatus+0x44>
 1e8:	e6 5d       	subi	r30, 0xD6	; 214
 1ea:	ff 4f       	sbci	r31, 0xFF	; 255
 1ec:	0c 94 4b 01 	jmp	0x296	; 0x296 <__tablejump2__>
 1f0:	80 e0       	ldi	r24, 0x00	; 0
 1f2:	08 95       	ret
 1f4:	82 e0       	ldi	r24, 0x02	; 2
 1f6:	08 95       	ret
 1f8:	83 e0       	ldi	r24, 0x03	; 3
 1fa:	08 95       	ret
 1fc:	84 e0       	ldi	r24, 0x04	; 4
 1fe:	08 95       	ret
 200:	85 e0       	ldi	r24, 0x05	; 5
 202:	08 95       	ret
 204:	86 e0       	ldi	r24, 0x06	; 6
 206:	08 95       	ret
 208:	87 e0       	ldi	r24, 0x07	; 7
 20a:	08 95       	ret
 20c:	88 e0       	ldi	r24, 0x08	; 8
 20e:	08 95       	ret
 210:	89 e0       	ldi	r24, 0x09	; 9
 212:	08 95       	ret
 214:	8a e0       	ldi	r24, 0x0A	; 10
 216:	08 95       	ret
 218:	8b e0       	ldi	r24, 0x0B	; 11
 21a:	08 95       	ret
 21c:	81 e0       	ldi	r24, 0x01	; 1
 21e:	08 95       	ret

00000220 <I2C_init>:
 220:	11 b8       	out	0x01, r1	; 1
 222:	8f ef       	ldi	r24, 0xFF	; 255
 224:	80 b9       	out	0x00, r24	; 0
 226:	08 95       	ret

00000228 <I2C_start>:
 228:	84 ea       	ldi	r24, 0xA4	; 164
 22a:	86 bf       	out	0x36, r24	; 54
 22c:	06 b6       	in	r0, 0x36	; 54
 22e:	07 fe       	sbrs	r0, 7
 230:	fd cf       	rjmp	.-6      	; 0x22c <I2C_start+0x4>
 232:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <getCurrentStatus>
 236:	08 95       	ret

00000238 <I2C_write>:

EN_I2CMasterStatusCode_t I2C_write(uint8_t data) {
  TWDR = data;
 238:	83 b9       	out	0x03, r24	; 3
  TWCR = (1 << TWEN) | (1 << TWINT);
 23a:	84 e8       	ldi	r24, 0x84	; 132
 23c:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWINT) == 0);
 23e:	06 b6       	in	r0, 0x36	; 54
 240:	07 fe       	sbrs	r0, 7
 242:	fd cf       	rjmp	.-6      	; 0x23e <I2C_write+0x6>
  return getCurrentStatus();
 244:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <getCurrentStatus>
  }
 248:	08 95       	ret

0000024a <I2C_read_Ack>:

EN_I2CMasterStatusCode_t I2C_read_Ack(uint8_t* data) {
  TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWINT);
 24a:	24 ec       	ldi	r18, 0xC4	; 196
 24c:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
 24e:	06 b6       	in	r0, 0x36	; 54
 250:	07 fe       	sbrs	r0, 7
 252:	fd cf       	rjmp	.-6      	; 0x24e <I2C_read_Ack+0x4>
  *data = TWDR;
 254:	23 b1       	in	r18, 0x03	; 3
 256:	fc 01       	movw	r30, r24
 258:	20 83       	st	Z, r18
  return getCurrentStatus();
 25a:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <getCurrentStatus>
  }
 25e:	08 95       	ret

00000260 <I2C_read_Nack>:

EN_I2CMasterStatusCode_t I2C_read_Nack(uint8_t* data) {
  TWCR = (1 << TWEN) | (1 << TWINT);
 260:	24 e8       	ldi	r18, 0x84	; 132
 262:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
 264:	06 b6       	in	r0, 0x36	; 54
 266:	07 fe       	sbrs	r0, 7
 268:	fd cf       	rjmp	.-6      	; 0x264 <I2C_read_Nack+0x4>
  *data = TWDR;
 26a:	23 b1       	in	r18, 0x03	; 3
 26c:	fc 01       	movw	r30, r24
 26e:	20 83       	st	Z, r18
  return getCurrentStatus();
 270:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <getCurrentStatus>
  }
 274:	08 95       	ret

00000276 <I2C_stop>:

void I2C_stop(void) {
  TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
 276:	84 e9       	ldi	r24, 0x94	; 148
 278:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWSTO));	// Wait until stop condition finishes
 27a:	06 b6       	in	r0, 0x36	; 54
 27c:	04 fc       	sbrc	r0, 4
 27e:	fd cf       	rjmp	.-6      	; 0x27a <I2C_stop+0x4>
  }
 280:	08 95       	ret

00000282 <__vector_13>:
 *  Author: hesha
 */

#include "remote.h"

ISR(USART_RXC_vect) {
 282:	1f 92       	push	r1
 284:	0f 92       	push	r0
 286:	0f b6       	in	r0, 0x3f	; 63
 288:	0f 92       	push	r0
 28a:	11 24       	eor	r1, r1
  
 28c:	0f 90       	pop	r0
 28e:	0f be       	out	0x3f, r0	; 63
 290:	0f 90       	pop	r0
 292:	1f 90       	pop	r1
 294:	18 95       	reti

00000296 <__tablejump2__>:
 296:	ee 0f       	add	r30, r30
 298:	ff 1f       	adc	r31, r31
 29a:	05 90       	lpm	r0, Z+
 29c:	f4 91       	lpm	r31, Z
 29e:	e0 2d       	mov	r30, r0
 2a0:	09 94       	ijmp

000002a2 <_exit>:
 2a2:	f8 94       	cli

000002a4 <__stop_program>:
 2a4:	ff cf       	rjmp	.-2      	; 0x2a4 <__stop_program>
