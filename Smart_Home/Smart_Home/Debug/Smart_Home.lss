
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000033bc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000718  00800060  000033bc  00003450  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000b7  00800778  00800778  00003b68  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003b68  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00003bc4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000590  00000000  00000000  00003c00  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006952  00000000  00000000  00004190  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001876  00000000  00000000  0000aae2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000040ab  00000000  00000000  0000c358  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000db4  00000000  00000000  00010404  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001438  00000000  00000000  000111b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003605  00000000  00000000  000125f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000460  00000000  00000000  00015bf5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__ctors_end>
       4:	0c 94 1c 12 	jmp	0x2438	; 0x2438 <__vector_1>
       8:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
       c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      10:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      14:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      18:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      1c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      20:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      24:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      28:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      2c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      30:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      34:	0c 94 a5 11 	jmp	0x234a	; 0x234a <__vector_13>
      38:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      3c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      40:	0c 94 40 12 	jmp	0x2480	; 0x2480 <__vector_16>
      44:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      48:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      4c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      50:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
      54:	2c 06       	cpc	r2, r28
      56:	40 06       	cpc	r4, r16
      58:	40 06       	cpc	r4, r16
      5a:	40 06       	cpc	r4, r16
      5c:	40 06       	cpc	r4, r16
      5e:	40 06       	cpc	r4, r16
      60:	40 06       	cpc	r4, r16
      62:	40 06       	cpc	r4, r16
      64:	42 06       	cpc	r4, r18
      66:	40 06       	cpc	r4, r16
      68:	40 06       	cpc	r4, r16
      6a:	40 06       	cpc	r4, r16
      6c:	40 06       	cpc	r4, r16
      6e:	40 06       	cpc	r4, r16
      70:	40 06       	cpc	r4, r16
      72:	40 06       	cpc	r4, r16
      74:	2e 06       	cpc	r2, r30
      76:	40 06       	cpc	r4, r16
      78:	40 06       	cpc	r4, r16
      7a:	40 06       	cpc	r4, r16
      7c:	40 06       	cpc	r4, r16
      7e:	40 06       	cpc	r4, r16
      80:	40 06       	cpc	r4, r16
      82:	40 06       	cpc	r4, r16
      84:	30 06       	cpc	r3, r16
      86:	40 06       	cpc	r4, r16
      88:	40 06       	cpc	r4, r16
      8a:	40 06       	cpc	r4, r16
      8c:	40 06       	cpc	r4, r16
      8e:	40 06       	cpc	r4, r16
      90:	40 06       	cpc	r4, r16
      92:	40 06       	cpc	r4, r16
      94:	32 06       	cpc	r3, r18
      96:	40 06       	cpc	r4, r16
      98:	40 06       	cpc	r4, r16
      9a:	40 06       	cpc	r4, r16
      9c:	40 06       	cpc	r4, r16
      9e:	40 06       	cpc	r4, r16
      a0:	40 06       	cpc	r4, r16
      a2:	40 06       	cpc	r4, r16
      a4:	34 06       	cpc	r3, r20
      a6:	40 06       	cpc	r4, r16
      a8:	40 06       	cpc	r4, r16
      aa:	40 06       	cpc	r4, r16
      ac:	40 06       	cpc	r4, r16
      ae:	40 06       	cpc	r4, r16
      b0:	40 06       	cpc	r4, r16
      b2:	40 06       	cpc	r4, r16
      b4:	36 06       	cpc	r3, r22
      b6:	40 06       	cpc	r4, r16
      b8:	40 06       	cpc	r4, r16
      ba:	40 06       	cpc	r4, r16
      bc:	40 06       	cpc	r4, r16
      be:	40 06       	cpc	r4, r16
      c0:	40 06       	cpc	r4, r16
      c2:	40 06       	cpc	r4, r16
      c4:	38 06       	cpc	r3, r24
      c6:	40 06       	cpc	r4, r16
      c8:	40 06       	cpc	r4, r16
      ca:	40 06       	cpc	r4, r16
      cc:	40 06       	cpc	r4, r16
      ce:	40 06       	cpc	r4, r16
      d0:	40 06       	cpc	r4, r16
      d2:	40 06       	cpc	r4, r16
      d4:	3a 06       	cpc	r3, r26
      d6:	40 06       	cpc	r4, r16
      d8:	40 06       	cpc	r4, r16
      da:	40 06       	cpc	r4, r16
      dc:	40 06       	cpc	r4, r16
      de:	40 06       	cpc	r4, r16
      e0:	40 06       	cpc	r4, r16
      e2:	40 06       	cpc	r4, r16
      e4:	3c 06       	cpc	r3, r28
      e6:	40 06       	cpc	r4, r16
      e8:	40 06       	cpc	r4, r16
      ea:	40 06       	cpc	r4, r16
      ec:	40 06       	cpc	r4, r16
      ee:	40 06       	cpc	r4, r16
      f0:	40 06       	cpc	r4, r16
      f2:	40 06       	cpc	r4, r16
      f4:	3e 06       	cpc	r3, r30
      f6:	6f 0a       	sbc	r6, r31
      f8:	76 0a       	sbc	r7, r22
      fa:	7d 0a       	sbc	r7, r29
      fc:	84 0a       	sbc	r8, r20
      fe:	8b 0a       	sbc	r8, r27
     100:	92 0a       	sbc	r9, r18
     102:	99 0a       	sbc	r9, r25
     104:	a0 0a       	sbc	r10, r16
     106:	a7 0a       	sbc	r10, r23
     108:	ae 0a       	sbc	r10, r30

0000010a <__ctors_end>:
     10a:	11 24       	eor	r1, r1
     10c:	1f be       	out	0x3f, r1	; 63
     10e:	cf e5       	ldi	r28, 0x5F	; 95
     110:	d8 e0       	ldi	r29, 0x08	; 8
     112:	de bf       	out	0x3e, r29	; 62
     114:	cd bf       	out	0x3d, r28	; 61

00000116 <__do_copy_data>:
     116:	17 e0       	ldi	r17, 0x07	; 7
     118:	a0 e6       	ldi	r26, 0x60	; 96
     11a:	b0 e0       	ldi	r27, 0x00	; 0
     11c:	ec eb       	ldi	r30, 0xBC	; 188
     11e:	f3 e3       	ldi	r31, 0x33	; 51
     120:	02 c0       	rjmp	.+4      	; 0x126 <__do_copy_data+0x10>
     122:	05 90       	lpm	r0, Z+
     124:	0d 92       	st	X+, r0
     126:	a8 37       	cpi	r26, 0x78	; 120
     128:	b1 07       	cpc	r27, r17
     12a:	d9 f7       	brne	.-10     	; 0x122 <__do_copy_data+0xc>

0000012c <__do_clear_bss>:
     12c:	28 e0       	ldi	r18, 0x08	; 8
     12e:	a8 e7       	ldi	r26, 0x78	; 120
     130:	b7 e0       	ldi	r27, 0x07	; 7
     132:	01 c0       	rjmp	.+2      	; 0x136 <.do_clear_bss_start>

00000134 <.do_clear_bss_loop>:
     134:	1d 92       	st	X+, r1

00000136 <.do_clear_bss_start>:
     136:	af 32       	cpi	r26, 0x2F	; 47
     138:	b2 07       	cpc	r27, r18
     13a:	e1 f7       	brne	.-8      	; 0x134 <.do_clear_bss_loop>
     13c:	0e 94 19 04 	call	0x832	; 0x832 <main>
     140:	0c 94 dc 19 	jmp	0x33b8	; 0x33b8 <_exit>

00000144 <__bad_interrupt>:
     144:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000148 <Buzzer_on>:
  // Return error code to indicate that the buzzer initialization failed
  return BUZZER_ERROR_INIT;
  }

// Turn on the buzzer
EN_BuzzerError_t Buzzer_on(u8 buzzerPort, u8 buzzerPin) {
     148:	98 2f       	mov	r25, r24
     14a:	86 2f       	mov	r24, r22
  if (DIO_write(buzzerPin, buzzerPort, HIGH) == DIO_OK) {
     14c:	41 e0       	ldi	r20, 0x01	; 1
     14e:	69 2f       	mov	r22, r25
     150:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
     154:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that attempting to turn on the buzzer has failed
  return BUZZER_ERROR_ON;
     156:	82 e0       	ldi	r24, 0x02	; 2
  }
     158:	08 95       	ret

0000015a <EEPROM_init>:
 */

#include "eeprom.h"

void EEPROM_init() {
  I2C_init();
     15a:	0e 94 44 06 	call	0xc88	; 0xc88 <I2C_init>
     15e:	08 95       	ret

00000160 <EEPROM_read_byte>:
  }

void EEPROM_read_byte(u8 page, u8 address, s8* data) {
     160:	0f 93       	push	r16
     162:	1f 93       	push	r17
     164:	cf 93       	push	r28
     166:	df 93       	push	r29
     168:	c8 2f       	mov	r28, r24
     16a:	d6 2f       	mov	r29, r22
     16c:	8a 01       	movw	r16, r20
  I2C_start();
     16e:	0e 94 48 06 	call	0xc90	; 0xc90 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     172:	cc 0f       	add	r28, r28
     174:	80 ea       	ldi	r24, 0xA0	; 160
     176:	8c 0f       	add	r24, r28
     178:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  I2C_write(address);
     17c:	8d 2f       	mov	r24, r29
     17e:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  I2C_start();
     182:	0e 94 48 06 	call	0xc90	; 0xc90 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     186:	81 ea       	ldi	r24, 0xA1	; 161
     188:	8c 0f       	add	r24, r28
     18a:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  // read_Ack will halt the reading here, because it will send the next byte, which will not be received and wait for ack, which will not be sent. 
  // Nack must be sent after the arrival of the last requested byte. It's used basically to indicate that no further data transmission is required and then the stop condition is sent
  I2C_read_Nack(data);
     18e:	c8 01       	movw	r24, r16
     190:	0e 94 64 06 	call	0xcc8	; 0xcc8 <I2C_read_Nack>
  I2C_stop();
     194:	0e 94 6f 06 	call	0xcde	; 0xcde <I2C_stop>
  }
     198:	df 91       	pop	r29
     19a:	cf 91       	pop	r28
     19c:	1f 91       	pop	r17
     19e:	0f 91       	pop	r16
     1a0:	08 95       	ret

000001a2 <EEPROM_read_block>:

void EEPROM_read_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     1a2:	ef 92       	push	r14
     1a4:	ff 92       	push	r15
     1a6:	0f 93       	push	r16
     1a8:	1f 93       	push	r17
     1aa:	cf 93       	push	r28
     1ac:	df 93       	push	r29
     1ae:	c8 2f       	mov	r28, r24
     1b0:	d6 2f       	mov	r29, r22
     1b2:	7a 01       	movw	r14, r20
     1b4:	89 01       	movw	r16, r18
  u16 i;
  for (i = 0;i < bytes_number;i++) {
    EEPROM_read_byte(page, address + i, &data[i]);
    }
#elif READ_BLOCK_METHOD == MULTIBYTE
  I2C_start();
     1b6:	0e 94 48 06 	call	0xc90	; 0xc90 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     1ba:	cc 0f       	add	r28, r28
     1bc:	80 ea       	ldi	r24, 0xA0	; 160
     1be:	8c 0f       	add	r24, r28
     1c0:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  I2C_write(address);
     1c4:	8d 2f       	mov	r24, r29
     1c6:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  I2C_start();
     1ca:	0e 94 48 06 	call	0xc90	; 0xc90 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     1ce:	81 ea       	ldi	r24, 0xA1	; 161
     1d0:	8c 0f       	add	r24, r28
     1d2:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1d6:	c0 e0       	ldi	r28, 0x00	; 0
     1d8:	d0 e0       	ldi	r29, 0x00	; 0
     1da:	06 c0       	rjmp	.+12     	; 0x1e8 <EEPROM_read_block+0x46>
    I2C_read_Ack(&data[i]);
     1dc:	c8 01       	movw	r24, r16
     1de:	8c 0f       	add	r24, r28
     1e0:	9d 1f       	adc	r25, r29
     1e2:	0e 94 59 06 	call	0xcb2	; 0xcb2 <I2C_read_Ack>
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  I2C_start();
  I2C_write(0xA0 + (page << 1) + 1);
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1e6:	21 96       	adiw	r28, 0x01	; 1
     1e8:	c7 01       	movw	r24, r14
     1ea:	01 97       	sbiw	r24, 0x01	; 1
     1ec:	c8 17       	cp	r28, r24
     1ee:	d9 07       	cpc	r29, r25
     1f0:	a8 f3       	brcs	.-22     	; 0x1dc <EEPROM_read_block+0x3a>
    I2C_read_Ack(&data[i]);
    }
  I2C_read_Nack(&data[i]);
     1f2:	c8 01       	movw	r24, r16
     1f4:	8c 0f       	add	r24, r28
     1f6:	9d 1f       	adc	r25, r29
     1f8:	0e 94 64 06 	call	0xcc8	; 0xcc8 <I2C_read_Nack>
  I2C_stop();
     1fc:	0e 94 6f 06 	call	0xcde	; 0xcde <I2C_stop>
#endif
  }
     200:	df 91       	pop	r29
     202:	cf 91       	pop	r28
     204:	1f 91       	pop	r17
     206:	0f 91       	pop	r16
     208:	ff 90       	pop	r15
     20a:	ef 90       	pop	r14
     20c:	08 95       	ret

0000020e <EEPROM_write_byte>:

void EEPROM_write_byte(u8 page, u8 address, s8 data) {
     20e:	1f 93       	push	r17
     210:	cf 93       	push	r28
     212:	df 93       	push	r29
     214:	c8 2f       	mov	r28, r24
     216:	16 2f       	mov	r17, r22
     218:	d4 2f       	mov	r29, r20
  I2C_start();
     21a:	0e 94 48 06 	call	0xc90	; 0xc90 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     21e:	8c 2f       	mov	r24, r28
     220:	88 0f       	add	r24, r24
     222:	80 56       	subi	r24, 0x60	; 96
     224:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  I2C_write(address);
     228:	81 2f       	mov	r24, r17
     22a:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  I2C_write(data);
     22e:	8d 2f       	mov	r24, r29
     230:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  I2C_stop();
     234:	0e 94 6f 06 	call	0xcde	; 0xcde <I2C_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     238:	8f e3       	ldi	r24, 0x3F	; 63
     23a:	9c e9       	ldi	r25, 0x9C	; 156
     23c:	01 97       	sbiw	r24, 0x01	; 1
     23e:	f1 f7       	brne	.-4      	; 0x23c <EEPROM_write_byte+0x2e>
     240:	00 c0       	rjmp	.+0      	; 0x242 <EEPROM_write_byte+0x34>
     242:	00 00       	nop

#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
  }
     244:	df 91       	pop	r29
     246:	cf 91       	pop	r28
     248:	1f 91       	pop	r17
     24a:	08 95       	ret

0000024c <EEPROM_write_block>:

// bytes_number must be within page size (256 bytes)
void EEPROM_write_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     24c:	6f 92       	push	r6
     24e:	7f 92       	push	r7
     250:	8f 92       	push	r8
     252:	9f 92       	push	r9
     254:	af 92       	push	r10
     256:	bf 92       	push	r11
     258:	cf 92       	push	r12
     25a:	df 92       	push	r13
     25c:	ef 92       	push	r14
     25e:	ff 92       	push	r15
     260:	0f 93       	push	r16
     262:	1f 93       	push	r17
     264:	cf 93       	push	r28
     266:	df 93       	push	r29
     268:	78 2e       	mov	r7, r24
     26a:	66 2e       	mov	r6, r22
     26c:	6a 01       	movw	r12, r20
     26e:	89 01       	movw	r16, r18
  //! If data is required to be written in the first 16 bytes starting from byte 10 for example, the data will be stored starting from bytes 10, 
  //! and if the data exceeds the row limit ** IT WILL ROLL OVER AND OVERWRITE THE ROW **. Therefore, in a single multibyte write cycle, we can't write more than 16 bytes at maximum if starting from the first byte in the row
  //! or the remaining bytes till the end of the row from the starting position. The remaining bytes must be written in another write cycle to avoind the roll over problem.

  u16 dataIndex, blockNumber, i;
  u16 first_block_size = 16 - (address % 16);
     270:	86 2f       	mov	r24, r22
     272:	8f 70       	andi	r24, 0x0F	; 15
     274:	20 e1       	ldi	r18, 0x10	; 16
     276:	30 e0       	ldi	r19, 0x00	; 0
     278:	79 01       	movw	r14, r18
     27a:	e8 1a       	sub	r14, r24
     27c:	f1 08       	sbc	r15, r1
  if (16 - (address % 16) > bytes_number) first_block_size = bytes_number;
     27e:	4e 15       	cp	r20, r14
     280:	5f 05       	cpc	r21, r15
     282:	08 f4       	brcc	.+2      	; 0x286 <EEPROM_write_block+0x3a>
     284:	7a 01       	movw	r14, r20

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
     286:	0e 94 48 06 	call	0xc90	; 0xc90 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     28a:	87 2d       	mov	r24, r7
     28c:	88 0f       	add	r24, r24
     28e:	0f 2e       	mov	r0, r31
     290:	f0 ea       	ldi	r31, 0xA0	; 160
     292:	7f 2e       	mov	r7, r31
     294:	f0 2d       	mov	r31, r0
     296:	78 0e       	add	r7, r24
     298:	87 2d       	mov	r24, r7
     29a:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  I2C_write(address);
     29e:	86 2d       	mov	r24, r6
     2a0:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2a4:	c0 e0       	ldi	r28, 0x00	; 0
     2a6:	d0 e0       	ldi	r29, 0x00	; 0
     2a8:	07 c0       	rjmp	.+14     	; 0x2b8 <EEPROM_write_block+0x6c>
    I2C_write(data[dataIndex]);
     2aa:	f8 01       	movw	r30, r16
     2ac:	ec 0f       	add	r30, r28
     2ae:	fd 1f       	adc	r31, r29
     2b0:	80 81       	ld	r24, Z
     2b2:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2b6:	21 96       	adiw	r28, 0x01	; 1
     2b8:	ce 15       	cp	r28, r14
     2ba:	df 05       	cpc	r29, r15
     2bc:	b0 f3       	brcs	.-20     	; 0x2aa <EEPROM_write_block+0x5e>
    I2C_write(data[dataIndex]);
    }
  I2C_stop();
     2be:	0e 94 6f 06 	call	0xcde	; 0xcde <I2C_stop>
     2c2:	8f e3       	ldi	r24, 0x3F	; 63
     2c4:	9c e9       	ldi	r25, 0x9C	; 156
     2c6:	01 97       	sbiw	r24, 0x01	; 1
     2c8:	f1 f7       	brne	.-4      	; 0x2c6 <EEPROM_write_block+0x7a>
     2ca:	00 c0       	rjmp	.+0      	; 0x2cc <EEPROM_write_block+0x80>
     2cc:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif

  // Return if the data fits in the row (data fits in a single row or the remaining part of it after the address)
  if (first_block_size == bytes_number) return;
     2ce:	ec 14       	cp	r14, r12
     2d0:	fd 04       	cpc	r15, r13
     2d2:	09 f4       	brne	.+2      	; 0x2d6 <EEPROM_write_block+0x8a>
     2d4:	61 c0       	rjmp	.+194    	; 0x398 <EEPROM_write_block+0x14c>

  u16 last_block_size = (address + bytes_number) % 16;
     2d6:	56 01       	movw	r10, r12
     2d8:	a6 0c       	add	r10, r6
     2da:	b1 1c       	adc	r11, r1
     2dc:	9f e0       	ldi	r25, 0x0F	; 15
     2de:	a9 22       	and	r10, r25
     2e0:	bb 24       	eor	r11, r11
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
     2e2:	ce 18       	sub	r12, r14
     2e4:	df 08       	sbc	r13, r15
     2e6:	ca 18       	sub	r12, r10
     2e8:	db 08       	sbc	r13, r11
     2ea:	d6 94       	lsr	r13
     2ec:	c7 94       	ror	r12
     2ee:	d6 94       	lsr	r13
     2f0:	c7 94       	ror	r12
     2f2:	d6 94       	lsr	r13
     2f4:	c7 94       	ror	r12
     2f6:	d6 94       	lsr	r13
     2f8:	c7 94       	ror	r12
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     2fa:	e1 2c       	mov	r14, r1
     2fc:	f1 2c       	mov	r15, r1
     2fe:	27 c0       	rjmp	.+78     	; 0x34e <EEPROM_write_block+0x102>
    I2C_start();
     300:	0e 94 48 06 	call	0xc90	; 0xc90 <I2C_start>
    I2C_write(0xA0 + (page << 1));
     304:	87 2d       	mov	r24, r7
     306:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
    I2C_write(address + dataIndex);
     30a:	8c 2f       	mov	r24, r28
     30c:	86 0d       	add	r24, r6
     30e:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
    for (i = 0;i < 16;i++) {
     312:	81 2c       	mov	r8, r1
     314:	91 2c       	mov	r9, r1
     316:	0b c0       	rjmp	.+22     	; 0x32e <EEPROM_write_block+0xe2>
      I2C_write(data[dataIndex + i]);
     318:	fe 01       	movw	r30, r28
     31a:	e8 0d       	add	r30, r8
     31c:	f9 1d       	adc	r31, r9
     31e:	e0 0f       	add	r30, r16
     320:	f1 1f       	adc	r31, r17
     322:	80 81       	ld	r24, Z
     324:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
    I2C_start();
    I2C_write(0xA0 + (page << 1));
    I2C_write(address + dataIndex);
    for (i = 0;i < 16;i++) {
     328:	8f ef       	ldi	r24, 0xFF	; 255
     32a:	88 1a       	sub	r8, r24
     32c:	98 0a       	sbc	r9, r24
     32e:	90 e1       	ldi	r25, 0x10	; 16
     330:	89 16       	cp	r8, r25
     332:	91 04       	cpc	r9, r1
     334:	88 f3       	brcs	.-30     	; 0x318 <EEPROM_write_block+0xcc>
      I2C_write(data[dataIndex + i]);
      }
    dataIndex += 16;
     336:	60 96       	adiw	r28, 0x10	; 16
    I2C_stop();
     338:	0e 94 6f 06 	call	0xcde	; 0xcde <I2C_stop>
     33c:	8f e3       	ldi	r24, 0x3F	; 63
     33e:	9c e9       	ldi	r25, 0x9C	; 156
     340:	01 97       	sbiw	r24, 0x01	; 1
     342:	f1 f7       	brne	.-4      	; 0x340 <EEPROM_write_block+0xf4>
     344:	00 c0       	rjmp	.+0      	; 0x346 <EEPROM_write_block+0xfa>
     346:	00 00       	nop
  if (first_block_size == bytes_number) return;

  u16 last_block_size = (address + bytes_number) % 16;
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     348:	9f ef       	ldi	r25, 0xFF	; 255
     34a:	e9 1a       	sub	r14, r25
     34c:	f9 0a       	sbc	r15, r25
     34e:	ec 14       	cp	r14, r12
     350:	fd 04       	cpc	r15, r13
     352:	b0 f2       	brcs	.-84     	; 0x300 <EEPROM_write_block+0xb4>
    _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
    }

  // Write the last part of the data
  I2C_start();
     354:	0e 94 48 06 	call	0xc90	; 0xc90 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     358:	87 2d       	mov	r24, r7
     35a:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  I2C_write(address + dataIndex);
     35e:	8c 2f       	mov	r24, r28
     360:	86 0d       	add	r24, r6
     362:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>
  for (i = 0;i < last_block_size;i++) {
     366:	e1 2c       	mov	r14, r1
     368:	f1 2c       	mov	r15, r1
     36a:	0b c0       	rjmp	.+22     	; 0x382 <EEPROM_write_block+0x136>
    I2C_write(data[dataIndex + i]);
     36c:	fe 01       	movw	r30, r28
     36e:	ee 0d       	add	r30, r14
     370:	ff 1d       	adc	r31, r15
     372:	e0 0f       	add	r30, r16
     374:	f1 1f       	adc	r31, r17
     376:	80 81       	ld	r24, Z
     378:	0e 94 50 06 	call	0xca0	; 0xca0 <I2C_write>

  // Write the last part of the data
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address + dataIndex);
  for (i = 0;i < last_block_size;i++) {
     37c:	8f ef       	ldi	r24, 0xFF	; 255
     37e:	e8 1a       	sub	r14, r24
     380:	f8 0a       	sbc	r15, r24
     382:	ea 14       	cp	r14, r10
     384:	fb 04       	cpc	r15, r11
     386:	90 f3       	brcs	.-28     	; 0x36c <EEPROM_write_block+0x120>
    I2C_write(data[dataIndex + i]);
    }
  I2C_stop();
     388:	0e 94 6f 06 	call	0xcde	; 0xcde <I2C_stop>
     38c:	8f e3       	ldi	r24, 0x3F	; 63
     38e:	9c e9       	ldi	r25, 0x9C	; 156
     390:	01 97       	sbiw	r24, 0x01	; 1
     392:	f1 f7       	brne	.-4      	; 0x390 <EEPROM_write_block+0x144>
     394:	00 c0       	rjmp	.+0      	; 0x396 <EEPROM_write_block+0x14a>
     396:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
#endif
     398:	df 91       	pop	r29
     39a:	cf 91       	pop	r28
     39c:	1f 91       	pop	r17
     39e:	0f 91       	pop	r16
     3a0:	ff 90       	pop	r15
     3a2:	ef 90       	pop	r14
     3a4:	df 90       	pop	r13
     3a6:	cf 90       	pop	r12
     3a8:	bf 90       	pop	r11
     3aa:	af 90       	pop	r10
     3ac:	9f 90       	pop	r9
     3ae:	8f 90       	pop	r8
     3b0:	7f 90       	pop	r7
     3b2:	6f 90       	pop	r6
     3b4:	08 95       	ret

000003b6 <BT_sendChar>:
  DIO_init(HC_05_STATUS_PIN, HC_05_STATUS_PORT, IN);
  UART_init(baudRate);
  }

void BT_sendChar(s8 data) {
  UART_sendChar(data);
     3b6:	0e 94 58 09 	call	0x12b0	; 0x12b0 <UART_sendChar>
     3ba:	08 95       	ret

000003bc <BT_sendString>:
  }

void BT_sendString(s8* str) {
  UART_sendString(str);
     3bc:	0e 94 5e 09 	call	0x12bc	; 0x12bc <UART_sendString>
     3c0:	08 95       	ret

000003c2 <Keypad_init>:

#include "keypad.h"

EN_KeypadStatusCode_t Keypad_init(void) {
  // Set rows as outputs
  DIO_init(KEYPAD_R0_PIN, KEYPAD_PORT, OUT);
     3c2:	41 e0       	ldi	r20, 0x01	; 1
     3c4:	62 e4       	ldi	r22, 0x42	; 66
     3c6:	80 e0       	ldi	r24, 0x00	; 0
     3c8:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  DIO_init(KEYPAD_R1_PIN, KEYPAD_PORT, OUT);
     3cc:	41 e0       	ldi	r20, 0x01	; 1
     3ce:	62 e4       	ldi	r22, 0x42	; 66
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  DIO_init(KEYPAD_R2_PIN, KEYPAD_PORT, OUT);
     3d6:	41 e0       	ldi	r20, 0x01	; 1
     3d8:	62 e4       	ldi	r22, 0x42	; 66
     3da:	82 e0       	ldi	r24, 0x02	; 2
     3dc:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  DIO_init(KEYPAD_R3_PIN, KEYPAD_PORT, OUT);
     3e0:	41 e0       	ldi	r20, 0x01	; 1
     3e2:	62 e4       	ldi	r22, 0x42	; 66
     3e4:	83 e0       	ldi	r24, 0x03	; 3
     3e6:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  // Set all high
  DIO_write(KEYPAD_R0_PIN, KEYPAD_PORT, HIGH);
     3ea:	41 e0       	ldi	r20, 0x01	; 1
     3ec:	62 e4       	ldi	r22, 0x42	; 66
     3ee:	80 e0       	ldi	r24, 0x00	; 0
     3f0:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  DIO_write(KEYPAD_R1_PIN, KEYPAD_PORT, HIGH);
     3f4:	41 e0       	ldi	r20, 0x01	; 1
     3f6:	62 e4       	ldi	r22, 0x42	; 66
     3f8:	81 e0       	ldi	r24, 0x01	; 1
     3fa:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  DIO_write(KEYPAD_R2_PIN, KEYPAD_PORT, HIGH);
     3fe:	41 e0       	ldi	r20, 0x01	; 1
     400:	62 e4       	ldi	r22, 0x42	; 66
     402:	82 e0       	ldi	r24, 0x02	; 2
     404:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  DIO_write(KEYPAD_R3_PIN, KEYPAD_PORT, HIGH);
     408:	41 e0       	ldi	r20, 0x01	; 1
     40a:	62 e4       	ldi	r22, 0x42	; 66
     40c:	83 e0       	ldi	r24, 0x03	; 3
     40e:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  // Set columns as inputs
  DIO_init(KEYPAD_C0_PIN, KEYPAD_PORT, IN);
     412:	40 e0       	ldi	r20, 0x00	; 0
     414:	62 e4       	ldi	r22, 0x42	; 66
     416:	84 e0       	ldi	r24, 0x04	; 4
     418:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  DIO_init(KEYPAD_C1_PIN, KEYPAD_PORT, IN);
     41c:	40 e0       	ldi	r20, 0x00	; 0
     41e:	62 e4       	ldi	r22, 0x42	; 66
     420:	85 e0       	ldi	r24, 0x05	; 5
     422:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  DIO_init(KEYPAD_C2_PIN, KEYPAD_PORT, IN);
     426:	40 e0       	ldi	r20, 0x00	; 0
     428:	62 e4       	ldi	r22, 0x42	; 66
     42a:	86 e0       	ldi	r24, 0x06	; 6
     42c:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  DIO_init(KEYPAD_C3_PIN, KEYPAD_PORT, IN);
     430:	40 e0       	ldi	r20, 0x00	; 0
     432:	62 e4       	ldi	r22, 0x42	; 66
     434:	87 e0       	ldi	r24, 0x07	; 7
     436:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  // Activate the pull up resistors
  DIO_write(KEYPAD_C0_PIN, KEYPAD_PORT, HIGH);
     43a:	41 e0       	ldi	r20, 0x01	; 1
     43c:	62 e4       	ldi	r22, 0x42	; 66
     43e:	84 e0       	ldi	r24, 0x04	; 4
     440:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  DIO_write(KEYPAD_C1_PIN, KEYPAD_PORT, HIGH);
     444:	41 e0       	ldi	r20, 0x01	; 1
     446:	62 e4       	ldi	r22, 0x42	; 66
     448:	85 e0       	ldi	r24, 0x05	; 5
     44a:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  DIO_write(KEYPAD_C2_PIN, KEYPAD_PORT, HIGH);
     44e:	41 e0       	ldi	r20, 0x01	; 1
     450:	62 e4       	ldi	r22, 0x42	; 66
     452:	86 e0       	ldi	r24, 0x06	; 6
     454:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  DIO_write(KEYPAD_C3_PIN, KEYPAD_PORT, HIGH);
     458:	41 e0       	ldi	r20, 0x01	; 1
     45a:	62 e4       	ldi	r22, 0x42	; 66
     45c:	87 e0       	ldi	r24, 0x07	; 7
     45e:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>

  return KEYPAD_INIT_OK;
  }
     462:	80 e0       	ldi	r24, 0x00	; 0
     464:	08 95       	ret

00000466 <toggle_row>:

void toggle_row(u8 row) {
  switch (row) {
     466:	81 30       	cpi	r24, 0x01	; 1
     468:	59 f0       	breq	.+22     	; 0x480 <toggle_row+0x1a>
     46a:	28 f0       	brcs	.+10     	; 0x476 <toggle_row+0x10>
     46c:	82 30       	cpi	r24, 0x02	; 2
     46e:	69 f0       	breq	.+26     	; 0x48a <toggle_row+0x24>
     470:	83 30       	cpi	r24, 0x03	; 3
     472:	81 f0       	breq	.+32     	; 0x494 <toggle_row+0x2e>
     474:	08 95       	ret
      case 0:
        DIO_toggle(KEYPAD_R0_PIN, KEYPAD_PORT);
     476:	62 e4       	ldi	r22, 0x42	; 66
     478:	80 e0       	ldi	r24, 0x00	; 0
     47a:	0e 94 cd 05 	call	0xb9a	; 0xb9a <DIO_toggle>
        break;
     47e:	08 95       	ret
      case 1:
        DIO_toggle(KEYPAD_R1_PIN, KEYPAD_PORT);
     480:	62 e4       	ldi	r22, 0x42	; 66
     482:	81 e0       	ldi	r24, 0x01	; 1
     484:	0e 94 cd 05 	call	0xb9a	; 0xb9a <DIO_toggle>
        break;
     488:	08 95       	ret
      case 2:
        DIO_toggle(KEYPAD_R2_PIN, KEYPAD_PORT);
     48a:	62 e4       	ldi	r22, 0x42	; 66
     48c:	82 e0       	ldi	r24, 0x02	; 2
     48e:	0e 94 cd 05 	call	0xb9a	; 0xb9a <DIO_toggle>
        break;
     492:	08 95       	ret
      case 3:
        DIO_toggle(KEYPAD_R3_PIN, KEYPAD_PORT);
     494:	62 e4       	ldi	r22, 0x42	; 66
     496:	83 e0       	ldi	r24, 0x03	; 3
     498:	0e 94 cd 05 	call	0xb9a	; 0xb9a <DIO_toggle>
     49c:	08 95       	ret

0000049e <check_col>:
        break;
    }
  }

void check_col(u8 col, u8* res) {
  switch (col) {
     49e:	81 30       	cpi	r24, 0x01	; 1
     4a0:	61 f0       	breq	.+24     	; 0x4ba <check_col+0x1c>
     4a2:	28 f0       	brcs	.+10     	; 0x4ae <check_col+0x10>
     4a4:	82 30       	cpi	r24, 0x02	; 2
     4a6:	79 f0       	breq	.+30     	; 0x4c6 <check_col+0x28>
     4a8:	83 30       	cpi	r24, 0x03	; 3
     4aa:	99 f0       	breq	.+38     	; 0x4d2 <check_col+0x34>
     4ac:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_C0_PIN, KEYPAD_PORT, res);
     4ae:	ab 01       	movw	r20, r22
     4b0:	62 e4       	ldi	r22, 0x42	; 66
     4b2:	84 e0       	ldi	r24, 0x04	; 4
     4b4:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_Read>
        break;
     4b8:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_C1_PIN, KEYPAD_PORT, res);
     4ba:	ab 01       	movw	r20, r22
     4bc:	62 e4       	ldi	r22, 0x42	; 66
     4be:	85 e0       	ldi	r24, 0x05	; 5
     4c0:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_Read>
        break;
     4c4:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_C2_PIN, KEYPAD_PORT, res);
     4c6:	ab 01       	movw	r20, r22
     4c8:	62 e4       	ldi	r22, 0x42	; 66
     4ca:	86 e0       	ldi	r24, 0x06	; 6
     4cc:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_Read>
        break;
     4d0:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_C3_PIN, KEYPAD_PORT, res);
     4d2:	ab 01       	movw	r20, r22
     4d4:	62 e4       	ldi	r22, 0x42	; 66
     4d6:	87 e0       	ldi	r24, 0x07	; 7
     4d8:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_Read>
     4dc:	08 95       	ret

000004de <check_row>:
        break;
    }
  }

void check_row(u8 row, u8* res) {
  switch (row) {
     4de:	81 30       	cpi	r24, 0x01	; 1
     4e0:	61 f0       	breq	.+24     	; 0x4fa <check_row+0x1c>
     4e2:	28 f0       	brcs	.+10     	; 0x4ee <check_row+0x10>
     4e4:	82 30       	cpi	r24, 0x02	; 2
     4e6:	79 f0       	breq	.+30     	; 0x506 <check_row+0x28>
     4e8:	83 30       	cpi	r24, 0x03	; 3
     4ea:	99 f0       	breq	.+38     	; 0x512 <check_row+0x34>
     4ec:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_R0_PIN, KEYPAD_PORT, res);
     4ee:	ab 01       	movw	r20, r22
     4f0:	62 e4       	ldi	r22, 0x42	; 66
     4f2:	80 e0       	ldi	r24, 0x00	; 0
     4f4:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_Read>
        break;
     4f8:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_R1_PIN, KEYPAD_PORT, res);
     4fa:	ab 01       	movw	r20, r22
     4fc:	62 e4       	ldi	r22, 0x42	; 66
     4fe:	81 e0       	ldi	r24, 0x01	; 1
     500:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_Read>
        break;
     504:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_R2_PIN, KEYPAD_PORT, res);
     506:	ab 01       	movw	r20, r22
     508:	62 e4       	ldi	r22, 0x42	; 66
     50a:	82 e0       	ldi	r24, 0x02	; 2
     50c:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_Read>
        break;
     510:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_R3_PIN, KEYPAD_PORT, res);
     512:	ab 01       	movw	r20, r22
     514:	62 e4       	ldi	r22, 0x42	; 66
     516:	83 e0       	ldi	r24, 0x03	; 3
     518:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_Read>
     51c:	08 95       	ret

0000051e <Keypad_getPressedKey>:
        break;
    }
  }

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
     51e:	ef 92       	push	r14
     520:	ff 92       	push	r15
     522:	0f 93       	push	r16
     524:	1f 93       	push	r17
     526:	cf 93       	push	r28
     528:	df 93       	push	r29
     52a:	cd b7       	in	r28, 0x3d	; 61
     52c:	de b7       	in	r29, 0x3e	; 62
     52e:	62 97       	sbiw	r28, 0x12	; 18
     530:	0f b6       	in	r0, 0x3f	; 63
     532:	f8 94       	cli
     534:	de bf       	out	0x3e, r29	; 62
     536:	0f be       	out	0x3f, r0	; 63
     538:	cd bf       	out	0x3d, r28	; 61
     53a:	7c 01       	movw	r14, r24
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
     53c:	80 e1       	ldi	r24, 0x10	; 16
     53e:	e1 e6       	ldi	r30, 0x61	; 97
     540:	f0 e0       	ldi	r31, 0x00	; 0
     542:	de 01       	movw	r26, r28
     544:	11 96       	adiw	r26, 0x01	; 1
     546:	01 90       	ld	r0, Z+
     548:	0d 92       	st	X+, r0
     54a:	8a 95       	dec	r24
     54c:	e1 f7       	brne	.-8      	; 0x546 <Keypad_getPressedKey+0x28>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     54e:	00 e0       	ldi	r16, 0x00	; 0
     550:	1c c0       	rjmp	.+56     	; 0x58a <Keypad_getPressedKey+0x6c>
    check_row(row, &row_state);
     552:	be 01       	movw	r22, r28
     554:	6e 5e       	subi	r22, 0xEE	; 238
     556:	7f 4f       	sbci	r23, 0xFF	; 255
     558:	80 2f       	mov	r24, r16
     55a:	0e 94 6f 02 	call	0x4de	; 0x4de <check_row>
    if (row_state == LOW) {
     55e:	8a 89       	ldd	r24, Y+18	; 0x12
     560:	88 23       	and	r24, r24
     562:	61 f0       	breq	.+24     	; 0x57c <Keypad_getPressedKey+0x5e>
     564:	11 c0       	rjmp	.+34     	; 0x588 <Keypad_getPressedKey+0x6a>
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
     566:	be 01       	movw	r22, r28
     568:	6f 5e       	subi	r22, 0xEF	; 239
     56a:	7f 4f       	sbci	r23, 0xFF	; 255
     56c:	81 2f       	mov	r24, r17
     56e:	0e 94 4f 02 	call	0x49e	; 0x49e <check_col>
        if (col_state == LOW) {
     572:	89 89       	ldd	r24, Y+17	; 0x11
     574:	88 23       	and	r24, r24
     576:	c9 f1       	breq	.+114    	; 0x5ea <Keypad_getPressedKey+0xcc>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
     578:	1f 5f       	subi	r17, 0xFF	; 255
     57a:	01 c0       	rjmp	.+2      	; 0x57e <Keypad_getPressedKey+0x60>
     57c:	10 e0       	ldi	r17, 0x00	; 0
     57e:	14 30       	cpi	r17, 0x04	; 4
     580:	90 f3       	brcs	.-28     	; 0x566 <Keypad_getPressedKey+0x48>
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
          }
        }
      toggle_row(row);
     582:	80 2f       	mov	r24, r16
     584:	0e 94 33 02 	call	0x466	; 0x466 <toggle_row>

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     588:	0f 5f       	subi	r16, 0xFF	; 255
     58a:	04 30       	cpi	r16, 0x04	; 4
     58c:	10 f3       	brcs	.-60     	; 0x552 <Keypad_getPressedKey+0x34>
     58e:	00 e0       	ldi	r16, 0x00	; 0
     590:	28 c0       	rjmp	.+80     	; 0x5e2 <Keypad_getPressedKey+0xc4>
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
     592:	80 2f       	mov	r24, r16
     594:	0e 94 33 02 	call	0x466	; 0x466 <toggle_row>
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     598:	10 e0       	ldi	r17, 0x00	; 0
     59a:	1d c0       	rjmp	.+58     	; 0x5d6 <Keypad_getPressedKey+0xb8>
      check_col(col, &col_state);
     59c:	be 01       	movw	r22, r28
     59e:	6f 5e       	subi	r22, 0xEF	; 239
     5a0:	7f 4f       	sbci	r23, 0xFF	; 255
     5a2:	81 2f       	mov	r24, r17
     5a4:	0e 94 4f 02 	call	0x49e	; 0x49e <check_col>
      if (col_state == LOW) {
     5a8:	89 89       	ldd	r24, Y+17	; 0x11
     5aa:	81 11       	cpse	r24, r1
     5ac:	13 c0       	rjmp	.+38     	; 0x5d4 <Keypad_getPressedKey+0xb6>
        // while (col_state == LOW) {  // Wait until the key is released (busy waiting - halts the system)
        //   check_col(col, &col_state);
        //   }
        *key = keys[row][col];
     5ae:	e0 2f       	mov	r30, r16
     5b0:	f0 e0       	ldi	r31, 0x00	; 0
     5b2:	ee 0f       	add	r30, r30
     5b4:	ff 1f       	adc	r31, r31
     5b6:	ee 0f       	add	r30, r30
     5b8:	ff 1f       	adc	r31, r31
     5ba:	81 e0       	ldi	r24, 0x01	; 1
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	8c 0f       	add	r24, r28
     5c0:	9d 1f       	adc	r25, r29
     5c2:	e8 0f       	add	r30, r24
     5c4:	f9 1f       	adc	r31, r25
     5c6:	e1 0f       	add	r30, r17
     5c8:	f1 1d       	adc	r31, r1
     5ca:	80 81       	ld	r24, Z
     5cc:	f7 01       	movw	r30, r14
     5ce:	80 83       	st	Z, r24
        return KEY_PRESSED;
     5d0:	81 e0       	ldi	r24, 0x01	; 1
     5d2:	0c c0       	rjmp	.+24     	; 0x5ec <Keypad_getPressedKey+0xce>
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     5d4:	1f 5f       	subi	r17, 0xFF	; 255
     5d6:	14 30       	cpi	r17, 0x04	; 4
     5d8:	08 f3       	brcs	.-62     	; 0x59c <Keypad_getPressedKey+0x7e>
        //   }
        *key = keys[row][col];
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
     5da:	80 2f       	mov	r24, r16
     5dc:	0e 94 33 02 	call	0x466	; 0x466 <toggle_row>
          }
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
     5e0:	0f 5f       	subi	r16, 0xFF	; 255
     5e2:	04 30       	cpi	r16, 0x04	; 4
     5e4:	b0 f2       	brcs	.-84     	; 0x592 <Keypad_getPressedKey+0x74>
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     5e6:	82 e0       	ldi	r24, 0x02	; 2
     5e8:	01 c0       	rjmp	.+2      	; 0x5ec <Keypad_getPressedKey+0xce>
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
     5ea:	82 e0       	ldi	r24, 0x02	; 2
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     5ec:	62 96       	adiw	r28, 0x12	; 18
     5ee:	0f b6       	in	r0, 0x3f	; 63
     5f0:	f8 94       	cli
     5f2:	de bf       	out	0x3e, r29	; 62
     5f4:	0f be       	out	0x3f, r0	; 63
     5f6:	cd bf       	out	0x3d, r28	; 61
     5f8:	df 91       	pop	r29
     5fa:	cf 91       	pop	r28
     5fc:	1f 91       	pop	r17
     5fe:	0f 91       	pop	r16
     600:	ff 90       	pop	r15
     602:	ef 90       	pop	r14
     604:	08 95       	ret

00000606 <LCD_sendEnablePulse>:
#include "lcd.h"

 // TODO: implement the eight bit mode

void LCD_sendEnablePulse(void) {
  DIO_write(EN, LCD_CTRL_PORT, HIGH);
     606:	41 e0       	ldi	r20, 0x01	; 1
     608:	61 e4       	ldi	r22, 0x41	; 65
     60a:	86 e0       	ldi	r24, 0x06	; 6
     60c:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     610:	8a e1       	ldi	r24, 0x1A	; 26
     612:	8a 95       	dec	r24
     614:	f1 f7       	brne	.-4      	; 0x612 <LCD_sendEnablePulse+0xc>
     616:	00 c0       	rjmp	.+0      	; 0x618 <LCD_sendEnablePulse+0x12>
  _delay_us(5);
  DIO_write(EN, LCD_CTRL_PORT, LOW);
     618:	40 e0       	ldi	r20, 0x00	; 0
     61a:	61 e4       	ldi	r22, 0x41	; 65
     61c:	86 e0       	ldi	r24, 0x06	; 6
     61e:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
     622:	08 95       	ret

00000624 <LCD_write_4bits>:
  }

void LCD_write_4bits(u8 data) {
     624:	cf 93       	push	r28
     626:	c8 2f       	mov	r28, r24
  DIO_write(LCD_DATA_PIN4, LCD_DATA_PORT, read_bit(data, 0));
     628:	48 2f       	mov	r20, r24
     62a:	41 70       	andi	r20, 0x01	; 1
     62c:	61 e4       	ldi	r22, 0x41	; 65
     62e:	80 e0       	ldi	r24, 0x00	; 0
     630:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  DIO_write(LCD_DATA_PIN5, LCD_DATA_PORT, read_bit(data, 1));
     634:	c1 fb       	bst	r28, 1
     636:	44 27       	eor	r20, r20
     638:	40 f9       	bld	r20, 0
     63a:	61 e4       	ldi	r22, 0x41	; 65
     63c:	81 e0       	ldi	r24, 0x01	; 1
     63e:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  DIO_write(LCD_DATA_PIN6, LCD_DATA_PORT, read_bit(data, 2));
     642:	c2 fb       	bst	r28, 2
     644:	44 27       	eor	r20, r20
     646:	40 f9       	bld	r20, 0
     648:	61 e4       	ldi	r22, 0x41	; 65
     64a:	82 e0       	ldi	r24, 0x02	; 2
     64c:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  DIO_write(LCD_DATA_PIN7, LCD_DATA_PORT, read_bit(data, 3));
     650:	c3 fb       	bst	r28, 3
     652:	44 27       	eor	r20, r20
     654:	40 f9       	bld	r20, 0
     656:	61 e4       	ldi	r22, 0x41	; 65
     658:	83 e0       	ldi	r24, 0x03	; 3
     65a:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  }
     65e:	cf 91       	pop	r28
     660:	08 95       	ret

00000662 <LCD_sendData>:

void LCD_sendData(u8 data) {
     662:	cf 93       	push	r28
     664:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(data >> 4);
     666:	82 95       	swap	r24
     668:	8f 70       	andi	r24, 0x0F	; 15
     66a:	0e 94 12 03 	call	0x624	; 0x624 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, HIGH); // To indicate that this data
     66e:	41 e0       	ldi	r20, 0x01	; 1
     670:	61 e4       	ldi	r22, 0x41	; 65
     672:	84 e0       	ldi	r24, 0x04	; 4
     674:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>

  LCD_sendEnablePulse();
     678:	0e 94 03 03 	call	0x606	; 0x606 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the data to be sent

  LCD_write_4bits(data);
     67c:	8c 2f       	mov	r24, r28
     67e:	0e 94 12 03 	call	0x624	; 0x624 <LCD_write_4bits>

  LCD_sendEnablePulse();
     682:	0e 94 03 03 	call	0x606	; 0x606 <LCD_sendEnablePulse>
     686:	85 e0       	ldi	r24, 0x05	; 5
     688:	8a 95       	dec	r24
     68a:	f1 f7       	brne	.-4      	; 0x688 <LCD_sendData+0x26>
     68c:	00 00       	nop

  _delay_us(1); // wait for the data to be processed
#else

#endif
  }
     68e:	cf 91       	pop	r28
     690:	08 95       	ret

00000692 <LCD_sendCommand>:

void LCD_sendCommand(u8 cmd) {
     692:	cf 93       	push	r28
     694:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(cmd >> 4);
     696:	82 95       	swap	r24
     698:	8f 70       	andi	r24, 0x0F	; 15
     69a:	0e 94 12 03 	call	0x624	; 0x624 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, LOW); // To indicate that this a command
     69e:	40 e0       	ldi	r20, 0x00	; 0
     6a0:	61 e4       	ldi	r22, 0x41	; 65
     6a2:	84 e0       	ldi	r24, 0x04	; 4
     6a4:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>

  LCD_sendEnablePulse();
     6a8:	0e 94 03 03 	call	0x606	; 0x606 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the command to be sent

  LCD_write_4bits(cmd);
     6ac:	8c 2f       	mov	r24, r28
     6ae:	0e 94 12 03 	call	0x624	; 0x624 <LCD_write_4bits>

  LCD_sendEnablePulse();
     6b2:	0e 94 03 03 	call	0x606	; 0x606 <LCD_sendEnablePulse>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6b6:	8f ed       	ldi	r24, 0xDF	; 223
     6b8:	9e e2       	ldi	r25, 0x2E	; 46
     6ba:	01 97       	sbiw	r24, 0x01	; 1
     6bc:	f1 f7       	brne	.-4      	; 0x6ba <LCD_sendCommand+0x28>
     6be:	00 c0       	rjmp	.+0      	; 0x6c0 <LCD_sendCommand+0x2e>
     6c0:	00 00       	nop

  _delay_ms(3); // wait for the command to be executed
#else

#endif
  }
     6c2:	cf 91       	pop	r28
     6c4:	08 95       	ret

000006c6 <LCD_clear_screen>:

void LCD_clear_screen() {
  LCD_sendCommand(0x01);
     6c6:	81 e0       	ldi	r24, 0x01	; 1
     6c8:	0e 94 49 03 	call	0x692	; 0x692 <LCD_sendCommand>
     6cc:	08 95       	ret

000006ce <LCD_init>:
     6ce:	2f ef       	ldi	r18, 0xFF	; 255
     6d0:	89 ef       	ldi	r24, 0xF9	; 249
     6d2:	90 e0       	ldi	r25, 0x00	; 0
     6d4:	21 50       	subi	r18, 0x01	; 1
     6d6:	80 40       	sbci	r24, 0x00	; 0
     6d8:	90 40       	sbci	r25, 0x00	; 0
     6da:	e1 f7       	brne	.-8      	; 0x6d4 <LCD_init+0x6>
     6dc:	00 c0       	rjmp	.+0      	; 0x6de <LCD_init+0x10>
     6de:	00 00       	nop

void LCD_init(void) {
  _delay_ms(20); // wait for the LCD to start up.

#if LCD_MODE == FOUR_BIT_MODE
  DIO_init(LCD_DATA_PIN4, LCD_DATA_PORT, OUT);
     6e0:	41 e0       	ldi	r20, 0x01	; 1
     6e2:	61 e4       	ldi	r22, 0x41	; 65
     6e4:	80 e0       	ldi	r24, 0x00	; 0
     6e6:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  DIO_init(LCD_DATA_PIN5, LCD_DATA_PORT, OUT);
     6ea:	41 e0       	ldi	r20, 0x01	; 1
     6ec:	61 e4       	ldi	r22, 0x41	; 65
     6ee:	81 e0       	ldi	r24, 0x01	; 1
     6f0:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  DIO_init(LCD_DATA_PIN6, LCD_DATA_PORT, OUT);
     6f4:	41 e0       	ldi	r20, 0x01	; 1
     6f6:	61 e4       	ldi	r22, 0x41	; 65
     6f8:	82 e0       	ldi	r24, 0x02	; 2
     6fa:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  DIO_init(LCD_DATA_PIN7, LCD_DATA_PORT, OUT);
     6fe:	41 e0       	ldi	r20, 0x01	; 1
     700:	61 e4       	ldi	r22, 0x41	; 65
     702:	83 e0       	ldi	r24, 0x03	; 3
     704:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>

  DIO_init(RS, LCD_CTRL_PORT, OUT);
     708:	41 e0       	ldi	r20, 0x01	; 1
     70a:	61 e4       	ldi	r22, 0x41	; 65
     70c:	84 e0       	ldi	r24, 0x04	; 4
     70e:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  DIO_init(RW, LCD_CTRL_PORT, OUT);
     712:	41 e0       	ldi	r20, 0x01	; 1
     714:	61 e4       	ldi	r22, 0x41	; 65
     716:	85 e0       	ldi	r24, 0x05	; 5
     718:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
  DIO_init(EN, LCD_CTRL_PORT, OUT);
     71c:	41 e0       	ldi	r20, 0x01	; 1
     71e:	61 e4       	ldi	r22, 0x41	; 65
     720:	86 e0       	ldi	r24, 0x06	; 6
     722:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>

  DIO_write(RW, LCD_CTRL_PORT, LOW);
     726:	40 e0       	ldi	r20, 0x00	; 0
     728:	61 e4       	ldi	r22, 0x41	; 65
     72a:	85 e0       	ldi	r24, 0x05	; 5
     72c:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>

  LCD_sendCommand(0x02);  // return home 
     730:	82 e0       	ldi	r24, 0x02	; 2
     732:	0e 94 49 03 	call	0x692	; 0x692 <LCD_sendCommand>
  LCD_sendCommand(0x28);  // 2 line  and 4 bit mode
     736:	88 e2       	ldi	r24, 0x28	; 40
     738:	0e 94 49 03 	call	0x692	; 0x692 <LCD_sendCommand>
  LCD_sendCommand(0x0C);  // display on 
     73c:	8c e0       	ldi	r24, 0x0C	; 12
     73e:	0e 94 49 03 	call	0x692	; 0x692 <LCD_sendCommand>
  LCD_sendCommand(0x06);  // auto increment 
     742:	86 e0       	ldi	r24, 0x06	; 6
     744:	0e 94 49 03 	call	0x692	; 0x692 <LCD_sendCommand>
  LCD_clear_screen();
     748:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
     74c:	08 95       	ret

0000074e <LCD_write_string>:
#else

#endif
  }

void LCD_write_string(s8* str) {
     74e:	cf 92       	push	r12
     750:	df 92       	push	r13
     752:	ef 92       	push	r14
     754:	ff 92       	push	r15
     756:	cf 93       	push	r28
     758:	df 93       	push	r29
     75a:	ec 01       	movw	r28, r24
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     75c:	c1 2c       	mov	r12, r1
     75e:	d1 2c       	mov	r13, r1
     760:	76 01       	movw	r14, r12
     762:	07 c0       	rjmp	.+14     	; 0x772 <LCD_write_string+0x24>
    LCD_sendData(str[i]);
     764:	0e 94 31 03 	call	0x662	; 0x662 <LCD_sendData>
#endif
  }

void LCD_write_string(s8* str) {
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     768:	8f ef       	ldi	r24, 0xFF	; 255
     76a:	c8 1a       	sub	r12, r24
     76c:	d8 0a       	sbc	r13, r24
     76e:	e8 0a       	sbc	r14, r24
     770:	f8 0a       	sbc	r15, r24
     772:	fe 01       	movw	r30, r28
     774:	ec 0d       	add	r30, r12
     776:	fd 1d       	adc	r31, r13
     778:	80 81       	ld	r24, Z
     77a:	81 11       	cpse	r24, r1
     77c:	f3 cf       	rjmp	.-26     	; 0x764 <LCD_write_string+0x16>
    LCD_sendData(str[i]);
    }
  }
     77e:	df 91       	pop	r29
     780:	cf 91       	pop	r28
     782:	ff 90       	pop	r15
     784:	ef 90       	pop	r14
     786:	df 90       	pop	r13
     788:	cf 90       	pop	r12
     78a:	08 95       	ret

0000078c <LCD_move_cursor_xy>:

void LCD_move_cursor_xy(u8 x, u8 y) {
  switch (y) {
     78c:	66 23       	and	r22, r22
     78e:	19 f0       	breq	.+6      	; 0x796 <LCD_move_cursor_xy+0xa>
     790:	61 30       	cpi	r22, 0x01	; 1
     792:	29 f0       	breq	.+10     	; 0x79e <LCD_move_cursor_xy+0x12>
     794:	08 95       	ret
      case 0:
        LCD_sendCommand(0x80 + x);
     796:	80 58       	subi	r24, 0x80	; 128
     798:	0e 94 49 03 	call	0x692	; 0x692 <LCD_sendCommand>
        break;
     79c:	08 95       	ret
      case 1:
        LCD_sendCommand(0xC0 + x);
     79e:	80 54       	subi	r24, 0x40	; 64
     7a0:	0e 94 49 03 	call	0x692	; 0x692 <LCD_sendCommand>
     7a4:	08 95       	ret

000007a6 <LCD_write_string_xy>:
        break;
    }
  }

void LCD_write_string_xy(u8 x, u8 y, s8* str) {
     7a6:	cf 93       	push	r28
     7a8:	df 93       	push	r29
     7aa:	ea 01       	movw	r28, r20
  LCD_move_cursor_xy(x, y);
     7ac:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_move_cursor_xy>
  LCD_write_string(str);
     7b0:	ce 01       	movw	r24, r28
     7b2:	0e 94 a7 03 	call	0x74e	; 0x74e <LCD_write_string>
  // TODO: Input validation
     7b6:	df 91       	pop	r29
     7b8:	cf 91       	pop	r28
     7ba:	08 95       	ret

000007bc <LED_init>:
 */

#include "led.h"

 // Initialize the LED
EN_ledError_t LED_init(u8 ledPort, u8 ledPin) {
     7bc:	98 2f       	mov	r25, r24
     7be:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(ledPin, ledPort, OUT) == DIO_OK) {
     7c0:	41 e0       	ldi	r20, 0x01	; 1
     7c2:	69 2f       	mov	r22, r25
     7c4:	0e 94 43 04 	call	0x886	; 0x886 <DIO_init>
     7c8:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that the led initialization failed
  return LED_ERROR_INIT;
     7ca:	81 e0       	ldi	r24, 0x01	; 1
  }
     7cc:	08 95       	ret

000007ce <LED_on>:

// Turn on the LED
EN_ledError_t LED_on(u8 ledPort, u8 ledPin) {
     7ce:	98 2f       	mov	r25, r24
     7d0:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, HIGH) == DIO_OK) {
     7d2:	41 e0       	ldi	r20, 0x01	; 1
     7d4:	69 2f       	mov	r22, r25
     7d6:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
     7da:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn on the led has failed
  return LED_ERROR_ON;
     7dc:	82 e0       	ldi	r24, 0x02	; 2
  }
     7de:	08 95       	ret

000007e0 <LED_off>:

// Turn off the LED
EN_ledError_t LED_off(u8 ledPort, u8 ledPin) {
     7e0:	98 2f       	mov	r25, r24
     7e2:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, LOW) == DIO_OK) {
     7e4:	40 e0       	ldi	r20, 0x00	; 0
     7e6:	69 2f       	mov	r22, r25
     7e8:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
     7ec:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn off the led has failed
  return LED_ERROR_OFF;
     7ee:	83 e0       	ldi	r24, 0x03	; 3
  }
     7f0:	08 95       	ret

000007f2 <LED_toggle>:

// Toggle the LED
EN_ledError_t LED_toggle(u8 ledPort, u8 ledPin) {
     7f2:	98 2f       	mov	r25, r24
     7f4:	86 2f       	mov	r24, r22
  if (DIO_toggle(ledPin, ledPort) == DIO_OK) {
     7f6:	69 2f       	mov	r22, r25
     7f8:	0e 94 cd 05 	call	0xb9a	; 0xb9a <DIO_toggle>
     7fc:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to toggle the led has failed
  return LED_ERROR_TOGGLE;
     7fe:	84 e0       	ldi	r24, 0x04	; 4
     800:	08 95       	ret

00000802 <Servo_move_to_angle>:
  Timer_start(TIMER_1, 8);
  }

// Moves the servo to a specific angle (relative to the 0 angle position, not the previous one).
void Servo_move_to_angle(u8 angle) {
  PWM_set_DC(SERVO_PWM_PIN, ((double)angle / ((SERVO_MAX_ANGLE - SERVO_MIN_ANGLE) * (SERVO_PULSE_PERIODIC_TIME_mS / (SERVO_MAX_HIGH_PULSE_DURATION_mS - SERVO_MIN_HIGH_PULSE_DURATION_mS)))) + (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS));
     802:	68 2f       	mov	r22, r24
     804:	70 e0       	ldi	r23, 0x00	; 0
     806:	80 e0       	ldi	r24, 0x00	; 0
     808:	90 e0       	ldi	r25, 0x00	; 0
     80a:	0e 94 e1 15 	call	0x2bc2	; 0x2bc2 <__floatunsisf>
     80e:	20 e0       	ldi	r18, 0x00	; 0
     810:	30 e0       	ldi	r19, 0x00	; 0
     812:	41 ee       	ldi	r20, 0xE1	; 225
     814:	54 e4       	ldi	r21, 0x44	; 68
     816:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__divsf3>
     81a:	2d ec       	ldi	r18, 0xCD	; 205
     81c:	3c ec       	ldi	r19, 0xCC	; 204
     81e:	4c ec       	ldi	r20, 0xCC	; 204
     820:	5c e3       	ldi	r21, 0x3C	; 60
     822:	0e 94 cd 14 	call	0x299a	; 0x299a <__addsf3>
     826:	ab 01       	movw	r20, r22
     828:	bc 01       	movw	r22, r24
     82a:	81 e0       	ldi	r24, 0x01	; 1
     82c:	0e 94 19 09 	call	0x1232	; 0x1232 <PWM_set_DC>
     830:	08 95       	ret

00000832 <main>:
 */

#include "Application/app.h"

int main(void) {
	Local_access_init();
     832:	0e 94 3a 0a 	call	0x1474	; 0x1474 <Local_access_init>
	run_system = true;
     836:	81 e0       	ldi	r24, 0x01	; 1
     838:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
	Lamps_init();
     83c:	0e 94 87 09 	call	0x130e	; 0x130e <Lamps_init>
	// App_init();

	// App_start();
	while (run_system) {
     840:	02 c0       	rjmp	.+4      	; 0x846 <main+0x14>
		Local_control_input_handler();
     842:	0e 94 1d 0c 	call	0x183a	; 0x183a <Local_control_input_handler>
	run_system = true;
	Lamps_init();
	// App_init();

	// App_start();
	while (run_system) {
     846:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     84a:	81 11       	cpse	r24, r1
     84c:	fa cf       	rjmp	.-12     	; 0x842 <main+0x10>
		Local_control_input_handler();
		}
	}
     84e:	80 e0       	ldi	r24, 0x00	; 0
     850:	90 e0       	ldi	r25, 0x00	; 0
     852:	08 95       	ret

00000854 <isValidPinNumber>:
 */

#include "dio.h"

bool isValidPinNumber(u8 pinNumber) {
	if (pinNumber < 8) {
     854:	88 30       	cpi	r24, 0x08	; 8
     856:	10 f4       	brcc	.+4      	; 0x85c <isValidPinNumber+0x8>
		return true;
     858:	81 e0       	ldi	r24, 0x01	; 1
     85a:	08 95       	ret
		}
	return false;
     85c:	80 e0       	ldi	r24, 0x00	; 0
	}
     85e:	08 95       	ret

00000860 <isValidPortNumber>:

bool isValidPortNumber(u8 portNumber) {
	if (portNumber == PORT_A || portNumber == PORT_B || portNumber == PORT_C || portNumber == PORT_D) {
     860:	81 54       	subi	r24, 0x41	; 65
     862:	84 30       	cpi	r24, 0x04	; 4
     864:	10 f4       	brcc	.+4      	; 0x86a <isValidPortNumber+0xa>
		return true;
     866:	81 e0       	ldi	r24, 0x01	; 1
     868:	08 95       	ret
		}
	return false;
     86a:	80 e0       	ldi	r24, 0x00	; 0
	}
     86c:	08 95       	ret

0000086e <isValidDirection>:

bool isValidDirection(u8 direction) {
	if (direction == IN || direction == OUT) {
     86e:	82 30       	cpi	r24, 0x02	; 2
     870:	10 f4       	brcc	.+4      	; 0x876 <isValidDirection+0x8>
		return true;
     872:	81 e0       	ldi	r24, 0x01	; 1
     874:	08 95       	ret
		}
	return false;
     876:	80 e0       	ldi	r24, 0x00	; 0
	}
     878:	08 95       	ret

0000087a <isValidState>:

bool isValidState(u8 state) {
	if (state == HIGH || state == LOW) {
     87a:	82 30       	cpi	r24, 0x02	; 2
     87c:	10 f4       	brcc	.+4      	; 0x882 <isValidState+0x8>
		return true;
     87e:	81 e0       	ldi	r24, 0x01	; 1
     880:	08 95       	ret
		}
	return false;
     882:	80 e0       	ldi	r24, 0x00	; 0
	}
     884:	08 95       	ret

00000886 <DIO_init>:

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
     886:	1f 93       	push	r17
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
     88c:	c8 2f       	mov	r28, r24
     88e:	d6 2f       	mov	r29, r22
     890:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     892:	0e 94 2a 04 	call	0x854	; 0x854 <isValidPinNumber>
     896:	88 23       	and	r24, r24
     898:	09 f4       	brne	.+2      	; 0x89c <DIO_init+0x16>
     89a:	84 c0       	rjmp	.+264    	; 0x9a4 <DIO_init+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     89c:	8d 2f       	mov	r24, r29
     89e:	0e 94 30 04 	call	0x860	; 0x860 <isValidPortNumber>
     8a2:	88 23       	and	r24, r24
     8a4:	09 f4       	brne	.+2      	; 0x8a8 <DIO_init+0x22>
     8a6:	80 c0       	rjmp	.+256    	; 0x9a8 <DIO_init+0x122>
		return WRONG_PORT;
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
     8a8:	81 2f       	mov	r24, r17
     8aa:	0e 94 37 04 	call	0x86e	; 0x86e <isValidDirection>
     8ae:	88 23       	and	r24, r24
     8b0:	09 f4       	brne	.+2      	; 0x8b4 <DIO_init+0x2e>
     8b2:	7c c0       	rjmp	.+248    	; 0x9ac <DIO_init+0x126>
		return WRONG_DIRECTION;
		}
	switch (portNumber) {
     8b4:	d2 34       	cpi	r29, 0x42	; 66
     8b6:	29 f1       	breq	.+74     	; 0x902 <DIO_init+0x7c>
     8b8:	18 f4       	brcc	.+6      	; 0x8c0 <DIO_init+0x3a>
     8ba:	d1 34       	cpi	r29, 0x41	; 65
     8bc:	39 f0       	breq	.+14     	; 0x8cc <DIO_init+0x46>
     8be:	78 c0       	rjmp	.+240    	; 0x9b0 <DIO_init+0x12a>
     8c0:	d3 34       	cpi	r29, 0x43	; 67
     8c2:	d1 f1       	breq	.+116    	; 0x938 <DIO_init+0xb2>
     8c4:	d4 34       	cpi	r29, 0x44	; 68
     8c6:	09 f4       	brne	.+2      	; 0x8ca <DIO_init+0x44>
     8c8:	52 c0       	rjmp	.+164    	; 0x96e <DIO_init+0xe8>
     8ca:	72 c0       	rjmp	.+228    	; 0x9b0 <DIO_init+0x12a>
			case PORT_A:
				if (direction == OUT) {
     8cc:	11 30       	cpi	r17, 0x01	; 1
     8ce:	61 f4       	brne	.+24     	; 0x8e8 <DIO_init+0x62>
					set_bit(DDRA, pinNumber);
     8d0:	2a b3       	in	r18, 0x1a	; 26
     8d2:	81 e0       	ldi	r24, 0x01	; 1
     8d4:	90 e0       	ldi	r25, 0x00	; 0
     8d6:	02 c0       	rjmp	.+4      	; 0x8dc <DIO_init+0x56>
     8d8:	88 0f       	add	r24, r24
     8da:	99 1f       	adc	r25, r25
     8dc:	ca 95       	dec	r28
     8de:	e2 f7       	brpl	.-8      	; 0x8d8 <DIO_init+0x52>
     8e0:	82 2b       	or	r24, r18
     8e2:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     8e4:	80 e0       	ldi	r24, 0x00	; 0
     8e6:	65 c0       	rjmp	.+202    	; 0x9b2 <DIO_init+0x12c>
			case PORT_A:
				if (direction == OUT) {
					set_bit(DDRA, pinNumber);
					}
				else {
					clear_bit(DDRA, pinNumber);
     8e8:	2a b3       	in	r18, 0x1a	; 26
     8ea:	81 e0       	ldi	r24, 0x01	; 1
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	02 c0       	rjmp	.+4      	; 0x8f4 <DIO_init+0x6e>
     8f0:	88 0f       	add	r24, r24
     8f2:	99 1f       	adc	r25, r25
     8f4:	ca 95       	dec	r28
     8f6:	e2 f7       	brpl	.-8      	; 0x8f0 <DIO_init+0x6a>
     8f8:	80 95       	com	r24
     8fa:	82 23       	and	r24, r18
     8fc:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     8fe:	80 e0       	ldi	r24, 0x00	; 0
     900:	58 c0       	rjmp	.+176    	; 0x9b2 <DIO_init+0x12c>
				else {
					clear_bit(DDRA, pinNumber);
					}
				break;
			case PORT_B:
				if (direction == OUT) {
     902:	11 30       	cpi	r17, 0x01	; 1
     904:	61 f4       	brne	.+24     	; 0x91e <DIO_init+0x98>
					set_bit(DDRB, pinNumber);
     906:	27 b3       	in	r18, 0x17	; 23
     908:	81 e0       	ldi	r24, 0x01	; 1
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	02 c0       	rjmp	.+4      	; 0x912 <DIO_init+0x8c>
     90e:	88 0f       	add	r24, r24
     910:	99 1f       	adc	r25, r25
     912:	ca 95       	dec	r28
     914:	e2 f7       	brpl	.-8      	; 0x90e <DIO_init+0x88>
     916:	82 2b       	or	r24, r18
     918:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     91a:	80 e0       	ldi	r24, 0x00	; 0
     91c:	4a c0       	rjmp	.+148    	; 0x9b2 <DIO_init+0x12c>
			case PORT_B:
				if (direction == OUT) {
					set_bit(DDRB, pinNumber);
					}
				else {
					clear_bit(DDRB, pinNumber);
     91e:	27 b3       	in	r18, 0x17	; 23
     920:	81 e0       	ldi	r24, 0x01	; 1
     922:	90 e0       	ldi	r25, 0x00	; 0
     924:	02 c0       	rjmp	.+4      	; 0x92a <DIO_init+0xa4>
     926:	88 0f       	add	r24, r24
     928:	99 1f       	adc	r25, r25
     92a:	ca 95       	dec	r28
     92c:	e2 f7       	brpl	.-8      	; 0x926 <DIO_init+0xa0>
     92e:	80 95       	com	r24
     930:	82 23       	and	r24, r18
     932:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     934:	80 e0       	ldi	r24, 0x00	; 0
     936:	3d c0       	rjmp	.+122    	; 0x9b2 <DIO_init+0x12c>
				else {
					clear_bit(DDRB, pinNumber);
					}
				break;
			case PORT_C:
				if (direction == OUT) {
     938:	11 30       	cpi	r17, 0x01	; 1
     93a:	61 f4       	brne	.+24     	; 0x954 <DIO_init+0xce>
					set_bit(DDRC, pinNumber);
     93c:	24 b3       	in	r18, 0x14	; 20
     93e:	81 e0       	ldi	r24, 0x01	; 1
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	02 c0       	rjmp	.+4      	; 0x948 <DIO_init+0xc2>
     944:	88 0f       	add	r24, r24
     946:	99 1f       	adc	r25, r25
     948:	ca 95       	dec	r28
     94a:	e2 f7       	brpl	.-8      	; 0x944 <DIO_init+0xbe>
     94c:	82 2b       	or	r24, r18
     94e:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     950:	80 e0       	ldi	r24, 0x00	; 0
     952:	2f c0       	rjmp	.+94     	; 0x9b2 <DIO_init+0x12c>
			case PORT_C:
				if (direction == OUT) {
					set_bit(DDRC, pinNumber);
					}
				else {
					clear_bit(DDRC, pinNumber);
     954:	24 b3       	in	r18, 0x14	; 20
     956:	81 e0       	ldi	r24, 0x01	; 1
     958:	90 e0       	ldi	r25, 0x00	; 0
     95a:	02 c0       	rjmp	.+4      	; 0x960 <DIO_init+0xda>
     95c:	88 0f       	add	r24, r24
     95e:	99 1f       	adc	r25, r25
     960:	ca 95       	dec	r28
     962:	e2 f7       	brpl	.-8      	; 0x95c <DIO_init+0xd6>
     964:	80 95       	com	r24
     966:	82 23       	and	r24, r18
     968:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     96a:	80 e0       	ldi	r24, 0x00	; 0
     96c:	22 c0       	rjmp	.+68     	; 0x9b2 <DIO_init+0x12c>
				else {
					clear_bit(DDRC, pinNumber);
					}
				break;
			case PORT_D:
				if (direction == OUT) {
     96e:	11 30       	cpi	r17, 0x01	; 1
     970:	61 f4       	brne	.+24     	; 0x98a <DIO_init+0x104>
					set_bit(DDRD, pinNumber);
     972:	21 b3       	in	r18, 0x11	; 17
     974:	81 e0       	ldi	r24, 0x01	; 1
     976:	90 e0       	ldi	r25, 0x00	; 0
     978:	02 c0       	rjmp	.+4      	; 0x97e <DIO_init+0xf8>
     97a:	88 0f       	add	r24, r24
     97c:	99 1f       	adc	r25, r25
     97e:	ca 95       	dec	r28
     980:	e2 f7       	brpl	.-8      	; 0x97a <DIO_init+0xf4>
     982:	82 2b       	or	r24, r18
     984:	81 bb       	out	0x11, r24	; 17
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     986:	80 e0       	ldi	r24, 0x00	; 0
     988:	14 c0       	rjmp	.+40     	; 0x9b2 <DIO_init+0x12c>
			case PORT_D:
				if (direction == OUT) {
					set_bit(DDRD, pinNumber);
					}
				else {
					clear_bit(DDRD, pinNumber);
     98a:	21 b3       	in	r18, 0x11	; 17
     98c:	81 e0       	ldi	r24, 0x01	; 1
     98e:	90 e0       	ldi	r25, 0x00	; 0
     990:	02 c0       	rjmp	.+4      	; 0x996 <DIO_init+0x110>
     992:	88 0f       	add	r24, r24
     994:	99 1f       	adc	r25, r25
     996:	ca 95       	dec	r28
     998:	e2 f7       	brpl	.-8      	; 0x992 <DIO_init+0x10c>
     99a:	80 95       	com	r24
     99c:	82 23       	and	r24, r18
     99e:	81 bb       	out	0x11, r24	; 17
					}
				break;
		}
	return DIO_OK;
     9a0:	80 e0       	ldi	r24, 0x00	; 0
     9a2:	07 c0       	rjmp	.+14     	; 0x9b2 <DIO_init+0x12c>

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     9a4:	81 e0       	ldi	r24, 0x01	; 1
     9a6:	05 c0       	rjmp	.+10     	; 0x9b2 <DIO_init+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     9a8:	82 e0       	ldi	r24, 0x02	; 2
     9aa:	03 c0       	rjmp	.+6      	; 0x9b2 <DIO_init+0x12c>
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
		return WRONG_DIRECTION;
     9ac:	83 e0       	ldi	r24, 0x03	; 3
     9ae:	01 c0       	rjmp	.+2      	; 0x9b2 <DIO_init+0x12c>
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     9b0:	80 e0       	ldi	r24, 0x00	; 0
	}
     9b2:	df 91       	pop	r29
     9b4:	cf 91       	pop	r28
     9b6:	1f 91       	pop	r17
     9b8:	08 95       	ret

000009ba <DIO_write>:

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
     9ba:	1f 93       	push	r17
     9bc:	cf 93       	push	r28
     9be:	df 93       	push	r29
     9c0:	c8 2f       	mov	r28, r24
     9c2:	d6 2f       	mov	r29, r22
     9c4:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     9c6:	0e 94 2a 04 	call	0x854	; 0x854 <isValidPinNumber>
     9ca:	88 23       	and	r24, r24
     9cc:	09 f4       	brne	.+2      	; 0x9d0 <DIO_write+0x16>
     9ce:	84 c0       	rjmp	.+264    	; 0xad8 <DIO_write+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     9d0:	8d 2f       	mov	r24, r29
     9d2:	0e 94 30 04 	call	0x860	; 0x860 <isValidPortNumber>
     9d6:	88 23       	and	r24, r24
     9d8:	09 f4       	brne	.+2      	; 0x9dc <DIO_write+0x22>
     9da:	80 c0       	rjmp	.+256    	; 0xadc <DIO_write+0x122>
		return WRONG_PORT;
		}
	// Validate the pin state
	if (!isValidState(state)) {
     9dc:	81 2f       	mov	r24, r17
     9de:	0e 94 3d 04 	call	0x87a	; 0x87a <isValidState>
     9e2:	88 23       	and	r24, r24
     9e4:	09 f4       	brne	.+2      	; 0x9e8 <DIO_write+0x2e>
     9e6:	7c c0       	rjmp	.+248    	; 0xae0 <DIO_write+0x126>
		return WRONG_STATE;
		}
	switch (portNumber) {
     9e8:	d2 34       	cpi	r29, 0x42	; 66
     9ea:	29 f1       	breq	.+74     	; 0xa36 <DIO_write+0x7c>
     9ec:	18 f4       	brcc	.+6      	; 0x9f4 <DIO_write+0x3a>
     9ee:	d1 34       	cpi	r29, 0x41	; 65
     9f0:	39 f0       	breq	.+14     	; 0xa00 <DIO_write+0x46>
     9f2:	78 c0       	rjmp	.+240    	; 0xae4 <DIO_write+0x12a>
     9f4:	d3 34       	cpi	r29, 0x43	; 67
     9f6:	d1 f1       	breq	.+116    	; 0xa6c <DIO_write+0xb2>
     9f8:	d4 34       	cpi	r29, 0x44	; 68
     9fa:	09 f4       	brne	.+2      	; 0x9fe <DIO_write+0x44>
     9fc:	52 c0       	rjmp	.+164    	; 0xaa2 <DIO_write+0xe8>
     9fe:	72 c0       	rjmp	.+228    	; 0xae4 <DIO_write+0x12a>
			case PORT_A:
				if (state == HIGH) {
     a00:	11 30       	cpi	r17, 0x01	; 1
     a02:	61 f4       	brne	.+24     	; 0xa1c <DIO_write+0x62>
					set_bit(PORTA, pinNumber);
     a04:	2b b3       	in	r18, 0x1b	; 27
     a06:	81 e0       	ldi	r24, 0x01	; 1
     a08:	90 e0       	ldi	r25, 0x00	; 0
     a0a:	02 c0       	rjmp	.+4      	; 0xa10 <DIO_write+0x56>
     a0c:	88 0f       	add	r24, r24
     a0e:	99 1f       	adc	r25, r25
     a10:	ca 95       	dec	r28
     a12:	e2 f7       	brpl	.-8      	; 0xa0c <DIO_write+0x52>
     a14:	82 2b       	or	r24, r18
     a16:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a18:	80 e0       	ldi	r24, 0x00	; 0
     a1a:	65 c0       	rjmp	.+202    	; 0xae6 <DIO_write+0x12c>
			case PORT_A:
				if (state == HIGH) {
					set_bit(PORTA, pinNumber);
					}
				else {
					clear_bit(PORTA, pinNumber);
     a1c:	2b b3       	in	r18, 0x1b	; 27
     a1e:	81 e0       	ldi	r24, 0x01	; 1
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	02 c0       	rjmp	.+4      	; 0xa28 <DIO_write+0x6e>
     a24:	88 0f       	add	r24, r24
     a26:	99 1f       	adc	r25, r25
     a28:	ca 95       	dec	r28
     a2a:	e2 f7       	brpl	.-8      	; 0xa24 <DIO_write+0x6a>
     a2c:	80 95       	com	r24
     a2e:	82 23       	and	r24, r18
     a30:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a32:	80 e0       	ldi	r24, 0x00	; 0
     a34:	58 c0       	rjmp	.+176    	; 0xae6 <DIO_write+0x12c>
				else {
					clear_bit(PORTA, pinNumber);
					}
				break;
			case PORT_B:
				if (state == HIGH) {
     a36:	11 30       	cpi	r17, 0x01	; 1
     a38:	61 f4       	brne	.+24     	; 0xa52 <DIO_write+0x98>
					set_bit(PORTB, pinNumber);
     a3a:	28 b3       	in	r18, 0x18	; 24
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	02 c0       	rjmp	.+4      	; 0xa46 <DIO_write+0x8c>
     a42:	88 0f       	add	r24, r24
     a44:	99 1f       	adc	r25, r25
     a46:	ca 95       	dec	r28
     a48:	e2 f7       	brpl	.-8      	; 0xa42 <DIO_write+0x88>
     a4a:	82 2b       	or	r24, r18
     a4c:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a4e:	80 e0       	ldi	r24, 0x00	; 0
     a50:	4a c0       	rjmp	.+148    	; 0xae6 <DIO_write+0x12c>
			case PORT_B:
				if (state == HIGH) {
					set_bit(PORTB, pinNumber);
					}
				else {
					clear_bit(PORTB, pinNumber);
     a52:	28 b3       	in	r18, 0x18	; 24
     a54:	81 e0       	ldi	r24, 0x01	; 1
     a56:	90 e0       	ldi	r25, 0x00	; 0
     a58:	02 c0       	rjmp	.+4      	; 0xa5e <DIO_write+0xa4>
     a5a:	88 0f       	add	r24, r24
     a5c:	99 1f       	adc	r25, r25
     a5e:	ca 95       	dec	r28
     a60:	e2 f7       	brpl	.-8      	; 0xa5a <DIO_write+0xa0>
     a62:	80 95       	com	r24
     a64:	82 23       	and	r24, r18
     a66:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a68:	80 e0       	ldi	r24, 0x00	; 0
     a6a:	3d c0       	rjmp	.+122    	; 0xae6 <DIO_write+0x12c>
				else {
					clear_bit(PORTB, pinNumber);
					}
				break;
			case PORT_C:
				if (state == HIGH) {
     a6c:	11 30       	cpi	r17, 0x01	; 1
     a6e:	61 f4       	brne	.+24     	; 0xa88 <DIO_write+0xce>
					set_bit(PORTC, pinNumber);
     a70:	25 b3       	in	r18, 0x15	; 21
     a72:	81 e0       	ldi	r24, 0x01	; 1
     a74:	90 e0       	ldi	r25, 0x00	; 0
     a76:	02 c0       	rjmp	.+4      	; 0xa7c <DIO_write+0xc2>
     a78:	88 0f       	add	r24, r24
     a7a:	99 1f       	adc	r25, r25
     a7c:	ca 95       	dec	r28
     a7e:	e2 f7       	brpl	.-8      	; 0xa78 <DIO_write+0xbe>
     a80:	82 2b       	or	r24, r18
     a82:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	2f c0       	rjmp	.+94     	; 0xae6 <DIO_write+0x12c>
			case PORT_C:
				if (state == HIGH) {
					set_bit(PORTC, pinNumber);
					}
				else {
					clear_bit(PORTC, pinNumber);
     a88:	25 b3       	in	r18, 0x15	; 21
     a8a:	81 e0       	ldi	r24, 0x01	; 1
     a8c:	90 e0       	ldi	r25, 0x00	; 0
     a8e:	02 c0       	rjmp	.+4      	; 0xa94 <DIO_write+0xda>
     a90:	88 0f       	add	r24, r24
     a92:	99 1f       	adc	r25, r25
     a94:	ca 95       	dec	r28
     a96:	e2 f7       	brpl	.-8      	; 0xa90 <DIO_write+0xd6>
     a98:	80 95       	com	r24
     a9a:	82 23       	and	r24, r18
     a9c:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a9e:	80 e0       	ldi	r24, 0x00	; 0
     aa0:	22 c0       	rjmp	.+68     	; 0xae6 <DIO_write+0x12c>
				else {
					clear_bit(PORTC, pinNumber);
					}
				break;
			case PORT_D:
				if (state == HIGH) {
     aa2:	11 30       	cpi	r17, 0x01	; 1
     aa4:	61 f4       	brne	.+24     	; 0xabe <DIO_write+0x104>
					set_bit(PORTD, pinNumber);
     aa6:	22 b3       	in	r18, 0x12	; 18
     aa8:	81 e0       	ldi	r24, 0x01	; 1
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	02 c0       	rjmp	.+4      	; 0xab2 <DIO_write+0xf8>
     aae:	88 0f       	add	r24, r24
     ab0:	99 1f       	adc	r25, r25
     ab2:	ca 95       	dec	r28
     ab4:	e2 f7       	brpl	.-8      	; 0xaae <DIO_write+0xf4>
     ab6:	82 2b       	or	r24, r18
     ab8:	82 bb       	out	0x12, r24	; 18
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     aba:	80 e0       	ldi	r24, 0x00	; 0
     abc:	14 c0       	rjmp	.+40     	; 0xae6 <DIO_write+0x12c>
			case PORT_D:
				if (state == HIGH) {
					set_bit(PORTD, pinNumber);
					}
				else {
					clear_bit(PORTD, pinNumber);
     abe:	22 b3       	in	r18, 0x12	; 18
     ac0:	81 e0       	ldi	r24, 0x01	; 1
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	02 c0       	rjmp	.+4      	; 0xaca <DIO_write+0x110>
     ac6:	88 0f       	add	r24, r24
     ac8:	99 1f       	adc	r25, r25
     aca:	ca 95       	dec	r28
     acc:	e2 f7       	brpl	.-8      	; 0xac6 <DIO_write+0x10c>
     ace:	80 95       	com	r24
     ad0:	82 23       	and	r24, r18
     ad2:	82 bb       	out	0x12, r24	; 18
					}
				break;
		}
	return DIO_OK;
     ad4:	80 e0       	ldi	r24, 0x00	; 0
     ad6:	07 c0       	rjmp	.+14     	; 0xae6 <DIO_write+0x12c>

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     ad8:	81 e0       	ldi	r24, 0x01	; 1
     ada:	05 c0       	rjmp	.+10     	; 0xae6 <DIO_write+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     adc:	82 e0       	ldi	r24, 0x02	; 2
     ade:	03 c0       	rjmp	.+6      	; 0xae6 <DIO_write+0x12c>
		}
	// Validate the pin state
	if (!isValidState(state)) {
		return WRONG_STATE;
     ae0:	84 e0       	ldi	r24, 0x04	; 4
     ae2:	01 c0       	rjmp	.+2      	; 0xae6 <DIO_write+0x12c>
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     ae4:	80 e0       	ldi	r24, 0x00	; 0
	}
     ae6:	df 91       	pop	r29
     ae8:	cf 91       	pop	r28
     aea:	1f 91       	pop	r17
     aec:	08 95       	ret

00000aee <DIO_Read>:

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
     aee:	0f 93       	push	r16
     af0:	1f 93       	push	r17
     af2:	cf 93       	push	r28
     af4:	df 93       	push	r29
     af6:	d8 2f       	mov	r29, r24
     af8:	c6 2f       	mov	r28, r22
     afa:	8a 01       	movw	r16, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     afc:	0e 94 2a 04 	call	0x854	; 0x854 <isValidPinNumber>
     b00:	88 23       	and	r24, r24
     b02:	09 f4       	brne	.+2      	; 0xb06 <DIO_Read+0x18>
     b04:	40 c0       	rjmp	.+128    	; 0xb86 <DIO_Read+0x98>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     b06:	8c 2f       	mov	r24, r28
     b08:	0e 94 30 04 	call	0x860	; 0x860 <isValidPortNumber>
     b0c:	88 23       	and	r24, r24
     b0e:	e9 f1       	breq	.+122    	; 0xb8a <DIO_Read+0x9c>
		return WRONG_PORT;
		}
	switch (portNumber) {
     b10:	c2 34       	cpi	r28, 0x42	; 66
     b12:	a9 f0       	breq	.+42     	; 0xb3e <DIO_Read+0x50>
     b14:	18 f4       	brcc	.+6      	; 0xb1c <DIO_Read+0x2e>
     b16:	c1 34       	cpi	r28, 0x41	; 65
     b18:	31 f0       	breq	.+12     	; 0xb26 <DIO_Read+0x38>
     b1a:	39 c0       	rjmp	.+114    	; 0xb8e <DIO_Read+0xa0>
     b1c:	c3 34       	cpi	r28, 0x43	; 67
     b1e:	d9 f0       	breq	.+54     	; 0xb56 <DIO_Read+0x68>
     b20:	c4 34       	cpi	r28, 0x44	; 68
     b22:	29 f1       	breq	.+74     	; 0xb6e <DIO_Read+0x80>
     b24:	34 c0       	rjmp	.+104    	; 0xb8e <DIO_Read+0xa0>
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
     b26:	89 b3       	in	r24, 0x19	; 25
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	02 c0       	rjmp	.+4      	; 0xb30 <DIO_Read+0x42>
     b2c:	95 95       	asr	r25
     b2e:	87 95       	ror	r24
     b30:	da 95       	dec	r29
     b32:	e2 f7       	brpl	.-8      	; 0xb2c <DIO_Read+0x3e>
     b34:	81 70       	andi	r24, 0x01	; 1
     b36:	f8 01       	movw	r30, r16
     b38:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b3a:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
     b3c:	29 c0       	rjmp	.+82     	; 0xb90 <DIO_Read+0xa2>
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
     b3e:	86 b3       	in	r24, 0x16	; 22
     b40:	90 e0       	ldi	r25, 0x00	; 0
     b42:	02 c0       	rjmp	.+4      	; 0xb48 <DIO_Read+0x5a>
     b44:	95 95       	asr	r25
     b46:	87 95       	ror	r24
     b48:	da 95       	dec	r29
     b4a:	e2 f7       	brpl	.-8      	; 0xb44 <DIO_Read+0x56>
     b4c:	81 70       	andi	r24, 0x01	; 1
     b4e:	f8 01       	movw	r30, r16
     b50:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b52:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
     b54:	1d c0       	rjmp	.+58     	; 0xb90 <DIO_Read+0xa2>
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
     b56:	83 b3       	in	r24, 0x13	; 19
     b58:	90 e0       	ldi	r25, 0x00	; 0
     b5a:	02 c0       	rjmp	.+4      	; 0xb60 <DIO_Read+0x72>
     b5c:	95 95       	asr	r25
     b5e:	87 95       	ror	r24
     b60:	da 95       	dec	r29
     b62:	e2 f7       	brpl	.-8      	; 0xb5c <DIO_Read+0x6e>
     b64:	81 70       	andi	r24, 0x01	; 1
     b66:	f8 01       	movw	r30, r16
     b68:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b6a:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
     b6c:	11 c0       	rjmp	.+34     	; 0xb90 <DIO_Read+0xa2>
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
     b6e:	80 b3       	in	r24, 0x10	; 16
     b70:	90 e0       	ldi	r25, 0x00	; 0
     b72:	02 c0       	rjmp	.+4      	; 0xb78 <DIO_Read+0x8a>
     b74:	95 95       	asr	r25
     b76:	87 95       	ror	r24
     b78:	da 95       	dec	r29
     b7a:	e2 f7       	brpl	.-8      	; 0xb74 <DIO_Read+0x86>
     b7c:	81 70       	andi	r24, 0x01	; 1
     b7e:	f8 01       	movw	r30, r16
     b80:	80 83       	st	Z, r24
				break;
		}
	return DIO_OK;
     b82:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
     b84:	05 c0       	rjmp	.+10     	; 0xb90 <DIO_Read+0xa2>

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     b86:	81 e0       	ldi	r24, 0x01	; 1
     b88:	03 c0       	rjmp	.+6      	; 0xb90 <DIO_Read+0xa2>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     b8a:	82 e0       	ldi	r24, 0x02	; 2
     b8c:	01 c0       	rjmp	.+2      	; 0xb90 <DIO_Read+0xa2>
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     b8e:	80 e0       	ldi	r24, 0x00	; 0
	}
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
     b94:	1f 91       	pop	r17
     b96:	0f 91       	pop	r16
     b98:	08 95       	ret

00000b9a <DIO_toggle>:

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
     b9a:	cf 93       	push	r28
     b9c:	df 93       	push	r29
     b9e:	d8 2f       	mov	r29, r24
     ba0:	c6 2f       	mov	r28, r22
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     ba2:	0e 94 2a 04 	call	0x854	; 0x854 <isValidPinNumber>
     ba6:	88 23       	and	r24, r24
     ba8:	09 f4       	brne	.+2      	; 0xbac <DIO_toggle+0x12>
     baa:	40 c0       	rjmp	.+128    	; 0xc2c <DIO_toggle+0x92>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     bac:	8c 2f       	mov	r24, r28
     bae:	0e 94 30 04 	call	0x860	; 0x860 <isValidPortNumber>
     bb2:	88 23       	and	r24, r24
     bb4:	e9 f1       	breq	.+122    	; 0xc30 <DIO_toggle+0x96>
		return WRONG_PORT;
		}
	switch (portNumber) {
     bb6:	c2 34       	cpi	r28, 0x42	; 66
     bb8:	a9 f0       	breq	.+42     	; 0xbe4 <DIO_toggle+0x4a>
     bba:	18 f4       	brcc	.+6      	; 0xbc2 <DIO_toggle+0x28>
     bbc:	c1 34       	cpi	r28, 0x41	; 65
     bbe:	31 f0       	breq	.+12     	; 0xbcc <DIO_toggle+0x32>
     bc0:	39 c0       	rjmp	.+114    	; 0xc34 <DIO_toggle+0x9a>
     bc2:	c3 34       	cpi	r28, 0x43	; 67
     bc4:	d9 f0       	breq	.+54     	; 0xbfc <DIO_toggle+0x62>
     bc6:	c4 34       	cpi	r28, 0x44	; 68
     bc8:	29 f1       	breq	.+74     	; 0xc14 <DIO_toggle+0x7a>
     bca:	34 c0       	rjmp	.+104    	; 0xc34 <DIO_toggle+0x9a>
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
     bcc:	2b b3       	in	r18, 0x1b	; 27
     bce:	81 e0       	ldi	r24, 0x01	; 1
     bd0:	90 e0       	ldi	r25, 0x00	; 0
     bd2:	02 c0       	rjmp	.+4      	; 0xbd8 <DIO_toggle+0x3e>
     bd4:	88 0f       	add	r24, r24
     bd6:	99 1f       	adc	r25, r25
     bd8:	da 95       	dec	r29
     bda:	e2 f7       	brpl	.-8      	; 0xbd4 <DIO_toggle+0x3a>
     bdc:	82 27       	eor	r24, r18
     bde:	8b bb       	out	0x1b, r24	; 27
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     be0:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
     be2:	29 c0       	rjmp	.+82     	; 0xc36 <DIO_toggle+0x9c>
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
     be4:	28 b3       	in	r18, 0x18	; 24
     be6:	81 e0       	ldi	r24, 0x01	; 1
     be8:	90 e0       	ldi	r25, 0x00	; 0
     bea:	02 c0       	rjmp	.+4      	; 0xbf0 <DIO_toggle+0x56>
     bec:	88 0f       	add	r24, r24
     bee:	99 1f       	adc	r25, r25
     bf0:	da 95       	dec	r29
     bf2:	e2 f7       	brpl	.-8      	; 0xbec <DIO_toggle+0x52>
     bf4:	82 27       	eor	r24, r18
     bf6:	88 bb       	out	0x18, r24	; 24
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     bf8:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
     bfa:	1d c0       	rjmp	.+58     	; 0xc36 <DIO_toggle+0x9c>
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
     bfc:	25 b3       	in	r18, 0x15	; 21
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	90 e0       	ldi	r25, 0x00	; 0
     c02:	02 c0       	rjmp	.+4      	; 0xc08 <DIO_toggle+0x6e>
     c04:	88 0f       	add	r24, r24
     c06:	99 1f       	adc	r25, r25
     c08:	da 95       	dec	r29
     c0a:	e2 f7       	brpl	.-8      	; 0xc04 <DIO_toggle+0x6a>
     c0c:	82 27       	eor	r24, r18
     c0e:	85 bb       	out	0x15, r24	; 21
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     c10:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
     c12:	11 c0       	rjmp	.+34     	; 0xc36 <DIO_toggle+0x9c>
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
     c14:	22 b3       	in	r18, 0x12	; 18
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	90 e0       	ldi	r25, 0x00	; 0
     c1a:	02 c0       	rjmp	.+4      	; 0xc20 <DIO_toggle+0x86>
     c1c:	88 0f       	add	r24, r24
     c1e:	99 1f       	adc	r25, r25
     c20:	da 95       	dec	r29
     c22:	e2 f7       	brpl	.-8      	; 0xc1c <DIO_toggle+0x82>
     c24:	82 27       	eor	r24, r18
     c26:	82 bb       	out	0x12, r24	; 18
				break;
		}
	return DIO_OK;
     c28:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
     c2a:	05 c0       	rjmp	.+10     	; 0xc36 <DIO_toggle+0x9c>

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     c2c:	81 e0       	ldi	r24, 0x01	; 1
     c2e:	03 c0       	rjmp	.+6      	; 0xc36 <DIO_toggle+0x9c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     c30:	82 e0       	ldi	r24, 0x02	; 2
     c32:	01 c0       	rjmp	.+2      	; 0xc36 <DIO_toggle+0x9c>
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     c34:	80 e0       	ldi	r24, 0x00	; 0
     c36:	df 91       	pop	r29
     c38:	cf 91       	pop	r28
     c3a:	08 95       	ret

00000c3c <getCurrentStatus>:

EN_I2CMasterStatusCode_t I2C_repeatedStart() {   // Same as start, just a different name
  TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  while (read_bit(TWCR, TWINT) == 0);
  return getCurrentStatus();
  }
     c3c:	81 b1       	in	r24, 0x01	; 1
     c3e:	e8 2f       	mov	r30, r24
     c40:	e8 7f       	andi	r30, 0xF8	; 248
     c42:	8e 2f       	mov	r24, r30
     c44:	90 e0       	ldi	r25, 0x00	; 0
     c46:	fc 01       	movw	r30, r24
     c48:	38 97       	sbiw	r30, 0x08	; 8
     c4a:	e1 35       	cpi	r30, 0x51	; 81
     c4c:	f1 05       	cpc	r31, r1
     c4e:	c0 f4       	brcc	.+48     	; 0xc80 <getCurrentStatus+0x44>
     c50:	e6 5d       	subi	r30, 0xD6	; 214
     c52:	ff 4f       	sbci	r31, 0xFF	; 255
     c54:	0c 94 dc 16 	jmp	0x2db8	; 0x2db8 <__tablejump2__>
     c58:	80 e0       	ldi	r24, 0x00	; 0
     c5a:	08 95       	ret
     c5c:	82 e0       	ldi	r24, 0x02	; 2
     c5e:	08 95       	ret
     c60:	83 e0       	ldi	r24, 0x03	; 3
     c62:	08 95       	ret
     c64:	84 e0       	ldi	r24, 0x04	; 4
     c66:	08 95       	ret
     c68:	85 e0       	ldi	r24, 0x05	; 5
     c6a:	08 95       	ret
     c6c:	86 e0       	ldi	r24, 0x06	; 6
     c6e:	08 95       	ret
     c70:	87 e0       	ldi	r24, 0x07	; 7
     c72:	08 95       	ret
     c74:	88 e0       	ldi	r24, 0x08	; 8
     c76:	08 95       	ret
     c78:	89 e0       	ldi	r24, 0x09	; 9
     c7a:	08 95       	ret
     c7c:	8a e0       	ldi	r24, 0x0A	; 10
     c7e:	08 95       	ret
     c80:	8b e0       	ldi	r24, 0x0B	; 11
     c82:	08 95       	ret
     c84:	81 e0       	ldi	r24, 0x01	; 1
     c86:	08 95       	ret

00000c88 <I2C_init>:
     c88:	11 b8       	out	0x01, r1	; 1
     c8a:	8f ef       	ldi	r24, 0xFF	; 255
     c8c:	80 b9       	out	0x00, r24	; 0
     c8e:	08 95       	ret

00000c90 <I2C_start>:
     c90:	84 ea       	ldi	r24, 0xA4	; 164
     c92:	86 bf       	out	0x36, r24	; 54
     c94:	06 b6       	in	r0, 0x36	; 54
     c96:	07 fe       	sbrs	r0, 7
     c98:	fd cf       	rjmp	.-6      	; 0xc94 <I2C_start+0x4>
     c9a:	0e 94 1e 06 	call	0xc3c	; 0xc3c <getCurrentStatus>
     c9e:	08 95       	ret

00000ca0 <I2C_write>:

EN_I2CMasterStatusCode_t I2C_write(u8 data) {
  TWDR = data;
     ca0:	83 b9       	out	0x03, r24	; 3
  TWCR = (1 << TWEN) | (1 << TWINT);
     ca2:	84 e8       	ldi	r24, 0x84	; 132
     ca4:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWINT) == 0);
     ca6:	06 b6       	in	r0, 0x36	; 54
     ca8:	07 fe       	sbrs	r0, 7
     caa:	fd cf       	rjmp	.-6      	; 0xca6 <I2C_write+0x6>
  return getCurrentStatus();
     cac:	0e 94 1e 06 	call	0xc3c	; 0xc3c <getCurrentStatus>
  }
     cb0:	08 95       	ret

00000cb2 <I2C_read_Ack>:

EN_I2CMasterStatusCode_t I2C_read_Ack(u8* data) {
  TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWINT);
     cb2:	24 ec       	ldi	r18, 0xC4	; 196
     cb4:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     cb6:	06 b6       	in	r0, 0x36	; 54
     cb8:	07 fe       	sbrs	r0, 7
     cba:	fd cf       	rjmp	.-6      	; 0xcb6 <I2C_read_Ack+0x4>
  *data = TWDR;
     cbc:	23 b1       	in	r18, 0x03	; 3
     cbe:	fc 01       	movw	r30, r24
     cc0:	20 83       	st	Z, r18
  return getCurrentStatus();
     cc2:	0e 94 1e 06 	call	0xc3c	; 0xc3c <getCurrentStatus>
  }
     cc6:	08 95       	ret

00000cc8 <I2C_read_Nack>:

EN_I2CMasterStatusCode_t I2C_read_Nack(u8* data) {
  TWCR = (1 << TWEN) | (1 << TWINT);
     cc8:	24 e8       	ldi	r18, 0x84	; 132
     cca:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     ccc:	06 b6       	in	r0, 0x36	; 54
     cce:	07 fe       	sbrs	r0, 7
     cd0:	fd cf       	rjmp	.-6      	; 0xccc <I2C_read_Nack+0x4>
  *data = TWDR;
     cd2:	23 b1       	in	r18, 0x03	; 3
     cd4:	fc 01       	movw	r30, r24
     cd6:	20 83       	st	Z, r18
  return getCurrentStatus();
     cd8:	0e 94 1e 06 	call	0xc3c	; 0xc3c <getCurrentStatus>
  }
     cdc:	08 95       	ret

00000cde <I2C_stop>:

void I2C_stop(void) {
  TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
     cde:	84 e9       	ldi	r24, 0x94	; 148
     ce0:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWSTO));	// Wait until stop condition finishes
     ce2:	06 b6       	in	r0, 0x36	; 54
     ce4:	04 fc       	sbrc	r0, 4
     ce6:	fd cf       	rjmp	.-6      	; 0xce2 <I2C_stop+0x4>
  }
     ce8:	08 95       	ret

00000cea <isValidTimer>:
        clear_bit(TCCR2, COM21);
        set_prescalar(TIMER_2, 0);
        break;
    }
  return TIMER_OK;
  }
     cea:	83 30       	cpi	r24, 0x03	; 3
     cec:	10 f4       	brcc	.+4      	; 0xcf2 <isValidTimer+0x8>
     cee:	81 e0       	ldi	r24, 0x01	; 1
     cf0:	08 95       	ret
     cf2:	80 e0       	ldi	r24, 0x00	; 0
     cf4:	08 95       	ret

00000cf6 <set_prescalar>:
     cf6:	1f 93       	push	r17
     cf8:	cf 93       	push	r28
     cfa:	df 93       	push	r29
     cfc:	18 2f       	mov	r17, r24
     cfe:	eb 01       	movw	r28, r22
     d00:	0e 94 75 06 	call	0xcea	; 0xcea <isValidTimer>
     d04:	88 23       	and	r24, r24
     d06:	09 f4       	brne	.+2      	; 0xd0a <set_prescalar+0x14>
     d08:	6a c1       	rjmp	.+724    	; 0xfde <set_prescalar+0x2e8>
     d0a:	11 30       	cpi	r17, 0x01	; 1
     d0c:	09 f4       	brne	.+2      	; 0xd10 <set_prescalar+0x1a>
     d0e:	6f c0       	rjmp	.+222    	; 0xdee <set_prescalar+0xf8>
     d10:	20 f0       	brcs	.+8      	; 0xd1a <set_prescalar+0x24>
     d12:	12 30       	cpi	r17, 0x02	; 2
     d14:	09 f4       	brne	.+2      	; 0xd18 <set_prescalar+0x22>
     d16:	d5 c0       	rjmp	.+426    	; 0xec2 <set_prescalar+0x1cc>
     d18:	64 c1       	rjmp	.+712    	; 0xfe2 <set_prescalar+0x2ec>
     d1a:	c2 30       	cpi	r28, 0x02	; 2
     d1c:	d1 05       	cpc	r29, r1
     d1e:	78 f0       	brcs	.+30     	; 0xd3e <set_prescalar+0x48>
     d20:	c8 30       	cpi	r28, 0x08	; 8
     d22:	d1 05       	cpc	r29, r1
     d24:	61 f0       	breq	.+24     	; 0xd3e <set_prescalar+0x48>
     d26:	c0 34       	cpi	r28, 0x40	; 64
     d28:	d1 05       	cpc	r29, r1
     d2a:	49 f0       	breq	.+18     	; 0xd3e <set_prescalar+0x48>
     d2c:	c1 15       	cp	r28, r1
     d2e:	81 e0       	ldi	r24, 0x01	; 1
     d30:	d8 07       	cpc	r29, r24
     d32:	29 f0       	breq	.+10     	; 0xd3e <set_prescalar+0x48>
     d34:	c1 15       	cp	r28, r1
     d36:	84 e0       	ldi	r24, 0x04	; 4
     d38:	d8 07       	cpc	r29, r24
     d3a:	09 f0       	breq	.+2      	; 0xd3e <set_prescalar+0x48>
     d3c:	54 c1       	rjmp	.+680    	; 0xfe6 <set_prescalar+0x2f0>
     d3e:	c8 30       	cpi	r28, 0x08	; 8
     d40:	d1 05       	cpc	r29, r1
     d42:	49 f1       	breq	.+82     	; 0xd96 <set_prescalar+0xa0>
     d44:	28 f4       	brcc	.+10     	; 0xd50 <set_prescalar+0x5a>
     d46:	20 97       	sbiw	r28, 0x00	; 0
     d48:	81 f0       	breq	.+32     	; 0xd6a <set_prescalar+0x74>
     d4a:	21 97       	sbiw	r28, 0x01	; 1
     d4c:	c9 f0       	breq	.+50     	; 0xd80 <set_prescalar+0x8a>
     d4e:	4d c1       	rjmp	.+666    	; 0xfea <set_prescalar+0x2f4>
     d50:	c1 15       	cp	r28, r1
     d52:	81 e0       	ldi	r24, 0x01	; 1
     d54:	d8 07       	cpc	r29, r24
     d56:	a9 f1       	breq	.+106    	; 0xdc2 <set_prescalar+0xcc>
     d58:	c1 15       	cp	r28, r1
     d5a:	84 e0       	ldi	r24, 0x04	; 4
     d5c:	d8 07       	cpc	r29, r24
     d5e:	e1 f1       	breq	.+120    	; 0xdd8 <set_prescalar+0xe2>
     d60:	c0 34       	cpi	r28, 0x40	; 64
     d62:	d1 05       	cpc	r29, r1
     d64:	09 f0       	breq	.+2      	; 0xd68 <set_prescalar+0x72>
     d66:	41 c1       	rjmp	.+642    	; 0xfea <set_prescalar+0x2f4>
     d68:	21 c0       	rjmp	.+66     	; 0xdac <set_prescalar+0xb6>
     d6a:	83 b7       	in	r24, 0x33	; 51
     d6c:	8e 7f       	andi	r24, 0xFE	; 254
     d6e:	83 bf       	out	0x33, r24	; 51
     d70:	83 b7       	in	r24, 0x33	; 51
     d72:	8d 7f       	andi	r24, 0xFD	; 253
     d74:	83 bf       	out	0x33, r24	; 51
     d76:	83 b7       	in	r24, 0x33	; 51
     d78:	8b 7f       	andi	r24, 0xFB	; 251
     d7a:	83 bf       	out	0x33, r24	; 51
     d7c:	80 e0       	ldi	r24, 0x00	; 0
     d7e:	3e c1       	rjmp	.+636    	; 0xffc <set_prescalar+0x306>
     d80:	83 b7       	in	r24, 0x33	; 51
     d82:	81 60       	ori	r24, 0x01	; 1
     d84:	83 bf       	out	0x33, r24	; 51
     d86:	83 b7       	in	r24, 0x33	; 51
     d88:	8d 7f       	andi	r24, 0xFD	; 253
     d8a:	83 bf       	out	0x33, r24	; 51
     d8c:	83 b7       	in	r24, 0x33	; 51
     d8e:	8b 7f       	andi	r24, 0xFB	; 251
     d90:	83 bf       	out	0x33, r24	; 51
     d92:	80 e0       	ldi	r24, 0x00	; 0
     d94:	33 c1       	rjmp	.+614    	; 0xffc <set_prescalar+0x306>
     d96:	83 b7       	in	r24, 0x33	; 51
     d98:	8e 7f       	andi	r24, 0xFE	; 254
     d9a:	83 bf       	out	0x33, r24	; 51
     d9c:	83 b7       	in	r24, 0x33	; 51
     d9e:	82 60       	ori	r24, 0x02	; 2
     da0:	83 bf       	out	0x33, r24	; 51
     da2:	83 b7       	in	r24, 0x33	; 51
     da4:	8b 7f       	andi	r24, 0xFB	; 251
     da6:	83 bf       	out	0x33, r24	; 51
     da8:	80 e0       	ldi	r24, 0x00	; 0
     daa:	28 c1       	rjmp	.+592    	; 0xffc <set_prescalar+0x306>
     dac:	83 b7       	in	r24, 0x33	; 51
     dae:	81 60       	ori	r24, 0x01	; 1
     db0:	83 bf       	out	0x33, r24	; 51
     db2:	83 b7       	in	r24, 0x33	; 51
     db4:	82 60       	ori	r24, 0x02	; 2
     db6:	83 bf       	out	0x33, r24	; 51
     db8:	83 b7       	in	r24, 0x33	; 51
     dba:	8b 7f       	andi	r24, 0xFB	; 251
     dbc:	83 bf       	out	0x33, r24	; 51
     dbe:	80 e0       	ldi	r24, 0x00	; 0
     dc0:	1d c1       	rjmp	.+570    	; 0xffc <set_prescalar+0x306>
     dc2:	83 b7       	in	r24, 0x33	; 51
     dc4:	8e 7f       	andi	r24, 0xFE	; 254
     dc6:	83 bf       	out	0x33, r24	; 51
     dc8:	83 b7       	in	r24, 0x33	; 51
     dca:	8d 7f       	andi	r24, 0xFD	; 253
     dcc:	83 bf       	out	0x33, r24	; 51
     dce:	83 b7       	in	r24, 0x33	; 51
     dd0:	84 60       	ori	r24, 0x04	; 4
     dd2:	83 bf       	out	0x33, r24	; 51
     dd4:	80 e0       	ldi	r24, 0x00	; 0
     dd6:	12 c1       	rjmp	.+548    	; 0xffc <set_prescalar+0x306>
     dd8:	83 b7       	in	r24, 0x33	; 51
     dda:	81 60       	ori	r24, 0x01	; 1
     ddc:	83 bf       	out	0x33, r24	; 51
     dde:	83 b7       	in	r24, 0x33	; 51
     de0:	8d 7f       	andi	r24, 0xFD	; 253
     de2:	83 bf       	out	0x33, r24	; 51
     de4:	83 b7       	in	r24, 0x33	; 51
     de6:	84 60       	ori	r24, 0x04	; 4
     de8:	83 bf       	out	0x33, r24	; 51
     dea:	80 e0       	ldi	r24, 0x00	; 0
     dec:	07 c1       	rjmp	.+526    	; 0xffc <set_prescalar+0x306>
     dee:	c2 30       	cpi	r28, 0x02	; 2
     df0:	d1 05       	cpc	r29, r1
     df2:	78 f0       	brcs	.+30     	; 0xe12 <set_prescalar+0x11c>
     df4:	c8 30       	cpi	r28, 0x08	; 8
     df6:	d1 05       	cpc	r29, r1
     df8:	61 f0       	breq	.+24     	; 0xe12 <set_prescalar+0x11c>
     dfa:	c0 34       	cpi	r28, 0x40	; 64
     dfc:	d1 05       	cpc	r29, r1
     dfe:	49 f0       	breq	.+18     	; 0xe12 <set_prescalar+0x11c>
     e00:	c1 15       	cp	r28, r1
     e02:	81 e0       	ldi	r24, 0x01	; 1
     e04:	d8 07       	cpc	r29, r24
     e06:	29 f0       	breq	.+10     	; 0xe12 <set_prescalar+0x11c>
     e08:	c1 15       	cp	r28, r1
     e0a:	84 e0       	ldi	r24, 0x04	; 4
     e0c:	d8 07       	cpc	r29, r24
     e0e:	09 f0       	breq	.+2      	; 0xe12 <set_prescalar+0x11c>
     e10:	ee c0       	rjmp	.+476    	; 0xfee <set_prescalar+0x2f8>
     e12:	c8 30       	cpi	r28, 0x08	; 8
     e14:	d1 05       	cpc	r29, r1
     e16:	49 f1       	breq	.+82     	; 0xe6a <set_prescalar+0x174>
     e18:	28 f4       	brcc	.+10     	; 0xe24 <set_prescalar+0x12e>
     e1a:	20 97       	sbiw	r28, 0x00	; 0
     e1c:	81 f0       	breq	.+32     	; 0xe3e <set_prescalar+0x148>
     e1e:	21 97       	sbiw	r28, 0x01	; 1
     e20:	c9 f0       	breq	.+50     	; 0xe54 <set_prescalar+0x15e>
     e22:	e7 c0       	rjmp	.+462    	; 0xff2 <set_prescalar+0x2fc>
     e24:	c1 15       	cp	r28, r1
     e26:	81 e0       	ldi	r24, 0x01	; 1
     e28:	d8 07       	cpc	r29, r24
     e2a:	a9 f1       	breq	.+106    	; 0xe96 <set_prescalar+0x1a0>
     e2c:	c1 15       	cp	r28, r1
     e2e:	84 e0       	ldi	r24, 0x04	; 4
     e30:	d8 07       	cpc	r29, r24
     e32:	e1 f1       	breq	.+120    	; 0xeac <set_prescalar+0x1b6>
     e34:	c0 34       	cpi	r28, 0x40	; 64
     e36:	d1 05       	cpc	r29, r1
     e38:	09 f0       	breq	.+2      	; 0xe3c <set_prescalar+0x146>
     e3a:	db c0       	rjmp	.+438    	; 0xff2 <set_prescalar+0x2fc>
     e3c:	21 c0       	rjmp	.+66     	; 0xe80 <set_prescalar+0x18a>
     e3e:	8e b5       	in	r24, 0x2e	; 46
     e40:	8e 7f       	andi	r24, 0xFE	; 254
     e42:	8e bd       	out	0x2e, r24	; 46
     e44:	8e b5       	in	r24, 0x2e	; 46
     e46:	8d 7f       	andi	r24, 0xFD	; 253
     e48:	8e bd       	out	0x2e, r24	; 46
     e4a:	8e b5       	in	r24, 0x2e	; 46
     e4c:	8b 7f       	andi	r24, 0xFB	; 251
     e4e:	8e bd       	out	0x2e, r24	; 46
     e50:	80 e0       	ldi	r24, 0x00	; 0
     e52:	d4 c0       	rjmp	.+424    	; 0xffc <set_prescalar+0x306>
     e54:	8e b5       	in	r24, 0x2e	; 46
     e56:	81 60       	ori	r24, 0x01	; 1
     e58:	8e bd       	out	0x2e, r24	; 46
     e5a:	8e b5       	in	r24, 0x2e	; 46
     e5c:	8d 7f       	andi	r24, 0xFD	; 253
     e5e:	8e bd       	out	0x2e, r24	; 46
     e60:	8e b5       	in	r24, 0x2e	; 46
     e62:	8b 7f       	andi	r24, 0xFB	; 251
     e64:	8e bd       	out	0x2e, r24	; 46
     e66:	80 e0       	ldi	r24, 0x00	; 0
     e68:	c9 c0       	rjmp	.+402    	; 0xffc <set_prescalar+0x306>
     e6a:	8e b5       	in	r24, 0x2e	; 46
     e6c:	8e 7f       	andi	r24, 0xFE	; 254
     e6e:	8e bd       	out	0x2e, r24	; 46
     e70:	8e b5       	in	r24, 0x2e	; 46
     e72:	82 60       	ori	r24, 0x02	; 2
     e74:	8e bd       	out	0x2e, r24	; 46
     e76:	8e b5       	in	r24, 0x2e	; 46
     e78:	8b 7f       	andi	r24, 0xFB	; 251
     e7a:	8e bd       	out	0x2e, r24	; 46
     e7c:	80 e0       	ldi	r24, 0x00	; 0
     e7e:	be c0       	rjmp	.+380    	; 0xffc <set_prescalar+0x306>
     e80:	8e b5       	in	r24, 0x2e	; 46
     e82:	81 60       	ori	r24, 0x01	; 1
     e84:	8e bd       	out	0x2e, r24	; 46
     e86:	8e b5       	in	r24, 0x2e	; 46
     e88:	82 60       	ori	r24, 0x02	; 2
     e8a:	8e bd       	out	0x2e, r24	; 46
     e8c:	8e b5       	in	r24, 0x2e	; 46
     e8e:	8b 7f       	andi	r24, 0xFB	; 251
     e90:	8e bd       	out	0x2e, r24	; 46
     e92:	80 e0       	ldi	r24, 0x00	; 0
     e94:	b3 c0       	rjmp	.+358    	; 0xffc <set_prescalar+0x306>
     e96:	8e b5       	in	r24, 0x2e	; 46
     e98:	8e 7f       	andi	r24, 0xFE	; 254
     e9a:	8e bd       	out	0x2e, r24	; 46
     e9c:	8e b5       	in	r24, 0x2e	; 46
     e9e:	8d 7f       	andi	r24, 0xFD	; 253
     ea0:	8e bd       	out	0x2e, r24	; 46
     ea2:	8e b5       	in	r24, 0x2e	; 46
     ea4:	84 60       	ori	r24, 0x04	; 4
     ea6:	8e bd       	out	0x2e, r24	; 46
     ea8:	80 e0       	ldi	r24, 0x00	; 0
     eaa:	a8 c0       	rjmp	.+336    	; 0xffc <set_prescalar+0x306>
     eac:	8e b5       	in	r24, 0x2e	; 46
     eae:	81 60       	ori	r24, 0x01	; 1
     eb0:	8e bd       	out	0x2e, r24	; 46
     eb2:	8e b5       	in	r24, 0x2e	; 46
     eb4:	8d 7f       	andi	r24, 0xFD	; 253
     eb6:	8e bd       	out	0x2e, r24	; 46
     eb8:	8e b5       	in	r24, 0x2e	; 46
     eba:	84 60       	ori	r24, 0x04	; 4
     ebc:	8e bd       	out	0x2e, r24	; 46
     ebe:	80 e0       	ldi	r24, 0x00	; 0
     ec0:	9d c0       	rjmp	.+314    	; 0xffc <set_prescalar+0x306>
     ec2:	c2 30       	cpi	r28, 0x02	; 2
     ec4:	d1 05       	cpc	r29, r1
     ec6:	a8 f0       	brcs	.+42     	; 0xef2 <set_prescalar+0x1fc>
     ec8:	c8 30       	cpi	r28, 0x08	; 8
     eca:	d1 05       	cpc	r29, r1
     ecc:	91 f0       	breq	.+36     	; 0xef2 <set_prescalar+0x1fc>
     ece:	c0 32       	cpi	r28, 0x20	; 32
     ed0:	d1 05       	cpc	r29, r1
     ed2:	79 f0       	breq	.+30     	; 0xef2 <set_prescalar+0x1fc>
     ed4:	c0 34       	cpi	r28, 0x40	; 64
     ed6:	d1 05       	cpc	r29, r1
     ed8:	61 f0       	breq	.+24     	; 0xef2 <set_prescalar+0x1fc>
     eda:	c0 38       	cpi	r28, 0x80	; 128
     edc:	d1 05       	cpc	r29, r1
     ede:	49 f0       	breq	.+18     	; 0xef2 <set_prescalar+0x1fc>
     ee0:	c1 15       	cp	r28, r1
     ee2:	81 e0       	ldi	r24, 0x01	; 1
     ee4:	d8 07       	cpc	r29, r24
     ee6:	29 f0       	breq	.+10     	; 0xef2 <set_prescalar+0x1fc>
     ee8:	c1 15       	cp	r28, r1
     eea:	84 e0       	ldi	r24, 0x04	; 4
     eec:	d8 07       	cpc	r29, r24
     eee:	09 f0       	breq	.+2      	; 0xef2 <set_prescalar+0x1fc>
     ef0:	82 c0       	rjmp	.+260    	; 0xff6 <set_prescalar+0x300>
     ef2:	c0 32       	cpi	r28, 0x20	; 32
     ef4:	d1 05       	cpc	r29, r1
     ef6:	e1 f1       	breq	.+120    	; 0xf70 <set_prescalar+0x27a>
     ef8:	38 f4       	brcc	.+14     	; 0xf08 <set_prescalar+0x212>
     efa:	c1 30       	cpi	r28, 0x01	; 1
     efc:	d1 05       	cpc	r29, r1
     efe:	11 f1       	breq	.+68     	; 0xf44 <set_prescalar+0x24e>
     f00:	b0 f0       	brcs	.+44     	; 0xf2e <set_prescalar+0x238>
     f02:	28 97       	sbiw	r28, 0x08	; 8
     f04:	51 f1       	breq	.+84     	; 0xf5a <set_prescalar+0x264>
     f06:	79 c0       	rjmp	.+242    	; 0xffa <set_prescalar+0x304>
     f08:	c0 38       	cpi	r28, 0x80	; 128
     f0a:	d1 05       	cpc	r29, r1
     f0c:	09 f4       	brne	.+2      	; 0xf10 <set_prescalar+0x21a>
     f0e:	46 c0       	rjmp	.+140    	; 0xf9c <set_prescalar+0x2a6>
     f10:	20 f4       	brcc	.+8      	; 0xf1a <set_prescalar+0x224>
     f12:	c0 34       	cpi	r28, 0x40	; 64
     f14:	d1 05       	cpc	r29, r1
     f16:	b9 f1       	breq	.+110    	; 0xf86 <set_prescalar+0x290>
     f18:	70 c0       	rjmp	.+224    	; 0xffa <set_prescalar+0x304>
     f1a:	c1 15       	cp	r28, r1
     f1c:	81 e0       	ldi	r24, 0x01	; 1
     f1e:	d8 07       	cpc	r29, r24
     f20:	09 f4       	brne	.+2      	; 0xf24 <set_prescalar+0x22e>
     f22:	47 c0       	rjmp	.+142    	; 0xfb2 <set_prescalar+0x2bc>
     f24:	c1 15       	cp	r28, r1
     f26:	d4 40       	sbci	r29, 0x04	; 4
     f28:	09 f4       	brne	.+2      	; 0xf2c <set_prescalar+0x236>
     f2a:	4e c0       	rjmp	.+156    	; 0xfc8 <set_prescalar+0x2d2>
     f2c:	66 c0       	rjmp	.+204    	; 0xffa <set_prescalar+0x304>
     f2e:	85 b5       	in	r24, 0x25	; 37
     f30:	8e 7f       	andi	r24, 0xFE	; 254
     f32:	85 bd       	out	0x25, r24	; 37
     f34:	85 b5       	in	r24, 0x25	; 37
     f36:	8d 7f       	andi	r24, 0xFD	; 253
     f38:	85 bd       	out	0x25, r24	; 37
     f3a:	85 b5       	in	r24, 0x25	; 37
     f3c:	8b 7f       	andi	r24, 0xFB	; 251
     f3e:	85 bd       	out	0x25, r24	; 37
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	5c c0       	rjmp	.+184    	; 0xffc <set_prescalar+0x306>
     f44:	85 b5       	in	r24, 0x25	; 37
     f46:	81 60       	ori	r24, 0x01	; 1
     f48:	85 bd       	out	0x25, r24	; 37
     f4a:	85 b5       	in	r24, 0x25	; 37
     f4c:	8d 7f       	andi	r24, 0xFD	; 253
     f4e:	85 bd       	out	0x25, r24	; 37
     f50:	85 b5       	in	r24, 0x25	; 37
     f52:	8b 7f       	andi	r24, 0xFB	; 251
     f54:	85 bd       	out	0x25, r24	; 37
     f56:	80 e0       	ldi	r24, 0x00	; 0
     f58:	51 c0       	rjmp	.+162    	; 0xffc <set_prescalar+0x306>
     f5a:	85 b5       	in	r24, 0x25	; 37
     f5c:	8e 7f       	andi	r24, 0xFE	; 254
     f5e:	85 bd       	out	0x25, r24	; 37
     f60:	85 b5       	in	r24, 0x25	; 37
     f62:	82 60       	ori	r24, 0x02	; 2
     f64:	85 bd       	out	0x25, r24	; 37
     f66:	85 b5       	in	r24, 0x25	; 37
     f68:	8b 7f       	andi	r24, 0xFB	; 251
     f6a:	85 bd       	out	0x25, r24	; 37
     f6c:	80 e0       	ldi	r24, 0x00	; 0
     f6e:	46 c0       	rjmp	.+140    	; 0xffc <set_prescalar+0x306>
     f70:	85 b5       	in	r24, 0x25	; 37
     f72:	81 60       	ori	r24, 0x01	; 1
     f74:	85 bd       	out	0x25, r24	; 37
     f76:	85 b5       	in	r24, 0x25	; 37
     f78:	82 60       	ori	r24, 0x02	; 2
     f7a:	85 bd       	out	0x25, r24	; 37
     f7c:	85 b5       	in	r24, 0x25	; 37
     f7e:	8b 7f       	andi	r24, 0xFB	; 251
     f80:	85 bd       	out	0x25, r24	; 37
     f82:	80 e0       	ldi	r24, 0x00	; 0
     f84:	3b c0       	rjmp	.+118    	; 0xffc <set_prescalar+0x306>
     f86:	85 b5       	in	r24, 0x25	; 37
     f88:	8e 7f       	andi	r24, 0xFE	; 254
     f8a:	85 bd       	out	0x25, r24	; 37
     f8c:	85 b5       	in	r24, 0x25	; 37
     f8e:	8d 7f       	andi	r24, 0xFD	; 253
     f90:	85 bd       	out	0x25, r24	; 37
     f92:	85 b5       	in	r24, 0x25	; 37
     f94:	84 60       	ori	r24, 0x04	; 4
     f96:	85 bd       	out	0x25, r24	; 37
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	30 c0       	rjmp	.+96     	; 0xffc <set_prescalar+0x306>
     f9c:	85 b5       	in	r24, 0x25	; 37
     f9e:	81 60       	ori	r24, 0x01	; 1
     fa0:	85 bd       	out	0x25, r24	; 37
     fa2:	85 b5       	in	r24, 0x25	; 37
     fa4:	8d 7f       	andi	r24, 0xFD	; 253
     fa6:	85 bd       	out	0x25, r24	; 37
     fa8:	85 b5       	in	r24, 0x25	; 37
     faa:	84 60       	ori	r24, 0x04	; 4
     fac:	85 bd       	out	0x25, r24	; 37
     fae:	80 e0       	ldi	r24, 0x00	; 0
     fb0:	25 c0       	rjmp	.+74     	; 0xffc <set_prescalar+0x306>
     fb2:	85 b5       	in	r24, 0x25	; 37
     fb4:	8e 7f       	andi	r24, 0xFE	; 254
     fb6:	85 bd       	out	0x25, r24	; 37
     fb8:	85 b5       	in	r24, 0x25	; 37
     fba:	82 60       	ori	r24, 0x02	; 2
     fbc:	85 bd       	out	0x25, r24	; 37
     fbe:	85 b5       	in	r24, 0x25	; 37
     fc0:	84 60       	ori	r24, 0x04	; 4
     fc2:	85 bd       	out	0x25, r24	; 37
     fc4:	80 e0       	ldi	r24, 0x00	; 0
     fc6:	1a c0       	rjmp	.+52     	; 0xffc <set_prescalar+0x306>
     fc8:	85 b5       	in	r24, 0x25	; 37
     fca:	81 60       	ori	r24, 0x01	; 1
     fcc:	85 bd       	out	0x25, r24	; 37
     fce:	85 b5       	in	r24, 0x25	; 37
     fd0:	82 60       	ori	r24, 0x02	; 2
     fd2:	85 bd       	out	0x25, r24	; 37
     fd4:	85 b5       	in	r24, 0x25	; 37
     fd6:	84 60       	ori	r24, 0x04	; 4
     fd8:	85 bd       	out	0x25, r24	; 37
     fda:	80 e0       	ldi	r24, 0x00	; 0
     fdc:	0f c0       	rjmp	.+30     	; 0xffc <set_prescalar+0x306>
     fde:	81 e0       	ldi	r24, 0x01	; 1
     fe0:	0d c0       	rjmp	.+26     	; 0xffc <set_prescalar+0x306>
     fe2:	80 e0       	ldi	r24, 0x00	; 0
     fe4:	0b c0       	rjmp	.+22     	; 0xffc <set_prescalar+0x306>
     fe6:	82 e0       	ldi	r24, 0x02	; 2
     fe8:	09 c0       	rjmp	.+18     	; 0xffc <set_prescalar+0x306>
     fea:	80 e0       	ldi	r24, 0x00	; 0
     fec:	07 c0       	rjmp	.+14     	; 0xffc <set_prescalar+0x306>
     fee:	82 e0       	ldi	r24, 0x02	; 2
     ff0:	05 c0       	rjmp	.+10     	; 0xffc <set_prescalar+0x306>
     ff2:	80 e0       	ldi	r24, 0x00	; 0
     ff4:	03 c0       	rjmp	.+6      	; 0xffc <set_prescalar+0x306>
     ff6:	82 e0       	ldi	r24, 0x02	; 2
     ff8:	01 c0       	rjmp	.+2      	; 0xffc <set_prescalar+0x306>
     ffa:	80 e0       	ldi	r24, 0x00	; 0
     ffc:	df 91       	pop	r29
     ffe:	cf 91       	pop	r28
    1000:	1f 91       	pop	r17
    1002:	08 95       	ret

00001004 <Timer_start>:
    1004:	0f 93       	push	r16
    1006:	1f 93       	push	r17
    1008:	cf 93       	push	r28
    100a:	c8 2f       	mov	r28, r24
    100c:	8b 01       	movw	r16, r22
    100e:	0e 94 75 06 	call	0xcea	; 0xcea <isValidTimer>
    1012:	88 23       	and	r24, r24
    1014:	31 f0       	breq	.+12     	; 0x1022 <Timer_start+0x1e>
    1016:	b8 01       	movw	r22, r16
    1018:	8c 2f       	mov	r24, r28
    101a:	0e 94 7b 06 	call	0xcf6	; 0xcf6 <set_prescalar>
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	01 c0       	rjmp	.+2      	; 0x1024 <Timer_start+0x20>
    1022:	81 e0       	ldi	r24, 0x01	; 1
    1024:	cf 91       	pop	r28
    1026:	1f 91       	pop	r17
    1028:	0f 91       	pop	r16
    102a:	08 95       	ret

0000102c <PWM_OCP_disconnect>:

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    102c:	84 30       	cpi	r24, 0x04	; 4
    102e:	40 f5       	brcc	.+80     	; 0x1080 <PWM_OCP_disconnect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    1030:	81 30       	cpi	r24, 0x01	; 1
    1032:	71 f0       	breq	.+28     	; 0x1050 <PWM_OCP_disconnect+0x24>
    1034:	28 f0       	brcs	.+10     	; 0x1040 <PWM_OCP_disconnect+0x14>
    1036:	82 30       	cpi	r24, 0x02	; 2
    1038:	99 f0       	breq	.+38     	; 0x1060 <PWM_OCP_disconnect+0x34>
    103a:	83 30       	cpi	r24, 0x03	; 3
    103c:	c9 f0       	breq	.+50     	; 0x1070 <PWM_OCP_disconnect+0x44>
    103e:	22 c0       	rjmp	.+68     	; 0x1084 <PWM_OCP_disconnect+0x58>
      case OC_0:
        clear_bit(TCCR0, COM00);
    1040:	83 b7       	in	r24, 0x33	; 51
    1042:	8f 7e       	andi	r24, 0xEF	; 239
    1044:	83 bf       	out	0x33, r24	; 51
        clear_bit(TCCR0, COM01);
    1046:	83 b7       	in	r24, 0x33	; 51
    1048:	8f 7d       	andi	r24, 0xDF	; 223
    104a:	83 bf       	out	0x33, r24	; 51
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    104c:	80 e0       	ldi	r24, 0x00	; 0
    }
  switch (pwmPin) {
      case OC_0:
        clear_bit(TCCR0, COM00);
        clear_bit(TCCR0, COM01);
        break;
    104e:	08 95       	ret
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
    1050:	8f b5       	in	r24, 0x2f	; 47
    1052:	8f 7b       	andi	r24, 0xBF	; 191
    1054:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1A1);
    1056:	8f b5       	in	r24, 0x2f	; 47
    1058:	8f 77       	andi	r24, 0x7F	; 127
    105a:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    105c:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR0, COM01);
        break;
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
        clear_bit(TCCR1A, COM1A1);
        break;
    105e:	08 95       	ret
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
    1060:	8f b5       	in	r24, 0x2f	; 47
    1062:	8f 7e       	andi	r24, 0xEF	; 239
    1064:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1B1);
    1066:	8f b5       	in	r24, 0x2f	; 47
    1068:	8f 7d       	andi	r24, 0xDF	; 223
    106a:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    106c:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1A1);
        break;
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
        clear_bit(TCCR1A, COM1B1);
        break;
    106e:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
    1070:	85 b5       	in	r24, 0x25	; 37
    1072:	8f 7e       	andi	r24, 0xEF	; 239
    1074:	85 bd       	out	0x25, r24	; 37
        clear_bit(TCCR2, COM21);
    1076:	85 b5       	in	r24, 0x25	; 37
    1078:	8f 7d       	andi	r24, 0xDF	; 223
    107a:	85 bd       	out	0x25, r24	; 37
        break;
    }
  return TIMER_OK;
    107c:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1B1);
        break;
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    107e:	08 95       	ret
  }

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    1080:	87 e0       	ldi	r24, 0x07	; 7
    1082:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1084:	80 e0       	ldi	r24, 0x00	; 0
  }
    1086:	08 95       	ret

00001088 <PWM_OCP_connect>:

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    1088:	84 30       	cpi	r24, 0x04	; 4
    108a:	40 f5       	brcc	.+80     	; 0x10dc <PWM_OCP_connect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    108c:	81 30       	cpi	r24, 0x01	; 1
    108e:	71 f0       	breq	.+28     	; 0x10ac <PWM_OCP_connect+0x24>
    1090:	28 f0       	brcs	.+10     	; 0x109c <PWM_OCP_connect+0x14>
    1092:	82 30       	cpi	r24, 0x02	; 2
    1094:	99 f0       	breq	.+38     	; 0x10bc <PWM_OCP_connect+0x34>
    1096:	83 30       	cpi	r24, 0x03	; 3
    1098:	c9 f0       	breq	.+50     	; 0x10cc <PWM_OCP_connect+0x44>
    109a:	22 c0       	rjmp	.+68     	; 0x10e0 <PWM_OCP_connect+0x58>
      case OC_0:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR0, COM00);
    109c:	83 b7       	in	r24, 0x33	; 51
    109e:	8f 7e       	andi	r24, 0xEF	; 239
    10a0:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR0, COM01);
    10a2:	83 b7       	in	r24, 0x33	; 51
    10a4:	80 62       	ori	r24, 0x20	; 32
    10a6:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    10a8:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR0, COM01);
#else 
        set_bit(TCCR0, COM00);
        set_bit(TCCR0, COM01);
#endif
        break;
    10aa:	08 95       	ret
      case OC_1A:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1A0);
    10ac:	8f b5       	in	r24, 0x2f	; 47
    10ae:	8f 7b       	andi	r24, 0xBF	; 191
    10b0:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1A1);
    10b2:	8f b5       	in	r24, 0x2f	; 47
    10b4:	80 68       	ori	r24, 0x80	; 128
    10b6:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    10b8:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1A1);
#else 
        set_bit(TCCR1A, COM1A0);
        set_bit(TCCR1A, COM1A1);
#endif
        break;
    10ba:	08 95       	ret
      case OC_1B:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1B0);
    10bc:	8f b5       	in	r24, 0x2f	; 47
    10be:	8f 7e       	andi	r24, 0xEF	; 239
    10c0:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1B1);
    10c2:	8f b5       	in	r24, 0x2f	; 47
    10c4:	80 62       	ori	r24, 0x20	; 32
    10c6:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    10c8:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1B1);
#else 
        set_bit(TCCR1A, COM1B0);
        set_bit(TCCR1A, COM1B1);
#endif
        break;
    10ca:	08 95       	ret
      case OC_2:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR2, COM20);
    10cc:	85 b5       	in	r24, 0x25	; 37
    10ce:	8f 7e       	andi	r24, 0xEF	; 239
    10d0:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM21);
    10d2:	85 b5       	in	r24, 0x25	; 37
    10d4:	80 62       	ori	r24, 0x20	; 32
    10d6:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    10d8:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR2, COM21);
#else 
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    10da:	08 95       	ret
  }

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    10dc:	87 e0       	ldi	r24, 0x07	; 7
    10de:	08 95       	ret
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    10e0:	80 e0       	ldi	r24, 0x00	; 0
  }
    10e2:	08 95       	ret

000010e4 <PWM_init>:
  return TIMER_OK;
  }

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
    10e4:	cf 92       	push	r12
    10e6:	df 92       	push	r13
    10e8:	ef 92       	push	r14
    10ea:	ff 92       	push	r15
    10ec:	cf 93       	push	r28
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    10ee:	84 30       	cpi	r24, 0x04	; 4
    10f0:	08 f0       	brcs	.+2      	; 0x10f4 <PWM_init+0x10>
    10f2:	96 c0       	rjmp	.+300    	; 0x1220 <PWM_init+0x13c>
    return WRONG_PWM_PIN;
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    10f4:	9f ef       	ldi	r25, 0xFF	; 255
    10f6:	92 0f       	add	r25, r18
    10f8:	92 30       	cpi	r25, 0x02	; 2
    10fa:	08 f0       	brcs	.+2      	; 0x10fe <PWM_init+0x1a>
    10fc:	93 c0       	rjmp	.+294    	; 0x1224 <PWM_init+0x140>
    10fe:	6a 01       	movw	r12, r20
    1100:	7b 01       	movw	r14, r22
    1102:	c8 2f       	mov	r28, r24
    return WRONG_PWM_MODE;
    }
  switch (pwmPin) {
    1104:	83 30       	cpi	r24, 0x03	; 3
    1106:	18 f4       	brcc	.+6      	; 0x110e <PWM_init+0x2a>
    1108:	81 30       	cpi	r24, 0x01	; 1
    110a:	28 f0       	brcs	.+10     	; 0x1116 <PWM_init+0x32>
    110c:	22 c0       	rjmp	.+68     	; 0x1152 <PWM_init+0x6e>
    110e:	83 30       	cpi	r24, 0x03	; 3
    1110:	09 f4       	brne	.+2      	; 0x1114 <PWM_init+0x30>
    1112:	64 c0       	rjmp	.+200    	; 0x11dc <PWM_init+0xf8>
    1114:	80 c0       	rjmp	.+256    	; 0x1216 <PWM_init+0x132>
      case OC_0:
        switch (mode) {
    1116:	21 30       	cpi	r18, 0x01	; 1
    1118:	19 f0       	breq	.+6      	; 0x1120 <PWM_init+0x3c>
    111a:	22 30       	cpi	r18, 0x02	; 2
    111c:	41 f0       	breq	.+16     	; 0x112e <PWM_init+0x4a>
    111e:	0d c0       	rjmp	.+26     	; 0x113a <PWM_init+0x56>
            case PWM_FAST:
              set_bit(TCCR0, WGM00);
    1120:	83 b7       	in	r24, 0x33	; 51
    1122:	80 64       	ori	r24, 0x40	; 64
    1124:	83 bf       	out	0x33, r24	; 51
              set_bit(TCCR0, WGM01);
    1126:	83 b7       	in	r24, 0x33	; 51
    1128:	88 60       	ori	r24, 0x08	; 8
    112a:	83 bf       	out	0x33, r24	; 51
              break;
    112c:	06 c0       	rjmp	.+12     	; 0x113a <PWM_init+0x56>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR0, WGM00);
    112e:	83 b7       	in	r24, 0x33	; 51
    1130:	80 64       	ori	r24, 0x40	; 64
    1132:	83 bf       	out	0x33, r24	; 51
              clear_bit(TCCR0, WGM01);
    1134:	83 b7       	in	r24, 0x33	; 51
    1136:	87 7f       	andi	r24, 0xF7	; 247
    1138:	83 bf       	out	0x33, r24	; 51
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR0 = (u8)(dutyCycle * 255);
    113a:	20 e0       	ldi	r18, 0x00	; 0
    113c:	30 e0       	ldi	r19, 0x00	; 0
    113e:	4f e7       	ldi	r20, 0x7F	; 127
    1140:	53 e4       	ldi	r21, 0x43	; 67
    1142:	c7 01       	movw	r24, r14
    1144:	b6 01       	movw	r22, r12
    1146:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__mulsf3>
    114a:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <__fixunssfsi>
    114e:	6c bf       	out	0x3c, r22	; 60
        break;
    1150:	62 c0       	rjmp	.+196    	; 0x1216 <PWM_init+0x132>
        //? The fix for this issue is to use ICR1 as TOP instead (mode 14 in fast pwm), thus allowing OCR1A and OCR1B to be used to set the duty cycle while ICR1 is used tyo set the frequency.
        //? Mode 15 can be used at the cost of disabling PWM on OC1A, but we get more glitch-free variable frequency PWM signal on OC1B due to the double buffering of OC1A, which ICR1 doesn't have.
        //? Since I don't need a variable frequency pwm signal, ICR1 will be used as TOP by default and set to MAX.
      case OC_1A:
      case OC_1B:
        switch (mode) {
    1152:	21 30       	cpi	r18, 0x01	; 1
    1154:	19 f0       	breq	.+6      	; 0x115c <PWM_init+0x78>
    1156:	22 30       	cpi	r18, 0x02	; 2
    1158:	91 f0       	breq	.+36     	; 0x117e <PWM_init+0x9a>
    115a:	21 c0       	rjmp	.+66     	; 0x119e <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
    115c:	8f b5       	in	r24, 0x2f	; 47
    115e:	8e 7f       	andi	r24, 0xFE	; 254
    1160:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
    1162:	8f b5       	in	r24, 0x2f	; 47
    1164:	82 60       	ori	r24, 0x02	; 2
    1166:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1B, WGM12);
    1168:	8e b5       	in	r24, 0x2e	; 46
    116a:	88 60       	ori	r24, 0x08	; 8
    116c:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
    116e:	8e b5       	in	r24, 0x2e	; 46
    1170:	80 61       	ori	r24, 0x10	; 16
    1172:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
    1174:	80 e2       	ldi	r24, 0x20	; 32
    1176:	9e e4       	ldi	r25, 0x4E	; 78
    1178:	97 bd       	out	0x27, r25	; 39
    117a:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              set_bit(TCCR1B, WGM13);
#endif
              break;
    117c:	10 c0       	rjmp	.+32     	; 0x119e <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              clear_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
    117e:	8f b5       	in	r24, 0x2f	; 47
    1180:	8e 7f       	andi	r24, 0xFE	; 254
    1182:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
    1184:	8f b5       	in	r24, 0x2f	; 47
    1186:	82 60       	ori	r24, 0x02	; 2
    1188:	8f bd       	out	0x2f, r24	; 47
              clear_bit(TCCR1B, WGM12);
    118a:	8e b5       	in	r24, 0x2e	; 46
    118c:	87 7f       	andi	r24, 0xF7	; 247
    118e:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
    1190:	8e b5       	in	r24, 0x2e	; 46
    1192:	80 61       	ori	r24, 0x10	; 16
    1194:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
    1196:	80 e2       	ldi	r24, 0x20	; 32
    1198:	9e e4       	ldi	r25, 0x4E	; 78
    119a:	97 bd       	out	0x27, r25	; 39
    119c:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1B, WGM13);
#endif
              break;
          }
        // Enable the PWM function of the OC pin.
        switch (pwmPin) {
    119e:	c1 30       	cpi	r28, 0x01	; 1
    11a0:	19 f0       	breq	.+6      	; 0x11a8 <PWM_init+0xc4>
    11a2:	c2 30       	cpi	r28, 0x02	; 2
    11a4:	71 f0       	breq	.+28     	; 0x11c2 <PWM_init+0xde>
    11a6:	37 c0       	rjmp	.+110    	; 0x1216 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    11a8:	20 e0       	ldi	r18, 0x00	; 0
    11aa:	30 e4       	ldi	r19, 0x40	; 64
    11ac:	4c e9       	ldi	r20, 0x9C	; 156
    11ae:	56 e4       	ldi	r21, 0x46	; 70
    11b0:	c7 01       	movw	r24, r14
    11b2:	b6 01       	movw	r22, r12
    11b4:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__mulsf3>
    11b8:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <__fixunssfsi>
    11bc:	7b bd       	out	0x2b, r23	; 43
    11be:	6a bd       	out	0x2a, r22	; 42
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1A = (u16)(dutyCycle * 65535);
#endif
              break;
    11c0:	2a c0       	rjmp	.+84     	; 0x1216 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    11c2:	20 e0       	ldi	r18, 0x00	; 0
    11c4:	30 e4       	ldi	r19, 0x40	; 64
    11c6:	4c e9       	ldi	r20, 0x9C	; 156
    11c8:	56 e4       	ldi	r21, 0x46	; 70
    11ca:	c7 01       	movw	r24, r14
    11cc:	b6 01       	movw	r22, r12
    11ce:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__mulsf3>
    11d2:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <__fixunssfsi>
    11d6:	79 bd       	out	0x29, r23	; 41
    11d8:	68 bd       	out	0x28, r22	; 40
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1B = (u16)(dutyCycle * 65535);
#endif
              break;
    11da:	1d c0       	rjmp	.+58     	; 0x1216 <PWM_init+0x132>
          }
        break;
      case OC_2:
        switch (mode) {
    11dc:	21 30       	cpi	r18, 0x01	; 1
    11de:	19 f0       	breq	.+6      	; 0x11e6 <PWM_init+0x102>
    11e0:	22 30       	cpi	r18, 0x02	; 2
    11e2:	41 f0       	breq	.+16     	; 0x11f4 <PWM_init+0x110>
    11e4:	0d c0       	rjmp	.+26     	; 0x1200 <PWM_init+0x11c>
            case PWM_FAST:
              set_bit(TCCR2, WGM20);
    11e6:	85 b5       	in	r24, 0x25	; 37
    11e8:	80 64       	ori	r24, 0x40	; 64
    11ea:	85 bd       	out	0x25, r24	; 37
              set_bit(TCCR2, WGM21);
    11ec:	85 b5       	in	r24, 0x25	; 37
    11ee:	88 60       	ori	r24, 0x08	; 8
    11f0:	85 bd       	out	0x25, r24	; 37
              break;
    11f2:	06 c0       	rjmp	.+12     	; 0x1200 <PWM_init+0x11c>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR2, WGM20);
    11f4:	85 b5       	in	r24, 0x25	; 37
    11f6:	80 64       	ori	r24, 0x40	; 64
    11f8:	85 bd       	out	0x25, r24	; 37
              clear_bit(TCCR2, WGM21);
    11fa:	85 b5       	in	r24, 0x25	; 37
    11fc:	87 7f       	andi	r24, 0xF7	; 247
    11fe:	85 bd       	out	0x25, r24	; 37
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR2 = (u8)(dutyCycle * 255);
    1200:	20 e0       	ldi	r18, 0x00	; 0
    1202:	30 e0       	ldi	r19, 0x00	; 0
    1204:	4f e7       	ldi	r20, 0x7F	; 127
    1206:	53 e4       	ldi	r21, 0x43	; 67
    1208:	c7 01       	movw	r24, r14
    120a:	b6 01       	movw	r22, r12
    120c:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__mulsf3>
    1210:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <__fixunssfsi>
    1214:	63 bd       	out	0x23, r22	; 35
        break;
    }
  PWM_OCP_connect(pwmPin);
    1216:	8c 2f       	mov	r24, r28
    1218:	0e 94 44 08 	call	0x1088	; 0x1088 <PWM_OCP_connect>
  return TIMER_OK;
    121c:	80 e0       	ldi	r24, 0x00	; 0
    121e:	03 c0       	rjmp	.+6      	; 0x1226 <PWM_init+0x142>

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    1220:	87 e0       	ldi	r24, 0x07	; 7
    1222:	01 c0       	rjmp	.+2      	; 0x1226 <PWM_init+0x142>
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    return WRONG_PWM_MODE;
    1224:	86 e0       	ldi	r24, 0x06	; 6
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  PWM_OCP_connect(pwmPin);
  return TIMER_OK;
  }
    1226:	cf 91       	pop	r28
    1228:	ff 90       	pop	r15
    122a:	ef 90       	pop	r14
    122c:	df 90       	pop	r13
    122e:	cf 90       	pop	r12
    1230:	08 95       	ret

00001232 <PWM_set_DC>:
    }
  return TIMER_OK;
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
    1232:	28 2f       	mov	r18, r24
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    1234:	84 30       	cpi	r24, 0x04	; 4
    1236:	c0 f5       	brcc	.+112    	; 0x12a8 <PWM_set_DC+0x76>
    1238:	cb 01       	movw	r24, r22
    123a:	ba 01       	movw	r22, r20
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    123c:	21 30       	cpi	r18, 0x01	; 1
    123e:	89 f0       	breq	.+34     	; 0x1262 <PWM_set_DC+0x30>
    1240:	28 f0       	brcs	.+10     	; 0x124c <PWM_set_DC+0x1a>
    1242:	22 30       	cpi	r18, 0x02	; 2
    1244:	d1 f0       	breq	.+52     	; 0x127a <PWM_set_DC+0x48>
    1246:	23 30       	cpi	r18, 0x03	; 3
    1248:	21 f1       	breq	.+72     	; 0x1292 <PWM_set_DC+0x60>
    124a:	30 c0       	rjmp	.+96     	; 0x12ac <PWM_set_DC+0x7a>
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
    124c:	20 e0       	ldi	r18, 0x00	; 0
    124e:	30 e0       	ldi	r19, 0x00	; 0
    1250:	4f e7       	ldi	r20, 0x7F	; 127
    1252:	53 e4       	ldi	r21, 0x43	; 67
    1254:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__mulsf3>
    1258:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <__fixunssfsi>
    125c:	6c bf       	out	0x3c, r22	; 60
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    125e:	80 e0       	ldi	r24, 0x00	; 0
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
        break;
    1260:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    1262:	20 e0       	ldi	r18, 0x00	; 0
    1264:	30 e4       	ldi	r19, 0x40	; 64
    1266:	4c e9       	ldi	r20, 0x9C	; 156
    1268:	56 e4       	ldi	r21, 0x46	; 70
    126a:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__mulsf3>
    126e:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <__fixunssfsi>
    1272:	7b bd       	out	0x2b, r23	; 43
    1274:	6a bd       	out	0x2a, r22	; 42
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    1276:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1A = (u16)(dutyCycle * 65535);
#endif
        break;
    1278:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    127a:	20 e0       	ldi	r18, 0x00	; 0
    127c:	30 e4       	ldi	r19, 0x40	; 64
    127e:	4c e9       	ldi	r20, 0x9C	; 156
    1280:	56 e4       	ldi	r21, 0x46	; 70
    1282:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__mulsf3>
    1286:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <__fixunssfsi>
    128a:	79 bd       	out	0x29, r23	; 41
    128c:	68 bd       	out	0x28, r22	; 40
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    128e:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
    1290:	08 95       	ret
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
    1292:	20 e0       	ldi	r18, 0x00	; 0
    1294:	30 e0       	ldi	r19, 0x00	; 0
    1296:	4f e7       	ldi	r20, 0x7F	; 127
    1298:	53 e4       	ldi	r21, 0x43	; 67
    129a:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__mulsf3>
    129e:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <__fixunssfsi>
    12a2:	63 bd       	out	0x23, r22	; 35
        break;
    }
  return TIMER_OK;
    12a4:	80 e0       	ldi	r24, 0x00	; 0
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    12a6:	08 95       	ret
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    12a8:	87 e0       	ldi	r24, 0x07	; 7
    12aa:	08 95       	ret
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    12ac:	80 e0       	ldi	r24, 0x00	; 0
  }
    12ae:	08 95       	ret

000012b0 <UART_sendChar>:
  }

// Receive a Char using UART
void UART_receiveChar(s8* x) {
  while (!read_bit(UCSRA, RXC)); // Wait for the data to be received.
  *x = UDR;
    12b0:	5d 9b       	sbis	0x0b, 5	; 11
    12b2:	fe cf       	rjmp	.-4      	; 0x12b0 <UART_sendChar>
    12b4:	8c b9       	out	0x0c, r24	; 12
    12b6:	5e 9b       	sbis	0x0b, 6	; 11
    12b8:	fe cf       	rjmp	.-4      	; 0x12b6 <UART_sendChar+0x6>
    12ba:	08 95       	ret

000012bc <UART_sendString>:
  }

void UART_sendString(s8* str) {
    12bc:	cf 92       	push	r12
    12be:	df 92       	push	r13
    12c0:	ef 92       	push	r14
    12c2:	ff 92       	push	r15
    12c4:	cf 93       	push	r28
    12c6:	df 93       	push	r29
    12c8:	ec 01       	movw	r28, r24
  u32 i = 0;
    12ca:	c1 2c       	mov	r12, r1
    12cc:	d1 2c       	mov	r13, r1
    12ce:	76 01       	movw	r14, r12
  while (str[i] != 0) {
    12d0:	07 c0       	rjmp	.+14     	; 0x12e0 <UART_sendString+0x24>
    UART_sendChar(str[i]);
    12d2:	0e 94 58 09 	call	0x12b0	; 0x12b0 <UART_sendChar>
    i++;
    12d6:	8f ef       	ldi	r24, 0xFF	; 255
    12d8:	c8 1a       	sub	r12, r24
    12da:	d8 0a       	sbc	r13, r24
    12dc:	e8 0a       	sbc	r14, r24
    12de:	f8 0a       	sbc	r15, r24
  *x = UDR;
  }

void UART_sendString(s8* str) {
  u32 i = 0;
  while (str[i] != 0) {
    12e0:	fe 01       	movw	r30, r28
    12e2:	ec 0d       	add	r30, r12
    12e4:	fd 1d       	adc	r31, r13
    12e6:	80 81       	ld	r24, Z
    12e8:	81 11       	cpse	r24, r1
    12ea:	f3 cf       	rjmp	.-26     	; 0x12d2 <UART_sendString+0x16>
    UART_sendChar(str[i]);
    i++;
    }
  UART_sendChar(0); // Send null to terminate the string
    12ec:	0e 94 58 09 	call	0x12b0	; 0x12b0 <UART_sendChar>
  }
    12f0:	df 91       	pop	r29
    12f2:	cf 91       	pop	r28
    12f4:	ff 90       	pop	r15
    12f6:	ef 90       	pop	r14
    12f8:	df 90       	pop	r13
    12fa:	cf 90       	pop	r12
    12fc:	08 95       	ret

000012fe <Door_open>:
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
  }

// Open the door by moving the servo to the open angle
void Door_open(void) {
  Servo_move_to_angle(DOOR_OPEN_ANGLE);
    12fe:	84 eb       	ldi	r24, 0xB4	; 180
    1300:	0e 94 01 04 	call	0x802	; 0x802 <Servo_move_to_angle>
    1304:	08 95       	ret

00001306 <Door_close>:
  }

// Close the door by moving the servo to the close angle
void Door_close(void) {
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    1306:	80 e0       	ldi	r24, 0x00	; 0
    1308:	0e 94 01 04 	call	0x802	; 0x802 <Servo_move_to_angle>
    130c:	08 95       	ret

0000130e <Lamps_init>:

#include "lights.h"

 // Initializes all six lamps
void Lamps_init(void) {
  LED_init(LAMP_1_PORT, LAMP_1_PIN);
    130e:	62 e0       	ldi	r22, 0x02	; 2
    1310:	83 e4       	ldi	r24, 0x43	; 67
    1312:	0e 94 de 03 	call	0x7bc	; 0x7bc <LED_init>
  LED_init(LAMP_2_PORT, LAMP_2_PIN);
    1316:	63 e0       	ldi	r22, 0x03	; 3
    1318:	83 e4       	ldi	r24, 0x43	; 67
    131a:	0e 94 de 03 	call	0x7bc	; 0x7bc <LED_init>
  LED_init(LAMP_3_PORT, LAMP_3_PIN);
    131e:	64 e0       	ldi	r22, 0x04	; 4
    1320:	83 e4       	ldi	r24, 0x43	; 67
    1322:	0e 94 de 03 	call	0x7bc	; 0x7bc <LED_init>
  LED_init(LAMP_4_PORT, LAMP_4_PIN);
    1326:	65 e0       	ldi	r22, 0x05	; 5
    1328:	83 e4       	ldi	r24, 0x43	; 67
    132a:	0e 94 de 03 	call	0x7bc	; 0x7bc <LED_init>
  LED_init(LAMP_5_PORT, LAMP_5_PIN);
    132e:	66 e0       	ldi	r22, 0x06	; 6
    1330:	83 e4       	ldi	r24, 0x43	; 67
    1332:	0e 94 de 03 	call	0x7bc	; 0x7bc <LED_init>
  LED_init(LAMP_6_DIMMABLE_PORT, LAMP_6_DIMMABLE_PIN);
    1336:	67 e0       	ldi	r22, 0x07	; 7
    1338:	84 e4       	ldi	r24, 0x44	; 68
    133a:	0e 94 de 03 	call	0x7bc	; 0x7bc <LED_init>
  // Initialize the pwm pin which lamp6 is on for brightness control
  PWM_init(LAMP_6_DIMMABLE_PWM_PIN, 0, PWM_FAST);
    133e:	21 e0       	ldi	r18, 0x01	; 1
    1340:	40 e0       	ldi	r20, 0x00	; 0
    1342:	50 e0       	ldi	r21, 0x00	; 0
    1344:	ba 01       	movw	r22, r20
    1346:	83 e0       	ldi	r24, 0x03	; 3
    1348:	0e 94 72 08 	call	0x10e4	; 0x10e4 <PWM_init>

  Timer_start(TIMER_2, LAMP_6_DIMMABLE_PRESCALAR);
    134c:	60 e0       	ldi	r22, 0x00	; 0
    134e:	71 e0       	ldi	r23, 0x01	; 1
    1350:	82 e0       	ldi	r24, 0x02	; 2
    1352:	0e 94 02 08 	call	0x1004	; 0x1004 <Timer_start>
    1356:	08 95       	ret

00001358 <Lamp_on>:
  }

// Turn on a lamp
void Lamp_on(u8 lampNumber) {
  switch (lampNumber) {
    1358:	83 30       	cpi	r24, 0x03	; 3
    135a:	b1 f0       	breq	.+44     	; 0x1388 <Lamp_on+0x30>
    135c:	28 f4       	brcc	.+10     	; 0x1368 <Lamp_on+0x10>
    135e:	81 30       	cpi	r24, 0x01	; 1
    1360:	49 f0       	breq	.+18     	; 0x1374 <Lamp_on+0x1c>
    1362:	82 30       	cpi	r24, 0x02	; 2
    1364:	61 f0       	breq	.+24     	; 0x137e <Lamp_on+0x26>
    1366:	08 95       	ret
    1368:	85 30       	cpi	r24, 0x05	; 5
    136a:	c1 f0       	breq	.+48     	; 0x139c <Lamp_on+0x44>
    136c:	90 f0       	brcs	.+36     	; 0x1392 <Lamp_on+0x3a>
    136e:	86 30       	cpi	r24, 0x06	; 6
    1370:	d1 f0       	breq	.+52     	; 0x13a6 <Lamp_on+0x4e>
    1372:	08 95       	ret
      case LAMP_1:
        LED_on(LAMP_1_PORT, LAMP_1_PIN);
    1374:	62 e0       	ldi	r22, 0x02	; 2
    1376:	83 e4       	ldi	r24, 0x43	; 67
    1378:	0e 94 e7 03 	call	0x7ce	; 0x7ce <LED_on>
        break;
    137c:	08 95       	ret
      case LAMP_2:
        LED_on(LAMP_2_PORT, LAMP_2_PIN);
    137e:	63 e0       	ldi	r22, 0x03	; 3
    1380:	83 e4       	ldi	r24, 0x43	; 67
    1382:	0e 94 e7 03 	call	0x7ce	; 0x7ce <LED_on>
        break;
    1386:	08 95       	ret
      case LAMP_3:
        LED_on(LAMP_3_PORT, LAMP_3_PIN);
    1388:	64 e0       	ldi	r22, 0x04	; 4
    138a:	83 e4       	ldi	r24, 0x43	; 67
    138c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <LED_on>
        break;
    1390:	08 95       	ret
      case LAMP_4:
        LED_on(LAMP_4_PORT, LAMP_4_PIN);
    1392:	65 e0       	ldi	r22, 0x05	; 5
    1394:	83 e4       	ldi	r24, 0x43	; 67
    1396:	0e 94 e7 03 	call	0x7ce	; 0x7ce <LED_on>
        break;
    139a:	08 95       	ret
      case LAMP_5:
        LED_on(LAMP_5_PORT, LAMP_5_PIN);
    139c:	66 e0       	ldi	r22, 0x06	; 6
    139e:	83 e4       	ldi	r24, 0x43	; 67
    13a0:	0e 94 e7 03 	call	0x7ce	; 0x7ce <LED_on>
        break;
    13a4:	08 95       	ret
      case LAMP_6:
        PWM_OCP_connect(LAMP_6_DIMMABLE_PWM_PIN);
    13a6:	83 e0       	ldi	r24, 0x03	; 3
    13a8:	0e 94 44 08 	call	0x1088	; 0x1088 <PWM_OCP_connect>
    13ac:	08 95       	ret

000013ae <Lamp_off>:
    }
  }

// Turn off a lamp
void Lamp_off(u8 lampNumber) {
  switch (lampNumber) {
    13ae:	83 30       	cpi	r24, 0x03	; 3
    13b0:	b1 f0       	breq	.+44     	; 0x13de <Lamp_off+0x30>
    13b2:	28 f4       	brcc	.+10     	; 0x13be <Lamp_off+0x10>
    13b4:	81 30       	cpi	r24, 0x01	; 1
    13b6:	49 f0       	breq	.+18     	; 0x13ca <Lamp_off+0x1c>
    13b8:	82 30       	cpi	r24, 0x02	; 2
    13ba:	61 f0       	breq	.+24     	; 0x13d4 <Lamp_off+0x26>
    13bc:	08 95       	ret
    13be:	85 30       	cpi	r24, 0x05	; 5
    13c0:	c1 f0       	breq	.+48     	; 0x13f2 <Lamp_off+0x44>
    13c2:	90 f0       	brcs	.+36     	; 0x13e8 <Lamp_off+0x3a>
    13c4:	86 30       	cpi	r24, 0x06	; 6
    13c6:	d1 f0       	breq	.+52     	; 0x13fc <Lamp_off+0x4e>
    13c8:	08 95       	ret
      case LAMP_1:
        LED_off(LAMP_1_PORT, LAMP_1_PIN);
    13ca:	62 e0       	ldi	r22, 0x02	; 2
    13cc:	83 e4       	ldi	r24, 0x43	; 67
    13ce:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <LED_off>
        break;
    13d2:	08 95       	ret
      case LAMP_2:
        LED_off(LAMP_2_PORT, LAMP_2_PIN);
    13d4:	63 e0       	ldi	r22, 0x03	; 3
    13d6:	83 e4       	ldi	r24, 0x43	; 67
    13d8:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <LED_off>
        break;
    13dc:	08 95       	ret
      case LAMP_3:
        LED_off(LAMP_3_PORT, LAMP_3_PIN);
    13de:	64 e0       	ldi	r22, 0x04	; 4
    13e0:	83 e4       	ldi	r24, 0x43	; 67
    13e2:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <LED_off>
        break;
    13e6:	08 95       	ret
      case LAMP_4:
        LED_off(LAMP_4_PORT, LAMP_4_PIN);
    13e8:	65 e0       	ldi	r22, 0x05	; 5
    13ea:	83 e4       	ldi	r24, 0x43	; 67
    13ec:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <LED_off>
        break;
    13f0:	08 95       	ret
      case LAMP_5:
        LED_off(LAMP_5_PORT, LAMP_5_PIN);
    13f2:	66 e0       	ldi	r22, 0x06	; 6
    13f4:	83 e4       	ldi	r24, 0x43	; 67
    13f6:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <LED_off>
        break;
    13fa:	08 95       	ret
      case LAMP_6:
        PWM_OCP_disconnect(LAMP_6_DIMMABLE_PWM_PIN);
    13fc:	83 e0       	ldi	r24, 0x03	; 3
    13fe:	0e 94 16 08 	call	0x102c	; 0x102c <PWM_OCP_disconnect>
    1402:	08 95       	ret

00001404 <Lamp_toggle>:
    }
  }

// Toggle a lamp
void Lamp_toggle(u8 lampNumber) {
  switch (lampNumber) {
    1404:	83 30       	cpi	r24, 0x03	; 3
    1406:	b1 f0       	breq	.+44     	; 0x1434 <Lamp_toggle+0x30>
    1408:	28 f4       	brcc	.+10     	; 0x1414 <Lamp_toggle+0x10>
    140a:	81 30       	cpi	r24, 0x01	; 1
    140c:	49 f0       	breq	.+18     	; 0x1420 <Lamp_toggle+0x1c>
    140e:	82 30       	cpi	r24, 0x02	; 2
    1410:	61 f0       	breq	.+24     	; 0x142a <Lamp_toggle+0x26>
    1412:	08 95       	ret
    1414:	85 30       	cpi	r24, 0x05	; 5
    1416:	c1 f0       	breq	.+48     	; 0x1448 <Lamp_toggle+0x44>
    1418:	90 f0       	brcs	.+36     	; 0x143e <Lamp_toggle+0x3a>
    141a:	86 30       	cpi	r24, 0x06	; 6
    141c:	d1 f0       	breq	.+52     	; 0x1452 <Lamp_toggle+0x4e>
    141e:	08 95       	ret
      case LAMP_1:
        LED_toggle(LAMP_1_PORT, LAMP_1_PIN);
    1420:	62 e0       	ldi	r22, 0x02	; 2
    1422:	83 e4       	ldi	r24, 0x43	; 67
    1424:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LED_toggle>
        break;
    1428:	08 95       	ret
      case LAMP_2:
        LED_toggle(LAMP_2_PORT, LAMP_2_PIN);
    142a:	63 e0       	ldi	r22, 0x03	; 3
    142c:	83 e4       	ldi	r24, 0x43	; 67
    142e:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LED_toggle>
        break;
    1432:	08 95       	ret
      case LAMP_3:
        LED_toggle(LAMP_3_PORT, LAMP_3_PIN);
    1434:	64 e0       	ldi	r22, 0x04	; 4
    1436:	83 e4       	ldi	r24, 0x43	; 67
    1438:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LED_toggle>
        break;
    143c:	08 95       	ret
      case LAMP_4:
        LED_toggle(LAMP_4_PORT, LAMP_4_PIN);
    143e:	65 e0       	ldi	r22, 0x05	; 5
    1440:	83 e4       	ldi	r24, 0x43	; 67
    1442:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LED_toggle>
        break;
    1446:	08 95       	ret
      case LAMP_5:
        LED_toggle(LAMP_5_PORT, LAMP_5_PIN);
    1448:	66 e0       	ldi	r22, 0x06	; 6
    144a:	83 e4       	ldi	r24, 0x43	; 67
    144c:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <LED_toggle>
        break;
    1450:	08 95       	ret
      case LAMP_6:
        if (read_bit(TCCR2, COM21)) { // OC pin is connected and lamp6 is on
    1452:	05 b4       	in	r0, 0x25	; 37
    1454:	05 fe       	sbrs	r0, 5
    1456:	04 c0       	rjmp	.+8      	; 0x1460 <Lamp_toggle+0x5c>
          Lamp_off(6);
    1458:	86 e0       	ldi	r24, 0x06	; 6
    145a:	0e 94 d7 09 	call	0x13ae	; 0x13ae <Lamp_off>
    145e:	08 95       	ret
          }
        else {
          Lamp_on(6);
    1460:	86 e0       	ldi	r24, 0x06	; 6
    1462:	0e 94 ac 09 	call	0x1358	; 0x1358 <Lamp_on>
    1466:	08 95       	ret

00001468 <Lamp_dimmable_set_brightness>:
        break;
    }
  }

// Adjust the brightness of the dimmable lamp
void Lamp_dimmable_set_brightness(double brightness) {
    1468:	ab 01       	movw	r20, r22
    146a:	bc 01       	movw	r22, r24
  PWM_set_DC(LAMP_6_DIMMABLE_PWM_PIN, brightness);
    146c:	83 e0       	ldi	r24, 0x03	; 3
    146e:	0e 94 19 09 	call	0x1232	; 0x1232 <PWM_set_DC>
    1472:	08 95       	ret

00001474 <Local_access_init>:

ST_User_t local_user;

// Initialize the local control system
void Local_access_init(void) {
  LCD_init();
    1474:	0e 94 67 03 	call	0x6ce	; 0x6ce <LCD_init>
  Keypad_init();
    1478:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <Keypad_init>
  User_DB_init();
    147c:	0e 94 80 12 	call	0x2500	; 0x2500 <User_DB_init>
    1480:	08 95       	ret

00001482 <Get_running_devices>:
  }

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
    1482:	cf 93       	push	r28
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    1484:	c0 e0       	ldi	r28, 0x00	; 0
    1486:	0a c0       	rjmp	.+20     	; 0x149c <Get_running_devices+0x1a>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
    1488:	4c 2f       	mov	r20, r28
    148a:	50 e0       	ldi	r21, 0x00	; 0
    148c:	4f 56       	subi	r20, 0x6F	; 111
    148e:	58 4f       	sbci	r21, 0xF8	; 248
    1490:	63 e4       	ldi	r22, 0x43	; 67
    1492:	82 e0       	ldi	r24, 0x02	; 2
    1494:	8c 0f       	add	r24, r28
    1496:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_Read>

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    149a:	cf 5f       	subi	r28, 0xFF	; 255
    149c:	c5 30       	cpi	r28, 0x05	; 5
    149e:	a0 f3       	brcs	.-24     	; 0x1488 <Get_running_devices+0x6>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
    }
  // Check the dimmable lamp
  running_devices[5] = read_bit(TCCR2, COM21); // To see if the OC pins are connected
    14a0:	85 b5       	in	r24, 0x25	; 37
    14a2:	85 fb       	bst	r24, 5
    14a4:	88 27       	eor	r24, r24
    14a6:	80 f9       	bld	r24, 0
    14a8:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <running_devices+0x5>
  // Check the AC
  DIO_Read(7, PORT_D, &running_devices[6]);
    14ac:	47 e9       	ldi	r20, 0x97	; 151
    14ae:	57 e0       	ldi	r21, 0x07	; 7
    14b0:	64 e4       	ldi	r22, 0x44	; 68
    14b2:	87 e0       	ldi	r24, 0x07	; 7
    14b4:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_Read>
  // The value in OCR2 determine the brightness of the led
  dimmer_brightness = OCR2;
    14b8:	83 b5       	in	r24, 0x23	; 35
    14ba:	90 e0       	ldi	r25, 0x00	; 0
    14bc:	90 93 c7 07 	sts	0x07C7, r25	; 0x8007c7 <dimmer_brightness+0x1>
    14c0:	80 93 c6 07 	sts	0x07C6, r24	; 0x8007c6 <dimmer_brightness>
  }
    14c4:	cf 91       	pop	r28
    14c6:	08 95       	ret

000014c8 <Show_bottom_options_menu>:

// Shows the bottom line options on the LCD
void Show_bottom_options_menu(u8 menu) {
  switch (menu) {
    14c8:	90 e0       	ldi	r25, 0x00	; 0
    14ca:	fc 01       	movw	r30, r24
    14cc:	31 97       	sbiw	r30, 0x01	; 1
    14ce:	ea 30       	cpi	r30, 0x0A	; 10
    14d0:	f1 05       	cpc	r31, r1
    14d2:	08 f0       	brcs	.+2      	; 0x14d6 <Show_bottom_options_menu+0xe>
    14d4:	49 c0       	rjmp	.+146    	; 0x1568 <Show_bottom_options_menu+0xa0>
    14d6:	e5 58       	subi	r30, 0x85	; 133
    14d8:	ff 4f       	sbci	r31, 0xFF	; 255
    14da:	0c 94 dc 16 	jmp	0x2db8	; 0x2db8 <__tablejump2__>
      case 1:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_1);
    14de:	41 e7       	ldi	r20, 0x71	; 113
    14e0:	50 e0       	ldi	r21, 0x00	; 0
    14e2:	61 e0       	ldi	r22, 0x01	; 1
    14e4:	80 e0       	ldi	r24, 0x00	; 0
    14e6:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
        break;
    14ea:	08 95       	ret
      case 2:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_2);
    14ec:	42 e8       	ldi	r20, 0x82	; 130
    14ee:	50 e0       	ldi	r21, 0x00	; 0
    14f0:	61 e0       	ldi	r22, 0x01	; 1
    14f2:	80 e0       	ldi	r24, 0x00	; 0
    14f4:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
        break;
    14f8:	08 95       	ret
      case 3:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_3);
    14fa:	43 e9       	ldi	r20, 0x93	; 147
    14fc:	50 e0       	ldi	r21, 0x00	; 0
    14fe:	61 e0       	ldi	r22, 0x01	; 1
    1500:	80 e0       	ldi	r24, 0x00	; 0
    1502:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
        break;
    1506:	08 95       	ret
      case 4:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_4);
    1508:	44 ea       	ldi	r20, 0xA4	; 164
    150a:	50 e0       	ldi	r21, 0x00	; 0
    150c:	61 e0       	ldi	r22, 0x01	; 1
    150e:	80 e0       	ldi	r24, 0x00	; 0
    1510:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
        break;
    1514:	08 95       	ret
      case 5:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_5);
    1516:	45 eb       	ldi	r20, 0xB5	; 181
    1518:	50 e0       	ldi	r21, 0x00	; 0
    151a:	61 e0       	ldi	r22, 0x01	; 1
    151c:	80 e0       	ldi	r24, 0x00	; 0
    151e:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
        break;
    1522:	08 95       	ret
      case 6:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_6);
    1524:	46 ec       	ldi	r20, 0xC6	; 198
    1526:	50 e0       	ldi	r21, 0x00	; 0
    1528:	61 e0       	ldi	r22, 0x01	; 1
    152a:	80 e0       	ldi	r24, 0x00	; 0
    152c:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
        break;
    1530:	08 95       	ret
      case 7:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_7);
    1532:	47 ed       	ldi	r20, 0xD7	; 215
    1534:	50 e0       	ldi	r21, 0x00	; 0
    1536:	61 e0       	ldi	r22, 0x01	; 1
    1538:	80 e0       	ldi	r24, 0x00	; 0
    153a:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
        break;
    153e:	08 95       	ret
      case 8:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_8);
    1540:	48 ee       	ldi	r20, 0xE8	; 232
    1542:	50 e0       	ldi	r21, 0x00	; 0
    1544:	61 e0       	ldi	r22, 0x01	; 1
    1546:	80 e0       	ldi	r24, 0x00	; 0
    1548:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
        break;
    154c:	08 95       	ret
      case 9:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_9);
    154e:	49 ef       	ldi	r20, 0xF9	; 249
    1550:	50 e0       	ldi	r21, 0x00	; 0
    1552:	61 e0       	ldi	r22, 0x01	; 1
    1554:	80 e0       	ldi	r24, 0x00	; 0
    1556:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
        break;
    155a:	08 95       	ret
      case 10:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_10);
    155c:	4a e0       	ldi	r20, 0x0A	; 10
    155e:	51 e0       	ldi	r21, 0x01	; 1
    1560:	61 e0       	ldi	r22, 0x01	; 1
    1562:	80 e0       	ldi	r24, 0x00	; 0
    1564:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
    1568:	08 95       	ret

0000156a <Show_side_options_menu>:
    }
  }

// Shows the side options list on the LCD
void Show_side_options_menu(void) {
  LCD_write_string_xy(12, 0, BACKSPACE_OPTION);
    156a:	4b e1       	ldi	r20, 0x1B	; 27
    156c:	51 e0       	ldi	r21, 0x01	; 1
    156e:	60 e0       	ldi	r22, 0x00	; 0
    1570:	8c e0       	ldi	r24, 0x0C	; 12
    1572:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
  LCD_write_string_xy(12, 1, ENTER_OPTION);
    1576:	40 e2       	ldi	r20, 0x20	; 32
    1578:	51 e0       	ldi	r21, 0x01	; 1
    157a:	61 e0       	ldi	r22, 0x01	; 1
    157c:	8c e0       	ldi	r24, 0x0C	; 12
    157e:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
    1582:	08 95       	ret

00001584 <Show_running_devices>:
  }

// Shows the currently running devices with the appropriate control menu appended (Screen controls and login- no device controls)
void Show_running_devices(u8 screen) {
    1584:	ef 92       	push	r14
    1586:	ff 92       	push	r15
    1588:	1f 93       	push	r17
    158a:	cf 93       	push	r28
    158c:	df 93       	push	r29
    158e:	00 d0       	rcall	.+0      	; 0x1590 <Show_running_devices+0xc>
    1590:	00 d0       	rcall	.+0      	; 0x1592 <Show_running_devices+0xe>
    1592:	cd b7       	in	r28, 0x3d	; 61
    1594:	de b7       	in	r29, 0x3e	; 62
    1596:	18 2f       	mov	r17, r24
  // Do nothing if the correct screen is shown.
  // if (screen == running_devices_screen) return;
  LCD_clear_screen();
    1598:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
  // Write device name
  switch (screen) {
    159c:	17 30       	cpi	r17, 0x07	; 7
    159e:	39 f4       	brne	.+14     	; 0x15ae <Show_running_devices+0x2a>
      case 7:
        LCD_write_string_xy(0, 0, "AC: ");
    15a0:	45 e2       	ldi	r20, 0x25	; 37
    15a2:	51 e0       	ldi	r21, 0x01	; 1
    15a4:	60 e0       	ldi	r22, 0x00	; 0
    15a6:	80 e0       	ldi	r24, 0x00	; 0
    15a8:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
        break;
    15ac:	0e c0       	rjmp	.+28     	; 0x15ca <Show_running_devices+0x46>
      default:
        LCD_write_string_xy(0, 0, "Lamp");
    15ae:	4a e2       	ldi	r20, 0x2A	; 42
    15b0:	51 e0       	ldi	r21, 0x01	; 1
    15b2:	60 e0       	ldi	r22, 0x00	; 0
    15b4:	80 e0       	ldi	r24, 0x00	; 0
    15b6:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
        LCD_sendData(screen + 48);
    15ba:	80 e3       	ldi	r24, 0x30	; 48
    15bc:	81 0f       	add	r24, r17
    15be:	0e 94 31 03 	call	0x662	; 0x662 <LCD_sendData>
        LCD_write_string(":  ");
    15c2:	8f e2       	ldi	r24, 0x2F	; 47
    15c4:	91 e0       	ldi	r25, 0x01	; 1
    15c6:	0e 94 a7 03 	call	0x74e	; 0x74e <LCD_write_string>
        break;
    }
  if (screen == 6) {
    15ca:	16 30       	cpi	r17, 0x06	; 6
    15cc:	49 f5       	brne	.+82     	; 0x1620 <Show_running_devices+0x9c>
    s8 brightness[4];
    sprintf(brightness, "%d%%", (u8)((double)dimmer_brightness / 2.55));
    15ce:	60 91 c6 07 	lds	r22, 0x07C6	; 0x8007c6 <dimmer_brightness>
    15d2:	70 91 c7 07 	lds	r23, 0x07C7	; 0x8007c7 <dimmer_brightness+0x1>
    15d6:	07 2e       	mov	r0, r23
    15d8:	00 0c       	add	r0, r0
    15da:	88 0b       	sbc	r24, r24
    15dc:	99 0b       	sbc	r25, r25
    15de:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__floatsisf>
    15e2:	23 e3       	ldi	r18, 0x33	; 51
    15e4:	33 e3       	ldi	r19, 0x33	; 51
    15e6:	43 e2       	ldi	r20, 0x23	; 35
    15e8:	50 e4       	ldi	r21, 0x40	; 64
    15ea:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__divsf3>
    15ee:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <__fixunssfsi>
    15f2:	1f 92       	push	r1
    15f4:	6f 93       	push	r22
    15f6:	83 e3       	ldi	r24, 0x33	; 51
    15f8:	91 e0       	ldi	r25, 0x01	; 1
    15fa:	9f 93       	push	r25
    15fc:	8f 93       	push	r24
    15fe:	ce 01       	movw	r24, r28
    1600:	01 96       	adiw	r24, 0x01	; 1
    1602:	7c 01       	movw	r14, r24
    1604:	9f 93       	push	r25
    1606:	8f 93       	push	r24
    1608:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <sprintf>
    LCD_write_string(brightness);
    160c:	c7 01       	movw	r24, r14
    160e:	0e 94 a7 03 	call	0x74e	; 0x74e <LCD_write_string>
    1612:	0f 90       	pop	r0
    1614:	0f 90       	pop	r0
    1616:	0f 90       	pop	r0
    1618:	0f 90       	pop	r0
    161a:	0f 90       	pop	r0
    161c:	0f 90       	pop	r0
    161e:	10 c0       	rjmp	.+32     	; 0x1640 <Show_running_devices+0xbc>
    }
  else {// Write the device state
    if (running_devices[screen - 1])
    1620:	e1 2f       	mov	r30, r17
    1622:	f0 e0       	ldi	r31, 0x00	; 0
    1624:	e0 57       	subi	r30, 0x70	; 112
    1626:	f8 4f       	sbci	r31, 0xF8	; 248
    1628:	80 81       	ld	r24, Z
    162a:	88 23       	and	r24, r24
    162c:	29 f0       	breq	.+10     	; 0x1638 <Show_running_devices+0xb4>
      LCD_write_string("On");
    162e:	88 e3       	ldi	r24, 0x38	; 56
    1630:	91 e0       	ldi	r25, 0x01	; 1
    1632:	0e 94 a7 03 	call	0x74e	; 0x74e <LCD_write_string>
    1636:	04 c0       	rjmp	.+8      	; 0x1640 <Show_running_devices+0xbc>
    else
      LCD_write_string("Off");
    1638:	8b e3       	ldi	r24, 0x3B	; 59
    163a:	91 e0       	ldi	r25, 0x01	; 1
    163c:	0e 94 a7 03 	call	0x74e	; 0x74e <LCD_write_string>
    }
  // Show the options menu
  switch (screen) {
    1640:	11 30       	cpi	r17, 0x01	; 1
    1642:	19 f0       	breq	.+6      	; 0x164a <Show_running_devices+0xc6>
    1644:	17 30       	cpi	r17, 0x07	; 7
    1646:	29 f0       	breq	.+10     	; 0x1652 <Show_running_devices+0xce>
    1648:	08 c0       	rjmp	.+16     	; 0x165a <Show_running_devices+0xd6>
      case 1:
        Show_bottom_options_menu(3);
    164a:	83 e0       	ldi	r24, 0x03	; 3
    164c:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <Show_bottom_options_menu>
        break;
    1650:	07 c0       	rjmp	.+14     	; 0x1660 <Show_running_devices+0xdc>
      case 7:
        Show_bottom_options_menu(2);
    1652:	82 e0       	ldi	r24, 0x02	; 2
    1654:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <Show_bottom_options_menu>
        break;
    1658:	03 c0       	rjmp	.+6      	; 0x1660 <Show_running_devices+0xdc>
      default:
        Show_bottom_options_menu(1);
    165a:	81 e0       	ldi	r24, 0x01	; 1
    165c:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <Show_bottom_options_menu>
        break;
    }
  }
    1660:	0f 90       	pop	r0
    1662:	0f 90       	pop	r0
    1664:	0f 90       	pop	r0
    1666:	0f 90       	pop	r0
    1668:	df 91       	pop	r29
    166a:	cf 91       	pop	r28
    166c:	1f 91       	pop	r17
    166e:	ff 90       	pop	r15
    1670:	ef 90       	pop	r14
    1672:	08 95       	ret

00001674 <Show_devices_controls>:

// Shows the currently running devices with the appropriate control menu appended (Devices' controls)
void Show_devices_controls(u8 screen) {
    1674:	ef 92       	push	r14
    1676:	ff 92       	push	r15
    1678:	1f 93       	push	r17
    167a:	cf 93       	push	r28
    167c:	df 93       	push	r29
    167e:	00 d0       	rcall	.+0      	; 0x1680 <Show_devices_controls+0xc>
    1680:	00 d0       	rcall	.+0      	; 0x1682 <Show_devices_controls+0xe>
    1682:	cd b7       	in	r28, 0x3d	; 61
    1684:	de b7       	in	r29, 0x3e	; 62
    1686:	18 2f       	mov	r17, r24
  // Do nothing if the correct screen is shown.
  // if (screen == control_devices_screen) return;
  LCD_clear_screen();
    1688:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
  LCD_write_string_xy(0, 0, "Lamp");
    168c:	4a e2       	ldi	r20, 0x2A	; 42
    168e:	51 e0       	ldi	r21, 0x01	; 1
    1690:	60 e0       	ldi	r22, 0x00	; 0
    1692:	80 e0       	ldi	r24, 0x00	; 0
    1694:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
  LCD_sendData(screen + 48);
    1698:	80 e3       	ldi	r24, 0x30	; 48
    169a:	81 0f       	add	r24, r17
    169c:	0e 94 31 03 	call	0x662	; 0x662 <LCD_sendData>
  LCD_write_string(":  ");
    16a0:	8f e2       	ldi	r24, 0x2F	; 47
    16a2:	91 e0       	ldi	r25, 0x01	; 1
    16a4:	0e 94 a7 03 	call	0x74e	; 0x74e <LCD_write_string>

  if (screen < 6) {
    16a8:	16 30       	cpi	r17, 0x06	; 6
    16aa:	88 f4       	brcc	.+34     	; 0x16ce <Show_devices_controls+0x5a>
    // Write the device state
    if (running_devices[screen - 1])
    16ac:	e1 2f       	mov	r30, r17
    16ae:	f0 e0       	ldi	r31, 0x00	; 0
    16b0:	e0 57       	subi	r30, 0x70	; 112
    16b2:	f8 4f       	sbci	r31, 0xF8	; 248
    16b4:	80 81       	ld	r24, Z
    16b6:	88 23       	and	r24, r24
    16b8:	29 f0       	breq	.+10     	; 0x16c4 <Show_devices_controls+0x50>
      LCD_write_string("On");
    16ba:	88 e3       	ldi	r24, 0x38	; 56
    16bc:	91 e0       	ldi	r25, 0x01	; 1
    16be:	0e 94 a7 03 	call	0x74e	; 0x74e <LCD_write_string>
    16c2:	38 c0       	rjmp	.+112    	; 0x1734 <Show_devices_controls+0xc0>
    else
      LCD_write_string("Off");
    16c4:	8b e3       	ldi	r24, 0x3B	; 59
    16c6:	91 e0       	ldi	r25, 0x01	; 1
    16c8:	0e 94 a7 03 	call	0x74e	; 0x74e <LCD_write_string>
    16cc:	33 c0       	rjmp	.+102    	; 0x1734 <Show_devices_controls+0xc0>
    }
  else if (screen == 6) { // Dimmer
    16ce:	16 30       	cpi	r17, 0x06	; 6
    16d0:	49 f5       	brne	.+82     	; 0x1724 <Show_devices_controls+0xb0>
    s8 brightness[4];
    sprintf(brightness, "%d%%", (u8)((double)dimmer_brightness / 2.55));
    16d2:	60 91 c6 07 	lds	r22, 0x07C6	; 0x8007c6 <dimmer_brightness>
    16d6:	70 91 c7 07 	lds	r23, 0x07C7	; 0x8007c7 <dimmer_brightness+0x1>
    16da:	07 2e       	mov	r0, r23
    16dc:	00 0c       	add	r0, r0
    16de:	88 0b       	sbc	r24, r24
    16e0:	99 0b       	sbc	r25, r25
    16e2:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__floatsisf>
    16e6:	23 e3       	ldi	r18, 0x33	; 51
    16e8:	33 e3       	ldi	r19, 0x33	; 51
    16ea:	43 e2       	ldi	r20, 0x23	; 35
    16ec:	50 e4       	ldi	r21, 0x40	; 64
    16ee:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__divsf3>
    16f2:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <__fixunssfsi>
    16f6:	1f 92       	push	r1
    16f8:	6f 93       	push	r22
    16fa:	83 e3       	ldi	r24, 0x33	; 51
    16fc:	91 e0       	ldi	r25, 0x01	; 1
    16fe:	9f 93       	push	r25
    1700:	8f 93       	push	r24
    1702:	ce 01       	movw	r24, r28
    1704:	01 96       	adiw	r24, 0x01	; 1
    1706:	7c 01       	movw	r14, r24
    1708:	9f 93       	push	r25
    170a:	8f 93       	push	r24
    170c:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <sprintf>
    LCD_write_string(brightness);
    1710:	c7 01       	movw	r24, r14
    1712:	0e 94 a7 03 	call	0x74e	; 0x74e <LCD_write_string>
    1716:	0f 90       	pop	r0
    1718:	0f 90       	pop	r0
    171a:	0f 90       	pop	r0
    171c:	0f 90       	pop	r0
    171e:	0f 90       	pop	r0
    1720:	0f 90       	pop	r0
    1722:	08 c0       	rjmp	.+16     	; 0x1734 <Show_devices_controls+0xc0>
    }
  else {  // Logout screen
    LCD_clear_screen();
    1724:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
    LCD_write_string_xy(4, 0, "Log out?");
    1728:	4f e3       	ldi	r20, 0x3F	; 63
    172a:	51 e0       	ldi	r21, 0x01	; 1
    172c:	60 e0       	ldi	r22, 0x00	; 0
    172e:	84 e0       	ldi	r24, 0x04	; 4
    1730:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
    }
  // Show the options menu
  switch (screen) {
    1734:	16 30       	cpi	r17, 0x06	; 6
    1736:	81 f0       	breq	.+32     	; 0x1758 <Show_devices_controls+0xe4>
    1738:	17 30       	cpi	r17, 0x07	; 7
    173a:	91 f0       	breq	.+36     	; 0x1760 <Show_devices_controls+0xec>
    173c:	11 30       	cpi	r17, 0x01	; 1
    173e:	a1 f4       	brne	.+40     	; 0x1768 <Show_devices_controls+0xf4>
      case 1:
        if (running_devices[0])
    1740:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <running_devices>
    1744:	88 23       	and	r24, r24
    1746:	21 f0       	breq	.+8      	; 0x1750 <Show_devices_controls+0xdc>
          Show_bottom_options_menu(8);
    1748:	88 e0       	ldi	r24, 0x08	; 8
    174a:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <Show_bottom_options_menu>
    174e:	1a c0       	rjmp	.+52     	; 0x1784 <Show_devices_controls+0x110>
        else
          Show_bottom_options_menu(7);
    1750:	87 e0       	ldi	r24, 0x07	; 7
    1752:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <Show_bottom_options_menu>
    1756:	16 c0       	rjmp	.+44     	; 0x1784 <Show_devices_controls+0x110>
        break;
      case 6:
        Show_bottom_options_menu(9);
    1758:	89 e0       	ldi	r24, 0x09	; 9
    175a:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <Show_bottom_options_menu>
        break;
    175e:	12 c0       	rjmp	.+36     	; 0x1784 <Show_devices_controls+0x110>
      case 7:
        Show_bottom_options_menu(10);
    1760:	8a e0       	ldi	r24, 0x0A	; 10
    1762:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <Show_bottom_options_menu>
        break;
    1766:	0e c0       	rjmp	.+28     	; 0x1784 <Show_devices_controls+0x110>
      default:
        if (running_devices[screen - 1])
    1768:	e1 2f       	mov	r30, r17
    176a:	f0 e0       	ldi	r31, 0x00	; 0
    176c:	e0 57       	subi	r30, 0x70	; 112
    176e:	f8 4f       	sbci	r31, 0xF8	; 248
    1770:	80 81       	ld	r24, Z
    1772:	88 23       	and	r24, r24
    1774:	21 f0       	breq	.+8      	; 0x177e <Show_devices_controls+0x10a>
          Show_bottom_options_menu(6);
    1776:	86 e0       	ldi	r24, 0x06	; 6
    1778:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <Show_bottom_options_menu>
    177c:	03 c0       	rjmp	.+6      	; 0x1784 <Show_devices_controls+0x110>
        else
          Show_bottom_options_menu(5);
    177e:	85 e0       	ldi	r24, 0x05	; 5
    1780:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <Show_bottom_options_menu>
        break;
    }
  }
    1784:	0f 90       	pop	r0
    1786:	0f 90       	pop	r0
    1788:	0f 90       	pop	r0
    178a:	0f 90       	pop	r0
    178c:	df 91       	pop	r29
    178e:	cf 91       	pop	r28
    1790:	1f 91       	pop	r17
    1792:	ff 90       	pop	r15
    1794:	ef 90       	pop	r14
    1796:	08 95       	ret

00001798 <invalid_local_login_attempt>:

// Handles setting the alarm and halting the system when the user enters invalid credentials during login
void invalid_local_login_attempt(void) {
  invalid_trails++;
    1798:	80 91 78 07 	lds	r24, 0x0778	; 0x800778 <__data_end>
    179c:	8f 5f       	subi	r24, 0xFF	; 255
    179e:	80 93 78 07 	sts	0x0778, r24	; 0x800778 <__data_end>
  if (invalid_trails < 3) {
    17a2:	83 30       	cpi	r24, 0x03	; 3
    17a4:	00 f5       	brcc	.+64     	; 0x17e6 <invalid_local_login_attempt+0x4e>
    LCD_clear_screen();
    17a6:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
    LCD_move_cursor_xy(3, 0);
    17aa:	60 e0       	ldi	r22, 0x00	; 0
    17ac:	83 e0       	ldi	r24, 0x03	; 3
    17ae:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_move_cursor_xy>
    LCD_sendData((3 - invalid_trails) + 48);
    17b2:	90 91 78 07 	lds	r25, 0x0778	; 0x800778 <__data_end>
    17b6:	83 e3       	ldi	r24, 0x33	; 51
    17b8:	89 1b       	sub	r24, r25
    17ba:	0e 94 31 03 	call	0x662	; 0x662 <LCD_sendData>
    LCD_write_string(" attempts");
    17be:	88 e4       	ldi	r24, 0x48	; 72
    17c0:	91 e0       	ldi	r25, 0x01	; 1
    17c2:	0e 94 a7 03 	call	0x74e	; 0x74e <LCD_write_string>
    LCD_write_string_xy(3, 1, "remaining !");
    17c6:	42 e5       	ldi	r20, 0x52	; 82
    17c8:	51 e0       	ldi	r21, 0x01	; 1
    17ca:	61 e0       	ldi	r22, 0x01	; 1
    17cc:	83 e0       	ldi	r24, 0x03	; 3
    17ce:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
    17d2:	2f ef       	ldi	r18, 0xFF	; 255
    17d4:	83 ed       	ldi	r24, 0xD3	; 211
    17d6:	90 e3       	ldi	r25, 0x30	; 48
    17d8:	21 50       	subi	r18, 0x01	; 1
    17da:	80 40       	sbci	r24, 0x00	; 0
    17dc:	90 40       	sbci	r25, 0x00	; 0
    17de:	e1 f7       	brne	.-8      	; 0x17d8 <invalid_local_login_attempt+0x40>
    17e0:	00 c0       	rjmp	.+0      	; 0x17e2 <invalid_local_login_attempt+0x4a>
    17e2:	00 00       	nop
    17e4:	08 95       	ret
    _delay_ms(1000);
    return;
    }
  LCD_clear_screen();
    17e6:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
  LCD_write_string_xy(4, 0, "Too many");
    17ea:	4e e5       	ldi	r20, 0x5E	; 94
    17ec:	51 e0       	ldi	r21, 0x01	; 1
    17ee:	60 e0       	ldi	r22, 0x00	; 0
    17f0:	84 e0       	ldi	r24, 0x04	; 4
    17f2:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
  LCD_write_string_xy(0, 1, "wrong attempts!");
    17f6:	47 e6       	ldi	r20, 0x67	; 103
    17f8:	51 e0       	ldi	r21, 0x01	; 1
    17fa:	61 e0       	ldi	r22, 0x01	; 1
    17fc:	80 e0       	ldi	r24, 0x00	; 0
    17fe:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
    1802:	2f ef       	ldi	r18, 0xFF	; 255
    1804:	83 ed       	ldi	r24, 0xD3	; 211
    1806:	90 e3       	ldi	r25, 0x30	; 48
    1808:	21 50       	subi	r18, 0x01	; 1
    180a:	80 40       	sbci	r24, 0x00	; 0
    180c:	90 40       	sbci	r25, 0x00	; 0
    180e:	e1 f7       	brne	.-8      	; 0x1808 <invalid_local_login_attempt+0x70>
    1810:	00 c0       	rjmp	.+0      	; 0x1812 <invalid_local_login_attempt+0x7a>
    1812:	00 00       	nop
  _delay_ms(1000);
  LCD_clear_screen();
    1814:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
  LCD_write_string_xy(3, 0, "- System -");
    1818:	47 e7       	ldi	r20, 0x77	; 119
    181a:	51 e0       	ldi	r21, 0x01	; 1
    181c:	60 e0       	ldi	r22, 0x00	; 0
    181e:	83 e0       	ldi	r24, 0x03	; 3
    1820:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
  LCD_write_string_xy(2, 1, "- Suspended -");
    1824:	42 e8       	ldi	r20, 0x82	; 130
    1826:	51 e0       	ldi	r21, 0x01	; 1
    1828:	61 e0       	ldi	r22, 0x01	; 1
    182a:	82 e0       	ldi	r24, 0x02	; 2
    182c:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
  Alarm_set();
    1830:	0e 94 b5 13 	call	0x276a	; 0x276a <Alarm_set>
  run_system = false;
    1834:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__data_start>
    1838:	08 95       	ret

0000183a <Local_control_input_handler>:
  }

// Used in the super loop for getting the user input and handling it.
void Local_control_input_handler(void) {
    183a:	1f 93       	push	r17
    183c:	cf 93       	push	r28
    183e:	df 93       	push	r29
    1840:	1f 92       	push	r1
    1842:	cd b7       	in	r28, 0x3d	; 61
    1844:	de b7       	in	r29, 0x3e	; 62
  u8 pressed_key;
  EN_KeypadStatusCode_t keypad_stat = Keypad_getPressedKey(&pressed_key);
    1846:	ce 01       	movw	r24, r28
    1848:	01 96       	adiw	r24, 0x01	; 1
    184a:	0e 94 8f 02 	call	0x51e	; 0x51e <Keypad_getPressedKey>
    184e:	18 2f       	mov	r17, r24
  switch (local_control_running_task) {
    1850:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <local_control_running_task>
    1854:	81 30       	cpi	r24, 0x01	; 1
    1856:	a9 f1       	breq	.+106    	; 0x18c2 <Local_control_input_handler+0x88>
    1858:	20 f0       	brcs	.+8      	; 0x1862 <Local_control_input_handler+0x28>
    185a:	82 30       	cpi	r24, 0x02	; 2
    185c:	09 f4       	brne	.+2      	; 0x1860 <Local_control_input_handler+0x26>
    185e:	48 c1       	rjmp	.+656    	; 0x1af0 <Local_control_input_handler+0x2b6>
    1860:	30 c2       	rjmp	.+1120   	; 0x1cc2 <Local_control_input_handler+0x488>
    // Show running devices
      case 0:
        Get_running_devices();
    1862:	0e 94 41 0a 	call	0x1482	; 0x1482 <Get_running_devices>
        if (running_devices_screen == 0) {  // First run
    1866:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <running_devices_screen>
    186a:	81 11       	cpse	r24, r1
    186c:	08 c0       	rjmp	.+16     	; 0x187e <Local_control_input_handler+0x44>
          Show_running_devices(1);
    186e:	81 e0       	ldi	r24, 0x01	; 1
    1870:	0e 94 c2 0a 	call	0x1584	; 0x1584 <Show_running_devices>
          running_devices_screen++;
    1874:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <running_devices_screen>
    1878:	8f 5f       	subi	r24, 0xFF	; 255
    187a:	80 93 cb 07 	sts	0x07CB, r24	; 0x8007cb <running_devices_screen>
          }
        if (keypad_stat == NO_KEY_PRESSED) return;
    187e:	12 30       	cpi	r17, 0x02	; 2
    1880:	09 f4       	brne	.+2      	; 0x1884 <Local_control_input_handler+0x4a>
    1882:	1f c2       	rjmp	.+1086   	; 0x1cc2 <Local_control_input_handler+0x488>
        switch (pressed_key) {
    1884:	89 81       	ldd	r24, Y+1	; 0x01
    1886:	82 33       	cpi	r24, 0x32	; 50
    1888:	61 f0       	breq	.+24     	; 0x18a2 <Local_control_input_handler+0x68>
    188a:	83 33       	cpi	r24, 0x33	; 51
    188c:	71 f0       	breq	.+28     	; 0x18aa <Local_control_input_handler+0x70>
    188e:	81 33       	cpi	r24, 0x31	; 49
    1890:	99 f4       	brne	.+38     	; 0x18b8 <Local_control_input_handler+0x7e>
            case '1':
              if (running_devices_screen > 1) running_devices_screen--;
    1892:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <running_devices_screen>
    1896:	82 30       	cpi	r24, 0x02	; 2
    1898:	78 f0       	brcs	.+30     	; 0x18b8 <Local_control_input_handler+0x7e>
    189a:	81 50       	subi	r24, 0x01	; 1
    189c:	80 93 cb 07 	sts	0x07CB, r24	; 0x8007cb <running_devices_screen>
    18a0:	0b c0       	rjmp	.+22     	; 0x18b8 <Local_control_input_handler+0x7e>
              break;
            case '2':
              local_control_running_task = 1;
    18a2:	81 e0       	ldi	r24, 0x01	; 1
    18a4:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <local_control_running_task>
              break;
    18a8:	07 c0       	rjmp	.+14     	; 0x18b8 <Local_control_input_handler+0x7e>
            case '3':
              if (running_devices_screen < 7) running_devices_screen++;
    18aa:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <running_devices_screen>
    18ae:	87 30       	cpi	r24, 0x07	; 7
    18b0:	18 f4       	brcc	.+6      	; 0x18b8 <Local_control_input_handler+0x7e>
    18b2:	8f 5f       	subi	r24, 0xFF	; 255
    18b4:	80 93 cb 07 	sts	0x07CB, r24	; 0x8007cb <running_devices_screen>
              break;
          }
        Show_running_devices(running_devices_screen);
    18b8:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <running_devices_screen>
    18bc:	0e 94 c2 0a 	call	0x1584	; 0x1584 <Show_running_devices>
        break;
    18c0:	00 c2       	rjmp	.+1024   	; 0x1cc2 <Local_control_input_handler+0x488>
        // Logging in
      case 1:
        switch (login_stage) {
    18c2:	80 91 ca 07 	lds	r24, 0x07CA	; 0x8007ca <login_stage>
    18c6:	88 23       	and	r24, r24
    18c8:	21 f0       	breq	.+8      	; 0x18d2 <Local_control_input_handler+0x98>
    18ca:	81 30       	cpi	r24, 0x01	; 1
    18cc:	09 f4       	brne	.+2      	; 0x18d0 <Local_control_input_handler+0x96>
    18ce:	73 c0       	rjmp	.+230    	; 0x19b6 <Local_control_input_handler+0x17c>
    18d0:	f8 c1       	rjmp	.+1008   	; 0x1cc2 <Local_control_input_handler+0x488>
          // Entering the user code
            case 0:
              if (!login_stage_started) {
    18d2:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <login_stage_started>
    18d6:	81 11       	cpse	r24, r1
    18d8:	13 c0       	rjmp	.+38     	; 0x1900 <Local_control_input_handler+0xc6>
                LCD_clear_screen();
    18da:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
                Show_side_options_menu();
    18de:	0e 94 b5 0a 	call	0x156a	; 0x156a <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "User Code:");
    18e2:	40 e9       	ldi	r20, 0x90	; 144
    18e4:	51 e0       	ldi	r21, 0x01	; 1
    18e6:	60 e0       	ldi	r22, 0x00	; 0
    18e8:	80 e0       	ldi	r24, 0x00	; 0
    18ea:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    18ee:	61 e0       	ldi	r22, 0x01	; 1
    18f0:	80 e0       	ldi	r24, 0x00	; 0
    18f2:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_move_cursor_xy>
                login_stage_started = true;
    18f6:	81 e0       	ldi	r24, 0x01	; 1
    18f8:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <login_stage_started>
                input_buffer_pointer = 0;
    18fc:	10 92 9a 07 	sts	0x079A, r1	; 0x80079a <input_buffer_pointer>
                }
              if (keypad_stat == NO_KEY_PRESSED) return;
    1900:	12 30       	cpi	r17, 0x02	; 2
    1902:	09 f4       	brne	.+2      	; 0x1906 <Local_control_input_handler+0xcc>
    1904:	de c1       	rjmp	.+956    	; 0x1cc2 <Local_control_input_handler+0x488>
              if (pressed_key == '-') { // Delete last input number
    1906:	89 81       	ldd	r24, Y+1	; 0x01
    1908:	8d 32       	cpi	r24, 0x2D	; 45
    190a:	a1 f4       	brne	.+40     	; 0x1934 <Local_control_input_handler+0xfa>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    190c:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <input_buffer_pointer>
    1910:	88 23       	and	r24, r24
    1912:	19 f0       	breq	.+6      	; 0x191a <Local_control_input_handler+0xe0>
    1914:	81 50       	subi	r24, 0x01	; 1
    1916:	80 93 9a 07 	sts	0x079A, r24	; 0x80079a <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    191a:	41 e3       	ldi	r20, 0x31	; 49
    191c:	51 e0       	ldi	r21, 0x01	; 1
    191e:	61 e0       	ldi	r22, 0x01	; 1
    1920:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <input_buffer_pointer>
    1924:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    1928:	61 e0       	ldi	r22, 0x01	; 1
    192a:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <input_buffer_pointer>
    192e:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_move_cursor_xy>
    1932:	c7 c1       	rjmp	.+910    	; 0x1cc2 <Local_control_input_handler+0x488>
                }
              else if (pressed_key == '=') {
    1934:	8d 33       	cpi	r24, 0x3D	; 61
    1936:	39 f5       	brne	.+78     	; 0x1986 <Local_control_input_handler+0x14c>
                input_buffer[input_buffer_pointer] = 0;
    1938:	e0 91 9a 07 	lds	r30, 0x079A	; 0x80079a <input_buffer_pointer>
    193c:	f0 e0       	ldi	r31, 0x00	; 0
    193e:	e5 54       	subi	r30, 0x45	; 69
    1940:	f8 4f       	sbci	r31, 0xF8	; 248
    1942:	10 82       	st	Z, r1
                // Validate user code
                EN_UserStatusCode_t codeExists = getUserByCode(input_buffer, &local_user);
    1944:	6b e9       	ldi	r22, 0x9B	; 155
    1946:	77 e0       	ldi	r23, 0x07	; 7
    1948:	8b eb       	ldi	r24, 0xBB	; 187
    194a:	97 e0       	ldi	r25, 0x07	; 7
    194c:	0e 94 1c 13 	call	0x2638	; 0x2638 <getUserByCode>
                if (codeExists == USER_FOUND) {
    1950:	82 30       	cpi	r24, 0x02	; 2
    1952:	31 f4       	brne	.+12     	; 0x1960 <Local_control_input_handler+0x126>
                  login_stage_started = false;
    1954:	10 92 c9 07 	sts	0x07C9, r1	; 0x8007c9 <login_stage_started>
                  login_stage = 1;
    1958:	81 e0       	ldi	r24, 0x01	; 1
    195a:	80 93 ca 07 	sts	0x07CA, r24	; 0x8007ca <login_stage>
    195e:	b1 c1       	rjmp	.+866    	; 0x1cc2 <Local_control_input_handler+0x488>
                  }
                else {
                  LCD_clear_screen();
    1960:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    1964:	4b e9       	ldi	r20, 0x9B	; 155
    1966:	51 e0       	ldi	r21, 0x01	; 1
    1968:	60 e0       	ldi	r22, 0x00	; 0
    196a:	85 e0       	ldi	r24, 0x05	; 5
    196c:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
                  LCD_write_string_xy(2, 1, "User Code !");
    1970:	41 ea       	ldi	r20, 0xA1	; 161
    1972:	51 e0       	ldi	r21, 0x01	; 1
    1974:	61 e0       	ldi	r22, 0x01	; 1
    1976:	82 e0       	ldi	r24, 0x02	; 2
    1978:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
                  invalid_local_login_attempt();
    197c:	0e 94 cc 0b 	call	0x1798	; 0x1798 <invalid_local_login_attempt>
                  login_stage_started = false;
    1980:	10 92 c9 07 	sts	0x07C9, r1	; 0x8007c9 <login_stage_started>
    1984:	9e c1       	rjmp	.+828    	; 0x1cc2 <Local_control_input_handler+0x488>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    1986:	90 ed       	ldi	r25, 0xD0	; 208
    1988:	98 0f       	add	r25, r24
    198a:	9a 30       	cpi	r25, 0x0A	; 10
    198c:	08 f0       	brcs	.+2      	; 0x1990 <Local_control_input_handler+0x156>
    198e:	99 c1       	rjmp	.+818    	; 0x1cc2 <Local_control_input_handler+0x488>
                if (input_buffer_pointer < 6) {
    1990:	90 91 9a 07 	lds	r25, 0x079A	; 0x80079a <input_buffer_pointer>
    1994:	96 30       	cpi	r25, 0x06	; 6
    1996:	08 f0       	brcs	.+2      	; 0x199a <Local_control_input_handler+0x160>
    1998:	94 c1       	rjmp	.+808    	; 0x1cc2 <Local_control_input_handler+0x488>
                  // Echo the input on the LCD
                  LCD_sendData(pressed_key);
    199a:	0e 94 31 03 	call	0x662	; 0x662 <LCD_sendData>
                  input_buffer[input_buffer_pointer] = pressed_key;
    199e:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <input_buffer_pointer>
    19a2:	e8 2f       	mov	r30, r24
    19a4:	f0 e0       	ldi	r31, 0x00	; 0
    19a6:	e5 54       	subi	r30, 0x45	; 69
    19a8:	f8 4f       	sbci	r31, 0xF8	; 248
    19aa:	99 81       	ldd	r25, Y+1	; 0x01
    19ac:	90 83       	st	Z, r25
                  input_buffer_pointer++;
    19ae:	8f 5f       	subi	r24, 0xFF	; 255
    19b0:	80 93 9a 07 	sts	0x079A, r24	; 0x80079a <input_buffer_pointer>
    19b4:	86 c1       	rjmp	.+780    	; 0x1cc2 <Local_control_input_handler+0x488>
                  }
                }
              break;
              //  Entering the password
            case 1:
              if (!login_stage_started) {
    19b6:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <login_stage_started>
    19ba:	81 11       	cpse	r24, r1
    19bc:	13 c0       	rjmp	.+38     	; 0x19e4 <Local_control_input_handler+0x1aa>
                LCD_clear_screen();
    19be:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
                Show_side_options_menu();
    19c2:	0e 94 b5 0a 	call	0x156a	; 0x156a <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "Password:");
    19c6:	4d ea       	ldi	r20, 0xAD	; 173
    19c8:	51 e0       	ldi	r21, 0x01	; 1
    19ca:	60 e0       	ldi	r22, 0x00	; 0
    19cc:	80 e0       	ldi	r24, 0x00	; 0
    19ce:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    19d2:	61 e0       	ldi	r22, 0x01	; 1
    19d4:	80 e0       	ldi	r24, 0x00	; 0
    19d6:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_move_cursor_xy>
                login_stage_started = true;
    19da:	81 e0       	ldi	r24, 0x01	; 1
    19dc:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <login_stage_started>
                input_buffer_pointer = 0;
    19e0:	10 92 9a 07 	sts	0x079A, r1	; 0x80079a <input_buffer_pointer>
                }
              if (pressed_key == '-') { // Delete last input number
    19e4:	89 81       	ldd	r24, Y+1	; 0x01
    19e6:	8d 32       	cpi	r24, 0x2D	; 45
    19e8:	a1 f4       	brne	.+40     	; 0x1a12 <Local_control_input_handler+0x1d8>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    19ea:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <input_buffer_pointer>
    19ee:	88 23       	and	r24, r24
    19f0:	19 f0       	breq	.+6      	; 0x19f8 <Local_control_input_handler+0x1be>
    19f2:	81 50       	subi	r24, 0x01	; 1
    19f4:	80 93 9a 07 	sts	0x079A, r24	; 0x80079a <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    19f8:	41 e3       	ldi	r20, 0x31	; 49
    19fa:	51 e0       	ldi	r21, 0x01	; 1
    19fc:	61 e0       	ldi	r22, 0x01	; 1
    19fe:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <input_buffer_pointer>
    1a02:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    1a06:	61 e0       	ldi	r22, 0x01	; 1
    1a08:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <input_buffer_pointer>
    1a0c:	0e 94 c6 03 	call	0x78c	; 0x78c <LCD_move_cursor_xy>
    1a10:	58 c1       	rjmp	.+688    	; 0x1cc2 <Local_control_input_handler+0x488>
                }
              else if (pressed_key == '=') {
    1a12:	8d 33       	cpi	r24, 0x3D	; 61
    1a14:	09 f0       	breq	.+2      	; 0x1a18 <Local_control_input_handler+0x1de>
    1a16:	54 c0       	rjmp	.+168    	; 0x1ac0 <Local_control_input_handler+0x286>
                input_buffer[input_buffer_pointer] = 0;
    1a18:	e0 91 9a 07 	lds	r30, 0x079A	; 0x80079a <input_buffer_pointer>
    1a1c:	f0 e0       	ldi	r31, 0x00	; 0
    1a1e:	e5 54       	subi	r30, 0x45	; 69
    1a20:	f8 4f       	sbci	r31, 0xF8	; 248
    1a22:	10 82       	st	Z, r1
                // Validate user password
                if (strcmp(input_buffer, local_user.password) == 0) { // Password is correct
    1a24:	60 eb       	ldi	r22, 0xB0	; 176
    1a26:	77 e0       	ldi	r23, 0x07	; 7
    1a28:	8b eb       	ldi	r24, 0xBB	; 187
    1a2a:	97 e0       	ldi	r25, 0x07	; 7
    1a2c:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <strcmp>
    1a30:	89 2b       	or	r24, r25
    1a32:	99 f5       	brne	.+102    	; 0x1a9a <Local_control_input_handler+0x260>
                  login_stage_started = false;
    1a34:	10 92 c9 07 	sts	0x07C9, r1	; 0x8007c9 <login_stage_started>
                  login_stage = 0;
    1a38:	10 92 ca 07 	sts	0x07CA, r1	; 0x8007ca <login_stage>
                  local_control_running_task = 2;
    1a3c:	82 e0       	ldi	r24, 0x02	; 2
    1a3e:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <local_control_running_task>
                  local_user_loggedin = true;
    1a42:	81 e0       	ldi	r24, 0x01	; 1
    1a44:	80 93 79 07 	sts	0x0779, r24	; 0x800779 <local_user_loggedin>
                  LCD_clear_screen();
    1a48:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
                  LCD_write_string_xy(4, 0, "Welcome");
    1a4c:	47 eb       	ldi	r20, 0xB7	; 183
    1a4e:	51 e0       	ldi	r21, 0x01	; 1
    1a50:	60 e0       	ldi	r22, 0x00	; 0
    1a52:	84 e0       	ldi	r24, 0x04	; 4
    1a54:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
                  LCD_write_string_xy((16 - strlen(local_user.name)) / 2 - 1, 1, local_user.name);
    1a58:	ec e9       	ldi	r30, 0x9C	; 156
    1a5a:	f7 e0       	ldi	r31, 0x07	; 7
    1a5c:	01 90       	ld	r0, Z+
    1a5e:	00 20       	and	r0, r0
    1a60:	e9 f7       	brne	.-6      	; 0x1a5c <Local_control_input_handler+0x222>
    1a62:	9f 01       	movw	r18, r30
    1a64:	2d 59       	subi	r18, 0x9D	; 157
    1a66:	37 40       	sbci	r19, 0x07	; 7
    1a68:	80 e1       	ldi	r24, 0x10	; 16
    1a6a:	90 e0       	ldi	r25, 0x00	; 0
    1a6c:	82 1b       	sub	r24, r18
    1a6e:	93 0b       	sbc	r25, r19
    1a70:	96 95       	lsr	r25
    1a72:	87 95       	ror	r24
    1a74:	4c e9       	ldi	r20, 0x9C	; 156
    1a76:	57 e0       	ldi	r21, 0x07	; 7
    1a78:	61 e0       	ldi	r22, 0x01	; 1
    1a7a:	81 50       	subi	r24, 0x01	; 1
    1a7c:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
                  LCD_sendData('!');
    1a80:	81 e2       	ldi	r24, 0x21	; 33
    1a82:	0e 94 31 03 	call	0x662	; 0x662 <LCD_sendData>
    1a86:	2f ef       	ldi	r18, 0xFF	; 255
    1a88:	83 ed       	ldi	r24, 0xD3	; 211
    1a8a:	90 e3       	ldi	r25, 0x30	; 48
    1a8c:	21 50       	subi	r18, 0x01	; 1
    1a8e:	80 40       	sbci	r24, 0x00	; 0
    1a90:	90 40       	sbci	r25, 0x00	; 0
    1a92:	e1 f7       	brne	.-8      	; 0x1a8c <Local_control_input_handler+0x252>
    1a94:	00 c0       	rjmp	.+0      	; 0x1a96 <Local_control_input_handler+0x25c>
    1a96:	00 00       	nop
    1a98:	14 c1       	rjmp	.+552    	; 0x1cc2 <Local_control_input_handler+0x488>
                  _delay_ms(1000);
                  }
                else {
                  LCD_clear_screen();
    1a9a:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    1a9e:	4b e9       	ldi	r20, 0x9B	; 155
    1aa0:	51 e0       	ldi	r21, 0x01	; 1
    1aa2:	60 e0       	ldi	r22, 0x00	; 0
    1aa4:	85 e0       	ldi	r24, 0x05	; 5
    1aa6:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
                  LCD_write_string_xy(3, 1, "Password !");
    1aaa:	4f eb       	ldi	r20, 0xBF	; 191
    1aac:	51 e0       	ldi	r21, 0x01	; 1
    1aae:	61 e0       	ldi	r22, 0x01	; 1
    1ab0:	83 e0       	ldi	r24, 0x03	; 3
    1ab2:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
                  login_stage_started = false;
    1ab6:	10 92 c9 07 	sts	0x07C9, r1	; 0x8007c9 <login_stage_started>
                  invalid_local_login_attempt();
    1aba:	0e 94 cc 0b 	call	0x1798	; 0x1798 <invalid_local_login_attempt>
    1abe:	01 c1       	rjmp	.+514    	; 0x1cc2 <Local_control_input_handler+0x488>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    1ac0:	90 ed       	ldi	r25, 0xD0	; 208
    1ac2:	98 0f       	add	r25, r24
    1ac4:	9a 30       	cpi	r25, 0x0A	; 10
    1ac6:	08 f0       	brcs	.+2      	; 0x1aca <Local_control_input_handler+0x290>
    1ac8:	fc c0       	rjmp	.+504    	; 0x1cc2 <Local_control_input_handler+0x488>
                // Limit the input length
                if (input_buffer_pointer < 10) {
    1aca:	90 91 9a 07 	lds	r25, 0x079A	; 0x80079a <input_buffer_pointer>
    1ace:	9a 30       	cpi	r25, 0x0A	; 10
    1ad0:	08 f0       	brcs	.+2      	; 0x1ad4 <Local_control_input_handler+0x29a>
    1ad2:	f7 c0       	rjmp	.+494    	; 0x1cc2 <Local_control_input_handler+0x488>
                  // Echo the input on the LCD
                  LCD_sendData(pressed_key);
    1ad4:	0e 94 31 03 	call	0x662	; 0x662 <LCD_sendData>
                  input_buffer[input_buffer_pointer] = pressed_key;
    1ad8:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <input_buffer_pointer>
    1adc:	e8 2f       	mov	r30, r24
    1ade:	f0 e0       	ldi	r31, 0x00	; 0
    1ae0:	e5 54       	subi	r30, 0x45	; 69
    1ae2:	f8 4f       	sbci	r31, 0xF8	; 248
    1ae4:	99 81       	ldd	r25, Y+1	; 0x01
    1ae6:	90 83       	st	Z, r25
                  input_buffer_pointer++;
    1ae8:	8f 5f       	subi	r24, 0xFF	; 255
    1aea:	80 93 9a 07 	sts	0x079A, r24	; 0x80079a <input_buffer_pointer>
    1aee:	e9 c0       	rjmp	.+466    	; 0x1cc2 <Local_control_input_handler+0x488>
              break;
          }
        break;
        // Devices control
      case 2:
        if (remote_user_loggedin && !local_control_permission_granted) {
    1af0:	80 91 7a 07 	lds	r24, 0x077A	; 0x80077a <remote_user_loggedin>
    1af4:	88 23       	and	r24, r24
    1af6:	99 f0       	breq	.+38     	; 0x1b1e <Local_control_input_handler+0x2e4>
    1af8:	80 91 7c 07 	lds	r24, 0x077C	; 0x80077c <local_control_permission_granted>
    1afc:	81 11       	cpse	r24, r1
    1afe:	0f c0       	rjmp	.+30     	; 0x1b1e <Local_control_input_handler+0x2e4>
          LCD_clear_screen();
    1b00:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
          LCD_write_string_xy(0, 0, "Admin Permission");
    1b04:	4a ec       	ldi	r20, 0xCA	; 202
    1b06:	51 e0       	ldi	r21, 0x01	; 1
    1b08:	60 e0       	ldi	r22, 0x00	; 0
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
    1b0c:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
          LCD_write_string_xy(3, 1, "Required !");
    1b10:	4b ed       	ldi	r20, 0xDB	; 219
    1b12:	51 e0       	ldi	r21, 0x01	; 1
    1b14:	61 e0       	ldi	r22, 0x01	; 1
    1b16:	83 e0       	ldi	r24, 0x03	; 3
    1b18:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
    1b1c:	d2 c0       	rjmp	.+420    	; 0x1cc2 <Local_control_input_handler+0x488>
          //~ Controls can be added to allow the user to go back and view the running devices if needed.
          }
        else {
          Get_running_devices();
    1b1e:	0e 94 41 0a 	call	0x1482	; 0x1482 <Get_running_devices>
          if (control_devices_screen == 0) {  // First run
    1b22:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <control_devices_screen>
    1b26:	81 11       	cpse	r24, r1
    1b28:	08 c0       	rjmp	.+16     	; 0x1b3a <Local_control_input_handler+0x300>
            Show_devices_controls(1);
    1b2a:	81 e0       	ldi	r24, 0x01	; 1
    1b2c:	0e 94 3a 0b 	call	0x1674	; 0x1674 <Show_devices_controls>
            control_devices_screen++;
    1b30:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <control_devices_screen>
    1b34:	8f 5f       	subi	r24, 0xFF	; 255
    1b36:	80 93 c8 07 	sts	0x07C8, r24	; 0x8007c8 <control_devices_screen>
            }
          if (keypad_stat == NO_KEY_PRESSED) return;
    1b3a:	12 30       	cpi	r17, 0x02	; 2
    1b3c:	09 f4       	brne	.+2      	; 0x1b40 <Local_control_input_handler+0x306>
    1b3e:	c1 c0       	rjmp	.+386    	; 0x1cc2 <Local_control_input_handler+0x488>
          switch (pressed_key) {
    1b40:	89 81       	ldd	r24, Y+1	; 0x01
    1b42:	82 33       	cpi	r24, 0x32	; 50
    1b44:	a1 f0       	breq	.+40     	; 0x1b6e <Local_control_input_handler+0x334>
    1b46:	18 f4       	brcc	.+6      	; 0x1b4e <Local_control_input_handler+0x314>
    1b48:	81 33       	cpi	r24, 0x31	; 49
    1b4a:	41 f0       	breq	.+16     	; 0x1b5c <Local_control_input_handler+0x322>
    1b4c:	b6 c0       	rjmp	.+364    	; 0x1cba <Local_control_input_handler+0x480>
    1b4e:	83 33       	cpi	r24, 0x33	; 51
    1b50:	09 f4       	brne	.+2      	; 0x1b54 <Local_control_input_handler+0x31a>
    1b52:	73 c0       	rjmp	.+230    	; 0x1c3a <Local_control_input_handler+0x400>
    1b54:	84 33       	cpi	r24, 0x34	; 52
    1b56:	09 f4       	brne	.+2      	; 0x1b5a <Local_control_input_handler+0x320>
    1b58:	a9 c0       	rjmp	.+338    	; 0x1cac <Local_control_input_handler+0x472>
    1b5a:	af c0       	rjmp	.+350    	; 0x1cba <Local_control_input_handler+0x480>
              case '1':
                if (control_devices_screen > 1) control_devices_screen--;
    1b5c:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <control_devices_screen>
    1b60:	82 30       	cpi	r24, 0x02	; 2
    1b62:	08 f4       	brcc	.+2      	; 0x1b66 <Local_control_input_handler+0x32c>
    1b64:	aa c0       	rjmp	.+340    	; 0x1cba <Local_control_input_handler+0x480>
    1b66:	81 50       	subi	r24, 0x01	; 1
    1b68:	80 93 c8 07 	sts	0x07C8, r24	; 0x8007c8 <control_devices_screen>
    1b6c:	a6 c0       	rjmp	.+332    	; 0x1cba <Local_control_input_handler+0x480>
                break;
              case '2':
                switch (control_devices_screen) {
    1b6e:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <control_devices_screen>
    1b72:	86 30       	cpi	r24, 0x06	; 6
    1b74:	19 f0       	breq	.+6      	; 0x1b7c <Local_control_input_handler+0x342>
    1b76:	87 30       	cpi	r24, 0x07	; 7
    1b78:	a1 f1       	breq	.+104    	; 0x1be2 <Local_control_input_handler+0x3a8>
    1b7a:	53 c0       	rjmp	.+166    	; 0x1c22 <Local_control_input_handler+0x3e8>
                    case 6:
                      // Increment the brightness
                      // Floor the brightness
                      dimmer_brightness += ((double)LAMP_6_BRIGHTNESS_PERCENTAGE_STEP * 2.55);
    1b7c:	60 91 c6 07 	lds	r22, 0x07C6	; 0x8007c6 <dimmer_brightness>
    1b80:	70 91 c7 07 	lds	r23, 0x07C7	; 0x8007c7 <dimmer_brightness+0x1>
    1b84:	07 2e       	mov	r0, r23
    1b86:	00 0c       	add	r0, r0
    1b88:	88 0b       	sbc	r24, r24
    1b8a:	99 0b       	sbc	r25, r25
    1b8c:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__floatsisf>
    1b90:	20 e0       	ldi	r18, 0x00	; 0
    1b92:	30 e0       	ldi	r19, 0x00	; 0
    1b94:	4c ec       	ldi	r20, 0xCC	; 204
    1b96:	51 e4       	ldi	r21, 0x41	; 65
    1b98:	0e 94 cd 14 	call	0x299a	; 0x299a <__addsf3>
    1b9c:	0e 94 ab 15 	call	0x2b56	; 0x2b56 <__fixsfsi>
    1ba0:	70 93 c7 07 	sts	0x07C7, r23	; 0x8007c7 <dimmer_brightness+0x1>
    1ba4:	60 93 c6 07 	sts	0x07C6, r22	; 0x8007c6 <dimmer_brightness>
                      if (dimmer_brightness > 255) dimmer_brightness = 255;
    1ba8:	6f 3f       	cpi	r22, 0xFF	; 255
    1baa:	71 05       	cpc	r23, r1
    1bac:	39 f0       	breq	.+14     	; 0x1bbc <Local_control_input_handler+0x382>
    1bae:	34 f0       	brlt	.+12     	; 0x1bbc <Local_control_input_handler+0x382>
    1bb0:	8f ef       	ldi	r24, 0xFF	; 255
    1bb2:	90 e0       	ldi	r25, 0x00	; 0
    1bb4:	90 93 c7 07 	sts	0x07C7, r25	; 0x8007c7 <dimmer_brightness+0x1>
    1bb8:	80 93 c6 07 	sts	0x07C6, r24	; 0x8007c6 <dimmer_brightness>
                      Lamp_dimmable_set_brightness(((double)dimmer_brightness / 255.0));
    1bbc:	60 91 c6 07 	lds	r22, 0x07C6	; 0x8007c6 <dimmer_brightness>
    1bc0:	70 91 c7 07 	lds	r23, 0x07C7	; 0x8007c7 <dimmer_brightness+0x1>
    1bc4:	07 2e       	mov	r0, r23
    1bc6:	00 0c       	add	r0, r0
    1bc8:	88 0b       	sbc	r24, r24
    1bca:	99 0b       	sbc	r25, r25
    1bcc:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__floatsisf>
    1bd0:	20 e0       	ldi	r18, 0x00	; 0
    1bd2:	30 e0       	ldi	r19, 0x00	; 0
    1bd4:	4f e7       	ldi	r20, 0x7F	; 127
    1bd6:	53 e4       	ldi	r21, 0x43	; 67
    1bd8:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__divsf3>
    1bdc:	0e 94 34 0a 	call	0x1468	; 0x1468 <Lamp_dimmable_set_brightness>
                      break;
    1be0:	6c c0       	rjmp	.+216    	; 0x1cba <Local_control_input_handler+0x480>
                    case 7:
                      // Logout
                      local_user_loggedin = false;
    1be2:	10 92 79 07 	sts	0x0779, r1	; 0x800779 <local_user_loggedin>
                      control_devices_screen = 0;
    1be6:	10 92 c8 07 	sts	0x07C8, r1	; 0x8007c8 <control_devices_screen>
                      running_devices_screen = 0;
    1bea:	10 92 cb 07 	sts	0x07CB, r1	; 0x8007cb <running_devices_screen>
                      local_control_running_task = 0;
    1bee:	10 92 99 07 	sts	0x0799, r1	; 0x800799 <local_control_running_task>
                      LCD_clear_screen();
    1bf2:	0e 94 63 03 	call	0x6c6	; 0x6c6 <LCD_clear_screen>
                      LCD_write_string_xy(1, 0, "logging out...");
    1bf6:	46 ee       	ldi	r20, 0xE6	; 230
    1bf8:	51 e0       	ldi	r21, 0x01	; 1
    1bfa:	60 e0       	ldi	r22, 0x00	; 0
    1bfc:	81 e0       	ldi	r24, 0x01	; 1
    1bfe:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
                      LCD_write_string_xy(4, 0, "Good Bye!");
    1c02:	45 ef       	ldi	r20, 0xF5	; 245
    1c04:	51 e0       	ldi	r21, 0x01	; 1
    1c06:	60 e0       	ldi	r22, 0x00	; 0
    1c08:	84 e0       	ldi	r24, 0x04	; 4
    1c0a:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <LCD_write_string_xy>
    1c0e:	2f ef       	ldi	r18, 0xFF	; 255
    1c10:	83 ed       	ldi	r24, 0xD3	; 211
    1c12:	90 e3       	ldi	r25, 0x30	; 48
    1c14:	21 50       	subi	r18, 0x01	; 1
    1c16:	80 40       	sbci	r24, 0x00	; 0
    1c18:	90 40       	sbci	r25, 0x00	; 0
    1c1a:	e1 f7       	brne	.-8      	; 0x1c14 <Local_control_input_handler+0x3da>
    1c1c:	00 c0       	rjmp	.+0      	; 0x1c1e <Local_control_input_handler+0x3e4>
    1c1e:	00 00       	nop
    1c20:	4c c0       	rjmp	.+152    	; 0x1cba <Local_control_input_handler+0x480>
                      _delay_ms(1000);
                      break;
                    default:
                      Lamp_toggle(control_devices_screen);
    1c22:	0e 94 02 0a 	call	0x1404	; 0x1404 <Lamp_toggle>
                      running_devices[control_devices_screen - 1] = !running_devices[control_devices_screen - 1];
    1c26:	e0 91 c8 07 	lds	r30, 0x07C8	; 0x8007c8 <control_devices_screen>
    1c2a:	f0 e0       	ldi	r31, 0x00	; 0
    1c2c:	e0 57       	subi	r30, 0x70	; 112
    1c2e:	f8 4f       	sbci	r31, 0xF8	; 248
    1c30:	90 81       	ld	r25, Z
    1c32:	81 e0       	ldi	r24, 0x01	; 1
    1c34:	89 27       	eor	r24, r25
    1c36:	80 83       	st	Z, r24
                      break;
    1c38:	40 c0       	rjmp	.+128    	; 0x1cba <Local_control_input_handler+0x480>
                  }
                break;
              case '3':
                switch (control_devices_screen) {
    1c3a:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <control_devices_screen>
    1c3e:	86 30       	cpi	r24, 0x06	; 6
    1c40:	79 f5       	brne	.+94     	; 0x1ca0 <Local_control_input_handler+0x466>
                    case 6:
                      // Decrement the brightness
                      // Ceil the brightness
                      dimmer_brightness -= ((double)LAMP_6_BRIGHTNESS_PERCENTAGE_STEP * 2.55);
    1c42:	60 91 c6 07 	lds	r22, 0x07C6	; 0x8007c6 <dimmer_brightness>
    1c46:	70 91 c7 07 	lds	r23, 0x07C7	; 0x8007c7 <dimmer_brightness+0x1>
    1c4a:	07 2e       	mov	r0, r23
    1c4c:	00 0c       	add	r0, r0
    1c4e:	88 0b       	sbc	r24, r24
    1c50:	99 0b       	sbc	r25, r25
    1c52:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__floatsisf>
    1c56:	20 e0       	ldi	r18, 0x00	; 0
    1c58:	30 e0       	ldi	r19, 0x00	; 0
    1c5a:	4c ec       	ldi	r20, 0xCC	; 204
    1c5c:	51 e4       	ldi	r21, 0x41	; 65
    1c5e:	0e 94 cc 14 	call	0x2998	; 0x2998 <__subsf3>
    1c62:	0e 94 ab 15 	call	0x2b56	; 0x2b56 <__fixsfsi>
    1c66:	70 93 c7 07 	sts	0x07C7, r23	; 0x8007c7 <dimmer_brightness+0x1>
    1c6a:	60 93 c6 07 	sts	0x07C6, r22	; 0x8007c6 <dimmer_brightness>
                      if (dimmer_brightness < 0) dimmer_brightness = 0;
    1c6e:	77 23       	and	r23, r23
    1c70:	24 f4       	brge	.+8      	; 0x1c7a <Local_control_input_handler+0x440>
    1c72:	10 92 c7 07 	sts	0x07C7, r1	; 0x8007c7 <dimmer_brightness+0x1>
    1c76:	10 92 c6 07 	sts	0x07C6, r1	; 0x8007c6 <dimmer_brightness>
                      Lamp_dimmable_set_brightness(((double)dimmer_brightness / 255.0));
    1c7a:	60 91 c6 07 	lds	r22, 0x07C6	; 0x8007c6 <dimmer_brightness>
    1c7e:	70 91 c7 07 	lds	r23, 0x07C7	; 0x8007c7 <dimmer_brightness+0x1>
    1c82:	07 2e       	mov	r0, r23
    1c84:	00 0c       	add	r0, r0
    1c86:	88 0b       	sbc	r24, r24
    1c88:	99 0b       	sbc	r25, r25
    1c8a:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__floatsisf>
    1c8e:	20 e0       	ldi	r18, 0x00	; 0
    1c90:	30 e0       	ldi	r19, 0x00	; 0
    1c92:	4f e7       	ldi	r20, 0x7F	; 127
    1c94:	53 e4       	ldi	r21, 0x43	; 67
    1c96:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__divsf3>
    1c9a:	0e 94 34 0a 	call	0x1468	; 0x1468 <Lamp_dimmable_set_brightness>
                      break;
    1c9e:	0d c0       	rjmp	.+26     	; 0x1cba <Local_control_input_handler+0x480>
                    default:
                      if (control_devices_screen < 7) control_devices_screen++;
    1ca0:	87 30       	cpi	r24, 0x07	; 7
    1ca2:	58 f4       	brcc	.+22     	; 0x1cba <Local_control_input_handler+0x480>
    1ca4:	8f 5f       	subi	r24, 0xFF	; 255
    1ca6:	80 93 c8 07 	sts	0x07C8, r24	; 0x8007c8 <control_devices_screen>
    1caa:	07 c0       	rjmp	.+14     	; 0x1cba <Local_control_input_handler+0x480>
                      break;
                  }
                break;
              case '4':
                // Moving to logout screen
                if (control_devices_screen == 6) control_devices_screen++;
    1cac:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <control_devices_screen>
    1cb0:	86 30       	cpi	r24, 0x06	; 6
    1cb2:	19 f4       	brne	.+6      	; 0x1cba <Local_control_input_handler+0x480>
    1cb4:	8f 5f       	subi	r24, 0xFF	; 255
    1cb6:	80 93 c8 07 	sts	0x07C8, r24	; 0x8007c8 <control_devices_screen>
                break;
            }
          Show_devices_controls(control_devices_screen);
    1cba:	80 91 c8 07 	lds	r24, 0x07C8	; 0x8007c8 <control_devices_screen>
    1cbe:	0e 94 3a 0b 	call	0x1674	; 0x1674 <Show_devices_controls>
          }
        break;
    }
    1cc2:	0f 90       	pop	r0
    1cc4:	df 91       	pop	r29
    1cc6:	cf 91       	pop	r28
    1cc8:	1f 91       	pop	r17
    1cca:	08 95       	ret

00001ccc <println_msg>:
  BT_init(baudRate);
  }

void println_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    1ccc:	0e 94 de 01 	call	0x3bc	; 0x3bc <BT_sendString>
  // Send CRLF - carriage return + new line
  BT_sendString("\r\n");
    1cd0:	8f ef       	ldi	r24, 0xFF	; 255
    1cd2:	91 e0       	ldi	r25, 0x01	; 1
    1cd4:	0e 94 de 01 	call	0x3bc	; 0x3bc <BT_sendString>
    1cd8:	08 95       	ret

00001cda <print_msg>:
  }

void print_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    1cda:	0e 94 de 01 	call	0x3bc	; 0x3bc <BT_sendString>
    1cde:	08 95       	ret

00001ce0 <request_user_input>:
  }

void request_user_input(s8 options[4], u8 msgLength) {
    1ce0:	cf 93       	push	r28
    1ce2:	c6 2f       	mov	r28, r22
  strcpy(user_dialog_tree, options);
    1ce4:	bc 01       	movw	r22, r24
    1ce6:	8d e8       	ldi	r24, 0x8D	; 141
    1ce8:	97 e0       	ldi	r25, 0x07	; 7
    1cea:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <strcpy>
  msg_length = msgLength;
    1cee:	c0 93 8c 07 	sts	0x078C, r28	; 0x80078c <msg_length>
  }
    1cf2:	cf 91       	pop	r28
    1cf4:	08 95       	ret

00001cf6 <print_remote_control_menu>:
      }
    }
  }

void print_remote_control_menu(void) {
  println_msg("Select one of the following devices to control:\t");
    1cf6:	82 e0       	ldi	r24, 0x02	; 2
    1cf8:	92 e0       	ldi	r25, 0x02	; 2
    1cfa:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
  println_msg("[1] Lamp 1");
    1cfe:	83 e3       	ldi	r24, 0x33	; 51
    1d00:	92 e0       	ldi	r25, 0x02	; 2
    1d02:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
  println_msg("[2] Lamp 2");
    1d06:	8e e3       	ldi	r24, 0x3E	; 62
    1d08:	92 e0       	ldi	r25, 0x02	; 2
    1d0a:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
  println_msg("[3] Lamp 3");
    1d0e:	89 e4       	ldi	r24, 0x49	; 73
    1d10:	92 e0       	ldi	r25, 0x02	; 2
    1d12:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
  println_msg("[4] Lamp 4");
    1d16:	84 e5       	ldi	r24, 0x54	; 84
    1d18:	92 e0       	ldi	r25, 0x02	; 2
    1d1a:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
  println_msg("[5] Lamp 5");
    1d1e:	8f e5       	ldi	r24, 0x5F	; 95
    1d20:	92 e0       	ldi	r25, 0x02	; 2
    1d22:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
  println_msg("[6] Lamp 6");
    1d26:	8a e6       	ldi	r24, 0x6A	; 106
    1d28:	92 e0       	ldi	r25, 0x02	; 2
    1d2a:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
  if (remote_user.isAdmin) {
    1d2e:	80 91 cc 07 	lds	r24, 0x07CC	; 0x8007cc <remote_user>
    1d32:	88 23       	and	r24, r24
    1d34:	21 f0       	breq	.+8      	; 0x1d3e <print_remote_control_menu+0x48>
    println_msg("[7] The Door");
    1d36:	85 e7       	ldi	r24, 0x75	; 117
    1d38:	92 e0       	ldi	r25, 0x02	; 2
    1d3a:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    1d3e:	08 95       	ret

00001d40 <control_device>:
  }

// TODO: Send the status of each device to the user instead of just asking him to switch the device on or off.

void control_device(void) {
  u8 option = msg_buffer[0];
    1d40:	60 91 7d 07 	lds	r22, 0x077D	; 0x80077d <msg_buffer>
  if (invalid_user_input || option < '0' || option > '9') {
    1d44:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <invalid_user_input>
    1d48:	81 11       	cpse	r24, r1
    1d4a:	04 c0       	rjmp	.+8      	; 0x1d54 <control_device+0x14>
    1d4c:	60 33       	cpi	r22, 0x30	; 48
    1d4e:	10 f0       	brcs	.+4      	; 0x1d54 <control_device+0x14>
    1d50:	6a 33       	cpi	r22, 0x3A	; 58
    1d52:	60 f0       	brcs	.+24     	; 0x1d6c <control_device+0x2c>
    println_msg("\r\nInvalid input!!\t");
    1d54:	82 e8       	ldi	r24, 0x82	; 130
    1d56:	92 e0       	ldi	r25, 0x02	; 2
    1d58:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    print_remote_control_menu();
    1d5c:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    1d60:	62 e0       	ldi	r22, 0x02	; 2
    1d62:	89 ef       	ldi	r24, 0xF9	; 249
    1d64:	9e e0       	ldi	r25, 0x0E	; 14
    1d66:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    1d6a:	08 95       	ret
    }
  else {
    if (device_number < 6) {
    1d6c:	80 91 0e 08 	lds	r24, 0x080E	; 0x80080e <device_number>
    1d70:	86 30       	cpi	r24, 0x06	; 6
    1d72:	80 f4       	brcc	.+32     	; 0x1d94 <control_device+0x54>
      if (option == '1') {
    1d74:	61 33       	cpi	r22, 0x31	; 49
    1d76:	39 f4       	brne	.+14     	; 0x1d86 <control_device+0x46>
        Lamp_on(device_number);
    1d78:	0e 94 ac 09 	call	0x1358	; 0x1358 <Lamp_on>
        println_msg("The device has been turned on!");
    1d7c:	85 e9       	ldi	r24, 0x95	; 149
    1d7e:	92 e0       	ldi	r25, 0x02	; 2
    1d80:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    1d84:	2e c0       	rjmp	.+92     	; 0x1de2 <control_device+0xa2>
        }
      else {
        Lamp_off(device_number);
    1d86:	0e 94 d7 09 	call	0x13ae	; 0x13ae <Lamp_off>
        println_msg("The device has been turned off!");
    1d8a:	84 eb       	ldi	r24, 0xB4	; 180
    1d8c:	92 e0       	ldi	r25, 0x02	; 2
    1d8e:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    1d92:	27 c0       	rjmp	.+78     	; 0x1de2 <control_device+0xa2>
        }
      }
    else if (device_number == 6) { // Dimmable led
    1d94:	86 30       	cpi	r24, 0x06	; 6
    1d96:	b1 f4       	brne	.+44     	; 0x1dc4 <control_device+0x84>
      Lamp_dimmable_set_brightness(((double)(option - 48) / 9.0));
    1d98:	70 e0       	ldi	r23, 0x00	; 0
    1d9a:	60 53       	subi	r22, 0x30	; 48
    1d9c:	71 09       	sbc	r23, r1
    1d9e:	07 2e       	mov	r0, r23
    1da0:	00 0c       	add	r0, r0
    1da2:	88 0b       	sbc	r24, r24
    1da4:	99 0b       	sbc	r25, r25
    1da6:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__floatsisf>
    1daa:	20 e0       	ldi	r18, 0x00	; 0
    1dac:	30 e0       	ldi	r19, 0x00	; 0
    1dae:	40 e1       	ldi	r20, 0x10	; 16
    1db0:	51 e4       	ldi	r21, 0x41	; 65
    1db2:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__divsf3>
    1db6:	0e 94 34 0a 	call	0x1468	; 0x1468 <Lamp_dimmable_set_brightness>
      println_msg("The brightness has been adjusted!");
    1dba:	84 ed       	ldi	r24, 0xD4	; 212
    1dbc:	92 e0       	ldi	r25, 0x02	; 2
    1dbe:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    1dc2:	0f c0       	rjmp	.+30     	; 0x1de2 <control_device+0xa2>
      }
    else {
      if (option == '1') {
    1dc4:	61 33       	cpi	r22, 0x31	; 49
    1dc6:	39 f4       	brne	.+14     	; 0x1dd6 <control_device+0x96>
        Door_open();
    1dc8:	0e 94 7f 09 	call	0x12fe	; 0x12fe <Door_open>
        println_msg("The Door is open now.");
    1dcc:	86 ef       	ldi	r24, 0xF6	; 246
    1dce:	92 e0       	ldi	r25, 0x02	; 2
    1dd0:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    1dd4:	06 c0       	rjmp	.+12     	; 0x1de2 <control_device+0xa2>
        }
      else {
        Door_close();
    1dd6:	0e 94 83 09 	call	0x1306	; 0x1306 <Door_close>
        println_msg("The Door is closed now.");
    1dda:	8c e0       	ldi	r24, 0x0C	; 12
    1ddc:	93 e0       	ldi	r25, 0x03	; 3
    1dde:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
        }
      }
    print_remote_control_menu();
    1de2:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    1de6:	62 e0       	ldi	r22, 0x02	; 2
    1de8:	89 ef       	ldi	r24, 0xF9	; 249
    1dea:	9e e0       	ldi	r25, 0x0E	; 14
    1dec:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    1df0:	08 95       	ret

00001df2 <remote_control>:
    }
  }

void remote_control(void) {
    1df2:	cf 93       	push	r28
  u8 option = msg_buffer[0];
    1df4:	c0 91 7d 07 	lds	r28, 0x077D	; 0x80077d <msg_buffer>
  if (remote_user.isAdmin) {
    1df8:	80 91 cc 07 	lds	r24, 0x07CC	; 0x8007cc <remote_user>
    1dfc:	88 23       	and	r24, r24
    1dfe:	49 f1       	breq	.+82     	; 0x1e52 <remote_control+0x60>
    if (invalid_user_input || option < '1' || option > '7') {
    1e00:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <invalid_user_input>
    1e04:	81 11       	cpse	r24, r1
    1e06:	04 c0       	rjmp	.+8      	; 0x1e10 <remote_control+0x1e>
    1e08:	c1 33       	cpi	r28, 0x31	; 49
    1e0a:	10 f0       	brcs	.+4      	; 0x1e10 <remote_control+0x1e>
    1e0c:	c8 33       	cpi	r28, 0x38	; 56
    1e0e:	60 f0       	brcs	.+24     	; 0x1e28 <remote_control+0x36>
      println_msg("Invalid option!\t");
    1e10:	84 e2       	ldi	r24, 0x24	; 36
    1e12:	93 e0       	ldi	r25, 0x03	; 3
    1e14:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      print_remote_control_menu();
    1e18:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    1e1c:	62 e0       	ldi	r22, 0x02	; 2
    1e1e:	89 ef       	ldi	r24, 0xF9	; 249
    1e20:	9e e0       	ldi	r25, 0x0E	; 14
    1e22:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    1e26:	3d c0       	rjmp	.+122    	; 0x1ea2 <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    1e28:	85 e3       	ldi	r24, 0x35	; 53
    1e2a:	93 e0       	ldi	r25, 0x03	; 3
    1e2c:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    1e30:	8b e8       	ldi	r24, 0x8B	; 139
    1e32:	93 e0       	ldi	r25, 0x03	; 3
    1e34:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    1e38:	84 ec       	ldi	r24, 0xC4	; 196
    1e3a:	93 e0       	ldi	r25, 0x03	; 3
    1e3c:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      request_user_input(control_device, 2);
    1e40:	62 e0       	ldi	r22, 0x02	; 2
    1e42:	80 ea       	ldi	r24, 0xA0	; 160
    1e44:	9e e0       	ldi	r25, 0x0E	; 14
    1e46:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
      device_number = option - 48;
    1e4a:	c0 53       	subi	r28, 0x30	; 48
    1e4c:	c0 93 0e 08 	sts	0x080E, r28	; 0x80080e <device_number>
    1e50:	28 c0       	rjmp	.+80     	; 0x1ea2 <remote_control+0xb0>
      }
    }
  else {
    if (invalid_user_input || option < '1' || option > '6') {
    1e52:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <invalid_user_input>
    1e56:	81 11       	cpse	r24, r1
    1e58:	04 c0       	rjmp	.+8      	; 0x1e62 <remote_control+0x70>
    1e5a:	c1 33       	cpi	r28, 0x31	; 49
    1e5c:	10 f0       	brcs	.+4      	; 0x1e62 <remote_control+0x70>
    1e5e:	c7 33       	cpi	r28, 0x37	; 55
    1e60:	60 f0       	brcs	.+24     	; 0x1e7a <remote_control+0x88>
      println_msg("Invalid option!\t");
    1e62:	84 e2       	ldi	r24, 0x24	; 36
    1e64:	93 e0       	ldi	r25, 0x03	; 3
    1e66:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      print_remote_control_menu();
    1e6a:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    1e6e:	62 e0       	ldi	r22, 0x02	; 2
    1e70:	89 ef       	ldi	r24, 0xF9	; 249
    1e72:	9e e0       	ldi	r25, 0x0E	; 14
    1e74:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    1e78:	14 c0       	rjmp	.+40     	; 0x1ea2 <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    1e7a:	85 e3       	ldi	r24, 0x35	; 53
    1e7c:	93 e0       	ldi	r25, 0x03	; 3
    1e7e:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    1e82:	8b e8       	ldi	r24, 0x8B	; 139
    1e84:	93 e0       	ldi	r25, 0x03	; 3
    1e86:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    1e8a:	84 ec       	ldi	r24, 0xC4	; 196
    1e8c:	93 e0       	ldi	r25, 0x03	; 3
    1e8e:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      request_user_input(control_device, 2);
    1e92:	62 e0       	ldi	r22, 0x02	; 2
    1e94:	80 ea       	ldi	r24, 0xA0	; 160
    1e96:	9e e0       	ldi	r25, 0x0E	; 14
    1e98:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
      device_number = option - 48;
    1e9c:	c0 53       	subi	r28, 0x30	; 48
    1e9e:	c0 93 0e 08 	sts	0x080E, r28	; 0x80080e <device_number>
      }
    }
  }
    1ea2:	cf 91       	pop	r28
    1ea4:	08 95       	ret

00001ea6 <print_initial_options_menu>:

void print_initial_options_menu(void) {
  if (remote_user.isAdmin) {
    1ea6:	80 91 cc 07 	lds	r24, 0x07CC	; 0x8007cc <remote_user>
    1eaa:	88 23       	and	r24, r24
    1eac:	a9 f0       	breq	.+42     	; 0x1ed8 <print_initial_options_menu+0x32>
    println_msg("Select one of the following options(by entering its number):\t");
    1eae:	8c ef       	ldi	r24, 0xFC	; 252
    1eb0:	93 e0       	ldi	r25, 0x03	; 3
    1eb2:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    println_msg("[1] Add user\t");
    1eb6:	8a e3       	ldi	r24, 0x3A	; 58
    1eb8:	94 e0       	ldi	r25, 0x04	; 4
    1eba:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    println_msg("[2] Delete user\t");
    1ebe:	88 e4       	ldi	r24, 0x48	; 72
    1ec0:	94 e0       	ldi	r25, 0x04	; 4
    1ec2:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    println_msg("[3] Control a device\t");
    1ec6:	89 e5       	ldi	r24, 0x59	; 89
    1ec8:	94 e0       	ldi	r25, 0x04	; 4
    1eca:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    println_msg("[4] Log out\t");
    1ece:	8f e6       	ldi	r24, 0x6F	; 111
    1ed0:	94 e0       	ldi	r25, 0x04	; 4
    1ed2:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    1ed6:	08 95       	ret
    }
  else {
    println_msg("Select one of the following options(by entering its number):\t");
    1ed8:	8c ef       	ldi	r24, 0xFC	; 252
    1eda:	93 e0       	ldi	r25, 0x03	; 3
    1edc:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    println_msg("[1] Control a device\t");
    1ee0:	8c e7       	ldi	r24, 0x7C	; 124
    1ee2:	94 e0       	ldi	r25, 0x04	; 4
    1ee4:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    println_msg("[2] Log out\t");
    1ee8:	82 e9       	ldi	r24, 0x92	; 146
    1eea:	94 e0       	ldi	r25, 0x04	; 4
    1eec:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    1ef0:	08 95       	ret

00001ef2 <delete_user_prompt>:
  strcpy(user_dialog_tree, options);
  msg_length = msgLength;
  }

void delete_user_prompt(void) {
  if (invalid_user_input) {
    1ef2:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <invalid_user_input>
    1ef6:	88 23       	and	r24, r24
    1ef8:	61 f0       	breq	.+24     	; 0x1f12 <delete_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    1efa:	8f e9       	ldi	r24, 0x9F	; 159
    1efc:	94 e0       	ldi	r25, 0x04	; 4
    1efe:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1f02:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1f06:	62 e0       	ldi	r22, 0x02	; 2
    1f08:	8d ea       	ldi	r24, 0xAD	; 173
    1f0a:	9f e0       	ldi	r25, 0x0F	; 15
    1f0c:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    1f10:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    1f12:	6c ee       	ldi	r22, 0xEC	; 236
    1f14:	77 e0       	ldi	r23, 0x07	; 7
    1f16:	8d e7       	ldi	r24, 0x7D	; 125
    1f18:	97 e0       	ldi	r25, 0x07	; 7
    1f1a:	0e 94 83 12 	call	0x2506	; 0x2506 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    1f1e:	83 30       	cpi	r24, 0x03	; 3
    1f20:	61 f4       	brne	.+24     	; 0x1f3a <delete_user_prompt+0x48>
      println_msg("\rError! User not found. Returning to the main menu...");
    1f22:	85 eb       	ldi	r24, 0xB5	; 181
    1f24:	94 e0       	ldi	r25, 0x04	; 4
    1f26:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      print_initial_options_menu();
    1f2a:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1f2e:	62 e0       	ldi	r22, 0x02	; 2
    1f30:	8d ea       	ldi	r24, 0xAD	; 173
    1f32:	9f e0       	ldi	r25, 0x0F	; 15
    1f34:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    1f38:	08 95       	ret
      }
    else {
      // Delete the user
      delete_user(&temp_user);
    1f3a:	8c ee       	ldi	r24, 0xEC	; 236
    1f3c:	97 e0       	ldi	r25, 0x07	; 7
    1f3e:	0e 94 59 14 	call	0x28b2	; 0x28b2 <delete_user>
      println_msg("The user has been deleted successfully!\t");
    1f42:	8b ee       	ldi	r24, 0xEB	; 235
    1f44:	94 e0       	ldi	r25, 0x04	; 4
    1f46:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1f4a:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1f4e:	62 e0       	ldi	r22, 0x02	; 2
    1f50:	8d ea       	ldi	r24, 0xAD	; 173
    1f52:	9f e0       	ldi	r25, 0x0F	; 15
    1f54:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    1f58:	08 95       	ret

00001f5a <initial_options_menu>:
    println_msg("[2] Log out\t");
    }
  }

void initial_options_menu() {
  if (remote_user.isAdmin) {
    1f5a:	80 91 cc 07 	lds	r24, 0x07CC	; 0x8007cc <remote_user>
    1f5e:	88 23       	and	r24, r24
    1f60:	09 f4       	brne	.+2      	; 0x1f64 <initial_options_menu+0xa>
    1f62:	4b c0       	rjmp	.+150    	; 0x1ffa <initial_options_menu+0xa0>
    u8 option = msg_buffer[0];
    1f64:	80 91 7d 07 	lds	r24, 0x077D	; 0x80077d <msg_buffer>
    if (invalid_user_input || option < '1' || option > '4') {
    1f68:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <invalid_user_input>
    1f6c:	91 11       	cpse	r25, r1
    1f6e:	04 c0       	rjmp	.+8      	; 0x1f78 <initial_options_menu+0x1e>
    1f70:	81 33       	cpi	r24, 0x31	; 49
    1f72:	10 f0       	brcs	.+4      	; 0x1f78 <initial_options_menu+0x1e>
    1f74:	85 33       	cpi	r24, 0x35	; 53
    1f76:	60 f0       	brcs	.+24     	; 0x1f90 <initial_options_menu+0x36>
      println_msg("Invalid option!\t");
    1f78:	84 e2       	ldi	r24, 0x24	; 36
    1f7a:	93 e0       	ldi	r25, 0x03	; 3
    1f7c:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      print_initial_options_menu();
    1f80:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1f84:	62 e0       	ldi	r22, 0x02	; 2
    1f86:	8d ea       	ldi	r24, 0xAD	; 173
    1f88:	9f e0       	ldi	r25, 0x0F	; 15
    1f8a:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    1f8e:	08 95       	ret
      }
    else {
      switch (option) {
    1f90:	82 33       	cpi	r24, 0x32	; 50
    1f92:	99 f0       	breq	.+38     	; 0x1fba <initial_options_menu+0x60>
    1f94:	18 f4       	brcc	.+6      	; 0x1f9c <initial_options_menu+0x42>
    1f96:	81 33       	cpi	r24, 0x31	; 49
    1f98:	31 f0       	breq	.+12     	; 0x1fa6 <initial_options_menu+0x4c>
    1f9a:	08 95       	ret
    1f9c:	83 33       	cpi	r24, 0x33	; 51
    1f9e:	b9 f0       	breq	.+46     	; 0x1fce <initial_options_menu+0x74>
    1fa0:	84 33       	cpi	r24, 0x34	; 52
    1fa2:	e9 f0       	breq	.+58     	; 0x1fde <initial_options_menu+0x84>
    1fa4:	08 95       	ret
          case '1':
            print_msg("Enter the user name: ");
    1fa6:	84 e1       	ldi	r24, 0x14	; 20
    1fa8:	95 e0       	ldi	r25, 0x05	; 5
    1faa:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
            request_user_input(add_user_prompt, 13);
    1fae:	6d e0       	ldi	r22, 0x0D	; 13
    1fb0:	8f ea       	ldi	r24, 0xAF	; 175
    1fb2:	90 e1       	ldi	r25, 0x10	; 16
    1fb4:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
            break;
    1fb8:	08 95       	ret
          case '2':
            print_msg("Enter the user name: ");
    1fba:	84 e1       	ldi	r24, 0x14	; 20
    1fbc:	95 e0       	ldi	r25, 0x05	; 5
    1fbe:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
            request_user_input(delete_user_prompt, 13);
    1fc2:	6d e0       	ldi	r22, 0x0D	; 13
    1fc4:	89 e7       	ldi	r24, 0x79	; 121
    1fc6:	9f e0       	ldi	r25, 0x0F	; 15
    1fc8:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
            break;
    1fcc:	08 95       	ret
          case '3':
            print_remote_control_menu();
    1fce:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    1fd2:	62 e0       	ldi	r22, 0x02	; 2
    1fd4:	89 ef       	ldi	r24, 0xF9	; 249
    1fd6:	9e e0       	ldi	r25, 0x0E	; 14
    1fd8:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
            break;
    1fdc:	08 95       	ret
          case '4':
            remote_user_loggedin = true;
    1fde:	81 e0       	ldi	r24, 0x01	; 1
    1fe0:	80 93 7a 07 	sts	0x077A, r24	; 0x80077a <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    1fe4:	8a e2       	ldi	r24, 0x2A	; 42
    1fe6:	95 e0       	ldi	r25, 0x05	; 5
    1fe8:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
            println_msg("You have successfully logged out...");
    1fec:	82 e7       	ldi	r24, 0x72	; 114
    1fee:	95 e0       	ldi	r25, 0x05	; 5
    1ff0:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
            msg_length = 0;
    1ff4:	10 92 8c 07 	sts	0x078C, r1	; 0x80078c <msg_length>
            break;
    1ff8:	08 95       	ret
        }
      }
    }
  else {
    u8 option = msg_buffer[0];
    1ffa:	80 91 7d 07 	lds	r24, 0x077D	; 0x80077d <msg_buffer>
    if (invalid_user_input || option < '1' || option > '2') {
    1ffe:	90 91 98 07 	lds	r25, 0x0798	; 0x800798 <invalid_user_input>
    2002:	91 11       	cpse	r25, r1
    2004:	04 c0       	rjmp	.+8      	; 0x200e <initial_options_menu+0xb4>
    2006:	81 33       	cpi	r24, 0x31	; 49
    2008:	10 f0       	brcs	.+4      	; 0x200e <initial_options_menu+0xb4>
    200a:	83 33       	cpi	r24, 0x33	; 51
    200c:	60 f0       	brcs	.+24     	; 0x2026 <initial_options_menu+0xcc>
      println_msg("Invalid option!\t");
    200e:	84 e2       	ldi	r24, 0x24	; 36
    2010:	93 e0       	ldi	r25, 0x03	; 3
    2012:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      print_initial_options_menu();
    2016:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    201a:	62 e0       	ldi	r22, 0x02	; 2
    201c:	8d ea       	ldi	r24, 0xAD	; 173
    201e:	9f e0       	ldi	r25, 0x0F	; 15
    2020:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    2024:	08 95       	ret
      }
    else {
      switch (option) {
    2026:	81 33       	cpi	r24, 0x31	; 49
    2028:	19 f0       	breq	.+6      	; 0x2030 <initial_options_menu+0xd6>
    202a:	82 33       	cpi	r24, 0x32	; 50
    202c:	49 f0       	breq	.+18     	; 0x2040 <initial_options_menu+0xe6>
    202e:	08 95       	ret
          case '1':
            print_remote_control_menu();
    2030:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    2034:	62 e0       	ldi	r22, 0x02	; 2
    2036:	89 ef       	ldi	r24, 0xF9	; 249
    2038:	9e e0       	ldi	r25, 0x0E	; 14
    203a:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
            break;
    203e:	08 95       	ret
          case '2':
            remote_user_loggedin = true;
    2040:	81 e0       	ldi	r24, 0x01	; 1
    2042:	80 93 7a 07 	sts	0x077A, r24	; 0x80077a <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    2046:	8a e2       	ldi	r24, 0x2A	; 42
    2048:	95 e0       	ldi	r25, 0x05	; 5
    204a:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
            println_msg("You have successfully logged out...");
    204e:	82 e7       	ldi	r24, 0x72	; 114
    2050:	95 e0       	ldi	r25, 0x05	; 5
    2052:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
            msg_length = 0;
    2056:	10 92 8c 07 	sts	0x078C, r1	; 0x80078c <msg_length>
    205a:	08 95       	ret

0000205c <add_user_isAdmin_prompt>:
      }
    }
  }

void add_user_isAdmin_prompt(void) {
  if (invalid_user_input) {
    205c:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <invalid_user_input>
    2060:	88 23       	and	r24, r24
    2062:	61 f0       	breq	.+24     	; 0x207c <add_user_isAdmin_prompt+0x20>
    println_msg("\r\nInvalid input!!\t");
    2064:	82 e8       	ldi	r24, 0x82	; 130
    2066:	92 e0       	ldi	r25, 0x02	; 2
    2068:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    //! The system should ask the user wether he wants to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    206c:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    2070:	62 e0       	ldi	r22, 0x02	; 2
    2072:	8d ea       	ldi	r24, 0xAD	; 173
    2074:	9f e0       	ldi	r25, 0x0F	; 15
    2076:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    207a:	08 95       	ret
    }
  else {
    new_user.isAdmin = (msg_buffer[0] == 'y' || msg_buffer[0] == 'Y');
    207c:	80 91 7d 07 	lds	r24, 0x077D	; 0x80077d <msg_buffer>
    2080:	89 37       	cpi	r24, 0x79	; 121
    2082:	21 f0       	breq	.+8      	; 0x208c <add_user_isAdmin_prompt+0x30>
    2084:	89 35       	cpi	r24, 0x59	; 89
    2086:	21 f4       	brne	.+8      	; 0x2090 <add_user_isAdmin_prompt+0x34>
    2088:	81 e0       	ldi	r24, 0x01	; 1
    208a:	03 c0       	rjmp	.+6      	; 0x2092 <add_user_isAdmin_prompt+0x36>
    208c:	81 e0       	ldi	r24, 0x01	; 1
    208e:	01 c0       	rjmp	.+2      	; 0x2092 <add_user_isAdmin_prompt+0x36>
    2090:	80 e0       	ldi	r24, 0x00	; 0
    2092:	80 93 0f 08 	sts	0x080F, r24	; 0x80080f <new_user>
    add_user(&new_user);
    2096:	8f e0       	ldi	r24, 0x0F	; 15
    2098:	98 e0       	ldi	r25, 0x08	; 8
    209a:	0e 94 1e 14 	call	0x283c	; 0x283c <add_user>
    println_msg("User has been added successfully!");
    209e:	86 e9       	ldi	r24, 0x96	; 150
    20a0:	95 e0       	ldi	r25, 0x05	; 5
    20a2:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    //! Return to the main menu
    print_initial_options_menu();
    20a6:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    20aa:	62 e0       	ldi	r22, 0x02	; 2
    20ac:	8d ea       	ldi	r24, 0xAD	; 173
    20ae:	9f e0       	ldi	r25, 0x0F	; 15
    20b0:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    20b4:	08 95       	ret

000020b6 <add_user_password_prompt>:
    }
  }

void add_user_password_prompt(void) {
  if (invalid_user_input) {
    20b6:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <invalid_user_input>
    20ba:	88 23       	and	r24, r24
    20bc:	61 f0       	breq	.+24     	; 0x20d6 <add_user_password_prompt+0x20>
    println_msg("\r\nPassword too long!!\t");
    20be:	88 eb       	ldi	r24, 0xB8	; 184
    20c0:	95 e0       	ldi	r25, 0x05	; 5
    20c2:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    20c6:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    20ca:	62 e0       	ldi	r22, 0x02	; 2
    20cc:	8d ea       	ldi	r24, 0xAD	; 173
    20ce:	9f e0       	ldi	r25, 0x0F	; 15
    20d0:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    20d4:	08 95       	ret
    }
  else {
    strcpy(new_user.password, msg_buffer);
    20d6:	6d e7       	ldi	r22, 0x7D	; 125
    20d8:	77 e0       	ldi	r23, 0x07	; 7
    20da:	84 e2       	ldi	r24, 0x24	; 36
    20dc:	98 e0       	ldi	r25, 0x08	; 8
    20de:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <strcpy>
    print_msg("Do you want to make the new user an admin? (y/n) ");
    20e2:	8f ec       	ldi	r24, 0xCF	; 207
    20e4:	95 e0       	ldi	r25, 0x05	; 5
    20e6:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
    request_user_input(add_user_isAdmin_prompt, 2);
    20ea:	62 e0       	ldi	r22, 0x02	; 2
    20ec:	8e e2       	ldi	r24, 0x2E	; 46
    20ee:	90 e1       	ldi	r25, 0x10	; 16
    20f0:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    20f4:	08 95       	ret

000020f6 <add_user_code_prompt>:
    }
  }

void add_user_code_prompt(void) {
  if (invalid_user_input) {
    20f6:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <invalid_user_input>
    20fa:	88 23       	and	r24, r24
    20fc:	61 f0       	breq	.+24     	; 0x2116 <add_user_code_prompt+0x20>
    println_msg("\r\nInvalid user code!\t");
    20fe:	81 e0       	ldi	r24, 0x01	; 1
    2100:	96 e0       	ldi	r25, 0x06	; 6
    2102:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    2106:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    210a:	62 e0       	ldi	r22, 0x02	; 2
    210c:	8d ea       	ldi	r24, 0xAD	; 173
    210e:	9f e0       	ldi	r25, 0x0F	; 15
    2110:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    2114:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByCode(msg_buffer, &temp_user);
    2116:	6c ee       	ldi	r22, 0xEC	; 236
    2118:	77 e0       	ldi	r23, 0x07	; 7
    211a:	8d e7       	ldi	r24, 0x7D	; 125
    211c:	97 e0       	ldi	r25, 0x07	; 7
    211e:	0e 94 1c 13 	call	0x2638	; 0x2638 <getUserByCode>
    if (userExists == USER_NOT_FOUND) {
    2122:	83 30       	cpi	r24, 0x03	; 3
    2124:	81 f4       	brne	.+32     	; 0x2146 <add_user_code_prompt+0x50>
      strcpy(new_user.code, msg_buffer);
    2126:	6d e7       	ldi	r22, 0x7D	; 125
    2128:	77 e0       	ldi	r23, 0x07	; 7
    212a:	8d e1       	ldi	r24, 0x1D	; 29
    212c:	98 e0       	ldi	r25, 0x08	; 8
    212e:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <strcpy>
      print_msg("Enter the new user's password: ");
    2132:	87 e1       	ldi	r24, 0x17	; 23
    2134:	96 e0       	ldi	r25, 0x06	; 6
    2136:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
      request_user_input(add_user_password_prompt, 11);
    213a:	6b e0       	ldi	r22, 0x0B	; 11
    213c:	8b e5       	ldi	r24, 0x5B	; 91
    213e:	90 e1       	ldi	r25, 0x10	; 16
    2140:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    2144:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      println_msg("\rThe user code already exists!\t");
    2146:	87 e3       	ldi	r24, 0x37	; 55
    2148:	96 e0       	ldi	r25, 0x06	; 6
    214a:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    214e:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    2152:	62 e0       	ldi	r22, 0x02	; 2
    2154:	8d ea       	ldi	r24, 0xAD	; 173
    2156:	9f e0       	ldi	r25, 0x0F	; 15
    2158:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    215c:	08 95       	ret

0000215e <add_user_prompt>:
      }
    }
  }

void add_user_prompt(void) {
  if (invalid_user_input) {
    215e:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <invalid_user_input>
    2162:	88 23       	and	r24, r24
    2164:	61 f0       	breq	.+24     	; 0x217e <add_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    2166:	8f e9       	ldi	r24, 0x9F	; 159
    2168:	94 e0       	ldi	r25, 0x04	; 4
    216a:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    216e:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    2172:	62 e0       	ldi	r22, 0x02	; 2
    2174:	8d ea       	ldi	r24, 0xAD	; 173
    2176:	9f e0       	ldi	r25, 0x0F	; 15
    2178:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    217c:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    217e:	6c ee       	ldi	r22, 0xEC	; 236
    2180:	77 e0       	ldi	r23, 0x07	; 7
    2182:	8d e7       	ldi	r24, 0x7D	; 125
    2184:	97 e0       	ldi	r25, 0x07	; 7
    2186:	0e 94 83 12 	call	0x2506	; 0x2506 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    218a:	83 30       	cpi	r24, 0x03	; 3
    218c:	81 f4       	brne	.+32     	; 0x21ae <add_user_prompt+0x50>
      strcpy(new_user.name, msg_buffer);
    218e:	6d e7       	ldi	r22, 0x7D	; 125
    2190:	77 e0       	ldi	r23, 0x07	; 7
    2192:	80 e1       	ldi	r24, 0x10	; 16
    2194:	98 e0       	ldi	r25, 0x08	; 8
    2196:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <strcpy>
      print_msg("Enter the new user's code(must be a unique six digit code): ");
    219a:	87 e5       	ldi	r24, 0x57	; 87
    219c:	96 e0       	ldi	r25, 0x06	; 6
    219e:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
      request_user_input(add_user_code_prompt, 7);
    21a2:	67 e0       	ldi	r22, 0x07	; 7
    21a4:	8b e7       	ldi	r24, 0x7B	; 123
    21a6:	90 e1       	ldi	r25, 0x10	; 16
    21a8:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    21ac:	08 95       	ret
      }
    else {
      // Prompt the user to enter the user code
      println_msg("\rThe user already exists!\t");
    21ae:	84 e9       	ldi	r24, 0x94	; 148
    21b0:	96 e0       	ldi	r25, 0x06	; 6
    21b2:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    21b6:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    21ba:	62 e0       	ldi	r22, 0x02	; 2
    21bc:	8d ea       	ldi	r24, 0xAD	; 173
    21be:	9f e0       	ldi	r25, 0x0F	; 15
    21c0:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    21c4:	08 95       	ret

000021c6 <invalid_remote_login_attempt>:
      }
    }
  }

void invalid_remote_login_attempt(void) {
    21c6:	0f 93       	push	r16
    21c8:	1f 93       	push	r17
    21ca:	cf 93       	push	r28
    21cc:	df 93       	push	r29
    21ce:	cd b7       	in	r28, 0x3d	; 61
    21d0:	de b7       	in	r29, 0x3e	; 62
    21d2:	e2 97       	sbiw	r28, 0x32	; 50
    21d4:	0f b6       	in	r0, 0x3f	; 63
    21d6:	f8 94       	cli
    21d8:	de bf       	out	0x3e, r29	; 62
    21da:	0f be       	out	0x3f, r0	; 63
    21dc:	cd bf       	out	0x3d, r28	; 61
  invalid_trails++;
    21de:	80 91 78 07 	lds	r24, 0x0778	; 0x800778 <__data_end>
    21e2:	8f 5f       	subi	r24, 0xFF	; 255
    21e4:	80 93 78 07 	sts	0x0778, r24	; 0x800778 <__data_end>
  if (invalid_trails < 3) {
    21e8:	83 30       	cpi	r24, 0x03	; 3
    21ea:	e8 f4       	brcc	.+58     	; 0x2226 <invalid_remote_login_attempt+0x60>
    s8 msg[50];
    sprintf(msg, "\r\nInvalid login attempt! \r\n%d attempts remaining.", 3 - invalid_trails);
    21ec:	23 e0       	ldi	r18, 0x03	; 3
    21ee:	30 e0       	ldi	r19, 0x00	; 0
    21f0:	a9 01       	movw	r20, r18
    21f2:	48 1b       	sub	r20, r24
    21f4:	51 09       	sbc	r21, r1
    21f6:	ca 01       	movw	r24, r20
    21f8:	9f 93       	push	r25
    21fa:	4f 93       	push	r20
    21fc:	8f ea       	ldi	r24, 0xAF	; 175
    21fe:	96 e0       	ldi	r25, 0x06	; 6
    2200:	9f 93       	push	r25
    2202:	8f 93       	push	r24
    2204:	8e 01       	movw	r16, r28
    2206:	0f 5f       	subi	r16, 0xFF	; 255
    2208:	1f 4f       	sbci	r17, 0xFF	; 255
    220a:	1f 93       	push	r17
    220c:	0f 93       	push	r16
    220e:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <sprintf>
    println_msg(msg);
    2212:	c8 01       	movw	r24, r16
    2214:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
    2218:	0f 90       	pop	r0
    221a:	0f 90       	pop	r0
    221c:	0f 90       	pop	r0
    221e:	0f 90       	pop	r0
    2220:	0f 90       	pop	r0
    2222:	0f 90       	pop	r0
    2224:	04 c0       	rjmp	.+8      	; 0x222e <invalid_remote_login_attempt+0x68>
    return;
    }
  Alarm_set();
    2226:	0e 94 b5 13 	call	0x276a	; 0x276a <Alarm_set>
  run_system = false;
    222a:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__data_start>
  }
    222e:	e2 96       	adiw	r28, 0x32	; 50
    2230:	0f b6       	in	r0, 0x3f	; 63
    2232:	f8 94       	cli
    2234:	de bf       	out	0x3e, r29	; 62
    2236:	0f be       	out	0x3f, r0	; 63
    2238:	cd bf       	out	0x3d, r28	; 61
    223a:	df 91       	pop	r29
    223c:	cf 91       	pop	r28
    223e:	1f 91       	pop	r17
    2240:	0f 91       	pop	r16
    2242:	08 95       	ret

00002244 <userPassword_prompt_handler>:

void userPassword_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    2244:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <invalid_user_input>
    2248:	88 23       	and	r24, r24
    224a:	61 f0       	breq	.+24     	; 0x2264 <userPassword_prompt_handler+0x20>
    invalid_remote_login_attempt();
    224c:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <invalid_remote_login_attempt>
    print_msg("Enter your password:\t");
    2250:	81 ee       	ldi	r24, 0xE1	; 225
    2252:	96 e0       	ldi	r25, 0x06	; 6
    2254:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
    request_user_input(userPassword_prompt_handler, 11);
    2258:	6b e0       	ldi	r22, 0x0B	; 11
    225a:	82 e2       	ldi	r24, 0x22	; 34
    225c:	91 e1       	ldi	r25, 0x11	; 17
    225e:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    2262:	08 95       	ret
    }
  else {
    if (strcmp(remote_user.password, msg_buffer)) { // Wrong password
    2264:	6d e7       	ldi	r22, 0x7D	; 125
    2266:	77 e0       	ldi	r23, 0x07	; 7
    2268:	81 ee       	ldi	r24, 0xE1	; 225
    226a:	97 e0       	ldi	r25, 0x07	; 7
    226c:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <strcmp>
    2270:	89 2b       	or	r24, r25
    2272:	81 f0       	breq	.+32     	; 0x2294 <userPassword_prompt_handler+0x50>
      print_msg("Wrong password!");
    2274:	87 ef       	ldi	r24, 0xF7	; 247
    2276:	96 e0       	ldi	r25, 0x06	; 6
    2278:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
      invalid_remote_login_attempt();
    227c:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <invalid_remote_login_attempt>
      print_msg("Enter your password:\t");
    2280:	81 ee       	ldi	r24, 0xE1	; 225
    2282:	96 e0       	ldi	r25, 0x06	; 6
    2284:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    2288:	6b e0       	ldi	r22, 0x0B	; 11
    228a:	82 e2       	ldi	r24, 0x22	; 34
    228c:	91 e1       	ldi	r25, 0x11	; 17
    228e:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    2292:	08 95       	ret
      }
    else {
      remote_user_loggedin = true;
    2294:	81 e0       	ldi	r24, 0x01	; 1
    2296:	80 93 7a 07 	sts	0x077A, r24	; 0x80077a <remote_user_loggedin>
      print_msg("Welcome ");
    229a:	87 e0       	ldi	r24, 0x07	; 7
    229c:	97 e0       	ldi	r25, 0x07	; 7
    229e:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
      print_msg(remote_user.name);
    22a2:	8d ec       	ldi	r24, 0xCD	; 205
    22a4:	97 e0       	ldi	r25, 0x07	; 7
    22a6:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
      println_msg("!");
    22aa:	84 ee       	ldi	r24, 0xE4	; 228
    22ac:	91 e0       	ldi	r25, 0x01	; 1
    22ae:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
      // Show the options menu
      print_initial_options_menu();
    22b2:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    22b6:	62 e0       	ldi	r22, 0x02	; 2
    22b8:	8d ea       	ldi	r24, 0xAD	; 173
    22ba:	9f e0       	ldi	r25, 0x0F	; 15
    22bc:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    22c0:	08 95       	ret

000022c2 <userName_prompt_handler>:
    }
  }

void userName_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    22c2:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <invalid_user_input>
    22c6:	88 23       	and	r24, r24
    22c8:	61 f0       	breq	.+24     	; 0x22e2 <userName_prompt_handler+0x20>
    invalid_remote_login_attempt();
    22ca:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <invalid_remote_login_attempt>
    print_msg("Enter your user name:\t");
    22ce:	80 e1       	ldi	r24, 0x10	; 16
    22d0:	97 e0       	ldi	r25, 0x07	; 7
    22d2:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
    request_user_input(userName_prompt_handler, 13);
    22d6:	6d e0       	ldi	r22, 0x0D	; 13
    22d8:	81 e6       	ldi	r24, 0x61	; 97
    22da:	91 e1       	ldi	r25, 0x11	; 17
    22dc:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    22e0:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &remote_user);
    22e2:	6c ec       	ldi	r22, 0xCC	; 204
    22e4:	77 e0       	ldi	r23, 0x07	; 7
    22e6:	8d e7       	ldi	r24, 0x7D	; 125
    22e8:	97 e0       	ldi	r25, 0x07	; 7
    22ea:	0e 94 83 12 	call	0x2506	; 0x2506 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    22ee:	83 30       	cpi	r24, 0x03	; 3
    22f0:	81 f4       	brne	.+32     	; 0x2312 <userName_prompt_handler+0x50>
      print_msg("User doesn't exist!");
    22f2:	87 e2       	ldi	r24, 0x27	; 39
    22f4:	97 e0       	ldi	r25, 0x07	; 7
    22f6:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
      invalid_remote_login_attempt();
    22fa:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <invalid_remote_login_attempt>
      print_msg("Enter your user name:\t");
    22fe:	80 e1       	ldi	r24, 0x10	; 16
    2300:	97 e0       	ldi	r25, 0x07	; 7
    2302:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
      request_user_input(userName_prompt_handler, 13);
    2306:	6d e0       	ldi	r22, 0x0D	; 13
    2308:	81 e6       	ldi	r24, 0x61	; 97
    230a:	91 e1       	ldi	r25, 0x11	; 17
    230c:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    2310:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      print_msg("Enter your password:\t");
    2312:	81 ee       	ldi	r24, 0xE1	; 225
    2314:	96 e0       	ldi	r25, 0x06	; 6
    2316:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    231a:	6b e0       	ldi	r22, 0x0B	; 11
    231c:	82 e2       	ldi	r24, 0x22	; 34
    231e:	91 e1       	ldi	r25, 0x11	; 17
    2320:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    2324:	08 95       	ret

00002326 <remote_login_prompt>:
      }
    }
  }

void remote_login_prompt(void) {
  println_msg("Welcome to the Smart Home System!");
    2326:	8b e3       	ldi	r24, 0x3B	; 59
    2328:	97 e0       	ldi	r25, 0x07	; 7
    232a:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
  println_msg("To proceed, please login.");
    232e:	8d e5       	ldi	r24, 0x5D	; 93
    2330:	97 e0       	ldi	r25, 0x07	; 7
    2332:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <println_msg>
  print_msg("Enter your user name:\t");
    2336:	80 e1       	ldi	r24, 0x10	; 16
    2338:	97 e0       	ldi	r25, 0x07	; 7
    233a:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <print_msg>
  request_user_input(userName_prompt_handler, 13);
    233e:	6d e0       	ldi	r22, 0x0D	; 13
    2340:	81 e6       	ldi	r24, 0x61	; 97
    2342:	91 e1       	ldi	r25, 0x11	; 17
    2344:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <request_user_input>
    2348:	08 95       	ret

0000234a <__vector_13>:
  }

// Handles the user input asynchronously.
ISR(USART_RXC_vect) {
    234a:	1f 92       	push	r1
    234c:	0f 92       	push	r0
    234e:	0f b6       	in	r0, 0x3f	; 63
    2350:	0f 92       	push	r0
    2352:	11 24       	eor	r1, r1
    2354:	2f 93       	push	r18
    2356:	3f 93       	push	r19
    2358:	4f 93       	push	r20
    235a:	5f 93       	push	r21
    235c:	6f 93       	push	r22
    235e:	7f 93       	push	r23
    2360:	8f 93       	push	r24
    2362:	9f 93       	push	r25
    2364:	af 93       	push	r26
    2366:	bf 93       	push	r27
    2368:	ef 93       	push	r30
    236a:	ff 93       	push	r31
#if UART_COMMUNICATION_INTERFACE ==  PROTEUS_VIRTUAL_TERMINAL
  // Read the UDR to clear the RXC bit
  udr_temp = UDR;
    236c:	8c b1       	in	r24, 0x0c	; 12
    236e:	80 93 0d 08 	sts	0x080D, r24	; 0x80080d <udr_temp>

  // If no input requested, ignore the input. No input requested is indicated by msg length of zero
  if (msg_length == 0) return;
    2372:	90 91 8c 07 	lds	r25, 0x078C	; 0x80078c <msg_length>
    2376:	99 23       	and	r25, r25
    2378:	09 f4       	brne	.+2      	; 0x237c <__vector_13+0x32>
    237a:	4d c0       	rjmp	.+154    	; 0x2416 <__vector_13+0xcc>

  // Handling backspaces
  if (udr_temp == '\b') {
    237c:	88 30       	cpi	r24, 0x08	; 8
    237e:	59 f4       	brne	.+22     	; 0x2396 <__vector_13+0x4c>
    if (msg_buffer_pointer > 0) {
    2380:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <msg_buffer_pointer>
    2384:	99 23       	and	r25, r25
    2386:	09 f4       	brne	.+2      	; 0x238a <__vector_13+0x40>
    2388:	46 c0       	rjmp	.+140    	; 0x2416 <__vector_13+0xcc>
      msg_buffer_pointer--;
    238a:	91 50       	subi	r25, 0x01	; 1
    238c:	90 93 7b 07 	sts	0x077B, r25	; 0x80077b <msg_buffer_pointer>
      BT_sendChar(udr_temp);
    2390:	0e 94 db 01 	call	0x3b6	; 0x3b6 <BT_sendChar>
    2394:	40 c0       	rjmp	.+128    	; 0x2416 <__vector_13+0xcc>
      }
    return;
    }

  msg_buffer[msg_buffer_pointer] = udr_temp;
    2396:	90 91 7b 07 	lds	r25, 0x077B	; 0x80077b <msg_buffer_pointer>
    239a:	e9 2f       	mov	r30, r25
    239c:	f0 e0       	ldi	r31, 0x00	; 0
    239e:	e3 58       	subi	r30, 0x83	; 131
    23a0:	f8 4f       	sbci	r31, 0xF8	; 248
    23a2:	80 83       	st	Z, r24
  msg_buffer_pointer++;
    23a4:	9f 5f       	subi	r25, 0xFF	; 255
    23a6:	90 93 7b 07 	sts	0x077B, r25	; 0x80077b <msg_buffer_pointer>

  // Msg is empty
  // Ignore null msgs
  if (msg_buffer_pointer == 1) {
    23aa:	91 30       	cpi	r25, 0x01	; 1
    23ac:	39 f4       	brne	.+14     	; 0x23bc <__vector_13+0x72>
    if (msg_buffer[0] == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    23ae:	90 91 7d 07 	lds	r25, 0x077D	; 0x80077d <msg_buffer>
    23b2:	9d 30       	cpi	r25, 0x0D	; 13
    23b4:	19 f4       	brne	.+6      	; 0x23bc <__vector_13+0x72>
      msg_buffer_pointer = 0;
    23b6:	10 92 7b 07 	sts	0x077B, r1	; 0x80077b <msg_buffer_pointer>
      return;
    23ba:	2d c0       	rjmp	.+90     	; 0x2416 <__vector_13+0xcc>
      }
    }

  // Echo the sent char on the terminal
  //! Proteus virtual terminal doesn't send a line feed char (ASCII code: 10). Instead it sends a carriage return (ASCII code: 13).
  if (udr_temp != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER)
    23bc:	8d 30       	cpi	r24, 0x0D	; 13
    23be:	11 f0       	breq	.+4      	; 0x23c4 <__vector_13+0x7a>
    BT_sendChar(udr_temp);
    23c0:	0e 94 db 01 	call	0x3b6	; 0x3b6 <BT_sendChar>

  // Msg is longer than required
  if (msg_buffer_pointer == msg_length) {
    23c4:	e0 91 7b 07 	lds	r30, 0x077B	; 0x80077b <msg_buffer_pointer>
    23c8:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <msg_length>
    23cc:	e8 13       	cpse	r30, r24
    23ce:	10 c0       	rjmp	.+32     	; 0x23f0 <__vector_13+0xa6>
    if (msg_buffer[msg_buffer_pointer - 1] != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    23d0:	f0 e0       	ldi	r31, 0x00	; 0
    23d2:	e4 58       	subi	r30, 0x84	; 132
    23d4:	f8 4f       	sbci	r31, 0xF8	; 248
    23d6:	80 81       	ld	r24, Z
    23d8:	8d 30       	cpi	r24, 0x0D	; 13
    23da:	51 f0       	breq	.+20     	; 0x23f0 <__vector_13+0xa6>
      invalid_user_input = true;
    23dc:	81 e0       	ldi	r24, 0x01	; 1
    23de:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <invalid_user_input>
      dump_invalid_data = true;
    23e2:	80 93 0c 08 	sts	0x080C, r24	; 0x80080c <dump_invalid_data>
      msg_buffer_pointer = 0;
    23e6:	10 92 7b 07 	sts	0x077B, r1	; 0x80077b <msg_buffer_pointer>
      BT_sendChar('\r');
    23ea:	8d e0       	ldi	r24, 0x0D	; 13
    23ec:	0e 94 db 01 	call	0x3b6	; 0x3b6 <BT_sendChar>
      Remote_control_interface(user_dialog_tree);
      }
    }

  // Msg has ended and is within the required length
  if (udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    23f0:	80 91 0d 08 	lds	r24, 0x080D	; 0x80080d <udr_temp>
    23f4:	8d 30       	cpi	r24, 0x0D	; 13
    23f6:	79 f4       	brne	.+30     	; 0x2416 <__vector_13+0xcc>
    if (msg_buffer_pointer <= msg_length) {
    23f8:	e0 91 7b 07 	lds	r30, 0x077B	; 0x80077b <msg_buffer_pointer>
    23fc:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <msg_length>
    2400:	8e 17       	cp	r24, r30
    2402:	48 f0       	brcs	.+18     	; 0x2416 <__vector_13+0xcc>
      // Replace the carriage return with null to terminate the string correctly
      msg_buffer[msg_buffer_pointer - 1] = '\0';
    2404:	f0 e0       	ldi	r31, 0x00	; 0
    2406:	e4 58       	subi	r30, 0x84	; 132
    2408:	f8 4f       	sbci	r31, 0xF8	; 248
    240a:	10 82       	st	Z, r1
      BT_sendChar('\r');
    240c:	8d e0       	ldi	r24, 0x0D	; 13
    240e:	0e 94 db 01 	call	0x3b6	; 0x3b6 <BT_sendChar>
      Remote_control_interface(user_dialog_tree);
      msg_buffer_pointer = 0;
    2412:	10 92 7b 07 	sts	0x077B, r1	; 0x80077b <msg_buffer_pointer>
      Remote_control_interface(user_dialog_tree);
      msg_buffer_pointer = 0;
      }
    }
#endif
  }
    2416:	ff 91       	pop	r31
    2418:	ef 91       	pop	r30
    241a:	bf 91       	pop	r27
    241c:	af 91       	pop	r26
    241e:	9f 91       	pop	r25
    2420:	8f 91       	pop	r24
    2422:	7f 91       	pop	r23
    2424:	6f 91       	pop	r22
    2426:	5f 91       	pop	r21
    2428:	4f 91       	pop	r20
    242a:	3f 91       	pop	r19
    242c:	2f 91       	pop	r18
    242e:	0f 90       	pop	r0
    2430:	0f be       	out	0x3f, r0	; 63
    2432:	0f 90       	pop	r0
    2434:	1f 90       	pop	r1
    2436:	18 95       	reti

00002438 <__vector_1>:

ISR(INT0_vect) {
    2438:	1f 92       	push	r1
    243a:	0f 92       	push	r0
    243c:	0f b6       	in	r0, 0x3f	; 63
    243e:	0f 92       	push	r0
    2440:	11 24       	eor	r1, r1
    2442:	2f 93       	push	r18
    2444:	3f 93       	push	r19
    2446:	4f 93       	push	r20
    2448:	5f 93       	push	r21
    244a:	6f 93       	push	r22
    244c:	7f 93       	push	r23
    244e:	8f 93       	push	r24
    2450:	9f 93       	push	r25
    2452:	af 93       	push	r26
    2454:	bf 93       	push	r27
    2456:	ef 93       	push	r30
    2458:	ff 93       	push	r31
  // Initialize communication with the user
  // Request user login credentials
  remote_login_prompt();
    245a:	0e 94 93 11 	call	0x2326	; 0x2326 <remote_login_prompt>
  }
    245e:	ff 91       	pop	r31
    2460:	ef 91       	pop	r30
    2462:	bf 91       	pop	r27
    2464:	af 91       	pop	r26
    2466:	9f 91       	pop	r25
    2468:	8f 91       	pop	r24
    246a:	7f 91       	pop	r23
    246c:	6f 91       	pop	r22
    246e:	5f 91       	pop	r21
    2470:	4f 91       	pop	r20
    2472:	3f 91       	pop	r19
    2474:	2f 91       	pop	r18
    2476:	0f 90       	pop	r0
    2478:	0f be       	out	0x3f, r0	; 63
    247a:	0f 90       	pop	r0
    247c:	1f 90       	pop	r1
    247e:	18 95       	reti

00002480 <__vector_16>:
#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_BY_ACTIVATING_TIMER0_OVF_INT
// To reset the TOV0 flag. Alternatively, it can be reset in the ADC complete interrupt.
ISR(TIMER0_OVF_vect) {}
#endif

ISR(ADC_vect) {
    2480:	1f 92       	push	r1
    2482:	0f 92       	push	r0
    2484:	0f b6       	in	r0, 0x3f	; 63
    2486:	0f 92       	push	r0
    2488:	11 24       	eor	r1, r1
    248a:	2f 93       	push	r18
    248c:	3f 93       	push	r19
    248e:	4f 93       	push	r20
    2490:	5f 93       	push	r21
    2492:	6f 93       	push	r22
    2494:	7f 93       	push	r23
    2496:	8f 93       	push	r24
    2498:	9f 93       	push	r25
    249a:	af 93       	push	r26
    249c:	bf 93       	push	r27
    249e:	cf 93       	push	r28
    24a0:	df 93       	push	r29
    24a2:	ef 93       	push	r30
    24a4:	ff 93       	push	r31
  u16 temperature;
  temperature = ADCL + (ADCH << 8);
    24a6:	84 b1       	in	r24, 0x04	; 4
    24a8:	c5 b1       	in	r28, 0x05	; 5
    24aa:	d0 e0       	ldi	r29, 0x00	; 0
    24ac:	dc 2f       	mov	r29, r28
    24ae:	cc 27       	eor	r28, r28
    24b0:	c8 0f       	add	r28, r24
    24b2:	d1 1d       	adc	r29, r1
  // Since the ADC is set to use the internal VREF of 2.56 V, the resolution of the ADC is 2.5 mV. This resolution allows to measure the temperature
  // out of the LM35 with a resolution of 0.25 degree celsius, since each 10mV  increment on the LM35 output is 1 degree C.
  // If the temperature is higher than the maximum specified temperature, turn on the AC.
  if (temperature > AMBIENT_HIGH_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, HIGH);
    24b4:	c1 37       	cpi	r28, 0x71	; 113
    24b6:	d1 05       	cpc	r29, r1
    24b8:	28 f0       	brcs	.+10     	; 0x24c4 <__vector_16+0x44>
    24ba:	41 e0       	ldi	r20, 0x01	; 1
    24bc:	63 e4       	ldi	r22, 0x43	; 67
    24be:	87 e0       	ldi	r24, 0x07	; 7
    24c0:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>
  // If the temperature became below the minimum specified temperature turn off the AC.
  if (temperature < AMBIENT_LOW_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, LOW);
    24c4:	c4 35       	cpi	r28, 0x54	; 84
    24c6:	d1 05       	cpc	r29, r1
    24c8:	28 f4       	brcc	.+10     	; 0x24d4 <__vector_16+0x54>
    24ca:	40 e0       	ldi	r20, 0x00	; 0
    24cc:	63 e4       	ldi	r22, 0x43	; 67
    24ce:	87 e0       	ldi	r24, 0x07	; 7
    24d0:	0e 94 dd 04 	call	0x9ba	; 0x9ba <DIO_write>

#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_VIA_ADC_COMPLETE_INTERRUPT
  // Since the ADC is configured in auto trigger mode with timer 0 overflow as the trigger, 
  // The overflow interrupt flag bit must be cleared by software if timer 0 overflow interrupt isn't used. 
  // Otherwise the triggering won't work and the ADC will halt.
  set_bit(TIFR, TOV0);
    24d4:	88 b7       	in	r24, 0x38	; 56
    24d6:	81 60       	ori	r24, 0x01	; 1
    24d8:	88 bf       	out	0x38, r24	; 56
#endif
    24da:	ff 91       	pop	r31
    24dc:	ef 91       	pop	r30
    24de:	df 91       	pop	r29
    24e0:	cf 91       	pop	r28
    24e2:	bf 91       	pop	r27
    24e4:	af 91       	pop	r26
    24e6:	9f 91       	pop	r25
    24e8:	8f 91       	pop	r24
    24ea:	7f 91       	pop	r23
    24ec:	6f 91       	pop	r22
    24ee:	5f 91       	pop	r21
    24f0:	4f 91       	pop	r20
    24f2:	3f 91       	pop	r19
    24f4:	2f 91       	pop	r18
    24f6:	0f 90       	pop	r0
    24f8:	0f be       	out	0x3f, r0	; 63
    24fa:	0f 90       	pop	r0
    24fc:	1f 90       	pop	r1
    24fe:	18 95       	reti

00002500 <User_DB_init>:
    return getUserByName(user_code_or_name, user);
    }
  else {
    return getUserByCode(user_code_or_name, user);
    }
  }
    2500:	0e 94 ad 00 	call	0x15a	; 0x15a <EEPROM_init>
    2504:	08 95       	ret

00002506 <getUserByName>:
    2506:	9f 92       	push	r9
    2508:	af 92       	push	r10
    250a:	bf 92       	push	r11
    250c:	cf 92       	push	r12
    250e:	df 92       	push	r13
    2510:	ef 92       	push	r14
    2512:	ff 92       	push	r15
    2514:	0f 93       	push	r16
    2516:	1f 93       	push	r17
    2518:	cf 93       	push	r28
    251a:	df 93       	push	r29
    251c:	cd b7       	in	r28, 0x3d	; 61
    251e:	de b7       	in	r29, 0x3e	; 62
    2520:	6d 97       	sbiw	r28, 0x1d	; 29
    2522:	0f b6       	in	r0, 0x3f	; 63
    2524:	f8 94       	cli
    2526:	de bf       	out	0x3e, r29	; 62
    2528:	0f be       	out	0x3f, r0	; 63
    252a:	cd bf       	out	0x3d, r28	; 61
    252c:	7c 01       	movw	r14, r24
    252e:	6b 01       	movw	r12, r22
    2530:	91 2c       	mov	r9, r1
    2532:	6b c0       	rjmp	.+214    	; 0x260a <getUserByName+0x104>
    2534:	ae 01       	movw	r20, r28
    2536:	4f 5f       	subi	r20, 0xFF	; 255
    2538:	5f 4f       	sbci	r21, 0xFF	; 255
    253a:	60 e0       	ldi	r22, 0x00	; 0
    253c:	89 2d       	mov	r24, r9
    253e:	0e 94 b0 00 	call	0x160	; 0x160 <EEPROM_read_byte>
    2542:	ae 01       	movw	r20, r28
    2544:	4e 5f       	subi	r20, 0xFE	; 254
    2546:	5f 4f       	sbci	r21, 0xFF	; 255
    2548:	61 e0       	ldi	r22, 0x01	; 1
    254a:	89 2d       	mov	r24, r9
    254c:	0e 94 b0 00 	call	0x160	; 0x160 <EEPROM_read_byte>
    2550:	b1 2c       	mov	r11, r1
    2552:	56 c0       	rjmp	.+172    	; 0x2600 <getUserByName+0xfa>
    2554:	89 81       	ldd	r24, Y+1	; 0x01
    2556:	90 e0       	ldi	r25, 0x00	; 0
    2558:	0b 2c       	mov	r0, r11
    255a:	02 c0       	rjmp	.+4      	; 0x2560 <getUserByName+0x5a>
    255c:	95 95       	asr	r25
    255e:	87 95       	ror	r24
    2560:	0a 94       	dec	r0
    2562:	e2 f7       	brpl	.-8      	; 0x255c <getUserByName+0x56>
    2564:	80 ff       	sbrs	r24, 0
    2566:	4b c0       	rjmp	.+150    	; 0x25fe <getUserByName+0xf8>
    2568:	6f e1       	ldi	r22, 0x1F	; 31
    256a:	b6 9e       	mul	r11, r22
    256c:	a0 2c       	mov	r10, r0
    256e:	11 24       	eor	r1, r1
    2570:	68 e0       	ldi	r22, 0x08	; 8
    2572:	6a 0d       	add	r22, r10
    2574:	9e 01       	movw	r18, r28
    2576:	2d 5f       	subi	r18, 0xFD	; 253
    2578:	3f 4f       	sbci	r19, 0xFF	; 255
    257a:	4d e0       	ldi	r20, 0x0D	; 13
    257c:	50 e0       	ldi	r21, 0x00	; 0
    257e:	89 2d       	mov	r24, r9
    2580:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <EEPROM_read_block>
    2584:	be 01       	movw	r22, r28
    2586:	6d 5f       	subi	r22, 0xFD	; 253
    2588:	7f 4f       	sbci	r23, 0xFF	; 255
    258a:	c7 01       	movw	r24, r14
    258c:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <strcmp>
    2590:	89 2b       	or	r24, r25
    2592:	a9 f5       	brne	.+106    	; 0x25fe <getUserByName+0xf8>
    2594:	65 e1       	ldi	r22, 0x15	; 21
    2596:	6a 0d       	add	r22, r10
    2598:	9e 01       	movw	r18, r28
    259a:	20 5f       	subi	r18, 0xF0	; 240
    259c:	3f 4f       	sbci	r19, 0xFF	; 255
    259e:	47 e0       	ldi	r20, 0x07	; 7
    25a0:	50 e0       	ldi	r21, 0x00	; 0
    25a2:	89 2d       	mov	r24, r9
    25a4:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <EEPROM_read_block>
    25a8:	6c e1       	ldi	r22, 0x1C	; 28
    25aa:	6a 0d       	add	r22, r10
    25ac:	9e 01       	movw	r18, r28
    25ae:	29 5e       	subi	r18, 0xE9	; 233
    25b0:	3f 4f       	sbci	r19, 0xFF	; 255
    25b2:	47 e0       	ldi	r20, 0x07	; 7
    25b4:	50 e0       	ldi	r21, 0x00	; 0
    25b6:	89 2d       	mov	r24, r9
    25b8:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <EEPROM_read_block>
    25bc:	8a 81       	ldd	r24, Y+2	; 0x02
    25be:	90 e0       	ldi	r25, 0x00	; 0
    25c0:	02 c0       	rjmp	.+4      	; 0x25c6 <getUserByName+0xc0>
    25c2:	95 95       	asr	r25
    25c4:	87 95       	ror	r24
    25c6:	ba 94       	dec	r11
    25c8:	e2 f7       	brpl	.-8      	; 0x25c2 <getUserByName+0xbc>
    25ca:	98 2f       	mov	r25, r24
    25cc:	91 70       	andi	r25, 0x01	; 1
    25ce:	f6 01       	movw	r30, r12
    25d0:	91 93       	st	Z+, r25
    25d2:	be 01       	movw	r22, r28
    25d4:	6d 5f       	subi	r22, 0xFD	; 253
    25d6:	7f 4f       	sbci	r23, 0xFF	; 255
    25d8:	cf 01       	movw	r24, r30
    25da:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <strcpy>
    25de:	be 01       	movw	r22, r28
    25e0:	60 5f       	subi	r22, 0xF0	; 240
    25e2:	7f 4f       	sbci	r23, 0xFF	; 255
    25e4:	c6 01       	movw	r24, r12
    25e6:	0e 96       	adiw	r24, 0x0e	; 14
    25e8:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <strcpy>
    25ec:	be 01       	movw	r22, r28
    25ee:	69 5e       	subi	r22, 0xE9	; 233
    25f0:	7f 4f       	sbci	r23, 0xFF	; 255
    25f2:	c6 01       	movw	r24, r12
    25f4:	45 96       	adiw	r24, 0x15	; 21
    25f6:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <strcpy>
    25fa:	82 e0       	ldi	r24, 0x02	; 2
    25fc:	0b c0       	rjmp	.+22     	; 0x2614 <getUserByName+0x10e>
    25fe:	b3 94       	inc	r11
    2600:	87 e0       	ldi	r24, 0x07	; 7
    2602:	8b 15       	cp	r24, r11
    2604:	08 f0       	brcs	.+2      	; 0x2608 <getUserByName+0x102>
    2606:	a6 cf       	rjmp	.-180    	; 0x2554 <getUserByName+0x4e>
    2608:	93 94       	inc	r9
    260a:	87 e0       	ldi	r24, 0x07	; 7
    260c:	89 15       	cp	r24, r9
    260e:	08 f0       	brcs	.+2      	; 0x2612 <getUserByName+0x10c>
    2610:	91 cf       	rjmp	.-222    	; 0x2534 <getUserByName+0x2e>
    2612:	83 e0       	ldi	r24, 0x03	; 3
    2614:	6d 96       	adiw	r28, 0x1d	; 29
    2616:	0f b6       	in	r0, 0x3f	; 63
    2618:	f8 94       	cli
    261a:	de bf       	out	0x3e, r29	; 62
    261c:	0f be       	out	0x3f, r0	; 63
    261e:	cd bf       	out	0x3d, r28	; 61
    2620:	df 91       	pop	r29
    2622:	cf 91       	pop	r28
    2624:	1f 91       	pop	r17
    2626:	0f 91       	pop	r16
    2628:	ff 90       	pop	r15
    262a:	ef 90       	pop	r14
    262c:	df 90       	pop	r13
    262e:	cf 90       	pop	r12
    2630:	bf 90       	pop	r11
    2632:	af 90       	pop	r10
    2634:	9f 90       	pop	r9
    2636:	08 95       	ret

00002638 <getUserByCode>:
    2638:	9f 92       	push	r9
    263a:	af 92       	push	r10
    263c:	bf 92       	push	r11
    263e:	cf 92       	push	r12
    2640:	df 92       	push	r13
    2642:	ef 92       	push	r14
    2644:	ff 92       	push	r15
    2646:	0f 93       	push	r16
    2648:	1f 93       	push	r17
    264a:	cf 93       	push	r28
    264c:	df 93       	push	r29
    264e:	cd b7       	in	r28, 0x3d	; 61
    2650:	de b7       	in	r29, 0x3e	; 62
    2652:	6d 97       	sbiw	r28, 0x1d	; 29
    2654:	0f b6       	in	r0, 0x3f	; 63
    2656:	f8 94       	cli
    2658:	de bf       	out	0x3e, r29	; 62
    265a:	0f be       	out	0x3f, r0	; 63
    265c:	cd bf       	out	0x3d, r28	; 61
    265e:	7c 01       	movw	r14, r24
    2660:	6b 01       	movw	r12, r22
    2662:	91 2c       	mov	r9, r1
    2664:	6b c0       	rjmp	.+214    	; 0x273c <getUserByCode+0x104>
    2666:	ae 01       	movw	r20, r28
    2668:	4f 5f       	subi	r20, 0xFF	; 255
    266a:	5f 4f       	sbci	r21, 0xFF	; 255
    266c:	60 e0       	ldi	r22, 0x00	; 0
    266e:	89 2d       	mov	r24, r9
    2670:	0e 94 b0 00 	call	0x160	; 0x160 <EEPROM_read_byte>
    2674:	ae 01       	movw	r20, r28
    2676:	4e 5f       	subi	r20, 0xFE	; 254
    2678:	5f 4f       	sbci	r21, 0xFF	; 255
    267a:	61 e0       	ldi	r22, 0x01	; 1
    267c:	89 2d       	mov	r24, r9
    267e:	0e 94 b0 00 	call	0x160	; 0x160 <EEPROM_read_byte>
    2682:	b1 2c       	mov	r11, r1
    2684:	56 c0       	rjmp	.+172    	; 0x2732 <getUserByCode+0xfa>
    2686:	89 81       	ldd	r24, Y+1	; 0x01
    2688:	90 e0       	ldi	r25, 0x00	; 0
    268a:	0b 2c       	mov	r0, r11
    268c:	02 c0       	rjmp	.+4      	; 0x2692 <getUserByCode+0x5a>
    268e:	95 95       	asr	r25
    2690:	87 95       	ror	r24
    2692:	0a 94       	dec	r0
    2694:	e2 f7       	brpl	.-8      	; 0x268e <getUserByCode+0x56>
    2696:	80 ff       	sbrs	r24, 0
    2698:	4b c0       	rjmp	.+150    	; 0x2730 <getUserByCode+0xf8>
    269a:	6f e1       	ldi	r22, 0x1F	; 31
    269c:	b6 9e       	mul	r11, r22
    269e:	a0 2c       	mov	r10, r0
    26a0:	11 24       	eor	r1, r1
    26a2:	65 e1       	ldi	r22, 0x15	; 21
    26a4:	6a 0d       	add	r22, r10
    26a6:	9e 01       	movw	r18, r28
    26a8:	20 5f       	subi	r18, 0xF0	; 240
    26aa:	3f 4f       	sbci	r19, 0xFF	; 255
    26ac:	47 e0       	ldi	r20, 0x07	; 7
    26ae:	50 e0       	ldi	r21, 0x00	; 0
    26b0:	89 2d       	mov	r24, r9
    26b2:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <EEPROM_read_block>
    26b6:	be 01       	movw	r22, r28
    26b8:	60 5f       	subi	r22, 0xF0	; 240
    26ba:	7f 4f       	sbci	r23, 0xFF	; 255
    26bc:	c7 01       	movw	r24, r14
    26be:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <strcmp>
    26c2:	89 2b       	or	r24, r25
    26c4:	a9 f5       	brne	.+106    	; 0x2730 <getUserByCode+0xf8>
    26c6:	68 e0       	ldi	r22, 0x08	; 8
    26c8:	6a 0d       	add	r22, r10
    26ca:	9e 01       	movw	r18, r28
    26cc:	2d 5f       	subi	r18, 0xFD	; 253
    26ce:	3f 4f       	sbci	r19, 0xFF	; 255
    26d0:	4d e0       	ldi	r20, 0x0D	; 13
    26d2:	50 e0       	ldi	r21, 0x00	; 0
    26d4:	89 2d       	mov	r24, r9
    26d6:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <EEPROM_read_block>
    26da:	6c e1       	ldi	r22, 0x1C	; 28
    26dc:	6a 0d       	add	r22, r10
    26de:	9e 01       	movw	r18, r28
    26e0:	29 5e       	subi	r18, 0xE9	; 233
    26e2:	3f 4f       	sbci	r19, 0xFF	; 255
    26e4:	47 e0       	ldi	r20, 0x07	; 7
    26e6:	50 e0       	ldi	r21, 0x00	; 0
    26e8:	89 2d       	mov	r24, r9
    26ea:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <EEPROM_read_block>
    26ee:	8a 81       	ldd	r24, Y+2	; 0x02
    26f0:	90 e0       	ldi	r25, 0x00	; 0
    26f2:	02 c0       	rjmp	.+4      	; 0x26f8 <getUserByCode+0xc0>
    26f4:	95 95       	asr	r25
    26f6:	87 95       	ror	r24
    26f8:	ba 94       	dec	r11
    26fa:	e2 f7       	brpl	.-8      	; 0x26f4 <getUserByCode+0xbc>
    26fc:	98 2f       	mov	r25, r24
    26fe:	91 70       	andi	r25, 0x01	; 1
    2700:	f6 01       	movw	r30, r12
    2702:	91 93       	st	Z+, r25
    2704:	be 01       	movw	r22, r28
    2706:	6d 5f       	subi	r22, 0xFD	; 253
    2708:	7f 4f       	sbci	r23, 0xFF	; 255
    270a:	cf 01       	movw	r24, r30
    270c:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <strcpy>
    2710:	be 01       	movw	r22, r28
    2712:	60 5f       	subi	r22, 0xF0	; 240
    2714:	7f 4f       	sbci	r23, 0xFF	; 255
    2716:	c6 01       	movw	r24, r12
    2718:	0e 96       	adiw	r24, 0x0e	; 14
    271a:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <strcpy>
    271e:	be 01       	movw	r22, r28
    2720:	69 5e       	subi	r22, 0xE9	; 233
    2722:	7f 4f       	sbci	r23, 0xFF	; 255
    2724:	c6 01       	movw	r24, r12
    2726:	45 96       	adiw	r24, 0x15	; 21
    2728:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <strcpy>
    272c:	82 e0       	ldi	r24, 0x02	; 2
    272e:	0b c0       	rjmp	.+22     	; 0x2746 <getUserByCode+0x10e>
    2730:	b3 94       	inc	r11
    2732:	87 e0       	ldi	r24, 0x07	; 7
    2734:	8b 15       	cp	r24, r11
    2736:	08 f0       	brcs	.+2      	; 0x273a <getUserByCode+0x102>
    2738:	a6 cf       	rjmp	.-180    	; 0x2686 <getUserByCode+0x4e>
    273a:	93 94       	inc	r9
    273c:	87 e0       	ldi	r24, 0x07	; 7
    273e:	89 15       	cp	r24, r9
    2740:	08 f0       	brcs	.+2      	; 0x2744 <getUserByCode+0x10c>
    2742:	91 cf       	rjmp	.-222    	; 0x2666 <getUserByCode+0x2e>
    2744:	83 e0       	ldi	r24, 0x03	; 3
    2746:	6d 96       	adiw	r28, 0x1d	; 29
    2748:	0f b6       	in	r0, 0x3f	; 63
    274a:	f8 94       	cli
    274c:	de bf       	out	0x3e, r29	; 62
    274e:	0f be       	out	0x3f, r0	; 63
    2750:	cd bf       	out	0x3d, r28	; 61
    2752:	df 91       	pop	r29
    2754:	cf 91       	pop	r28
    2756:	1f 91       	pop	r17
    2758:	0f 91       	pop	r16
    275a:	ff 90       	pop	r15
    275c:	ef 90       	pop	r14
    275e:	df 90       	pop	r13
    2760:	cf 90       	pop	r12
    2762:	bf 90       	pop	r11
    2764:	af 90       	pop	r10
    2766:	9f 90       	pop	r9
    2768:	08 95       	ret

0000276a <Alarm_set>:

void Alarm_set(void) {
  Buzzer_on(BUZZER_PORT, BUZZER_PIN);
    276a:	66 e0       	ldi	r22, 0x06	; 6
    276c:	84 e4       	ldi	r24, 0x44	; 68
    276e:	0e 94 a4 00 	call	0x148	; 0x148 <Buzzer_on>
    2772:	08 95       	ret

00002774 <write_user>:
  }

void write_user(u8 userBlockIndex, ST_User_t* user) {
    2774:	ef 92       	push	r14
    2776:	ff 92       	push	r15
    2778:	0f 93       	push	r16
    277a:	1f 93       	push	r17
    277c:	cf 93       	push	r28
    277e:	df 93       	push	r29
    2780:	00 d0       	rcall	.+0      	; 0x2782 <write_user+0xe>
    2782:	cd b7       	in	r28, 0x3d	; 61
    2784:	de b7       	in	r29, 0x3e	; 62
    2786:	7b 01       	movw	r14, r22
  // Get the user block location (page - index)
  u8 page = userBlockIndex / 8;
    2788:	08 2f       	mov	r16, r24
    278a:	06 95       	lsr	r16
    278c:	06 95       	lsr	r16
    278e:	06 95       	lsr	r16
  u8 blockNumber = userBlockIndex % 8;
    2790:	18 2f       	mov	r17, r24
    2792:	17 70       	andi	r17, 0x07	; 7
  // Read and update the block status (reserve the block). And update the user authority level flag if the user is admin
  u8 usersBlockStatus, usersAuthorityLevel;
  EEPROM_read_byte(page, 0, &usersBlockStatus);
    2794:	ae 01       	movw	r20, r28
    2796:	4f 5f       	subi	r20, 0xFF	; 255
    2798:	5f 4f       	sbci	r21, 0xFF	; 255
    279a:	60 e0       	ldi	r22, 0x00	; 0
    279c:	80 2f       	mov	r24, r16
    279e:	0e 94 b0 00 	call	0x160	; 0x160 <EEPROM_read_byte>
  EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    27a2:	ae 01       	movw	r20, r28
    27a4:	4e 5f       	subi	r20, 0xFE	; 254
    27a6:	5f 4f       	sbci	r21, 0xFF	; 255
    27a8:	61 e0       	ldi	r22, 0x01	; 1
    27aa:	80 2f       	mov	r24, r16
    27ac:	0e 94 b0 00 	call	0x160	; 0x160 <EEPROM_read_byte>
  set_bit(usersBlockStatus, blockNumber);
    27b0:	81 e0       	ldi	r24, 0x01	; 1
    27b2:	90 e0       	ldi	r25, 0x00	; 0
    27b4:	01 2e       	mov	r0, r17
    27b6:	02 c0       	rjmp	.+4      	; 0x27bc <write_user+0x48>
    27b8:	88 0f       	add	r24, r24
    27ba:	99 1f       	adc	r25, r25
    27bc:	0a 94       	dec	r0
    27be:	e2 f7       	brpl	.-8      	; 0x27b8 <write_user+0x44>
    27c0:	49 81       	ldd	r20, Y+1	; 0x01
    27c2:	48 2b       	or	r20, r24
    27c4:	49 83       	std	Y+1, r20	; 0x01
  if (user->isAdmin) set_bit(usersAuthorityLevel, blockNumber);
    27c6:	f7 01       	movw	r30, r14
    27c8:	20 81       	ld	r18, Z
    27ca:	22 23       	and	r18, r18
    27cc:	19 f0       	breq	.+6      	; 0x27d4 <write_user+0x60>
    27ce:	9a 81       	ldd	r25, Y+2	; 0x02
    27d0:	89 2b       	or	r24, r25
    27d2:	8a 83       	std	Y+2, r24	; 0x02
  EEPROM_write_byte(page, 0, usersBlockStatus);
    27d4:	60 e0       	ldi	r22, 0x00	; 0
    27d6:	80 2f       	mov	r24, r16
    27d8:	0e 94 07 01 	call	0x20e	; 0x20e <EEPROM_write_byte>
  EEPROM_write_byte(page, 1, usersAuthorityLevel);
    27dc:	4a 81       	ldd	r20, Y+2	; 0x02
    27de:	61 e0       	ldi	r22, 0x01	; 1
    27e0:	80 2f       	mov	r24, r16
    27e2:	0e 94 07 01 	call	0x20e	; 0x20e <EEPROM_write_byte>
  // Write the user data
  EEPROM_write_block(page, 8 + 31 * blockNumber, 13, user->name);
    27e6:	97 01       	movw	r18, r14
    27e8:	2f 5f       	subi	r18, 0xFF	; 255
    27ea:	3f 4f       	sbci	r19, 0xFF	; 255
    27ec:	6f e1       	ldi	r22, 0x1F	; 31
    27ee:	16 9f       	mul	r17, r22
    27f0:	10 2d       	mov	r17, r0
    27f2:	11 24       	eor	r1, r1
    27f4:	68 e0       	ldi	r22, 0x08	; 8
    27f6:	61 0f       	add	r22, r17
    27f8:	4d e0       	ldi	r20, 0x0D	; 13
    27fa:	50 e0       	ldi	r21, 0x00	; 0
    27fc:	80 2f       	mov	r24, r16
    27fe:	0e 94 26 01 	call	0x24c	; 0x24c <EEPROM_write_block>
  EEPROM_write_block(page, 21 + 31 * blockNumber, 7, user->code);
    2802:	97 01       	movw	r18, r14
    2804:	22 5f       	subi	r18, 0xF2	; 242
    2806:	3f 4f       	sbci	r19, 0xFF	; 255
    2808:	65 e1       	ldi	r22, 0x15	; 21
    280a:	61 0f       	add	r22, r17
    280c:	47 e0       	ldi	r20, 0x07	; 7
    280e:	50 e0       	ldi	r21, 0x00	; 0
    2810:	80 2f       	mov	r24, r16
    2812:	0e 94 26 01 	call	0x24c	; 0x24c <EEPROM_write_block>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
    2816:	97 01       	movw	r18, r14
    2818:	2b 5e       	subi	r18, 0xEB	; 235
    281a:	3f 4f       	sbci	r19, 0xFF	; 255
    281c:	6c e1       	ldi	r22, 0x1C	; 28
    281e:	61 0f       	add	r22, r17
    2820:	4b e0       	ldi	r20, 0x0B	; 11
    2822:	50 e0       	ldi	r21, 0x00	; 0
    2824:	80 2f       	mov	r24, r16
    2826:	0e 94 26 01 	call	0x24c	; 0x24c <EEPROM_write_block>
  }
    282a:	0f 90       	pop	r0
    282c:	0f 90       	pop	r0
    282e:	df 91       	pop	r29
    2830:	cf 91       	pop	r28
    2832:	1f 91       	pop	r17
    2834:	0f 91       	pop	r16
    2836:	ff 90       	pop	r15
    2838:	ef 90       	pop	r14
    283a:	08 95       	ret

0000283c <add_user>:

EN_UserStatusCode_t add_user(ST_User_t* user) {
    283c:	ef 92       	push	r14
    283e:	ff 92       	push	r15
    2840:	1f 93       	push	r17
    2842:	cf 93       	push	r28
    2844:	df 93       	push	r29
    2846:	1f 92       	push	r1
    2848:	cd b7       	in	r28, 0x3d	; 61
    284a:	de b7       	in	r29, 0x3e	; 62
    284c:	7c 01       	movw	r14, r24
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    284e:	10 e0       	ldi	r17, 0x00	; 0
    2850:	1a c0       	rjmp	.+52     	; 0x2886 <add_user+0x4a>
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    2852:	ae 01       	movw	r20, r28
    2854:	4f 5f       	subi	r20, 0xFF	; 255
    2856:	5f 4f       	sbci	r21, 0xFF	; 255
    2858:	60 e0       	ldi	r22, 0x00	; 0
    285a:	81 2f       	mov	r24, r17
    285c:	0e 94 b0 00 	call	0x160	; 0x160 <EEPROM_read_byte>
    if (usersBlockStatus != 0xFF) {
    2860:	99 81       	ldd	r25, Y+1	; 0x01
    2862:	9f 3f       	cpi	r25, 0xFF	; 255
    2864:	79 f0       	breq	.+30     	; 0x2884 <add_user+0x48>
    2866:	02 c0       	rjmp	.+4      	; 0x286c <add_user+0x30>
      // Find the block number in the page
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
    2868:	8f 5f       	subi	r24, 0xFF	; 255
    286a:	01 c0       	rjmp	.+2      	; 0x286e <add_user+0x32>
    286c:	80 e0       	ldi	r24, 0x00	; 0
    286e:	29 2f       	mov	r18, r25
    2870:	30 e0       	ldi	r19, 0x00	; 0
    2872:	08 2e       	mov	r0, r24
    2874:	02 c0       	rjmp	.+4      	; 0x287a <add_user+0x3e>
    2876:	35 95       	asr	r19
    2878:	27 95       	ror	r18
    287a:	0a 94       	dec	r0
    287c:	e2 f7       	brpl	.-8      	; 0x2876 <add_user+0x3a>
    287e:	20 fd       	sbrc	r18, 0
    2880:	f3 cf       	rjmp	.-26     	; 0x2868 <add_user+0x2c>
    2882:	04 c0       	rjmp	.+8      	; 0x288c <add_user+0x50>
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    2884:	1f 5f       	subi	r17, 0xFF	; 255
    2886:	18 30       	cpi	r17, 0x08	; 8
    2888:	20 f3       	brcs	.-56     	; 0x2852 <add_user+0x16>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
    288a:	80 e0       	ldi	r24, 0x00	; 0
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    288c:	18 30       	cpi	r17, 0x08	; 8
    288e:	49 f0       	breq	.+18     	; 0x28a2 <add_user+0x66>
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
    2890:	11 0f       	add	r17, r17
    2892:	11 0f       	add	r17, r17
    2894:	11 0f       	add	r17, r17
  write_user(availableUserBlockIndex, user);
    2896:	b7 01       	movw	r22, r14
    2898:	81 0f       	add	r24, r17
    289a:	0e 94 ba 13 	call	0x2774	; 0x2774 <write_user>
  return USER_ADDED_SUCCESSFULLY;
    289e:	89 e0       	ldi	r24, 0x09	; 9
    28a0:	01 c0       	rjmp	.+2      	; 0x28a4 <add_user+0x68>
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    28a2:	8b e0       	ldi	r24, 0x0B	; 11
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
  write_user(availableUserBlockIndex, user);
  return USER_ADDED_SUCCESSFULLY;
  }
    28a4:	0f 90       	pop	r0
    28a6:	df 91       	pop	r29
    28a8:	cf 91       	pop	r28
    28aa:	1f 91       	pop	r17
    28ac:	ff 90       	pop	r15
    28ae:	ef 90       	pop	r14
    28b0:	08 95       	ret

000028b2 <delete_user>:

EN_UserStatusCode_t delete_user(ST_User_t* user) {
    28b2:	cf 92       	push	r12
    28b4:	df 92       	push	r13
    28b6:	ef 92       	push	r14
    28b8:	ff 92       	push	r15
    28ba:	0f 93       	push	r16
    28bc:	1f 93       	push	r17
    28be:	cf 93       	push	r28
    28c0:	df 93       	push	r29
    28c2:	cd b7       	in	r28, 0x3d	; 61
    28c4:	de b7       	in	r29, 0x3e	; 62
    28c6:	29 97       	sbiw	r28, 0x09	; 9
    28c8:	0f b6       	in	r0, 0x3f	; 63
    28ca:	f8 94       	cli
    28cc:	de bf       	out	0x3e, r29	; 62
    28ce:	0f be       	out	0x3f, r0	; 63
    28d0:	cd bf       	out	0x3d, r28	; 61
    28d2:	6c 01       	movw	r12, r24
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    28d4:	00 e0       	ldi	r16, 0x00	; 0
    28d6:	4d c0       	rjmp	.+154    	; 0x2972 <delete_user+0xc0>
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    28d8:	ae 01       	movw	r20, r28
    28da:	4f 5f       	subi	r20, 0xFF	; 255
    28dc:	5f 4f       	sbci	r21, 0xFF	; 255
    28de:	60 e0       	ldi	r22, 0x00	; 0
    28e0:	80 2f       	mov	r24, r16
    28e2:	0e 94 b0 00 	call	0x160	; 0x160 <EEPROM_read_byte>
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    28e6:	ae 01       	movw	r20, r28
    28e8:	4e 5f       	subi	r20, 0xFE	; 254
    28ea:	5f 4f       	sbci	r21, 0xFF	; 255
    28ec:	61 e0       	ldi	r22, 0x01	; 1
    28ee:	80 2f       	mov	r24, r16
    28f0:	0e 94 b0 00 	call	0x160	; 0x160 <EEPROM_read_byte>
    for (userIndex = 0; userIndex < 8;userIndex++) {
    28f4:	10 e0       	ldi	r17, 0x00	; 0
    28f6:	3a c0       	rjmp	.+116    	; 0x296c <delete_user+0xba>
      if (read_bit(usersBlockStatus, userIndex)) {  // If the user isn't deleted
    28f8:	89 81       	ldd	r24, Y+1	; 0x01
    28fa:	90 e0       	ldi	r25, 0x00	; 0
    28fc:	01 2e       	mov	r0, r17
    28fe:	02 c0       	rjmp	.+4      	; 0x2904 <delete_user+0x52>
    2900:	95 95       	asr	r25
    2902:	87 95       	ror	r24
    2904:	0a 94       	dec	r0
    2906:	e2 f7       	brpl	.-8      	; 0x2900 <delete_user+0x4e>
    2908:	80 ff       	sbrs	r24, 0
    290a:	2f c0       	rjmp	.+94     	; 0x296a <delete_user+0xb8>
        EEPROM_read_block(page, 21 + 31 * userIndex, 7, tempUserCode);
    290c:	6f e1       	ldi	r22, 0x1F	; 31
    290e:	16 9f       	mul	r17, r22
    2910:	60 2d       	mov	r22, r0
    2912:	11 24       	eor	r1, r1
    2914:	6b 5e       	subi	r22, 0xEB	; 235
    2916:	9e 01       	movw	r18, r28
    2918:	2d 5f       	subi	r18, 0xFD	; 253
    291a:	3f 4f       	sbci	r19, 0xFF	; 255
    291c:	47 e0       	ldi	r20, 0x07	; 7
    291e:	50 e0       	ldi	r21, 0x00	; 0
    2920:	80 2f       	mov	r24, r16
    2922:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <EEPROM_read_block>
        if (strcmp(user->code, tempUserCode) == 0) { // User has been found
    2926:	be 01       	movw	r22, r28
    2928:	6d 5f       	subi	r22, 0xFD	; 253
    292a:	7f 4f       	sbci	r23, 0xFF	; 255
    292c:	c6 01       	movw	r24, r12
    292e:	0e 96       	adiw	r24, 0x0e	; 14
    2930:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <strcmp>
    2934:	89 2b       	or	r24, r25
    2936:	c9 f4       	brne	.+50     	; 0x296a <delete_user+0xb8>
          // Mark it as deleted
          clear_bit(usersBlockStatus, userIndex);
    2938:	81 e0       	ldi	r24, 0x01	; 1
    293a:	90 e0       	ldi	r25, 0x00	; 0
    293c:	02 c0       	rjmp	.+4      	; 0x2942 <delete_user+0x90>
    293e:	88 0f       	add	r24, r24
    2940:	99 1f       	adc	r25, r25
    2942:	1a 95       	dec	r17
    2944:	e2 f7       	brpl	.-8      	; 0x293e <delete_user+0x8c>
    2946:	80 95       	com	r24
    2948:	49 81       	ldd	r20, Y+1	; 0x01
    294a:	48 23       	and	r20, r24
    294c:	49 83       	std	Y+1, r20	; 0x01
          clear_bit(usersAuthorityLevel, userIndex);
    294e:	9a 81       	ldd	r25, Y+2	; 0x02
    2950:	89 23       	and	r24, r25
    2952:	8a 83       	std	Y+2, r24	; 0x02
          EEPROM_write_byte(page, 0, usersBlockStatus);
    2954:	60 e0       	ldi	r22, 0x00	; 0
    2956:	80 2f       	mov	r24, r16
    2958:	0e 94 07 01 	call	0x20e	; 0x20e <EEPROM_write_byte>
          EEPROM_write_byte(page, 1, usersAuthorityLevel);
    295c:	4a 81       	ldd	r20, Y+2	; 0x02
    295e:	61 e0       	ldi	r22, 0x01	; 1
    2960:	80 2f       	mov	r24, r16
    2962:	0e 94 07 01 	call	0x20e	; 0x20e <EEPROM_write_byte>
          return USER_DELETED_SUCCESSFULLY;
    2966:	8a e0       	ldi	r24, 0x0A	; 10
    2968:	08 c0       	rjmp	.+16     	; 0x297a <delete_user+0xc8>
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    for (userIndex = 0; userIndex < 8;userIndex++) {
    296a:	1f 5f       	subi	r17, 0xFF	; 255
    296c:	18 30       	cpi	r17, 0x08	; 8
    296e:	20 f2       	brcs	.-120    	; 0x28f8 <delete_user+0x46>
EN_UserStatusCode_t delete_user(ST_User_t* user) {
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    2970:	0f 5f       	subi	r16, 0xFF	; 255
    2972:	08 30       	cpi	r16, 0x08	; 8
    2974:	08 f4       	brcc	.+2      	; 0x2978 <delete_user+0xc6>
    2976:	b0 cf       	rjmp	.-160    	; 0x28d8 <delete_user+0x26>
          return USER_DELETED_SUCCESSFULLY;
          }
        }
      }
    }
  return USER_NOT_FOUND;
    2978:	83 e0       	ldi	r24, 0x03	; 3
  }
    297a:	29 96       	adiw	r28, 0x09	; 9
    297c:	0f b6       	in	r0, 0x3f	; 63
    297e:	f8 94       	cli
    2980:	de bf       	out	0x3e, r29	; 62
    2982:	0f be       	out	0x3f, r0	; 63
    2984:	cd bf       	out	0x3d, r28	; 61
    2986:	df 91       	pop	r29
    2988:	cf 91       	pop	r28
    298a:	1f 91       	pop	r17
    298c:	0f 91       	pop	r16
    298e:	ff 90       	pop	r15
    2990:	ef 90       	pop	r14
    2992:	df 90       	pop	r13
    2994:	cf 90       	pop	r12
    2996:	08 95       	ret

00002998 <__subsf3>:
    2998:	50 58       	subi	r21, 0x80	; 128

0000299a <__addsf3>:
    299a:	bb 27       	eor	r27, r27
    299c:	aa 27       	eor	r26, r26
    299e:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <__addsf3x>
    29a2:	0c 94 35 16 	jmp	0x2c6a	; 0x2c6a <__fp_round>
    29a6:	0e 94 27 16 	call	0x2c4e	; 0x2c4e <__fp_pscA>
    29aa:	38 f0       	brcs	.+14     	; 0x29ba <__addsf3+0x20>
    29ac:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <__fp_pscB>
    29b0:	20 f0       	brcs	.+8      	; 0x29ba <__addsf3+0x20>
    29b2:	39 f4       	brne	.+14     	; 0x29c2 <__addsf3+0x28>
    29b4:	9f 3f       	cpi	r25, 0xFF	; 255
    29b6:	19 f4       	brne	.+6      	; 0x29be <__addsf3+0x24>
    29b8:	26 f4       	brtc	.+8      	; 0x29c2 <__addsf3+0x28>
    29ba:	0c 94 24 16 	jmp	0x2c48	; 0x2c48 <__fp_nan>
    29be:	0e f4       	brtc	.+2      	; 0x29c2 <__addsf3+0x28>
    29c0:	e0 95       	com	r30
    29c2:	e7 fb       	bst	r30, 7
    29c4:	0c 94 1e 16 	jmp	0x2c3c	; 0x2c3c <__fp_inf>

000029c8 <__addsf3x>:
    29c8:	e9 2f       	mov	r30, r25
    29ca:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <__fp_split3>
    29ce:	58 f3       	brcs	.-42     	; 0x29a6 <__addsf3+0xc>
    29d0:	ba 17       	cp	r27, r26
    29d2:	62 07       	cpc	r22, r18
    29d4:	73 07       	cpc	r23, r19
    29d6:	84 07       	cpc	r24, r20
    29d8:	95 07       	cpc	r25, r21
    29da:	20 f0       	brcs	.+8      	; 0x29e4 <__addsf3x+0x1c>
    29dc:	79 f4       	brne	.+30     	; 0x29fc <__addsf3x+0x34>
    29de:	a6 f5       	brtc	.+104    	; 0x2a48 <__addsf3x+0x80>
    29e0:	0c 94 68 16 	jmp	0x2cd0	; 0x2cd0 <__fp_zero>
    29e4:	0e f4       	brtc	.+2      	; 0x29e8 <__addsf3x+0x20>
    29e6:	e0 95       	com	r30
    29e8:	0b 2e       	mov	r0, r27
    29ea:	ba 2f       	mov	r27, r26
    29ec:	a0 2d       	mov	r26, r0
    29ee:	0b 01       	movw	r0, r22
    29f0:	b9 01       	movw	r22, r18
    29f2:	90 01       	movw	r18, r0
    29f4:	0c 01       	movw	r0, r24
    29f6:	ca 01       	movw	r24, r20
    29f8:	a0 01       	movw	r20, r0
    29fa:	11 24       	eor	r1, r1
    29fc:	ff 27       	eor	r31, r31
    29fe:	59 1b       	sub	r21, r25
    2a00:	99 f0       	breq	.+38     	; 0x2a28 <__addsf3x+0x60>
    2a02:	59 3f       	cpi	r21, 0xF9	; 249
    2a04:	50 f4       	brcc	.+20     	; 0x2a1a <__addsf3x+0x52>
    2a06:	50 3e       	cpi	r21, 0xE0	; 224
    2a08:	68 f1       	brcs	.+90     	; 0x2a64 <__addsf3x+0x9c>
    2a0a:	1a 16       	cp	r1, r26
    2a0c:	f0 40       	sbci	r31, 0x00	; 0
    2a0e:	a2 2f       	mov	r26, r18
    2a10:	23 2f       	mov	r18, r19
    2a12:	34 2f       	mov	r19, r20
    2a14:	44 27       	eor	r20, r20
    2a16:	58 5f       	subi	r21, 0xF8	; 248
    2a18:	f3 cf       	rjmp	.-26     	; 0x2a00 <__addsf3x+0x38>
    2a1a:	46 95       	lsr	r20
    2a1c:	37 95       	ror	r19
    2a1e:	27 95       	ror	r18
    2a20:	a7 95       	ror	r26
    2a22:	f0 40       	sbci	r31, 0x00	; 0
    2a24:	53 95       	inc	r21
    2a26:	c9 f7       	brne	.-14     	; 0x2a1a <__addsf3x+0x52>
    2a28:	7e f4       	brtc	.+30     	; 0x2a48 <__addsf3x+0x80>
    2a2a:	1f 16       	cp	r1, r31
    2a2c:	ba 0b       	sbc	r27, r26
    2a2e:	62 0b       	sbc	r22, r18
    2a30:	73 0b       	sbc	r23, r19
    2a32:	84 0b       	sbc	r24, r20
    2a34:	ba f0       	brmi	.+46     	; 0x2a64 <__addsf3x+0x9c>
    2a36:	91 50       	subi	r25, 0x01	; 1
    2a38:	a1 f0       	breq	.+40     	; 0x2a62 <__addsf3x+0x9a>
    2a3a:	ff 0f       	add	r31, r31
    2a3c:	bb 1f       	adc	r27, r27
    2a3e:	66 1f       	adc	r22, r22
    2a40:	77 1f       	adc	r23, r23
    2a42:	88 1f       	adc	r24, r24
    2a44:	c2 f7       	brpl	.-16     	; 0x2a36 <__addsf3x+0x6e>
    2a46:	0e c0       	rjmp	.+28     	; 0x2a64 <__addsf3x+0x9c>
    2a48:	ba 0f       	add	r27, r26
    2a4a:	62 1f       	adc	r22, r18
    2a4c:	73 1f       	adc	r23, r19
    2a4e:	84 1f       	adc	r24, r20
    2a50:	48 f4       	brcc	.+18     	; 0x2a64 <__addsf3x+0x9c>
    2a52:	87 95       	ror	r24
    2a54:	77 95       	ror	r23
    2a56:	67 95       	ror	r22
    2a58:	b7 95       	ror	r27
    2a5a:	f7 95       	ror	r31
    2a5c:	9e 3f       	cpi	r25, 0xFE	; 254
    2a5e:	08 f0       	brcs	.+2      	; 0x2a62 <__addsf3x+0x9a>
    2a60:	b0 cf       	rjmp	.-160    	; 0x29c2 <__addsf3+0x28>
    2a62:	93 95       	inc	r25
    2a64:	88 0f       	add	r24, r24
    2a66:	08 f0       	brcs	.+2      	; 0x2a6a <__addsf3x+0xa2>
    2a68:	99 27       	eor	r25, r25
    2a6a:	ee 0f       	add	r30, r30
    2a6c:	97 95       	ror	r25
    2a6e:	87 95       	ror	r24
    2a70:	08 95       	ret

00002a72 <__divsf3>:
    2a72:	0e 94 4d 15 	call	0x2a9a	; 0x2a9a <__divsf3x>
    2a76:	0c 94 35 16 	jmp	0x2c6a	; 0x2c6a <__fp_round>
    2a7a:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <__fp_pscB>
    2a7e:	58 f0       	brcs	.+22     	; 0x2a96 <__divsf3+0x24>
    2a80:	0e 94 27 16 	call	0x2c4e	; 0x2c4e <__fp_pscA>
    2a84:	40 f0       	brcs	.+16     	; 0x2a96 <__divsf3+0x24>
    2a86:	29 f4       	brne	.+10     	; 0x2a92 <__divsf3+0x20>
    2a88:	5f 3f       	cpi	r21, 0xFF	; 255
    2a8a:	29 f0       	breq	.+10     	; 0x2a96 <__divsf3+0x24>
    2a8c:	0c 94 1e 16 	jmp	0x2c3c	; 0x2c3c <__fp_inf>
    2a90:	51 11       	cpse	r21, r1
    2a92:	0c 94 69 16 	jmp	0x2cd2	; 0x2cd2 <__fp_szero>
    2a96:	0c 94 24 16 	jmp	0x2c48	; 0x2c48 <__fp_nan>

00002a9a <__divsf3x>:
    2a9a:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <__fp_split3>
    2a9e:	68 f3       	brcs	.-38     	; 0x2a7a <__divsf3+0x8>

00002aa0 <__divsf3_pse>:
    2aa0:	99 23       	and	r25, r25
    2aa2:	b1 f3       	breq	.-20     	; 0x2a90 <__divsf3+0x1e>
    2aa4:	55 23       	and	r21, r21
    2aa6:	91 f3       	breq	.-28     	; 0x2a8c <__divsf3+0x1a>
    2aa8:	95 1b       	sub	r25, r21
    2aaa:	55 0b       	sbc	r21, r21
    2aac:	bb 27       	eor	r27, r27
    2aae:	aa 27       	eor	r26, r26
    2ab0:	62 17       	cp	r22, r18
    2ab2:	73 07       	cpc	r23, r19
    2ab4:	84 07       	cpc	r24, r20
    2ab6:	38 f0       	brcs	.+14     	; 0x2ac6 <__divsf3_pse+0x26>
    2ab8:	9f 5f       	subi	r25, 0xFF	; 255
    2aba:	5f 4f       	sbci	r21, 0xFF	; 255
    2abc:	22 0f       	add	r18, r18
    2abe:	33 1f       	adc	r19, r19
    2ac0:	44 1f       	adc	r20, r20
    2ac2:	aa 1f       	adc	r26, r26
    2ac4:	a9 f3       	breq	.-22     	; 0x2ab0 <__divsf3_pse+0x10>
    2ac6:	35 d0       	rcall	.+106    	; 0x2b32 <__divsf3_pse+0x92>
    2ac8:	0e 2e       	mov	r0, r30
    2aca:	3a f0       	brmi	.+14     	; 0x2ada <__divsf3_pse+0x3a>
    2acc:	e0 e8       	ldi	r30, 0x80	; 128
    2ace:	32 d0       	rcall	.+100    	; 0x2b34 <__divsf3_pse+0x94>
    2ad0:	91 50       	subi	r25, 0x01	; 1
    2ad2:	50 40       	sbci	r21, 0x00	; 0
    2ad4:	e6 95       	lsr	r30
    2ad6:	00 1c       	adc	r0, r0
    2ad8:	ca f7       	brpl	.-14     	; 0x2acc <__divsf3_pse+0x2c>
    2ada:	2b d0       	rcall	.+86     	; 0x2b32 <__divsf3_pse+0x92>
    2adc:	fe 2f       	mov	r31, r30
    2ade:	29 d0       	rcall	.+82     	; 0x2b32 <__divsf3_pse+0x92>
    2ae0:	66 0f       	add	r22, r22
    2ae2:	77 1f       	adc	r23, r23
    2ae4:	88 1f       	adc	r24, r24
    2ae6:	bb 1f       	adc	r27, r27
    2ae8:	26 17       	cp	r18, r22
    2aea:	37 07       	cpc	r19, r23
    2aec:	48 07       	cpc	r20, r24
    2aee:	ab 07       	cpc	r26, r27
    2af0:	b0 e8       	ldi	r27, 0x80	; 128
    2af2:	09 f0       	breq	.+2      	; 0x2af6 <__divsf3_pse+0x56>
    2af4:	bb 0b       	sbc	r27, r27
    2af6:	80 2d       	mov	r24, r0
    2af8:	bf 01       	movw	r22, r30
    2afa:	ff 27       	eor	r31, r31
    2afc:	93 58       	subi	r25, 0x83	; 131
    2afe:	5f 4f       	sbci	r21, 0xFF	; 255
    2b00:	3a f0       	brmi	.+14     	; 0x2b10 <__divsf3_pse+0x70>
    2b02:	9e 3f       	cpi	r25, 0xFE	; 254
    2b04:	51 05       	cpc	r21, r1
    2b06:	78 f0       	brcs	.+30     	; 0x2b26 <__divsf3_pse+0x86>
    2b08:	0c 94 1e 16 	jmp	0x2c3c	; 0x2c3c <__fp_inf>
    2b0c:	0c 94 69 16 	jmp	0x2cd2	; 0x2cd2 <__fp_szero>
    2b10:	5f 3f       	cpi	r21, 0xFF	; 255
    2b12:	e4 f3       	brlt	.-8      	; 0x2b0c <__divsf3_pse+0x6c>
    2b14:	98 3e       	cpi	r25, 0xE8	; 232
    2b16:	d4 f3       	brlt	.-12     	; 0x2b0c <__divsf3_pse+0x6c>
    2b18:	86 95       	lsr	r24
    2b1a:	77 95       	ror	r23
    2b1c:	67 95       	ror	r22
    2b1e:	b7 95       	ror	r27
    2b20:	f7 95       	ror	r31
    2b22:	9f 5f       	subi	r25, 0xFF	; 255
    2b24:	c9 f7       	brne	.-14     	; 0x2b18 <__divsf3_pse+0x78>
    2b26:	88 0f       	add	r24, r24
    2b28:	91 1d       	adc	r25, r1
    2b2a:	96 95       	lsr	r25
    2b2c:	87 95       	ror	r24
    2b2e:	97 f9       	bld	r25, 7
    2b30:	08 95       	ret
    2b32:	e1 e0       	ldi	r30, 0x01	; 1
    2b34:	66 0f       	add	r22, r22
    2b36:	77 1f       	adc	r23, r23
    2b38:	88 1f       	adc	r24, r24
    2b3a:	bb 1f       	adc	r27, r27
    2b3c:	62 17       	cp	r22, r18
    2b3e:	73 07       	cpc	r23, r19
    2b40:	84 07       	cpc	r24, r20
    2b42:	ba 07       	cpc	r27, r26
    2b44:	20 f0       	brcs	.+8      	; 0x2b4e <__divsf3_pse+0xae>
    2b46:	62 1b       	sub	r22, r18
    2b48:	73 0b       	sbc	r23, r19
    2b4a:	84 0b       	sbc	r24, r20
    2b4c:	ba 0b       	sbc	r27, r26
    2b4e:	ee 1f       	adc	r30, r30
    2b50:	88 f7       	brcc	.-30     	; 0x2b34 <__divsf3_pse+0x94>
    2b52:	e0 95       	com	r30
    2b54:	08 95       	ret

00002b56 <__fixsfsi>:
    2b56:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <__fixunssfsi>
    2b5a:	68 94       	set
    2b5c:	b1 11       	cpse	r27, r1
    2b5e:	0c 94 69 16 	jmp	0x2cd2	; 0x2cd2 <__fp_szero>
    2b62:	08 95       	ret

00002b64 <__fixunssfsi>:
    2b64:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <__fp_splitA>
    2b68:	88 f0       	brcs	.+34     	; 0x2b8c <__fixunssfsi+0x28>
    2b6a:	9f 57       	subi	r25, 0x7F	; 127
    2b6c:	98 f0       	brcs	.+38     	; 0x2b94 <__fixunssfsi+0x30>
    2b6e:	b9 2f       	mov	r27, r25
    2b70:	99 27       	eor	r25, r25
    2b72:	b7 51       	subi	r27, 0x17	; 23
    2b74:	b0 f0       	brcs	.+44     	; 0x2ba2 <__fixunssfsi+0x3e>
    2b76:	e1 f0       	breq	.+56     	; 0x2bb0 <__fixunssfsi+0x4c>
    2b78:	66 0f       	add	r22, r22
    2b7a:	77 1f       	adc	r23, r23
    2b7c:	88 1f       	adc	r24, r24
    2b7e:	99 1f       	adc	r25, r25
    2b80:	1a f0       	brmi	.+6      	; 0x2b88 <__fixunssfsi+0x24>
    2b82:	ba 95       	dec	r27
    2b84:	c9 f7       	brne	.-14     	; 0x2b78 <__fixunssfsi+0x14>
    2b86:	14 c0       	rjmp	.+40     	; 0x2bb0 <__fixunssfsi+0x4c>
    2b88:	b1 30       	cpi	r27, 0x01	; 1
    2b8a:	91 f0       	breq	.+36     	; 0x2bb0 <__fixunssfsi+0x4c>
    2b8c:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <__fp_zero>
    2b90:	b1 e0       	ldi	r27, 0x01	; 1
    2b92:	08 95       	ret
    2b94:	0c 94 68 16 	jmp	0x2cd0	; 0x2cd0 <__fp_zero>
    2b98:	67 2f       	mov	r22, r23
    2b9a:	78 2f       	mov	r23, r24
    2b9c:	88 27       	eor	r24, r24
    2b9e:	b8 5f       	subi	r27, 0xF8	; 248
    2ba0:	39 f0       	breq	.+14     	; 0x2bb0 <__fixunssfsi+0x4c>
    2ba2:	b9 3f       	cpi	r27, 0xF9	; 249
    2ba4:	cc f3       	brlt	.-14     	; 0x2b98 <__fixunssfsi+0x34>
    2ba6:	86 95       	lsr	r24
    2ba8:	77 95       	ror	r23
    2baa:	67 95       	ror	r22
    2bac:	b3 95       	inc	r27
    2bae:	d9 f7       	brne	.-10     	; 0x2ba6 <__fixunssfsi+0x42>
    2bb0:	3e f4       	brtc	.+14     	; 0x2bc0 <__fixunssfsi+0x5c>
    2bb2:	90 95       	com	r25
    2bb4:	80 95       	com	r24
    2bb6:	70 95       	com	r23
    2bb8:	61 95       	neg	r22
    2bba:	7f 4f       	sbci	r23, 0xFF	; 255
    2bbc:	8f 4f       	sbci	r24, 0xFF	; 255
    2bbe:	9f 4f       	sbci	r25, 0xFF	; 255
    2bc0:	08 95       	ret

00002bc2 <__floatunsisf>:
    2bc2:	e8 94       	clt
    2bc4:	09 c0       	rjmp	.+18     	; 0x2bd8 <__floatsisf+0x12>

00002bc6 <__floatsisf>:
    2bc6:	97 fb       	bst	r25, 7
    2bc8:	3e f4       	brtc	.+14     	; 0x2bd8 <__floatsisf+0x12>
    2bca:	90 95       	com	r25
    2bcc:	80 95       	com	r24
    2bce:	70 95       	com	r23
    2bd0:	61 95       	neg	r22
    2bd2:	7f 4f       	sbci	r23, 0xFF	; 255
    2bd4:	8f 4f       	sbci	r24, 0xFF	; 255
    2bd6:	9f 4f       	sbci	r25, 0xFF	; 255
    2bd8:	99 23       	and	r25, r25
    2bda:	a9 f0       	breq	.+42     	; 0x2c06 <__floatsisf+0x40>
    2bdc:	f9 2f       	mov	r31, r25
    2bde:	96 e9       	ldi	r25, 0x96	; 150
    2be0:	bb 27       	eor	r27, r27
    2be2:	93 95       	inc	r25
    2be4:	f6 95       	lsr	r31
    2be6:	87 95       	ror	r24
    2be8:	77 95       	ror	r23
    2bea:	67 95       	ror	r22
    2bec:	b7 95       	ror	r27
    2bee:	f1 11       	cpse	r31, r1
    2bf0:	f8 cf       	rjmp	.-16     	; 0x2be2 <__floatsisf+0x1c>
    2bf2:	fa f4       	brpl	.+62     	; 0x2c32 <__floatsisf+0x6c>
    2bf4:	bb 0f       	add	r27, r27
    2bf6:	11 f4       	brne	.+4      	; 0x2bfc <__floatsisf+0x36>
    2bf8:	60 ff       	sbrs	r22, 0
    2bfa:	1b c0       	rjmp	.+54     	; 0x2c32 <__floatsisf+0x6c>
    2bfc:	6f 5f       	subi	r22, 0xFF	; 255
    2bfe:	7f 4f       	sbci	r23, 0xFF	; 255
    2c00:	8f 4f       	sbci	r24, 0xFF	; 255
    2c02:	9f 4f       	sbci	r25, 0xFF	; 255
    2c04:	16 c0       	rjmp	.+44     	; 0x2c32 <__floatsisf+0x6c>
    2c06:	88 23       	and	r24, r24
    2c08:	11 f0       	breq	.+4      	; 0x2c0e <__floatsisf+0x48>
    2c0a:	96 e9       	ldi	r25, 0x96	; 150
    2c0c:	11 c0       	rjmp	.+34     	; 0x2c30 <__floatsisf+0x6a>
    2c0e:	77 23       	and	r23, r23
    2c10:	21 f0       	breq	.+8      	; 0x2c1a <__floatsisf+0x54>
    2c12:	9e e8       	ldi	r25, 0x8E	; 142
    2c14:	87 2f       	mov	r24, r23
    2c16:	76 2f       	mov	r23, r22
    2c18:	05 c0       	rjmp	.+10     	; 0x2c24 <__floatsisf+0x5e>
    2c1a:	66 23       	and	r22, r22
    2c1c:	71 f0       	breq	.+28     	; 0x2c3a <__floatsisf+0x74>
    2c1e:	96 e8       	ldi	r25, 0x86	; 134
    2c20:	86 2f       	mov	r24, r22
    2c22:	70 e0       	ldi	r23, 0x00	; 0
    2c24:	60 e0       	ldi	r22, 0x00	; 0
    2c26:	2a f0       	brmi	.+10     	; 0x2c32 <__floatsisf+0x6c>
    2c28:	9a 95       	dec	r25
    2c2a:	66 0f       	add	r22, r22
    2c2c:	77 1f       	adc	r23, r23
    2c2e:	88 1f       	adc	r24, r24
    2c30:	da f7       	brpl	.-10     	; 0x2c28 <__floatsisf+0x62>
    2c32:	88 0f       	add	r24, r24
    2c34:	96 95       	lsr	r25
    2c36:	87 95       	ror	r24
    2c38:	97 f9       	bld	r25, 7
    2c3a:	08 95       	ret

00002c3c <__fp_inf>:
    2c3c:	97 f9       	bld	r25, 7
    2c3e:	9f 67       	ori	r25, 0x7F	; 127
    2c40:	80 e8       	ldi	r24, 0x80	; 128
    2c42:	70 e0       	ldi	r23, 0x00	; 0
    2c44:	60 e0       	ldi	r22, 0x00	; 0
    2c46:	08 95       	ret

00002c48 <__fp_nan>:
    2c48:	9f ef       	ldi	r25, 0xFF	; 255
    2c4a:	80 ec       	ldi	r24, 0xC0	; 192
    2c4c:	08 95       	ret

00002c4e <__fp_pscA>:
    2c4e:	00 24       	eor	r0, r0
    2c50:	0a 94       	dec	r0
    2c52:	16 16       	cp	r1, r22
    2c54:	17 06       	cpc	r1, r23
    2c56:	18 06       	cpc	r1, r24
    2c58:	09 06       	cpc	r0, r25
    2c5a:	08 95       	ret

00002c5c <__fp_pscB>:
    2c5c:	00 24       	eor	r0, r0
    2c5e:	0a 94       	dec	r0
    2c60:	12 16       	cp	r1, r18
    2c62:	13 06       	cpc	r1, r19
    2c64:	14 06       	cpc	r1, r20
    2c66:	05 06       	cpc	r0, r21
    2c68:	08 95       	ret

00002c6a <__fp_round>:
    2c6a:	09 2e       	mov	r0, r25
    2c6c:	03 94       	inc	r0
    2c6e:	00 0c       	add	r0, r0
    2c70:	11 f4       	brne	.+4      	; 0x2c76 <__fp_round+0xc>
    2c72:	88 23       	and	r24, r24
    2c74:	52 f0       	brmi	.+20     	; 0x2c8a <__fp_round+0x20>
    2c76:	bb 0f       	add	r27, r27
    2c78:	40 f4       	brcc	.+16     	; 0x2c8a <__fp_round+0x20>
    2c7a:	bf 2b       	or	r27, r31
    2c7c:	11 f4       	brne	.+4      	; 0x2c82 <__fp_round+0x18>
    2c7e:	60 ff       	sbrs	r22, 0
    2c80:	04 c0       	rjmp	.+8      	; 0x2c8a <__fp_round+0x20>
    2c82:	6f 5f       	subi	r22, 0xFF	; 255
    2c84:	7f 4f       	sbci	r23, 0xFF	; 255
    2c86:	8f 4f       	sbci	r24, 0xFF	; 255
    2c88:	9f 4f       	sbci	r25, 0xFF	; 255
    2c8a:	08 95       	ret

00002c8c <__fp_split3>:
    2c8c:	57 fd       	sbrc	r21, 7
    2c8e:	90 58       	subi	r25, 0x80	; 128
    2c90:	44 0f       	add	r20, r20
    2c92:	55 1f       	adc	r21, r21
    2c94:	59 f0       	breq	.+22     	; 0x2cac <__fp_splitA+0x10>
    2c96:	5f 3f       	cpi	r21, 0xFF	; 255
    2c98:	71 f0       	breq	.+28     	; 0x2cb6 <__fp_splitA+0x1a>
    2c9a:	47 95       	ror	r20

00002c9c <__fp_splitA>:
    2c9c:	88 0f       	add	r24, r24
    2c9e:	97 fb       	bst	r25, 7
    2ca0:	99 1f       	adc	r25, r25
    2ca2:	61 f0       	breq	.+24     	; 0x2cbc <__fp_splitA+0x20>
    2ca4:	9f 3f       	cpi	r25, 0xFF	; 255
    2ca6:	79 f0       	breq	.+30     	; 0x2cc6 <__fp_splitA+0x2a>
    2ca8:	87 95       	ror	r24
    2caa:	08 95       	ret
    2cac:	12 16       	cp	r1, r18
    2cae:	13 06       	cpc	r1, r19
    2cb0:	14 06       	cpc	r1, r20
    2cb2:	55 1f       	adc	r21, r21
    2cb4:	f2 cf       	rjmp	.-28     	; 0x2c9a <__fp_split3+0xe>
    2cb6:	46 95       	lsr	r20
    2cb8:	f1 df       	rcall	.-30     	; 0x2c9c <__fp_splitA>
    2cba:	08 c0       	rjmp	.+16     	; 0x2ccc <__fp_splitA+0x30>
    2cbc:	16 16       	cp	r1, r22
    2cbe:	17 06       	cpc	r1, r23
    2cc0:	18 06       	cpc	r1, r24
    2cc2:	99 1f       	adc	r25, r25
    2cc4:	f1 cf       	rjmp	.-30     	; 0x2ca8 <__fp_splitA+0xc>
    2cc6:	86 95       	lsr	r24
    2cc8:	71 05       	cpc	r23, r1
    2cca:	61 05       	cpc	r22, r1
    2ccc:	08 94       	sec
    2cce:	08 95       	ret

00002cd0 <__fp_zero>:
    2cd0:	e8 94       	clt

00002cd2 <__fp_szero>:
    2cd2:	bb 27       	eor	r27, r27
    2cd4:	66 27       	eor	r22, r22
    2cd6:	77 27       	eor	r23, r23
    2cd8:	cb 01       	movw	r24, r22
    2cda:	97 f9       	bld	r25, 7
    2cdc:	08 95       	ret

00002cde <__mulsf3>:
    2cde:	0e 94 82 16 	call	0x2d04	; 0x2d04 <__mulsf3x>
    2ce2:	0c 94 35 16 	jmp	0x2c6a	; 0x2c6a <__fp_round>
    2ce6:	0e 94 27 16 	call	0x2c4e	; 0x2c4e <__fp_pscA>
    2cea:	38 f0       	brcs	.+14     	; 0x2cfa <__mulsf3+0x1c>
    2cec:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <__fp_pscB>
    2cf0:	20 f0       	brcs	.+8      	; 0x2cfa <__mulsf3+0x1c>
    2cf2:	95 23       	and	r25, r21
    2cf4:	11 f0       	breq	.+4      	; 0x2cfa <__mulsf3+0x1c>
    2cf6:	0c 94 1e 16 	jmp	0x2c3c	; 0x2c3c <__fp_inf>
    2cfa:	0c 94 24 16 	jmp	0x2c48	; 0x2c48 <__fp_nan>
    2cfe:	11 24       	eor	r1, r1
    2d00:	0c 94 69 16 	jmp	0x2cd2	; 0x2cd2 <__fp_szero>

00002d04 <__mulsf3x>:
    2d04:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <__fp_split3>
    2d08:	70 f3       	brcs	.-36     	; 0x2ce6 <__mulsf3+0x8>

00002d0a <__mulsf3_pse>:
    2d0a:	95 9f       	mul	r25, r21
    2d0c:	c1 f3       	breq	.-16     	; 0x2cfe <__mulsf3+0x20>
    2d0e:	95 0f       	add	r25, r21
    2d10:	50 e0       	ldi	r21, 0x00	; 0
    2d12:	55 1f       	adc	r21, r21
    2d14:	62 9f       	mul	r22, r18
    2d16:	f0 01       	movw	r30, r0
    2d18:	72 9f       	mul	r23, r18
    2d1a:	bb 27       	eor	r27, r27
    2d1c:	f0 0d       	add	r31, r0
    2d1e:	b1 1d       	adc	r27, r1
    2d20:	63 9f       	mul	r22, r19
    2d22:	aa 27       	eor	r26, r26
    2d24:	f0 0d       	add	r31, r0
    2d26:	b1 1d       	adc	r27, r1
    2d28:	aa 1f       	adc	r26, r26
    2d2a:	64 9f       	mul	r22, r20
    2d2c:	66 27       	eor	r22, r22
    2d2e:	b0 0d       	add	r27, r0
    2d30:	a1 1d       	adc	r26, r1
    2d32:	66 1f       	adc	r22, r22
    2d34:	82 9f       	mul	r24, r18
    2d36:	22 27       	eor	r18, r18
    2d38:	b0 0d       	add	r27, r0
    2d3a:	a1 1d       	adc	r26, r1
    2d3c:	62 1f       	adc	r22, r18
    2d3e:	73 9f       	mul	r23, r19
    2d40:	b0 0d       	add	r27, r0
    2d42:	a1 1d       	adc	r26, r1
    2d44:	62 1f       	adc	r22, r18
    2d46:	83 9f       	mul	r24, r19
    2d48:	a0 0d       	add	r26, r0
    2d4a:	61 1d       	adc	r22, r1
    2d4c:	22 1f       	adc	r18, r18
    2d4e:	74 9f       	mul	r23, r20
    2d50:	33 27       	eor	r19, r19
    2d52:	a0 0d       	add	r26, r0
    2d54:	61 1d       	adc	r22, r1
    2d56:	23 1f       	adc	r18, r19
    2d58:	84 9f       	mul	r24, r20
    2d5a:	60 0d       	add	r22, r0
    2d5c:	21 1d       	adc	r18, r1
    2d5e:	82 2f       	mov	r24, r18
    2d60:	76 2f       	mov	r23, r22
    2d62:	6a 2f       	mov	r22, r26
    2d64:	11 24       	eor	r1, r1
    2d66:	9f 57       	subi	r25, 0x7F	; 127
    2d68:	50 40       	sbci	r21, 0x00	; 0
    2d6a:	9a f0       	brmi	.+38     	; 0x2d92 <__mulsf3_pse+0x88>
    2d6c:	f1 f0       	breq	.+60     	; 0x2daa <__mulsf3_pse+0xa0>
    2d6e:	88 23       	and	r24, r24
    2d70:	4a f0       	brmi	.+18     	; 0x2d84 <__mulsf3_pse+0x7a>
    2d72:	ee 0f       	add	r30, r30
    2d74:	ff 1f       	adc	r31, r31
    2d76:	bb 1f       	adc	r27, r27
    2d78:	66 1f       	adc	r22, r22
    2d7a:	77 1f       	adc	r23, r23
    2d7c:	88 1f       	adc	r24, r24
    2d7e:	91 50       	subi	r25, 0x01	; 1
    2d80:	50 40       	sbci	r21, 0x00	; 0
    2d82:	a9 f7       	brne	.-22     	; 0x2d6e <__mulsf3_pse+0x64>
    2d84:	9e 3f       	cpi	r25, 0xFE	; 254
    2d86:	51 05       	cpc	r21, r1
    2d88:	80 f0       	brcs	.+32     	; 0x2daa <__mulsf3_pse+0xa0>
    2d8a:	0c 94 1e 16 	jmp	0x2c3c	; 0x2c3c <__fp_inf>
    2d8e:	0c 94 69 16 	jmp	0x2cd2	; 0x2cd2 <__fp_szero>
    2d92:	5f 3f       	cpi	r21, 0xFF	; 255
    2d94:	e4 f3       	brlt	.-8      	; 0x2d8e <__mulsf3_pse+0x84>
    2d96:	98 3e       	cpi	r25, 0xE8	; 232
    2d98:	d4 f3       	brlt	.-12     	; 0x2d8e <__mulsf3_pse+0x84>
    2d9a:	86 95       	lsr	r24
    2d9c:	77 95       	ror	r23
    2d9e:	67 95       	ror	r22
    2da0:	b7 95       	ror	r27
    2da2:	f7 95       	ror	r31
    2da4:	e7 95       	ror	r30
    2da6:	9f 5f       	subi	r25, 0xFF	; 255
    2da8:	c1 f7       	brne	.-16     	; 0x2d9a <__mulsf3_pse+0x90>
    2daa:	fe 2b       	or	r31, r30
    2dac:	88 0f       	add	r24, r24
    2dae:	91 1d       	adc	r25, r1
    2db0:	96 95       	lsr	r25
    2db2:	87 95       	ror	r24
    2db4:	97 f9       	bld	r25, 7
    2db6:	08 95       	ret

00002db8 <__tablejump2__>:
    2db8:	ee 0f       	add	r30, r30
    2dba:	ff 1f       	adc	r31, r31
    2dbc:	05 90       	lpm	r0, Z+
    2dbe:	f4 91       	lpm	r31, Z
    2dc0:	e0 2d       	mov	r30, r0
    2dc2:	09 94       	ijmp

00002dc4 <strcmp>:
    2dc4:	fb 01       	movw	r30, r22
    2dc6:	dc 01       	movw	r26, r24
    2dc8:	8d 91       	ld	r24, X+
    2dca:	01 90       	ld	r0, Z+
    2dcc:	80 19       	sub	r24, r0
    2dce:	01 10       	cpse	r0, r1
    2dd0:	d9 f3       	breq	.-10     	; 0x2dc8 <strcmp+0x4>
    2dd2:	99 0b       	sbc	r25, r25
    2dd4:	08 95       	ret

00002dd6 <strcpy>:
    2dd6:	fb 01       	movw	r30, r22
    2dd8:	dc 01       	movw	r26, r24
    2dda:	01 90       	ld	r0, Z+
    2ddc:	0d 92       	st	X+, r0
    2dde:	00 20       	and	r0, r0
    2de0:	e1 f7       	brne	.-8      	; 0x2dda <strcpy+0x4>
    2de2:	08 95       	ret

00002de4 <sprintf>:
    2de4:	ae e0       	ldi	r26, 0x0E	; 14
    2de6:	b0 e0       	ldi	r27, 0x00	; 0
    2de8:	e8 ef       	ldi	r30, 0xF8	; 248
    2dea:	f6 e1       	ldi	r31, 0x16	; 22
    2dec:	0c 94 b3 19 	jmp	0x3366	; 0x3366 <__prologue_saves__+0x1c>
    2df0:	0d 89       	ldd	r16, Y+21	; 0x15
    2df2:	1e 89       	ldd	r17, Y+22	; 0x16
    2df4:	86 e0       	ldi	r24, 0x06	; 6
    2df6:	8c 83       	std	Y+4, r24	; 0x04
    2df8:	1a 83       	std	Y+2, r17	; 0x02
    2dfa:	09 83       	std	Y+1, r16	; 0x01
    2dfc:	8f ef       	ldi	r24, 0xFF	; 255
    2dfe:	9f e7       	ldi	r25, 0x7F	; 127
    2e00:	9e 83       	std	Y+6, r25	; 0x06
    2e02:	8d 83       	std	Y+5, r24	; 0x05
    2e04:	ae 01       	movw	r20, r28
    2e06:	47 5e       	subi	r20, 0xE7	; 231
    2e08:	5f 4f       	sbci	r21, 0xFF	; 255
    2e0a:	6f 89       	ldd	r22, Y+23	; 0x17
    2e0c:	78 8d       	ldd	r23, Y+24	; 0x18
    2e0e:	ce 01       	movw	r24, r28
    2e10:	01 96       	adiw	r24, 0x01	; 1
    2e12:	0e 94 14 17 	call	0x2e28	; 0x2e28 <vfprintf>
    2e16:	ef 81       	ldd	r30, Y+7	; 0x07
    2e18:	f8 85       	ldd	r31, Y+8	; 0x08
    2e1a:	e0 0f       	add	r30, r16
    2e1c:	f1 1f       	adc	r31, r17
    2e1e:	10 82       	st	Z, r1
    2e20:	2e 96       	adiw	r28, 0x0e	; 14
    2e22:	e4 e0       	ldi	r30, 0x04	; 4
    2e24:	0c 94 cf 19 	jmp	0x339e	; 0x339e <__epilogue_restores__+0x1c>

00002e28 <vfprintf>:
    2e28:	ab e0       	ldi	r26, 0x0B	; 11
    2e2a:	b0 e0       	ldi	r27, 0x00	; 0
    2e2c:	ea e1       	ldi	r30, 0x1A	; 26
    2e2e:	f7 e1       	ldi	r31, 0x17	; 23
    2e30:	0c 94 a5 19 	jmp	0x334a	; 0x334a <__prologue_saves__>
    2e34:	6c 01       	movw	r12, r24
    2e36:	7b 01       	movw	r14, r22
    2e38:	8a 01       	movw	r16, r20
    2e3a:	fc 01       	movw	r30, r24
    2e3c:	17 82       	std	Z+7, r1	; 0x07
    2e3e:	16 82       	std	Z+6, r1	; 0x06
    2e40:	83 81       	ldd	r24, Z+3	; 0x03
    2e42:	81 ff       	sbrs	r24, 1
    2e44:	cc c1       	rjmp	.+920    	; 0x31de <vfprintf+0x3b6>
    2e46:	ce 01       	movw	r24, r28
    2e48:	01 96       	adiw	r24, 0x01	; 1
    2e4a:	3c 01       	movw	r6, r24
    2e4c:	f6 01       	movw	r30, r12
    2e4e:	93 81       	ldd	r25, Z+3	; 0x03
    2e50:	f7 01       	movw	r30, r14
    2e52:	93 fd       	sbrc	r25, 3
    2e54:	85 91       	lpm	r24, Z+
    2e56:	93 ff       	sbrs	r25, 3
    2e58:	81 91       	ld	r24, Z+
    2e5a:	7f 01       	movw	r14, r30
    2e5c:	88 23       	and	r24, r24
    2e5e:	09 f4       	brne	.+2      	; 0x2e62 <vfprintf+0x3a>
    2e60:	ba c1       	rjmp	.+884    	; 0x31d6 <vfprintf+0x3ae>
    2e62:	85 32       	cpi	r24, 0x25	; 37
    2e64:	39 f4       	brne	.+14     	; 0x2e74 <vfprintf+0x4c>
    2e66:	93 fd       	sbrc	r25, 3
    2e68:	85 91       	lpm	r24, Z+
    2e6a:	93 ff       	sbrs	r25, 3
    2e6c:	81 91       	ld	r24, Z+
    2e6e:	7f 01       	movw	r14, r30
    2e70:	85 32       	cpi	r24, 0x25	; 37
    2e72:	29 f4       	brne	.+10     	; 0x2e7e <vfprintf+0x56>
    2e74:	b6 01       	movw	r22, r12
    2e76:	90 e0       	ldi	r25, 0x00	; 0
    2e78:	0e 94 0b 19 	call	0x3216	; 0x3216 <fputc>
    2e7c:	e7 cf       	rjmp	.-50     	; 0x2e4c <vfprintf+0x24>
    2e7e:	91 2c       	mov	r9, r1
    2e80:	21 2c       	mov	r2, r1
    2e82:	31 2c       	mov	r3, r1
    2e84:	ff e1       	ldi	r31, 0x1F	; 31
    2e86:	f3 15       	cp	r31, r3
    2e88:	d8 f0       	brcs	.+54     	; 0x2ec0 <vfprintf+0x98>
    2e8a:	8b 32       	cpi	r24, 0x2B	; 43
    2e8c:	79 f0       	breq	.+30     	; 0x2eac <vfprintf+0x84>
    2e8e:	38 f4       	brcc	.+14     	; 0x2e9e <vfprintf+0x76>
    2e90:	80 32       	cpi	r24, 0x20	; 32
    2e92:	79 f0       	breq	.+30     	; 0x2eb2 <vfprintf+0x8a>
    2e94:	83 32       	cpi	r24, 0x23	; 35
    2e96:	a1 f4       	brne	.+40     	; 0x2ec0 <vfprintf+0x98>
    2e98:	23 2d       	mov	r18, r3
    2e9a:	20 61       	ori	r18, 0x10	; 16
    2e9c:	1d c0       	rjmp	.+58     	; 0x2ed8 <vfprintf+0xb0>
    2e9e:	8d 32       	cpi	r24, 0x2D	; 45
    2ea0:	61 f0       	breq	.+24     	; 0x2eba <vfprintf+0x92>
    2ea2:	80 33       	cpi	r24, 0x30	; 48
    2ea4:	69 f4       	brne	.+26     	; 0x2ec0 <vfprintf+0x98>
    2ea6:	23 2d       	mov	r18, r3
    2ea8:	21 60       	ori	r18, 0x01	; 1
    2eaa:	16 c0       	rjmp	.+44     	; 0x2ed8 <vfprintf+0xb0>
    2eac:	83 2d       	mov	r24, r3
    2eae:	82 60       	ori	r24, 0x02	; 2
    2eb0:	38 2e       	mov	r3, r24
    2eb2:	e3 2d       	mov	r30, r3
    2eb4:	e4 60       	ori	r30, 0x04	; 4
    2eb6:	3e 2e       	mov	r3, r30
    2eb8:	2a c0       	rjmp	.+84     	; 0x2f0e <vfprintf+0xe6>
    2eba:	f3 2d       	mov	r31, r3
    2ebc:	f8 60       	ori	r31, 0x08	; 8
    2ebe:	1d c0       	rjmp	.+58     	; 0x2efa <vfprintf+0xd2>
    2ec0:	37 fc       	sbrc	r3, 7
    2ec2:	2d c0       	rjmp	.+90     	; 0x2f1e <vfprintf+0xf6>
    2ec4:	20 ed       	ldi	r18, 0xD0	; 208
    2ec6:	28 0f       	add	r18, r24
    2ec8:	2a 30       	cpi	r18, 0x0A	; 10
    2eca:	40 f0       	brcs	.+16     	; 0x2edc <vfprintf+0xb4>
    2ecc:	8e 32       	cpi	r24, 0x2E	; 46
    2ece:	b9 f4       	brne	.+46     	; 0x2efe <vfprintf+0xd6>
    2ed0:	36 fc       	sbrc	r3, 6
    2ed2:	81 c1       	rjmp	.+770    	; 0x31d6 <vfprintf+0x3ae>
    2ed4:	23 2d       	mov	r18, r3
    2ed6:	20 64       	ori	r18, 0x40	; 64
    2ed8:	32 2e       	mov	r3, r18
    2eda:	19 c0       	rjmp	.+50     	; 0x2f0e <vfprintf+0xe6>
    2edc:	36 fe       	sbrs	r3, 6
    2ede:	06 c0       	rjmp	.+12     	; 0x2eec <vfprintf+0xc4>
    2ee0:	8a e0       	ldi	r24, 0x0A	; 10
    2ee2:	98 9e       	mul	r9, r24
    2ee4:	20 0d       	add	r18, r0
    2ee6:	11 24       	eor	r1, r1
    2ee8:	92 2e       	mov	r9, r18
    2eea:	11 c0       	rjmp	.+34     	; 0x2f0e <vfprintf+0xe6>
    2eec:	ea e0       	ldi	r30, 0x0A	; 10
    2eee:	2e 9e       	mul	r2, r30
    2ef0:	20 0d       	add	r18, r0
    2ef2:	11 24       	eor	r1, r1
    2ef4:	22 2e       	mov	r2, r18
    2ef6:	f3 2d       	mov	r31, r3
    2ef8:	f0 62       	ori	r31, 0x20	; 32
    2efa:	3f 2e       	mov	r3, r31
    2efc:	08 c0       	rjmp	.+16     	; 0x2f0e <vfprintf+0xe6>
    2efe:	8c 36       	cpi	r24, 0x6C	; 108
    2f00:	21 f4       	brne	.+8      	; 0x2f0a <vfprintf+0xe2>
    2f02:	83 2d       	mov	r24, r3
    2f04:	80 68       	ori	r24, 0x80	; 128
    2f06:	38 2e       	mov	r3, r24
    2f08:	02 c0       	rjmp	.+4      	; 0x2f0e <vfprintf+0xe6>
    2f0a:	88 36       	cpi	r24, 0x68	; 104
    2f0c:	41 f4       	brne	.+16     	; 0x2f1e <vfprintf+0xf6>
    2f0e:	f7 01       	movw	r30, r14
    2f10:	93 fd       	sbrc	r25, 3
    2f12:	85 91       	lpm	r24, Z+
    2f14:	93 ff       	sbrs	r25, 3
    2f16:	81 91       	ld	r24, Z+
    2f18:	7f 01       	movw	r14, r30
    2f1a:	81 11       	cpse	r24, r1
    2f1c:	b3 cf       	rjmp	.-154    	; 0x2e84 <vfprintf+0x5c>
    2f1e:	98 2f       	mov	r25, r24
    2f20:	9f 7d       	andi	r25, 0xDF	; 223
    2f22:	95 54       	subi	r25, 0x45	; 69
    2f24:	93 30       	cpi	r25, 0x03	; 3
    2f26:	28 f4       	brcc	.+10     	; 0x2f32 <vfprintf+0x10a>
    2f28:	0c 5f       	subi	r16, 0xFC	; 252
    2f2a:	1f 4f       	sbci	r17, 0xFF	; 255
    2f2c:	9f e3       	ldi	r25, 0x3F	; 63
    2f2e:	99 83       	std	Y+1, r25	; 0x01
    2f30:	0d c0       	rjmp	.+26     	; 0x2f4c <vfprintf+0x124>
    2f32:	83 36       	cpi	r24, 0x63	; 99
    2f34:	31 f0       	breq	.+12     	; 0x2f42 <vfprintf+0x11a>
    2f36:	83 37       	cpi	r24, 0x73	; 115
    2f38:	71 f0       	breq	.+28     	; 0x2f56 <vfprintf+0x12e>
    2f3a:	83 35       	cpi	r24, 0x53	; 83
    2f3c:	09 f0       	breq	.+2      	; 0x2f40 <vfprintf+0x118>
    2f3e:	59 c0       	rjmp	.+178    	; 0x2ff2 <vfprintf+0x1ca>
    2f40:	21 c0       	rjmp	.+66     	; 0x2f84 <vfprintf+0x15c>
    2f42:	f8 01       	movw	r30, r16
    2f44:	80 81       	ld	r24, Z
    2f46:	89 83       	std	Y+1, r24	; 0x01
    2f48:	0e 5f       	subi	r16, 0xFE	; 254
    2f4a:	1f 4f       	sbci	r17, 0xFF	; 255
    2f4c:	88 24       	eor	r8, r8
    2f4e:	83 94       	inc	r8
    2f50:	91 2c       	mov	r9, r1
    2f52:	53 01       	movw	r10, r6
    2f54:	13 c0       	rjmp	.+38     	; 0x2f7c <vfprintf+0x154>
    2f56:	28 01       	movw	r4, r16
    2f58:	f2 e0       	ldi	r31, 0x02	; 2
    2f5a:	4f 0e       	add	r4, r31
    2f5c:	51 1c       	adc	r5, r1
    2f5e:	f8 01       	movw	r30, r16
    2f60:	a0 80       	ld	r10, Z
    2f62:	b1 80       	ldd	r11, Z+1	; 0x01
    2f64:	36 fe       	sbrs	r3, 6
    2f66:	03 c0       	rjmp	.+6      	; 0x2f6e <vfprintf+0x146>
    2f68:	69 2d       	mov	r22, r9
    2f6a:	70 e0       	ldi	r23, 0x00	; 0
    2f6c:	02 c0       	rjmp	.+4      	; 0x2f72 <vfprintf+0x14a>
    2f6e:	6f ef       	ldi	r22, 0xFF	; 255
    2f70:	7f ef       	ldi	r23, 0xFF	; 255
    2f72:	c5 01       	movw	r24, r10
    2f74:	0e 94 00 19 	call	0x3200	; 0x3200 <strnlen>
    2f78:	4c 01       	movw	r8, r24
    2f7a:	82 01       	movw	r16, r4
    2f7c:	f3 2d       	mov	r31, r3
    2f7e:	ff 77       	andi	r31, 0x7F	; 127
    2f80:	3f 2e       	mov	r3, r31
    2f82:	16 c0       	rjmp	.+44     	; 0x2fb0 <vfprintf+0x188>
    2f84:	28 01       	movw	r4, r16
    2f86:	22 e0       	ldi	r18, 0x02	; 2
    2f88:	42 0e       	add	r4, r18
    2f8a:	51 1c       	adc	r5, r1
    2f8c:	f8 01       	movw	r30, r16
    2f8e:	a0 80       	ld	r10, Z
    2f90:	b1 80       	ldd	r11, Z+1	; 0x01
    2f92:	36 fe       	sbrs	r3, 6
    2f94:	03 c0       	rjmp	.+6      	; 0x2f9c <vfprintf+0x174>
    2f96:	69 2d       	mov	r22, r9
    2f98:	70 e0       	ldi	r23, 0x00	; 0
    2f9a:	02 c0       	rjmp	.+4      	; 0x2fa0 <vfprintf+0x178>
    2f9c:	6f ef       	ldi	r22, 0xFF	; 255
    2f9e:	7f ef       	ldi	r23, 0xFF	; 255
    2fa0:	c5 01       	movw	r24, r10
    2fa2:	0e 94 f5 18 	call	0x31ea	; 0x31ea <strnlen_P>
    2fa6:	4c 01       	movw	r8, r24
    2fa8:	f3 2d       	mov	r31, r3
    2faa:	f0 68       	ori	r31, 0x80	; 128
    2fac:	3f 2e       	mov	r3, r31
    2fae:	82 01       	movw	r16, r4
    2fb0:	33 fc       	sbrc	r3, 3
    2fb2:	1b c0       	rjmp	.+54     	; 0x2fea <vfprintf+0x1c2>
    2fb4:	82 2d       	mov	r24, r2
    2fb6:	90 e0       	ldi	r25, 0x00	; 0
    2fb8:	88 16       	cp	r8, r24
    2fba:	99 06       	cpc	r9, r25
    2fbc:	b0 f4       	brcc	.+44     	; 0x2fea <vfprintf+0x1c2>
    2fbe:	b6 01       	movw	r22, r12
    2fc0:	80 e2       	ldi	r24, 0x20	; 32
    2fc2:	90 e0       	ldi	r25, 0x00	; 0
    2fc4:	0e 94 0b 19 	call	0x3216	; 0x3216 <fputc>
    2fc8:	2a 94       	dec	r2
    2fca:	f4 cf       	rjmp	.-24     	; 0x2fb4 <vfprintf+0x18c>
    2fcc:	f5 01       	movw	r30, r10
    2fce:	37 fc       	sbrc	r3, 7
    2fd0:	85 91       	lpm	r24, Z+
    2fd2:	37 fe       	sbrs	r3, 7
    2fd4:	81 91       	ld	r24, Z+
    2fd6:	5f 01       	movw	r10, r30
    2fd8:	b6 01       	movw	r22, r12
    2fda:	90 e0       	ldi	r25, 0x00	; 0
    2fdc:	0e 94 0b 19 	call	0x3216	; 0x3216 <fputc>
    2fe0:	21 10       	cpse	r2, r1
    2fe2:	2a 94       	dec	r2
    2fe4:	21 e0       	ldi	r18, 0x01	; 1
    2fe6:	82 1a       	sub	r8, r18
    2fe8:	91 08       	sbc	r9, r1
    2fea:	81 14       	cp	r8, r1
    2fec:	91 04       	cpc	r9, r1
    2fee:	71 f7       	brne	.-36     	; 0x2fcc <vfprintf+0x1a4>
    2ff0:	e8 c0       	rjmp	.+464    	; 0x31c2 <vfprintf+0x39a>
    2ff2:	84 36       	cpi	r24, 0x64	; 100
    2ff4:	11 f0       	breq	.+4      	; 0x2ffa <vfprintf+0x1d2>
    2ff6:	89 36       	cpi	r24, 0x69	; 105
    2ff8:	41 f5       	brne	.+80     	; 0x304a <vfprintf+0x222>
    2ffa:	f8 01       	movw	r30, r16
    2ffc:	37 fe       	sbrs	r3, 7
    2ffe:	07 c0       	rjmp	.+14     	; 0x300e <vfprintf+0x1e6>
    3000:	60 81       	ld	r22, Z
    3002:	71 81       	ldd	r23, Z+1	; 0x01
    3004:	82 81       	ldd	r24, Z+2	; 0x02
    3006:	93 81       	ldd	r25, Z+3	; 0x03
    3008:	0c 5f       	subi	r16, 0xFC	; 252
    300a:	1f 4f       	sbci	r17, 0xFF	; 255
    300c:	08 c0       	rjmp	.+16     	; 0x301e <vfprintf+0x1f6>
    300e:	60 81       	ld	r22, Z
    3010:	71 81       	ldd	r23, Z+1	; 0x01
    3012:	07 2e       	mov	r0, r23
    3014:	00 0c       	add	r0, r0
    3016:	88 0b       	sbc	r24, r24
    3018:	99 0b       	sbc	r25, r25
    301a:	0e 5f       	subi	r16, 0xFE	; 254
    301c:	1f 4f       	sbci	r17, 0xFF	; 255
    301e:	f3 2d       	mov	r31, r3
    3020:	ff 76       	andi	r31, 0x6F	; 111
    3022:	3f 2e       	mov	r3, r31
    3024:	97 ff       	sbrs	r25, 7
    3026:	09 c0       	rjmp	.+18     	; 0x303a <vfprintf+0x212>
    3028:	90 95       	com	r25
    302a:	80 95       	com	r24
    302c:	70 95       	com	r23
    302e:	61 95       	neg	r22
    3030:	7f 4f       	sbci	r23, 0xFF	; 255
    3032:	8f 4f       	sbci	r24, 0xFF	; 255
    3034:	9f 4f       	sbci	r25, 0xFF	; 255
    3036:	f0 68       	ori	r31, 0x80	; 128
    3038:	3f 2e       	mov	r3, r31
    303a:	2a e0       	ldi	r18, 0x0A	; 10
    303c:	30 e0       	ldi	r19, 0x00	; 0
    303e:	a3 01       	movw	r20, r6
    3040:	0e 94 47 19 	call	0x328e	; 0x328e <__ultoa_invert>
    3044:	88 2e       	mov	r8, r24
    3046:	86 18       	sub	r8, r6
    3048:	45 c0       	rjmp	.+138    	; 0x30d4 <vfprintf+0x2ac>
    304a:	85 37       	cpi	r24, 0x75	; 117
    304c:	31 f4       	brne	.+12     	; 0x305a <vfprintf+0x232>
    304e:	23 2d       	mov	r18, r3
    3050:	2f 7e       	andi	r18, 0xEF	; 239
    3052:	b2 2e       	mov	r11, r18
    3054:	2a e0       	ldi	r18, 0x0A	; 10
    3056:	30 e0       	ldi	r19, 0x00	; 0
    3058:	25 c0       	rjmp	.+74     	; 0x30a4 <vfprintf+0x27c>
    305a:	93 2d       	mov	r25, r3
    305c:	99 7f       	andi	r25, 0xF9	; 249
    305e:	b9 2e       	mov	r11, r25
    3060:	8f 36       	cpi	r24, 0x6F	; 111
    3062:	c1 f0       	breq	.+48     	; 0x3094 <vfprintf+0x26c>
    3064:	18 f4       	brcc	.+6      	; 0x306c <vfprintf+0x244>
    3066:	88 35       	cpi	r24, 0x58	; 88
    3068:	79 f0       	breq	.+30     	; 0x3088 <vfprintf+0x260>
    306a:	b5 c0       	rjmp	.+362    	; 0x31d6 <vfprintf+0x3ae>
    306c:	80 37       	cpi	r24, 0x70	; 112
    306e:	19 f0       	breq	.+6      	; 0x3076 <vfprintf+0x24e>
    3070:	88 37       	cpi	r24, 0x78	; 120
    3072:	21 f0       	breq	.+8      	; 0x307c <vfprintf+0x254>
    3074:	b0 c0       	rjmp	.+352    	; 0x31d6 <vfprintf+0x3ae>
    3076:	e9 2f       	mov	r30, r25
    3078:	e0 61       	ori	r30, 0x10	; 16
    307a:	be 2e       	mov	r11, r30
    307c:	b4 fe       	sbrs	r11, 4
    307e:	0d c0       	rjmp	.+26     	; 0x309a <vfprintf+0x272>
    3080:	fb 2d       	mov	r31, r11
    3082:	f4 60       	ori	r31, 0x04	; 4
    3084:	bf 2e       	mov	r11, r31
    3086:	09 c0       	rjmp	.+18     	; 0x309a <vfprintf+0x272>
    3088:	34 fe       	sbrs	r3, 4
    308a:	0a c0       	rjmp	.+20     	; 0x30a0 <vfprintf+0x278>
    308c:	29 2f       	mov	r18, r25
    308e:	26 60       	ori	r18, 0x06	; 6
    3090:	b2 2e       	mov	r11, r18
    3092:	06 c0       	rjmp	.+12     	; 0x30a0 <vfprintf+0x278>
    3094:	28 e0       	ldi	r18, 0x08	; 8
    3096:	30 e0       	ldi	r19, 0x00	; 0
    3098:	05 c0       	rjmp	.+10     	; 0x30a4 <vfprintf+0x27c>
    309a:	20 e1       	ldi	r18, 0x10	; 16
    309c:	30 e0       	ldi	r19, 0x00	; 0
    309e:	02 c0       	rjmp	.+4      	; 0x30a4 <vfprintf+0x27c>
    30a0:	20 e1       	ldi	r18, 0x10	; 16
    30a2:	32 e0       	ldi	r19, 0x02	; 2
    30a4:	f8 01       	movw	r30, r16
    30a6:	b7 fe       	sbrs	r11, 7
    30a8:	07 c0       	rjmp	.+14     	; 0x30b8 <vfprintf+0x290>
    30aa:	60 81       	ld	r22, Z
    30ac:	71 81       	ldd	r23, Z+1	; 0x01
    30ae:	82 81       	ldd	r24, Z+2	; 0x02
    30b0:	93 81       	ldd	r25, Z+3	; 0x03
    30b2:	0c 5f       	subi	r16, 0xFC	; 252
    30b4:	1f 4f       	sbci	r17, 0xFF	; 255
    30b6:	06 c0       	rjmp	.+12     	; 0x30c4 <vfprintf+0x29c>
    30b8:	60 81       	ld	r22, Z
    30ba:	71 81       	ldd	r23, Z+1	; 0x01
    30bc:	80 e0       	ldi	r24, 0x00	; 0
    30be:	90 e0       	ldi	r25, 0x00	; 0
    30c0:	0e 5f       	subi	r16, 0xFE	; 254
    30c2:	1f 4f       	sbci	r17, 0xFF	; 255
    30c4:	a3 01       	movw	r20, r6
    30c6:	0e 94 47 19 	call	0x328e	; 0x328e <__ultoa_invert>
    30ca:	88 2e       	mov	r8, r24
    30cc:	86 18       	sub	r8, r6
    30ce:	fb 2d       	mov	r31, r11
    30d0:	ff 77       	andi	r31, 0x7F	; 127
    30d2:	3f 2e       	mov	r3, r31
    30d4:	36 fe       	sbrs	r3, 6
    30d6:	0d c0       	rjmp	.+26     	; 0x30f2 <vfprintf+0x2ca>
    30d8:	23 2d       	mov	r18, r3
    30da:	2e 7f       	andi	r18, 0xFE	; 254
    30dc:	a2 2e       	mov	r10, r18
    30de:	89 14       	cp	r8, r9
    30e0:	58 f4       	brcc	.+22     	; 0x30f8 <vfprintf+0x2d0>
    30e2:	34 fe       	sbrs	r3, 4
    30e4:	0b c0       	rjmp	.+22     	; 0x30fc <vfprintf+0x2d4>
    30e6:	32 fc       	sbrc	r3, 2
    30e8:	09 c0       	rjmp	.+18     	; 0x30fc <vfprintf+0x2d4>
    30ea:	83 2d       	mov	r24, r3
    30ec:	8e 7e       	andi	r24, 0xEE	; 238
    30ee:	a8 2e       	mov	r10, r24
    30f0:	05 c0       	rjmp	.+10     	; 0x30fc <vfprintf+0x2d4>
    30f2:	b8 2c       	mov	r11, r8
    30f4:	a3 2c       	mov	r10, r3
    30f6:	03 c0       	rjmp	.+6      	; 0x30fe <vfprintf+0x2d6>
    30f8:	b8 2c       	mov	r11, r8
    30fa:	01 c0       	rjmp	.+2      	; 0x30fe <vfprintf+0x2d6>
    30fc:	b9 2c       	mov	r11, r9
    30fe:	a4 fe       	sbrs	r10, 4
    3100:	0f c0       	rjmp	.+30     	; 0x3120 <vfprintf+0x2f8>
    3102:	fe 01       	movw	r30, r28
    3104:	e8 0d       	add	r30, r8
    3106:	f1 1d       	adc	r31, r1
    3108:	80 81       	ld	r24, Z
    310a:	80 33       	cpi	r24, 0x30	; 48
    310c:	21 f4       	brne	.+8      	; 0x3116 <vfprintf+0x2ee>
    310e:	9a 2d       	mov	r25, r10
    3110:	99 7e       	andi	r25, 0xE9	; 233
    3112:	a9 2e       	mov	r10, r25
    3114:	09 c0       	rjmp	.+18     	; 0x3128 <vfprintf+0x300>
    3116:	a2 fe       	sbrs	r10, 2
    3118:	06 c0       	rjmp	.+12     	; 0x3126 <vfprintf+0x2fe>
    311a:	b3 94       	inc	r11
    311c:	b3 94       	inc	r11
    311e:	04 c0       	rjmp	.+8      	; 0x3128 <vfprintf+0x300>
    3120:	8a 2d       	mov	r24, r10
    3122:	86 78       	andi	r24, 0x86	; 134
    3124:	09 f0       	breq	.+2      	; 0x3128 <vfprintf+0x300>
    3126:	b3 94       	inc	r11
    3128:	a3 fc       	sbrc	r10, 3
    312a:	11 c0       	rjmp	.+34     	; 0x314e <vfprintf+0x326>
    312c:	a0 fe       	sbrs	r10, 0
    312e:	06 c0       	rjmp	.+12     	; 0x313c <vfprintf+0x314>
    3130:	b2 14       	cp	r11, r2
    3132:	88 f4       	brcc	.+34     	; 0x3156 <vfprintf+0x32e>
    3134:	28 0c       	add	r2, r8
    3136:	92 2c       	mov	r9, r2
    3138:	9b 18       	sub	r9, r11
    313a:	0e c0       	rjmp	.+28     	; 0x3158 <vfprintf+0x330>
    313c:	b2 14       	cp	r11, r2
    313e:	60 f4       	brcc	.+24     	; 0x3158 <vfprintf+0x330>
    3140:	b6 01       	movw	r22, r12
    3142:	80 e2       	ldi	r24, 0x20	; 32
    3144:	90 e0       	ldi	r25, 0x00	; 0
    3146:	0e 94 0b 19 	call	0x3216	; 0x3216 <fputc>
    314a:	b3 94       	inc	r11
    314c:	f7 cf       	rjmp	.-18     	; 0x313c <vfprintf+0x314>
    314e:	b2 14       	cp	r11, r2
    3150:	18 f4       	brcc	.+6      	; 0x3158 <vfprintf+0x330>
    3152:	2b 18       	sub	r2, r11
    3154:	02 c0       	rjmp	.+4      	; 0x315a <vfprintf+0x332>
    3156:	98 2c       	mov	r9, r8
    3158:	21 2c       	mov	r2, r1
    315a:	a4 fe       	sbrs	r10, 4
    315c:	10 c0       	rjmp	.+32     	; 0x317e <vfprintf+0x356>
    315e:	b6 01       	movw	r22, r12
    3160:	80 e3       	ldi	r24, 0x30	; 48
    3162:	90 e0       	ldi	r25, 0x00	; 0
    3164:	0e 94 0b 19 	call	0x3216	; 0x3216 <fputc>
    3168:	a2 fe       	sbrs	r10, 2
    316a:	17 c0       	rjmp	.+46     	; 0x319a <vfprintf+0x372>
    316c:	a1 fc       	sbrc	r10, 1
    316e:	03 c0       	rjmp	.+6      	; 0x3176 <vfprintf+0x34e>
    3170:	88 e7       	ldi	r24, 0x78	; 120
    3172:	90 e0       	ldi	r25, 0x00	; 0
    3174:	02 c0       	rjmp	.+4      	; 0x317a <vfprintf+0x352>
    3176:	88 e5       	ldi	r24, 0x58	; 88
    3178:	90 e0       	ldi	r25, 0x00	; 0
    317a:	b6 01       	movw	r22, r12
    317c:	0c c0       	rjmp	.+24     	; 0x3196 <vfprintf+0x36e>
    317e:	8a 2d       	mov	r24, r10
    3180:	86 78       	andi	r24, 0x86	; 134
    3182:	59 f0       	breq	.+22     	; 0x319a <vfprintf+0x372>
    3184:	a1 fe       	sbrs	r10, 1
    3186:	02 c0       	rjmp	.+4      	; 0x318c <vfprintf+0x364>
    3188:	8b e2       	ldi	r24, 0x2B	; 43
    318a:	01 c0       	rjmp	.+2      	; 0x318e <vfprintf+0x366>
    318c:	80 e2       	ldi	r24, 0x20	; 32
    318e:	a7 fc       	sbrc	r10, 7
    3190:	8d e2       	ldi	r24, 0x2D	; 45
    3192:	b6 01       	movw	r22, r12
    3194:	90 e0       	ldi	r25, 0x00	; 0
    3196:	0e 94 0b 19 	call	0x3216	; 0x3216 <fputc>
    319a:	89 14       	cp	r8, r9
    319c:	38 f4       	brcc	.+14     	; 0x31ac <vfprintf+0x384>
    319e:	b6 01       	movw	r22, r12
    31a0:	80 e3       	ldi	r24, 0x30	; 48
    31a2:	90 e0       	ldi	r25, 0x00	; 0
    31a4:	0e 94 0b 19 	call	0x3216	; 0x3216 <fputc>
    31a8:	9a 94       	dec	r9
    31aa:	f7 cf       	rjmp	.-18     	; 0x319a <vfprintf+0x372>
    31ac:	8a 94       	dec	r8
    31ae:	f3 01       	movw	r30, r6
    31b0:	e8 0d       	add	r30, r8
    31b2:	f1 1d       	adc	r31, r1
    31b4:	80 81       	ld	r24, Z
    31b6:	b6 01       	movw	r22, r12
    31b8:	90 e0       	ldi	r25, 0x00	; 0
    31ba:	0e 94 0b 19 	call	0x3216	; 0x3216 <fputc>
    31be:	81 10       	cpse	r8, r1
    31c0:	f5 cf       	rjmp	.-22     	; 0x31ac <vfprintf+0x384>
    31c2:	22 20       	and	r2, r2
    31c4:	09 f4       	brne	.+2      	; 0x31c8 <vfprintf+0x3a0>
    31c6:	42 ce       	rjmp	.-892    	; 0x2e4c <vfprintf+0x24>
    31c8:	b6 01       	movw	r22, r12
    31ca:	80 e2       	ldi	r24, 0x20	; 32
    31cc:	90 e0       	ldi	r25, 0x00	; 0
    31ce:	0e 94 0b 19 	call	0x3216	; 0x3216 <fputc>
    31d2:	2a 94       	dec	r2
    31d4:	f6 cf       	rjmp	.-20     	; 0x31c2 <vfprintf+0x39a>
    31d6:	f6 01       	movw	r30, r12
    31d8:	86 81       	ldd	r24, Z+6	; 0x06
    31da:	97 81       	ldd	r25, Z+7	; 0x07
    31dc:	02 c0       	rjmp	.+4      	; 0x31e2 <vfprintf+0x3ba>
    31de:	8f ef       	ldi	r24, 0xFF	; 255
    31e0:	9f ef       	ldi	r25, 0xFF	; 255
    31e2:	2b 96       	adiw	r28, 0x0b	; 11
    31e4:	e2 e1       	ldi	r30, 0x12	; 18
    31e6:	0c 94 c1 19 	jmp	0x3382	; 0x3382 <__epilogue_restores__>

000031ea <strnlen_P>:
    31ea:	fc 01       	movw	r30, r24
    31ec:	05 90       	lpm	r0, Z+
    31ee:	61 50       	subi	r22, 0x01	; 1
    31f0:	70 40       	sbci	r23, 0x00	; 0
    31f2:	01 10       	cpse	r0, r1
    31f4:	d8 f7       	brcc	.-10     	; 0x31ec <strnlen_P+0x2>
    31f6:	80 95       	com	r24
    31f8:	90 95       	com	r25
    31fa:	8e 0f       	add	r24, r30
    31fc:	9f 1f       	adc	r25, r31
    31fe:	08 95       	ret

00003200 <strnlen>:
    3200:	fc 01       	movw	r30, r24
    3202:	61 50       	subi	r22, 0x01	; 1
    3204:	70 40       	sbci	r23, 0x00	; 0
    3206:	01 90       	ld	r0, Z+
    3208:	01 10       	cpse	r0, r1
    320a:	d8 f7       	brcc	.-10     	; 0x3202 <strnlen+0x2>
    320c:	80 95       	com	r24
    320e:	90 95       	com	r25
    3210:	8e 0f       	add	r24, r30
    3212:	9f 1f       	adc	r25, r31
    3214:	08 95       	ret

00003216 <fputc>:
    3216:	0f 93       	push	r16
    3218:	1f 93       	push	r17
    321a:	cf 93       	push	r28
    321c:	df 93       	push	r29
    321e:	fb 01       	movw	r30, r22
    3220:	23 81       	ldd	r18, Z+3	; 0x03
    3222:	21 fd       	sbrc	r18, 1
    3224:	03 c0       	rjmp	.+6      	; 0x322c <fputc+0x16>
    3226:	8f ef       	ldi	r24, 0xFF	; 255
    3228:	9f ef       	ldi	r25, 0xFF	; 255
    322a:	2c c0       	rjmp	.+88     	; 0x3284 <fputc+0x6e>
    322c:	22 ff       	sbrs	r18, 2
    322e:	16 c0       	rjmp	.+44     	; 0x325c <fputc+0x46>
    3230:	46 81       	ldd	r20, Z+6	; 0x06
    3232:	57 81       	ldd	r21, Z+7	; 0x07
    3234:	24 81       	ldd	r18, Z+4	; 0x04
    3236:	35 81       	ldd	r19, Z+5	; 0x05
    3238:	42 17       	cp	r20, r18
    323a:	53 07       	cpc	r21, r19
    323c:	44 f4       	brge	.+16     	; 0x324e <fputc+0x38>
    323e:	a0 81       	ld	r26, Z
    3240:	b1 81       	ldd	r27, Z+1	; 0x01
    3242:	9d 01       	movw	r18, r26
    3244:	2f 5f       	subi	r18, 0xFF	; 255
    3246:	3f 4f       	sbci	r19, 0xFF	; 255
    3248:	31 83       	std	Z+1, r19	; 0x01
    324a:	20 83       	st	Z, r18
    324c:	8c 93       	st	X, r24
    324e:	26 81       	ldd	r18, Z+6	; 0x06
    3250:	37 81       	ldd	r19, Z+7	; 0x07
    3252:	2f 5f       	subi	r18, 0xFF	; 255
    3254:	3f 4f       	sbci	r19, 0xFF	; 255
    3256:	37 83       	std	Z+7, r19	; 0x07
    3258:	26 83       	std	Z+6, r18	; 0x06
    325a:	14 c0       	rjmp	.+40     	; 0x3284 <fputc+0x6e>
    325c:	8b 01       	movw	r16, r22
    325e:	ec 01       	movw	r28, r24
    3260:	fb 01       	movw	r30, r22
    3262:	00 84       	ldd	r0, Z+8	; 0x08
    3264:	f1 85       	ldd	r31, Z+9	; 0x09
    3266:	e0 2d       	mov	r30, r0
    3268:	09 95       	icall
    326a:	89 2b       	or	r24, r25
    326c:	e1 f6       	brne	.-72     	; 0x3226 <fputc+0x10>
    326e:	d8 01       	movw	r26, r16
    3270:	16 96       	adiw	r26, 0x06	; 6
    3272:	8d 91       	ld	r24, X+
    3274:	9c 91       	ld	r25, X
    3276:	17 97       	sbiw	r26, 0x07	; 7
    3278:	01 96       	adiw	r24, 0x01	; 1
    327a:	17 96       	adiw	r26, 0x07	; 7
    327c:	9c 93       	st	X, r25
    327e:	8e 93       	st	-X, r24
    3280:	16 97       	sbiw	r26, 0x06	; 6
    3282:	ce 01       	movw	r24, r28
    3284:	df 91       	pop	r29
    3286:	cf 91       	pop	r28
    3288:	1f 91       	pop	r17
    328a:	0f 91       	pop	r16
    328c:	08 95       	ret

0000328e <__ultoa_invert>:
    328e:	fa 01       	movw	r30, r20
    3290:	aa 27       	eor	r26, r26
    3292:	28 30       	cpi	r18, 0x08	; 8
    3294:	51 f1       	breq	.+84     	; 0x32ea <__ultoa_invert+0x5c>
    3296:	20 31       	cpi	r18, 0x10	; 16
    3298:	81 f1       	breq	.+96     	; 0x32fa <__ultoa_invert+0x6c>
    329a:	e8 94       	clt
    329c:	6f 93       	push	r22
    329e:	6e 7f       	andi	r22, 0xFE	; 254
    32a0:	6e 5f       	subi	r22, 0xFE	; 254
    32a2:	7f 4f       	sbci	r23, 0xFF	; 255
    32a4:	8f 4f       	sbci	r24, 0xFF	; 255
    32a6:	9f 4f       	sbci	r25, 0xFF	; 255
    32a8:	af 4f       	sbci	r26, 0xFF	; 255
    32aa:	b1 e0       	ldi	r27, 0x01	; 1
    32ac:	3e d0       	rcall	.+124    	; 0x332a <__ultoa_invert+0x9c>
    32ae:	b4 e0       	ldi	r27, 0x04	; 4
    32b0:	3c d0       	rcall	.+120    	; 0x332a <__ultoa_invert+0x9c>
    32b2:	67 0f       	add	r22, r23
    32b4:	78 1f       	adc	r23, r24
    32b6:	89 1f       	adc	r24, r25
    32b8:	9a 1f       	adc	r25, r26
    32ba:	a1 1d       	adc	r26, r1
    32bc:	68 0f       	add	r22, r24
    32be:	79 1f       	adc	r23, r25
    32c0:	8a 1f       	adc	r24, r26
    32c2:	91 1d       	adc	r25, r1
    32c4:	a1 1d       	adc	r26, r1
    32c6:	6a 0f       	add	r22, r26
    32c8:	71 1d       	adc	r23, r1
    32ca:	81 1d       	adc	r24, r1
    32cc:	91 1d       	adc	r25, r1
    32ce:	a1 1d       	adc	r26, r1
    32d0:	20 d0       	rcall	.+64     	; 0x3312 <__ultoa_invert+0x84>
    32d2:	09 f4       	brne	.+2      	; 0x32d6 <__ultoa_invert+0x48>
    32d4:	68 94       	set
    32d6:	3f 91       	pop	r19
    32d8:	2a e0       	ldi	r18, 0x0A	; 10
    32da:	26 9f       	mul	r18, r22
    32dc:	11 24       	eor	r1, r1
    32de:	30 19       	sub	r19, r0
    32e0:	30 5d       	subi	r19, 0xD0	; 208
    32e2:	31 93       	st	Z+, r19
    32e4:	de f6       	brtc	.-74     	; 0x329c <__ultoa_invert+0xe>
    32e6:	cf 01       	movw	r24, r30
    32e8:	08 95       	ret
    32ea:	46 2f       	mov	r20, r22
    32ec:	47 70       	andi	r20, 0x07	; 7
    32ee:	40 5d       	subi	r20, 0xD0	; 208
    32f0:	41 93       	st	Z+, r20
    32f2:	b3 e0       	ldi	r27, 0x03	; 3
    32f4:	0f d0       	rcall	.+30     	; 0x3314 <__ultoa_invert+0x86>
    32f6:	c9 f7       	brne	.-14     	; 0x32ea <__ultoa_invert+0x5c>
    32f8:	f6 cf       	rjmp	.-20     	; 0x32e6 <__ultoa_invert+0x58>
    32fa:	46 2f       	mov	r20, r22
    32fc:	4f 70       	andi	r20, 0x0F	; 15
    32fe:	40 5d       	subi	r20, 0xD0	; 208
    3300:	4a 33       	cpi	r20, 0x3A	; 58
    3302:	18 f0       	brcs	.+6      	; 0x330a <__ultoa_invert+0x7c>
    3304:	49 5d       	subi	r20, 0xD9	; 217
    3306:	31 fd       	sbrc	r19, 1
    3308:	40 52       	subi	r20, 0x20	; 32
    330a:	41 93       	st	Z+, r20
    330c:	02 d0       	rcall	.+4      	; 0x3312 <__ultoa_invert+0x84>
    330e:	a9 f7       	brne	.-22     	; 0x32fa <__ultoa_invert+0x6c>
    3310:	ea cf       	rjmp	.-44     	; 0x32e6 <__ultoa_invert+0x58>
    3312:	b4 e0       	ldi	r27, 0x04	; 4
    3314:	a6 95       	lsr	r26
    3316:	97 95       	ror	r25
    3318:	87 95       	ror	r24
    331a:	77 95       	ror	r23
    331c:	67 95       	ror	r22
    331e:	ba 95       	dec	r27
    3320:	c9 f7       	brne	.-14     	; 0x3314 <__ultoa_invert+0x86>
    3322:	00 97       	sbiw	r24, 0x00	; 0
    3324:	61 05       	cpc	r22, r1
    3326:	71 05       	cpc	r23, r1
    3328:	08 95       	ret
    332a:	9b 01       	movw	r18, r22
    332c:	ac 01       	movw	r20, r24
    332e:	0a 2e       	mov	r0, r26
    3330:	06 94       	lsr	r0
    3332:	57 95       	ror	r21
    3334:	47 95       	ror	r20
    3336:	37 95       	ror	r19
    3338:	27 95       	ror	r18
    333a:	ba 95       	dec	r27
    333c:	c9 f7       	brne	.-14     	; 0x3330 <__ultoa_invert+0xa2>
    333e:	62 0f       	add	r22, r18
    3340:	73 1f       	adc	r23, r19
    3342:	84 1f       	adc	r24, r20
    3344:	95 1f       	adc	r25, r21
    3346:	a0 1d       	adc	r26, r0
    3348:	08 95       	ret

0000334a <__prologue_saves__>:
    334a:	2f 92       	push	r2
    334c:	3f 92       	push	r3
    334e:	4f 92       	push	r4
    3350:	5f 92       	push	r5
    3352:	6f 92       	push	r6
    3354:	7f 92       	push	r7
    3356:	8f 92       	push	r8
    3358:	9f 92       	push	r9
    335a:	af 92       	push	r10
    335c:	bf 92       	push	r11
    335e:	cf 92       	push	r12
    3360:	df 92       	push	r13
    3362:	ef 92       	push	r14
    3364:	ff 92       	push	r15
    3366:	0f 93       	push	r16
    3368:	1f 93       	push	r17
    336a:	cf 93       	push	r28
    336c:	df 93       	push	r29
    336e:	cd b7       	in	r28, 0x3d	; 61
    3370:	de b7       	in	r29, 0x3e	; 62
    3372:	ca 1b       	sub	r28, r26
    3374:	db 0b       	sbc	r29, r27
    3376:	0f b6       	in	r0, 0x3f	; 63
    3378:	f8 94       	cli
    337a:	de bf       	out	0x3e, r29	; 62
    337c:	0f be       	out	0x3f, r0	; 63
    337e:	cd bf       	out	0x3d, r28	; 61
    3380:	09 94       	ijmp

00003382 <__epilogue_restores__>:
    3382:	2a 88       	ldd	r2, Y+18	; 0x12
    3384:	39 88       	ldd	r3, Y+17	; 0x11
    3386:	48 88       	ldd	r4, Y+16	; 0x10
    3388:	5f 84       	ldd	r5, Y+15	; 0x0f
    338a:	6e 84       	ldd	r6, Y+14	; 0x0e
    338c:	7d 84       	ldd	r7, Y+13	; 0x0d
    338e:	8c 84       	ldd	r8, Y+12	; 0x0c
    3390:	9b 84       	ldd	r9, Y+11	; 0x0b
    3392:	aa 84       	ldd	r10, Y+10	; 0x0a
    3394:	b9 84       	ldd	r11, Y+9	; 0x09
    3396:	c8 84       	ldd	r12, Y+8	; 0x08
    3398:	df 80       	ldd	r13, Y+7	; 0x07
    339a:	ee 80       	ldd	r14, Y+6	; 0x06
    339c:	fd 80       	ldd	r15, Y+5	; 0x05
    339e:	0c 81       	ldd	r16, Y+4	; 0x04
    33a0:	1b 81       	ldd	r17, Y+3	; 0x03
    33a2:	aa 81       	ldd	r26, Y+2	; 0x02
    33a4:	b9 81       	ldd	r27, Y+1	; 0x01
    33a6:	ce 0f       	add	r28, r30
    33a8:	d1 1d       	adc	r29, r1
    33aa:	0f b6       	in	r0, 0x3f	; 63
    33ac:	f8 94       	cli
    33ae:	de bf       	out	0x3e, r29	; 62
    33b0:	0f be       	out	0x3f, r0	; 63
    33b2:	cd bf       	out	0x3d, r28	; 61
    33b4:	ed 01       	movw	r28, r26
    33b6:	08 95       	ret

000033b8 <_exit>:
    33b8:	f8 94       	cli

000033ba <__stop_program>:
    33ba:	ff cf       	rjmp	.-2      	; 0x33ba <__stop_program>
