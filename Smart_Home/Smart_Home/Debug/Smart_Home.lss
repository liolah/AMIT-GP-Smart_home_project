
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002788  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000057a  00800060  00002788  0000281c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000083  008005da  008005da  00002d96  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00002d96  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002df4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004d8  00000000  00000000  00002e30  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004d9d  00000000  00000000  00003308  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001478  00000000  00000000  000080a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003369  00000000  00000000  0000951d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bb4  00000000  00000000  0000c888  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000011ec  00000000  00000000  0000d43c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002b1e  00000000  00000000  0000e628  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003c8  00000000  00000000  00011146  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__ctors_end>
       4:	0c 94 09 0c 	jmp	0x1812	; 0x1812 <__vector_1>
       8:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
       c:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      10:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      14:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      18:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      1c:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      20:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      24:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      28:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      2c:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      30:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      34:	0c 94 92 0b 	jmp	0x1724	; 0x1724 <__vector_13>
      38:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      3c:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      40:	0c 94 2d 0c 	jmp	0x185a	; 0x185a <__vector_16>
      44:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      48:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      4c:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      50:	0c 94 98 00 	jmp	0x130	; 0x130 <__bad_interrupt>
      54:	97 03       	fmuls	r17, r23
      56:	ab 03       	fmulsu	r18, r19
      58:	ab 03       	fmulsu	r18, r19
      5a:	ab 03       	fmulsu	r18, r19
      5c:	ab 03       	fmulsu	r18, r19
      5e:	ab 03       	fmulsu	r18, r19
      60:	ab 03       	fmulsu	r18, r19
      62:	ab 03       	fmulsu	r18, r19
      64:	ad 03       	fmulsu	r18, r21
      66:	ab 03       	fmulsu	r18, r19
      68:	ab 03       	fmulsu	r18, r19
      6a:	ab 03       	fmulsu	r18, r19
      6c:	ab 03       	fmulsu	r18, r19
      6e:	ab 03       	fmulsu	r18, r19
      70:	ab 03       	fmulsu	r18, r19
      72:	ab 03       	fmulsu	r18, r19
      74:	99 03       	fmulsu	r17, r17
      76:	ab 03       	fmulsu	r18, r19
      78:	ab 03       	fmulsu	r18, r19
      7a:	ab 03       	fmulsu	r18, r19
      7c:	ab 03       	fmulsu	r18, r19
      7e:	ab 03       	fmulsu	r18, r19
      80:	ab 03       	fmulsu	r18, r19
      82:	ab 03       	fmulsu	r18, r19
      84:	9b 03       	fmulsu	r17, r19
      86:	ab 03       	fmulsu	r18, r19
      88:	ab 03       	fmulsu	r18, r19
      8a:	ab 03       	fmulsu	r18, r19
      8c:	ab 03       	fmulsu	r18, r19
      8e:	ab 03       	fmulsu	r18, r19
      90:	ab 03       	fmulsu	r18, r19
      92:	ab 03       	fmulsu	r18, r19
      94:	9d 03       	fmulsu	r17, r21
      96:	ab 03       	fmulsu	r18, r19
      98:	ab 03       	fmulsu	r18, r19
      9a:	ab 03       	fmulsu	r18, r19
      9c:	ab 03       	fmulsu	r18, r19
      9e:	ab 03       	fmulsu	r18, r19
      a0:	ab 03       	fmulsu	r18, r19
      a2:	ab 03       	fmulsu	r18, r19
      a4:	9f 03       	fmulsu	r17, r23
      a6:	ab 03       	fmulsu	r18, r19
      a8:	ab 03       	fmulsu	r18, r19
      aa:	ab 03       	fmulsu	r18, r19
      ac:	ab 03       	fmulsu	r18, r19
      ae:	ab 03       	fmulsu	r18, r19
      b0:	ab 03       	fmulsu	r18, r19
      b2:	ab 03       	fmulsu	r18, r19
      b4:	a1 03       	fmuls	r18, r17
      b6:	ab 03       	fmulsu	r18, r19
      b8:	ab 03       	fmulsu	r18, r19
      ba:	ab 03       	fmulsu	r18, r19
      bc:	ab 03       	fmulsu	r18, r19
      be:	ab 03       	fmulsu	r18, r19
      c0:	ab 03       	fmulsu	r18, r19
      c2:	ab 03       	fmulsu	r18, r19
      c4:	a3 03       	fmuls	r18, r19
      c6:	ab 03       	fmulsu	r18, r19
      c8:	ab 03       	fmulsu	r18, r19
      ca:	ab 03       	fmulsu	r18, r19
      cc:	ab 03       	fmulsu	r18, r19
      ce:	ab 03       	fmulsu	r18, r19
      d0:	ab 03       	fmulsu	r18, r19
      d2:	ab 03       	fmulsu	r18, r19
      d4:	a5 03       	fmuls	r18, r21
      d6:	ab 03       	fmulsu	r18, r19
      d8:	ab 03       	fmulsu	r18, r19
      da:	ab 03       	fmulsu	r18, r19
      dc:	ab 03       	fmulsu	r18, r19
      de:	ab 03       	fmulsu	r18, r19
      e0:	ab 03       	fmulsu	r18, r19
      e2:	ab 03       	fmulsu	r18, r19
      e4:	a7 03       	fmuls	r18, r23
      e6:	ab 03       	fmulsu	r18, r19
      e8:	ab 03       	fmulsu	r18, r19
      ea:	ab 03       	fmulsu	r18, r19
      ec:	ab 03       	fmulsu	r18, r19
      ee:	ab 03       	fmulsu	r18, r19
      f0:	ab 03       	fmulsu	r18, r19
      f2:	ab 03       	fmulsu	r18, r19
      f4:	a9 03       	fmulsu	r18, r17

000000f6 <__ctors_end>:
      f6:	11 24       	eor	r1, r1
      f8:	1f be       	out	0x3f, r1	; 63
      fa:	cf e5       	ldi	r28, 0x5F	; 95
      fc:	d8 e0       	ldi	r29, 0x08	; 8
      fe:	de bf       	out	0x3e, r29	; 62
     100:	cd bf       	out	0x3d, r28	; 61

00000102 <__do_copy_data>:
     102:	15 e0       	ldi	r17, 0x05	; 5
     104:	a0 e6       	ldi	r26, 0x60	; 96
     106:	b0 e0       	ldi	r27, 0x00	; 0
     108:	e8 e8       	ldi	r30, 0x88	; 136
     10a:	f7 e2       	ldi	r31, 0x27	; 39
     10c:	02 c0       	rjmp	.+4      	; 0x112 <__do_copy_data+0x10>
     10e:	05 90       	lpm	r0, Z+
     110:	0d 92       	st	X+, r0
     112:	aa 3d       	cpi	r26, 0xDA	; 218
     114:	b1 07       	cpc	r27, r17
     116:	d9 f7       	brne	.-10     	; 0x10e <__do_copy_data+0xc>

00000118 <__do_clear_bss>:
     118:	26 e0       	ldi	r18, 0x06	; 6
     11a:	aa ed       	ldi	r26, 0xDA	; 218
     11c:	b5 e0       	ldi	r27, 0x05	; 5
     11e:	01 c0       	rjmp	.+2      	; 0x122 <.do_clear_bss_start>

00000120 <.do_clear_bss_loop>:
     120:	1d 92       	st	X+, r1

00000122 <.do_clear_bss_start>:
     122:	ad 35       	cpi	r26, 0x5D	; 93
     124:	b2 07       	cpc	r27, r18
     126:	e1 f7       	brne	.-8      	; 0x120 <.do_clear_bss_loop>
     128:	0e 94 31 02 	call	0x462	; 0x462 <main>
     12c:	0c 94 c2 13 	jmp	0x2784	; 0x2784 <_exit>

00000130 <__bad_interrupt>:
     130:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000134 <Buzzer_on>:
  // Return error code to indicate that the buzzer initialization failed
  return BUZZER_ERROR_INIT;
  }

// Turn on the buzzer
EN_BuzzerError_t Buzzer_on(u8 buzzerPort, u8 buzzerPin) {
     134:	98 2f       	mov	r25, r24
     136:	86 2f       	mov	r24, r22
  if (DIO_write(buzzerPin, buzzerPort, HIGH) == DIO_OK) {
     138:	41 e0       	ldi	r20, 0x01	; 1
     13a:	69 2f       	mov	r22, r25
     13c:	0e 94 ef 02 	call	0x5de	; 0x5de <DIO_write>
     140:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that attempting to turn on the buzzer has failed
  return BUZZER_ERROR_ON;
     142:	82 e0       	ldi	r24, 0x02	; 2
  }
     144:	08 95       	ret

00000146 <EEPROM_init>:
 */

#include "eeprom.h"

void EEPROM_init() {
  I2C_init();
     146:	0e 94 af 03 	call	0x75e	; 0x75e <I2C_init>
     14a:	08 95       	ret

0000014c <EEPROM_read_byte>:
  }

void EEPROM_read_byte(u8 page, u8 address, s8* data) {
     14c:	0f 93       	push	r16
     14e:	1f 93       	push	r17
     150:	cf 93       	push	r28
     152:	df 93       	push	r29
     154:	c8 2f       	mov	r28, r24
     156:	d6 2f       	mov	r29, r22
     158:	8a 01       	movw	r16, r20
  I2C_start();
     15a:	0e 94 b3 03 	call	0x766	; 0x766 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     15e:	cc 0f       	add	r28, r28
     160:	80 ea       	ldi	r24, 0xA0	; 160
     162:	8c 0f       	add	r24, r28
     164:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  I2C_write(address);
     168:	8d 2f       	mov	r24, r29
     16a:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  I2C_start();
     16e:	0e 94 b3 03 	call	0x766	; 0x766 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     172:	81 ea       	ldi	r24, 0xA1	; 161
     174:	8c 0f       	add	r24, r28
     176:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  // read_Ack will halt the reading here, because it will send the next byte, which will not be received and wait for ack, which will not be sent. 
  // Nack must be sent after the arrival of the last requested byte. It's used basically to indicate that no further data transmission is required and then the stop condition is sent
  I2C_read_Nack(data);
     17a:	c8 01       	movw	r24, r16
     17c:	0e 94 cf 03 	call	0x79e	; 0x79e <I2C_read_Nack>
  I2C_stop();
     180:	0e 94 da 03 	call	0x7b4	; 0x7b4 <I2C_stop>
  }
     184:	df 91       	pop	r29
     186:	cf 91       	pop	r28
     188:	1f 91       	pop	r17
     18a:	0f 91       	pop	r16
     18c:	08 95       	ret

0000018e <EEPROM_read_block>:

void EEPROM_read_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     18e:	ef 92       	push	r14
     190:	ff 92       	push	r15
     192:	0f 93       	push	r16
     194:	1f 93       	push	r17
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	c8 2f       	mov	r28, r24
     19c:	d6 2f       	mov	r29, r22
     19e:	7a 01       	movw	r14, r20
     1a0:	89 01       	movw	r16, r18
  u16 i;
  for (i = 0;i < bytes_number;i++) {
    EEPROM_read_byte(page, address + i, &data[i]);
    }
#elif READ_BLOCK_METHOD == MULTIBYTE
  I2C_start();
     1a2:	0e 94 b3 03 	call	0x766	; 0x766 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     1a6:	cc 0f       	add	r28, r28
     1a8:	80 ea       	ldi	r24, 0xA0	; 160
     1aa:	8c 0f       	add	r24, r28
     1ac:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  I2C_write(address);
     1b0:	8d 2f       	mov	r24, r29
     1b2:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  I2C_start();
     1b6:	0e 94 b3 03 	call	0x766	; 0x766 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     1ba:	81 ea       	ldi	r24, 0xA1	; 161
     1bc:	8c 0f       	add	r24, r28
     1be:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1c2:	c0 e0       	ldi	r28, 0x00	; 0
     1c4:	d0 e0       	ldi	r29, 0x00	; 0
     1c6:	06 c0       	rjmp	.+12     	; 0x1d4 <EEPROM_read_block+0x46>
    I2C_read_Ack(&data[i]);
     1c8:	c8 01       	movw	r24, r16
     1ca:	8c 0f       	add	r24, r28
     1cc:	9d 1f       	adc	r25, r29
     1ce:	0e 94 c4 03 	call	0x788	; 0x788 <I2C_read_Ack>
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  I2C_start();
  I2C_write(0xA0 + (page << 1) + 1);
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     1d2:	21 96       	adiw	r28, 0x01	; 1
     1d4:	c7 01       	movw	r24, r14
     1d6:	01 97       	sbiw	r24, 0x01	; 1
     1d8:	c8 17       	cp	r28, r24
     1da:	d9 07       	cpc	r29, r25
     1dc:	a8 f3       	brcs	.-22     	; 0x1c8 <EEPROM_read_block+0x3a>
    I2C_read_Ack(&data[i]);
    }
  I2C_read_Nack(&data[i]);
     1de:	c8 01       	movw	r24, r16
     1e0:	8c 0f       	add	r24, r28
     1e2:	9d 1f       	adc	r25, r29
     1e4:	0e 94 cf 03 	call	0x79e	; 0x79e <I2C_read_Nack>
  I2C_stop();
     1e8:	0e 94 da 03 	call	0x7b4	; 0x7b4 <I2C_stop>
#endif
  }
     1ec:	df 91       	pop	r29
     1ee:	cf 91       	pop	r28
     1f0:	1f 91       	pop	r17
     1f2:	0f 91       	pop	r16
     1f4:	ff 90       	pop	r15
     1f6:	ef 90       	pop	r14
     1f8:	08 95       	ret

000001fa <EEPROM_write_byte>:

void EEPROM_write_byte(u8 page, u8 address, s8 data) {
     1fa:	1f 93       	push	r17
     1fc:	cf 93       	push	r28
     1fe:	df 93       	push	r29
     200:	c8 2f       	mov	r28, r24
     202:	16 2f       	mov	r17, r22
     204:	d4 2f       	mov	r29, r20
  I2C_start();
     206:	0e 94 b3 03 	call	0x766	; 0x766 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     20a:	8c 2f       	mov	r24, r28
     20c:	88 0f       	add	r24, r24
     20e:	80 56       	subi	r24, 0x60	; 96
     210:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  I2C_write(address);
     214:	81 2f       	mov	r24, r17
     216:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  I2C_write(data);
     21a:	8d 2f       	mov	r24, r29
     21c:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  I2C_stop();
     220:	0e 94 da 03 	call	0x7b4	; 0x7b4 <I2C_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     224:	8f e3       	ldi	r24, 0x3F	; 63
     226:	9c e9       	ldi	r25, 0x9C	; 156
     228:	01 97       	sbiw	r24, 0x01	; 1
     22a:	f1 f7       	brne	.-4      	; 0x228 <EEPROM_write_byte+0x2e>
     22c:	00 c0       	rjmp	.+0      	; 0x22e <EEPROM_write_byte+0x34>
     22e:	00 00       	nop

#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
  }
     230:	df 91       	pop	r29
     232:	cf 91       	pop	r28
     234:	1f 91       	pop	r17
     236:	08 95       	ret

00000238 <EEPROM_write_block>:

// bytes_number must be within page size (256 bytes)
void EEPROM_write_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     238:	6f 92       	push	r6
     23a:	7f 92       	push	r7
     23c:	8f 92       	push	r8
     23e:	9f 92       	push	r9
     240:	af 92       	push	r10
     242:	bf 92       	push	r11
     244:	cf 92       	push	r12
     246:	df 92       	push	r13
     248:	ef 92       	push	r14
     24a:	ff 92       	push	r15
     24c:	0f 93       	push	r16
     24e:	1f 93       	push	r17
     250:	cf 93       	push	r28
     252:	df 93       	push	r29
     254:	78 2e       	mov	r7, r24
     256:	66 2e       	mov	r6, r22
     258:	6a 01       	movw	r12, r20
     25a:	89 01       	movw	r16, r18
  //! If data is required to be written in the first 16 bytes starting from byte 10 for example, the data will be stored starting from bytes 10, 
  //! and if the data exceeds the row limit ** IT WILL ROLL OVER AND OVERWRITE THE ROW **. Therefore, in a single multibyte write cycle, we can't write more than 16 bytes at maximum if starting from the first byte in the row
  //! or the remaining bytes till the end of the row from the starting position. The remaining bytes must be written in another write cycle to avoind the roll over problem.

  u16 dataIndex, blockNumber, i;
  u16 first_block_size = 16 - (address % 16);
     25c:	86 2f       	mov	r24, r22
     25e:	8f 70       	andi	r24, 0x0F	; 15
     260:	20 e1       	ldi	r18, 0x10	; 16
     262:	30 e0       	ldi	r19, 0x00	; 0
     264:	79 01       	movw	r14, r18
     266:	e8 1a       	sub	r14, r24
     268:	f1 08       	sbc	r15, r1
  if (16 - (address % 16) > bytes_number) first_block_size = bytes_number;
     26a:	4e 15       	cp	r20, r14
     26c:	5f 05       	cpc	r21, r15
     26e:	08 f4       	brcc	.+2      	; 0x272 <EEPROM_write_block+0x3a>
     270:	7a 01       	movw	r14, r20

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
     272:	0e 94 b3 03 	call	0x766	; 0x766 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     276:	87 2d       	mov	r24, r7
     278:	88 0f       	add	r24, r24
     27a:	0f 2e       	mov	r0, r31
     27c:	f0 ea       	ldi	r31, 0xA0	; 160
     27e:	7f 2e       	mov	r7, r31
     280:	f0 2d       	mov	r31, r0
     282:	78 0e       	add	r7, r24
     284:	87 2d       	mov	r24, r7
     286:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  I2C_write(address);
     28a:	86 2d       	mov	r24, r6
     28c:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     290:	c0 e0       	ldi	r28, 0x00	; 0
     292:	d0 e0       	ldi	r29, 0x00	; 0
     294:	07 c0       	rjmp	.+14     	; 0x2a4 <EEPROM_write_block+0x6c>
    I2C_write(data[dataIndex]);
     296:	f8 01       	movw	r30, r16
     298:	ec 0f       	add	r30, r28
     29a:	fd 1f       	adc	r31, r29
     29c:	80 81       	ld	r24, Z
     29e:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     2a2:	21 96       	adiw	r28, 0x01	; 1
     2a4:	ce 15       	cp	r28, r14
     2a6:	df 05       	cpc	r29, r15
     2a8:	b0 f3       	brcs	.-20     	; 0x296 <EEPROM_write_block+0x5e>
    I2C_write(data[dataIndex]);
    }
  I2C_stop();
     2aa:	0e 94 da 03 	call	0x7b4	; 0x7b4 <I2C_stop>
     2ae:	8f e3       	ldi	r24, 0x3F	; 63
     2b0:	9c e9       	ldi	r25, 0x9C	; 156
     2b2:	01 97       	sbiw	r24, 0x01	; 1
     2b4:	f1 f7       	brne	.-4      	; 0x2b2 <EEPROM_write_block+0x7a>
     2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <EEPROM_write_block+0x80>
     2b8:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif

  // Return if the data fits in the row (data fits in a single row or the remaining part of it after the address)
  if (first_block_size == bytes_number) return;
     2ba:	ec 14       	cp	r14, r12
     2bc:	fd 04       	cpc	r15, r13
     2be:	09 f4       	brne	.+2      	; 0x2c2 <EEPROM_write_block+0x8a>
     2c0:	61 c0       	rjmp	.+194    	; 0x384 <EEPROM_write_block+0x14c>

  u16 last_block_size = (address + bytes_number) % 16;
     2c2:	56 01       	movw	r10, r12
     2c4:	a6 0c       	add	r10, r6
     2c6:	b1 1c       	adc	r11, r1
     2c8:	9f e0       	ldi	r25, 0x0F	; 15
     2ca:	a9 22       	and	r10, r25
     2cc:	bb 24       	eor	r11, r11
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
     2ce:	ce 18       	sub	r12, r14
     2d0:	df 08       	sbc	r13, r15
     2d2:	ca 18       	sub	r12, r10
     2d4:	db 08       	sbc	r13, r11
     2d6:	d6 94       	lsr	r13
     2d8:	c7 94       	ror	r12
     2da:	d6 94       	lsr	r13
     2dc:	c7 94       	ror	r12
     2de:	d6 94       	lsr	r13
     2e0:	c7 94       	ror	r12
     2e2:	d6 94       	lsr	r13
     2e4:	c7 94       	ror	r12
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     2e6:	e1 2c       	mov	r14, r1
     2e8:	f1 2c       	mov	r15, r1
     2ea:	27 c0       	rjmp	.+78     	; 0x33a <EEPROM_write_block+0x102>
    I2C_start();
     2ec:	0e 94 b3 03 	call	0x766	; 0x766 <I2C_start>
    I2C_write(0xA0 + (page << 1));
     2f0:	87 2d       	mov	r24, r7
     2f2:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
    I2C_write(address + dataIndex);
     2f6:	8c 2f       	mov	r24, r28
     2f8:	86 0d       	add	r24, r6
     2fa:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
    for (i = 0;i < 16;i++) {
     2fe:	81 2c       	mov	r8, r1
     300:	91 2c       	mov	r9, r1
     302:	0b c0       	rjmp	.+22     	; 0x31a <EEPROM_write_block+0xe2>
      I2C_write(data[dataIndex + i]);
     304:	fe 01       	movw	r30, r28
     306:	e8 0d       	add	r30, r8
     308:	f9 1d       	adc	r31, r9
     30a:	e0 0f       	add	r30, r16
     30c:	f1 1f       	adc	r31, r17
     30e:	80 81       	ld	r24, Z
     310:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
    I2C_start();
    I2C_write(0xA0 + (page << 1));
    I2C_write(address + dataIndex);
    for (i = 0;i < 16;i++) {
     314:	8f ef       	ldi	r24, 0xFF	; 255
     316:	88 1a       	sub	r8, r24
     318:	98 0a       	sbc	r9, r24
     31a:	90 e1       	ldi	r25, 0x10	; 16
     31c:	89 16       	cp	r8, r25
     31e:	91 04       	cpc	r9, r1
     320:	88 f3       	brcs	.-30     	; 0x304 <EEPROM_write_block+0xcc>
      I2C_write(data[dataIndex + i]);
      }
    dataIndex += 16;
     322:	60 96       	adiw	r28, 0x10	; 16
    I2C_stop();
     324:	0e 94 da 03 	call	0x7b4	; 0x7b4 <I2C_stop>
     328:	8f e3       	ldi	r24, 0x3F	; 63
     32a:	9c e9       	ldi	r25, 0x9C	; 156
     32c:	01 97       	sbiw	r24, 0x01	; 1
     32e:	f1 f7       	brne	.-4      	; 0x32c <EEPROM_write_block+0xf4>
     330:	00 c0       	rjmp	.+0      	; 0x332 <EEPROM_write_block+0xfa>
     332:	00 00       	nop
  if (first_block_size == bytes_number) return;

  u16 last_block_size = (address + bytes_number) % 16;
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     334:	9f ef       	ldi	r25, 0xFF	; 255
     336:	e9 1a       	sub	r14, r25
     338:	f9 0a       	sbc	r15, r25
     33a:	ec 14       	cp	r14, r12
     33c:	fd 04       	cpc	r15, r13
     33e:	b0 f2       	brcs	.-84     	; 0x2ec <EEPROM_write_block+0xb4>
    _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
    }

  // Write the last part of the data
  I2C_start();
     340:	0e 94 b3 03 	call	0x766	; 0x766 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     344:	87 2d       	mov	r24, r7
     346:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  I2C_write(address + dataIndex);
     34a:	8c 2f       	mov	r24, r28
     34c:	86 0d       	add	r24, r6
     34e:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>
  for (i = 0;i < last_block_size;i++) {
     352:	e1 2c       	mov	r14, r1
     354:	f1 2c       	mov	r15, r1
     356:	0b c0       	rjmp	.+22     	; 0x36e <EEPROM_write_block+0x136>
    I2C_write(data[dataIndex + i]);
     358:	fe 01       	movw	r30, r28
     35a:	ee 0d       	add	r30, r14
     35c:	ff 1d       	adc	r31, r15
     35e:	e0 0f       	add	r30, r16
     360:	f1 1f       	adc	r31, r17
     362:	80 81       	ld	r24, Z
     364:	0e 94 bb 03 	call	0x776	; 0x776 <I2C_write>

  // Write the last part of the data
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address + dataIndex);
  for (i = 0;i < last_block_size;i++) {
     368:	8f ef       	ldi	r24, 0xFF	; 255
     36a:	e8 1a       	sub	r14, r24
     36c:	f8 0a       	sbc	r15, r24
     36e:	ea 14       	cp	r14, r10
     370:	fb 04       	cpc	r15, r11
     372:	90 f3       	brcs	.-28     	; 0x358 <EEPROM_write_block+0x120>
    I2C_write(data[dataIndex + i]);
    }
  I2C_stop();
     374:	0e 94 da 03 	call	0x7b4	; 0x7b4 <I2C_stop>
     378:	8f e3       	ldi	r24, 0x3F	; 63
     37a:	9c e9       	ldi	r25, 0x9C	; 156
     37c:	01 97       	sbiw	r24, 0x01	; 1
     37e:	f1 f7       	brne	.-4      	; 0x37c <EEPROM_write_block+0x144>
     380:	00 c0       	rjmp	.+0      	; 0x382 <EEPROM_write_block+0x14a>
     382:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
#endif
     384:	df 91       	pop	r29
     386:	cf 91       	pop	r28
     388:	1f 91       	pop	r17
     38a:	0f 91       	pop	r16
     38c:	ff 90       	pop	r15
     38e:	ef 90       	pop	r14
     390:	df 90       	pop	r13
     392:	cf 90       	pop	r12
     394:	bf 90       	pop	r11
     396:	af 90       	pop	r10
     398:	9f 90       	pop	r9
     39a:	8f 90       	pop	r8
     39c:	7f 90       	pop	r7
     39e:	6f 90       	pop	r6
     3a0:	08 95       	ret

000003a2 <BT_init>:
 *  Author: Hesham Hany
 */

#include "hc_05.h"

void BT_init(u32 baudRate) {
     3a2:	cf 92       	push	r12
     3a4:	df 92       	push	r13
     3a6:	ef 92       	push	r14
     3a8:	ff 92       	push	r15
     3aa:	6b 01       	movw	r12, r22
     3ac:	7c 01       	movw	r14, r24
  DIO_init(HC_05_STATUS_PIN, HC_05_STATUS_PORT, IN);
     3ae:	40 e0       	ldi	r20, 0x00	; 0
     3b0:	64 e4       	ldi	r22, 0x44	; 68
     3b2:	82 e0       	ldi	r24, 0x02	; 2
     3b4:	0e 94 55 02 	call	0x4aa	; 0x4aa <DIO_init>
  UART_init(baudRate);
     3b8:	c7 01       	movw	r24, r14
     3ba:	b6 01       	movw	r22, r12
     3bc:	0e 94 e5 06 	call	0xdca	; 0xdca <UART_init>
  }
     3c0:	ff 90       	pop	r15
     3c2:	ef 90       	pop	r14
     3c4:	df 90       	pop	r13
     3c6:	cf 90       	pop	r12
     3c8:	08 95       	ret

000003ca <BT_sendChar>:

void BT_sendChar(s8 data) {
  UART_sendChar(data);
     3ca:	0e 94 87 07 	call	0xf0e	; 0xf0e <UART_sendChar>
     3ce:	08 95       	ret

000003d0 <BT_sendString>:
  }

void BT_sendString(s8* str) {
  UART_sendString(str);
     3d0:	0e 94 8d 07 	call	0xf1a	; 0xf1a <UART_sendString>
     3d4:	08 95       	ret

000003d6 <LED_init>:
 */

#include "led.h"

 // Initialize the LED
EN_ledError_t LED_init(u8 ledPort, u8 ledPin) {
     3d6:	98 2f       	mov	r25, r24
     3d8:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(ledPin, ledPort, OUT) == DIO_OK) {
     3da:	41 e0       	ldi	r20, 0x01	; 1
     3dc:	69 2f       	mov	r22, r25
     3de:	0e 94 55 02 	call	0x4aa	; 0x4aa <DIO_init>
     3e2:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that the led initialization failed
  return LED_ERROR_INIT;
     3e4:	81 e0       	ldi	r24, 0x01	; 1
  }
     3e6:	08 95       	ret

000003e8 <LED_on>:

// Turn on the LED
EN_ledError_t LED_on(u8 ledPort, u8 ledPin) {
     3e8:	98 2f       	mov	r25, r24
     3ea:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, HIGH) == DIO_OK) {
     3ec:	41 e0       	ldi	r20, 0x01	; 1
     3ee:	69 2f       	mov	r22, r25
     3f0:	0e 94 ef 02 	call	0x5de	; 0x5de <DIO_write>
     3f4:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn on the led has failed
  return LED_ERROR_ON;
     3f6:	82 e0       	ldi	r24, 0x02	; 2
  }
     3f8:	08 95       	ret

000003fa <LED_off>:

// Turn off the LED
EN_ledError_t LED_off(u8 ledPort, u8 ledPin) {
     3fa:	98 2f       	mov	r25, r24
     3fc:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, LOW) == DIO_OK) {
     3fe:	40 e0       	ldi	r20, 0x00	; 0
     400:	69 2f       	mov	r22, r25
     402:	0e 94 ef 02 	call	0x5de	; 0x5de <DIO_write>
     406:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn off the led has failed
  return LED_ERROR_OFF;
     408:	83 e0       	ldi	r24, 0x03	; 3
  }
     40a:	08 95       	ret

0000040c <Servo_init>:

#include "servo.h"

 // Initialized the servo
void Servo_init() {
  DIO_init(SERVO_PIN, SERVO_PORT, OUT);
     40c:	41 e0       	ldi	r20, 0x01	; 1
     40e:	64 e4       	ldi	r22, 0x44	; 68
     410:	85 e0       	ldi	r24, 0x05	; 5
     412:	0e 94 55 02 	call	0x4aa	; 0x4aa <DIO_init>
  PWM_init(SERVO_PWM_PIN, (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS), PWM_PHASE_CORRECT);
     416:	22 e0       	ldi	r18, 0x02	; 2
     418:	4d ec       	ldi	r20, 0xCD	; 205
     41a:	5c ec       	ldi	r21, 0xCC	; 204
     41c:	6c ec       	ldi	r22, 0xCC	; 204
     41e:	7c e3       	ldi	r23, 0x3C	; 60
     420:	81 e0       	ldi	r24, 0x01	; 1
     422:	0e 94 ff 05 	call	0xbfe	; 0xbfe <PWM_init>
  Timer_start(TIMER_1, 8);
     426:	68 e0       	ldi	r22, 0x08	; 8
     428:	70 e0       	ldi	r23, 0x00	; 0
     42a:	81 e0       	ldi	r24, 0x01	; 1
     42c:	0e 94 8f 05 	call	0xb1e	; 0xb1e <Timer_start>
     430:	08 95       	ret

00000432 <Servo_move_to_angle>:
  }

// Moves the servo to a specific angle (relative to the 0 angle position, not the previous one).
void Servo_move_to_angle(u8 angle) {
  PWM_set_DC(SERVO_PWM_PIN, ((double)angle / ((SERVO_MAX_ANGLE - SERVO_MIN_ANGLE) * (SERVO_PULSE_PERIODIC_TIME_mS / (SERVO_MAX_HIGH_PULSE_DURATION_mS - SERVO_MIN_HIGH_PULSE_DURATION_mS)))) + (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS));
     432:	68 2f       	mov	r22, r24
     434:	70 e0       	ldi	r23, 0x00	; 0
     436:	80 e0       	ldi	r24, 0x00	; 0
     438:	90 e0       	ldi	r25, 0x00	; 0
     43a:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <__floatunsisf>
     43e:	20 e0       	ldi	r18, 0x00	; 0
     440:	30 e0       	ldi	r19, 0x00	; 0
     442:	41 ee       	ldi	r20, 0xE1	; 225
     444:	54 e4       	ldi	r21, 0x44	; 68
     446:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <__divsf3>
     44a:	2d ec       	ldi	r18, 0xCD	; 205
     44c:	3c ec       	ldi	r19, 0xCC	; 204
     44e:	4c ec       	ldi	r20, 0xCC	; 204
     450:	5c e3       	ldi	r21, 0x3C	; 60
     452:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <__addsf3>
     456:	ab 01       	movw	r20, r22
     458:	bc 01       	movw	r22, r24
     45a:	81 e0       	ldi	r24, 0x01	; 1
     45c:	0e 94 a6 06 	call	0xd4c	; 0xd4c <PWM_set_DC>
     460:	08 95       	ret

00000462 <main>:
 */

#include "Application/app.h"

int main(void) {
	Remote_init(9600);
     462:	60 e8       	ldi	r22, 0x80	; 128
     464:	75 e2       	ldi	r23, 0x25	; 37
     466:	80 e0       	ldi	r24, 0x00	; 0
     468:	90 e0       	ldi	r25, 0x00	; 0
     46a:	0e 94 3d 08 	call	0x107a	; 0x107a <Remote_init>
	Lamps_init();
     46e:	0e 94 bc 07 	call	0xf78	; 0xf78 <Lamps_init>
	Door_init();
     472:	0e 94 ae 07 	call	0xf5c	; 0xf5c <Door_init>
     476:	ff cf       	rjmp	.-2      	; 0x476 <main+0x14>

00000478 <isValidPinNumber>:
 */

#include "dio.h"

bool isValidPinNumber(u8 pinNumber) {
	if (pinNumber < 8) {
     478:	88 30       	cpi	r24, 0x08	; 8
     47a:	10 f4       	brcc	.+4      	; 0x480 <isValidPinNumber+0x8>
		return true;
     47c:	81 e0       	ldi	r24, 0x01	; 1
     47e:	08 95       	ret
		}
	return false;
     480:	80 e0       	ldi	r24, 0x00	; 0
	}
     482:	08 95       	ret

00000484 <isValidPortNumber>:

bool isValidPortNumber(u8 portNumber) {
	if (portNumber == PORT_A || portNumber == PORT_B || portNumber == PORT_C || portNumber == PORT_D) {
     484:	81 54       	subi	r24, 0x41	; 65
     486:	84 30       	cpi	r24, 0x04	; 4
     488:	10 f4       	brcc	.+4      	; 0x48e <isValidPortNumber+0xa>
		return true;
     48a:	81 e0       	ldi	r24, 0x01	; 1
     48c:	08 95       	ret
		}
	return false;
     48e:	80 e0       	ldi	r24, 0x00	; 0
	}
     490:	08 95       	ret

00000492 <isValidDirection>:

bool isValidDirection(u8 direction) {
	if (direction == IN || direction == OUT) {
     492:	82 30       	cpi	r24, 0x02	; 2
     494:	10 f4       	brcc	.+4      	; 0x49a <isValidDirection+0x8>
		return true;
     496:	81 e0       	ldi	r24, 0x01	; 1
     498:	08 95       	ret
		}
	return false;
     49a:	80 e0       	ldi	r24, 0x00	; 0
	}
     49c:	08 95       	ret

0000049e <isValidState>:

bool isValidState(u8 state) {
	if (state == HIGH || state == LOW) {
     49e:	82 30       	cpi	r24, 0x02	; 2
     4a0:	10 f4       	brcc	.+4      	; 0x4a6 <isValidState+0x8>
		return true;
     4a2:	81 e0       	ldi	r24, 0x01	; 1
     4a4:	08 95       	ret
		}
	return false;
     4a6:	80 e0       	ldi	r24, 0x00	; 0
	}
     4a8:	08 95       	ret

000004aa <DIO_init>:

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
     4aa:	1f 93       	push	r17
     4ac:	cf 93       	push	r28
     4ae:	df 93       	push	r29
     4b0:	c8 2f       	mov	r28, r24
     4b2:	d6 2f       	mov	r29, r22
     4b4:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     4b6:	0e 94 3c 02 	call	0x478	; 0x478 <isValidPinNumber>
     4ba:	88 23       	and	r24, r24
     4bc:	09 f4       	brne	.+2      	; 0x4c0 <DIO_init+0x16>
     4be:	84 c0       	rjmp	.+264    	; 0x5c8 <DIO_init+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     4c0:	8d 2f       	mov	r24, r29
     4c2:	0e 94 42 02 	call	0x484	; 0x484 <isValidPortNumber>
     4c6:	88 23       	and	r24, r24
     4c8:	09 f4       	brne	.+2      	; 0x4cc <DIO_init+0x22>
     4ca:	80 c0       	rjmp	.+256    	; 0x5cc <DIO_init+0x122>
		return WRONG_PORT;
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
     4cc:	81 2f       	mov	r24, r17
     4ce:	0e 94 49 02 	call	0x492	; 0x492 <isValidDirection>
     4d2:	88 23       	and	r24, r24
     4d4:	09 f4       	brne	.+2      	; 0x4d8 <DIO_init+0x2e>
     4d6:	7c c0       	rjmp	.+248    	; 0x5d0 <DIO_init+0x126>
		return WRONG_DIRECTION;
		}
	switch (portNumber) {
     4d8:	d2 34       	cpi	r29, 0x42	; 66
     4da:	29 f1       	breq	.+74     	; 0x526 <DIO_init+0x7c>
     4dc:	18 f4       	brcc	.+6      	; 0x4e4 <DIO_init+0x3a>
     4de:	d1 34       	cpi	r29, 0x41	; 65
     4e0:	39 f0       	breq	.+14     	; 0x4f0 <DIO_init+0x46>
     4e2:	78 c0       	rjmp	.+240    	; 0x5d4 <DIO_init+0x12a>
     4e4:	d3 34       	cpi	r29, 0x43	; 67
     4e6:	d1 f1       	breq	.+116    	; 0x55c <DIO_init+0xb2>
     4e8:	d4 34       	cpi	r29, 0x44	; 68
     4ea:	09 f4       	brne	.+2      	; 0x4ee <DIO_init+0x44>
     4ec:	52 c0       	rjmp	.+164    	; 0x592 <DIO_init+0xe8>
     4ee:	72 c0       	rjmp	.+228    	; 0x5d4 <DIO_init+0x12a>
			case PORT_A:
				if (direction == OUT) {
     4f0:	11 30       	cpi	r17, 0x01	; 1
     4f2:	61 f4       	brne	.+24     	; 0x50c <DIO_init+0x62>
					set_bit(DDRA, pinNumber);
     4f4:	2a b3       	in	r18, 0x1a	; 26
     4f6:	81 e0       	ldi	r24, 0x01	; 1
     4f8:	90 e0       	ldi	r25, 0x00	; 0
     4fa:	02 c0       	rjmp	.+4      	; 0x500 <DIO_init+0x56>
     4fc:	88 0f       	add	r24, r24
     4fe:	99 1f       	adc	r25, r25
     500:	ca 95       	dec	r28
     502:	e2 f7       	brpl	.-8      	; 0x4fc <DIO_init+0x52>
     504:	82 2b       	or	r24, r18
     506:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     508:	80 e0       	ldi	r24, 0x00	; 0
     50a:	65 c0       	rjmp	.+202    	; 0x5d6 <DIO_init+0x12c>
			case PORT_A:
				if (direction == OUT) {
					set_bit(DDRA, pinNumber);
					}
				else {
					clear_bit(DDRA, pinNumber);
     50c:	2a b3       	in	r18, 0x1a	; 26
     50e:	81 e0       	ldi	r24, 0x01	; 1
     510:	90 e0       	ldi	r25, 0x00	; 0
     512:	02 c0       	rjmp	.+4      	; 0x518 <DIO_init+0x6e>
     514:	88 0f       	add	r24, r24
     516:	99 1f       	adc	r25, r25
     518:	ca 95       	dec	r28
     51a:	e2 f7       	brpl	.-8      	; 0x514 <DIO_init+0x6a>
     51c:	80 95       	com	r24
     51e:	82 23       	and	r24, r18
     520:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     522:	80 e0       	ldi	r24, 0x00	; 0
     524:	58 c0       	rjmp	.+176    	; 0x5d6 <DIO_init+0x12c>
				else {
					clear_bit(DDRA, pinNumber);
					}
				break;
			case PORT_B:
				if (direction == OUT) {
     526:	11 30       	cpi	r17, 0x01	; 1
     528:	61 f4       	brne	.+24     	; 0x542 <DIO_init+0x98>
					set_bit(DDRB, pinNumber);
     52a:	27 b3       	in	r18, 0x17	; 23
     52c:	81 e0       	ldi	r24, 0x01	; 1
     52e:	90 e0       	ldi	r25, 0x00	; 0
     530:	02 c0       	rjmp	.+4      	; 0x536 <DIO_init+0x8c>
     532:	88 0f       	add	r24, r24
     534:	99 1f       	adc	r25, r25
     536:	ca 95       	dec	r28
     538:	e2 f7       	brpl	.-8      	; 0x532 <DIO_init+0x88>
     53a:	82 2b       	or	r24, r18
     53c:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     53e:	80 e0       	ldi	r24, 0x00	; 0
     540:	4a c0       	rjmp	.+148    	; 0x5d6 <DIO_init+0x12c>
			case PORT_B:
				if (direction == OUT) {
					set_bit(DDRB, pinNumber);
					}
				else {
					clear_bit(DDRB, pinNumber);
     542:	27 b3       	in	r18, 0x17	; 23
     544:	81 e0       	ldi	r24, 0x01	; 1
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	02 c0       	rjmp	.+4      	; 0x54e <DIO_init+0xa4>
     54a:	88 0f       	add	r24, r24
     54c:	99 1f       	adc	r25, r25
     54e:	ca 95       	dec	r28
     550:	e2 f7       	brpl	.-8      	; 0x54a <DIO_init+0xa0>
     552:	80 95       	com	r24
     554:	82 23       	and	r24, r18
     556:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     558:	80 e0       	ldi	r24, 0x00	; 0
     55a:	3d c0       	rjmp	.+122    	; 0x5d6 <DIO_init+0x12c>
				else {
					clear_bit(DDRB, pinNumber);
					}
				break;
			case PORT_C:
				if (direction == OUT) {
     55c:	11 30       	cpi	r17, 0x01	; 1
     55e:	61 f4       	brne	.+24     	; 0x578 <DIO_init+0xce>
					set_bit(DDRC, pinNumber);
     560:	24 b3       	in	r18, 0x14	; 20
     562:	81 e0       	ldi	r24, 0x01	; 1
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	02 c0       	rjmp	.+4      	; 0x56c <DIO_init+0xc2>
     568:	88 0f       	add	r24, r24
     56a:	99 1f       	adc	r25, r25
     56c:	ca 95       	dec	r28
     56e:	e2 f7       	brpl	.-8      	; 0x568 <DIO_init+0xbe>
     570:	82 2b       	or	r24, r18
     572:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     574:	80 e0       	ldi	r24, 0x00	; 0
     576:	2f c0       	rjmp	.+94     	; 0x5d6 <DIO_init+0x12c>
			case PORT_C:
				if (direction == OUT) {
					set_bit(DDRC, pinNumber);
					}
				else {
					clear_bit(DDRC, pinNumber);
     578:	24 b3       	in	r18, 0x14	; 20
     57a:	81 e0       	ldi	r24, 0x01	; 1
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	02 c0       	rjmp	.+4      	; 0x584 <DIO_init+0xda>
     580:	88 0f       	add	r24, r24
     582:	99 1f       	adc	r25, r25
     584:	ca 95       	dec	r28
     586:	e2 f7       	brpl	.-8      	; 0x580 <DIO_init+0xd6>
     588:	80 95       	com	r24
     58a:	82 23       	and	r24, r18
     58c:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     58e:	80 e0       	ldi	r24, 0x00	; 0
     590:	22 c0       	rjmp	.+68     	; 0x5d6 <DIO_init+0x12c>
				else {
					clear_bit(DDRC, pinNumber);
					}
				break;
			case PORT_D:
				if (direction == OUT) {
     592:	11 30       	cpi	r17, 0x01	; 1
     594:	61 f4       	brne	.+24     	; 0x5ae <DIO_init+0x104>
					set_bit(DDRD, pinNumber);
     596:	21 b3       	in	r18, 0x11	; 17
     598:	81 e0       	ldi	r24, 0x01	; 1
     59a:	90 e0       	ldi	r25, 0x00	; 0
     59c:	02 c0       	rjmp	.+4      	; 0x5a2 <DIO_init+0xf8>
     59e:	88 0f       	add	r24, r24
     5a0:	99 1f       	adc	r25, r25
     5a2:	ca 95       	dec	r28
     5a4:	e2 f7       	brpl	.-8      	; 0x59e <DIO_init+0xf4>
     5a6:	82 2b       	or	r24, r18
     5a8:	81 bb       	out	0x11, r24	; 17
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     5aa:	80 e0       	ldi	r24, 0x00	; 0
     5ac:	14 c0       	rjmp	.+40     	; 0x5d6 <DIO_init+0x12c>
			case PORT_D:
				if (direction == OUT) {
					set_bit(DDRD, pinNumber);
					}
				else {
					clear_bit(DDRD, pinNumber);
     5ae:	21 b3       	in	r18, 0x11	; 17
     5b0:	81 e0       	ldi	r24, 0x01	; 1
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	02 c0       	rjmp	.+4      	; 0x5ba <DIO_init+0x110>
     5b6:	88 0f       	add	r24, r24
     5b8:	99 1f       	adc	r25, r25
     5ba:	ca 95       	dec	r28
     5bc:	e2 f7       	brpl	.-8      	; 0x5b6 <DIO_init+0x10c>
     5be:	80 95       	com	r24
     5c0:	82 23       	and	r24, r18
     5c2:	81 bb       	out	0x11, r24	; 17
					}
				break;
		}
	return DIO_OK;
     5c4:	80 e0       	ldi	r24, 0x00	; 0
     5c6:	07 c0       	rjmp	.+14     	; 0x5d6 <DIO_init+0x12c>

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     5c8:	81 e0       	ldi	r24, 0x01	; 1
     5ca:	05 c0       	rjmp	.+10     	; 0x5d6 <DIO_init+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     5cc:	82 e0       	ldi	r24, 0x02	; 2
     5ce:	03 c0       	rjmp	.+6      	; 0x5d6 <DIO_init+0x12c>
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
		return WRONG_DIRECTION;
     5d0:	83 e0       	ldi	r24, 0x03	; 3
     5d2:	01 c0       	rjmp	.+2      	; 0x5d6 <DIO_init+0x12c>
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     5d4:	80 e0       	ldi	r24, 0x00	; 0
	}
     5d6:	df 91       	pop	r29
     5d8:	cf 91       	pop	r28
     5da:	1f 91       	pop	r17
     5dc:	08 95       	ret

000005de <DIO_write>:

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
     5de:	1f 93       	push	r17
     5e0:	cf 93       	push	r28
     5e2:	df 93       	push	r29
     5e4:	c8 2f       	mov	r28, r24
     5e6:	d6 2f       	mov	r29, r22
     5e8:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     5ea:	0e 94 3c 02 	call	0x478	; 0x478 <isValidPinNumber>
     5ee:	88 23       	and	r24, r24
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <DIO_write+0x16>
     5f2:	84 c0       	rjmp	.+264    	; 0x6fc <DIO_write+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     5f4:	8d 2f       	mov	r24, r29
     5f6:	0e 94 42 02 	call	0x484	; 0x484 <isValidPortNumber>
     5fa:	88 23       	and	r24, r24
     5fc:	09 f4       	brne	.+2      	; 0x600 <DIO_write+0x22>
     5fe:	80 c0       	rjmp	.+256    	; 0x700 <DIO_write+0x122>
		return WRONG_PORT;
		}
	// Validate the pin state
	if (!isValidState(state)) {
     600:	81 2f       	mov	r24, r17
     602:	0e 94 4f 02 	call	0x49e	; 0x49e <isValidState>
     606:	88 23       	and	r24, r24
     608:	09 f4       	brne	.+2      	; 0x60c <DIO_write+0x2e>
     60a:	7c c0       	rjmp	.+248    	; 0x704 <DIO_write+0x126>
		return WRONG_STATE;
		}
	switch (portNumber) {
     60c:	d2 34       	cpi	r29, 0x42	; 66
     60e:	29 f1       	breq	.+74     	; 0x65a <DIO_write+0x7c>
     610:	18 f4       	brcc	.+6      	; 0x618 <DIO_write+0x3a>
     612:	d1 34       	cpi	r29, 0x41	; 65
     614:	39 f0       	breq	.+14     	; 0x624 <DIO_write+0x46>
     616:	78 c0       	rjmp	.+240    	; 0x708 <DIO_write+0x12a>
     618:	d3 34       	cpi	r29, 0x43	; 67
     61a:	d1 f1       	breq	.+116    	; 0x690 <DIO_write+0xb2>
     61c:	d4 34       	cpi	r29, 0x44	; 68
     61e:	09 f4       	brne	.+2      	; 0x622 <DIO_write+0x44>
     620:	52 c0       	rjmp	.+164    	; 0x6c6 <DIO_write+0xe8>
     622:	72 c0       	rjmp	.+228    	; 0x708 <DIO_write+0x12a>
			case PORT_A:
				if (state == HIGH) {
     624:	11 30       	cpi	r17, 0x01	; 1
     626:	61 f4       	brne	.+24     	; 0x640 <DIO_write+0x62>
					set_bit(PORTA, pinNumber);
     628:	2b b3       	in	r18, 0x1b	; 27
     62a:	81 e0       	ldi	r24, 0x01	; 1
     62c:	90 e0       	ldi	r25, 0x00	; 0
     62e:	02 c0       	rjmp	.+4      	; 0x634 <DIO_write+0x56>
     630:	88 0f       	add	r24, r24
     632:	99 1f       	adc	r25, r25
     634:	ca 95       	dec	r28
     636:	e2 f7       	brpl	.-8      	; 0x630 <DIO_write+0x52>
     638:	82 2b       	or	r24, r18
     63a:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     63c:	80 e0       	ldi	r24, 0x00	; 0
     63e:	65 c0       	rjmp	.+202    	; 0x70a <DIO_write+0x12c>
			case PORT_A:
				if (state == HIGH) {
					set_bit(PORTA, pinNumber);
					}
				else {
					clear_bit(PORTA, pinNumber);
     640:	2b b3       	in	r18, 0x1b	; 27
     642:	81 e0       	ldi	r24, 0x01	; 1
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	02 c0       	rjmp	.+4      	; 0x64c <DIO_write+0x6e>
     648:	88 0f       	add	r24, r24
     64a:	99 1f       	adc	r25, r25
     64c:	ca 95       	dec	r28
     64e:	e2 f7       	brpl	.-8      	; 0x648 <DIO_write+0x6a>
     650:	80 95       	com	r24
     652:	82 23       	and	r24, r18
     654:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     656:	80 e0       	ldi	r24, 0x00	; 0
     658:	58 c0       	rjmp	.+176    	; 0x70a <DIO_write+0x12c>
				else {
					clear_bit(PORTA, pinNumber);
					}
				break;
			case PORT_B:
				if (state == HIGH) {
     65a:	11 30       	cpi	r17, 0x01	; 1
     65c:	61 f4       	brne	.+24     	; 0x676 <DIO_write+0x98>
					set_bit(PORTB, pinNumber);
     65e:	28 b3       	in	r18, 0x18	; 24
     660:	81 e0       	ldi	r24, 0x01	; 1
     662:	90 e0       	ldi	r25, 0x00	; 0
     664:	02 c0       	rjmp	.+4      	; 0x66a <DIO_write+0x8c>
     666:	88 0f       	add	r24, r24
     668:	99 1f       	adc	r25, r25
     66a:	ca 95       	dec	r28
     66c:	e2 f7       	brpl	.-8      	; 0x666 <DIO_write+0x88>
     66e:	82 2b       	or	r24, r18
     670:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     672:	80 e0       	ldi	r24, 0x00	; 0
     674:	4a c0       	rjmp	.+148    	; 0x70a <DIO_write+0x12c>
			case PORT_B:
				if (state == HIGH) {
					set_bit(PORTB, pinNumber);
					}
				else {
					clear_bit(PORTB, pinNumber);
     676:	28 b3       	in	r18, 0x18	; 24
     678:	81 e0       	ldi	r24, 0x01	; 1
     67a:	90 e0       	ldi	r25, 0x00	; 0
     67c:	02 c0       	rjmp	.+4      	; 0x682 <DIO_write+0xa4>
     67e:	88 0f       	add	r24, r24
     680:	99 1f       	adc	r25, r25
     682:	ca 95       	dec	r28
     684:	e2 f7       	brpl	.-8      	; 0x67e <DIO_write+0xa0>
     686:	80 95       	com	r24
     688:	82 23       	and	r24, r18
     68a:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     68c:	80 e0       	ldi	r24, 0x00	; 0
     68e:	3d c0       	rjmp	.+122    	; 0x70a <DIO_write+0x12c>
				else {
					clear_bit(PORTB, pinNumber);
					}
				break;
			case PORT_C:
				if (state == HIGH) {
     690:	11 30       	cpi	r17, 0x01	; 1
     692:	61 f4       	brne	.+24     	; 0x6ac <DIO_write+0xce>
					set_bit(PORTC, pinNumber);
     694:	25 b3       	in	r18, 0x15	; 21
     696:	81 e0       	ldi	r24, 0x01	; 1
     698:	90 e0       	ldi	r25, 0x00	; 0
     69a:	02 c0       	rjmp	.+4      	; 0x6a0 <DIO_write+0xc2>
     69c:	88 0f       	add	r24, r24
     69e:	99 1f       	adc	r25, r25
     6a0:	ca 95       	dec	r28
     6a2:	e2 f7       	brpl	.-8      	; 0x69c <DIO_write+0xbe>
     6a4:	82 2b       	or	r24, r18
     6a6:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     6a8:	80 e0       	ldi	r24, 0x00	; 0
     6aa:	2f c0       	rjmp	.+94     	; 0x70a <DIO_write+0x12c>
			case PORT_C:
				if (state == HIGH) {
					set_bit(PORTC, pinNumber);
					}
				else {
					clear_bit(PORTC, pinNumber);
     6ac:	25 b3       	in	r18, 0x15	; 21
     6ae:	81 e0       	ldi	r24, 0x01	; 1
     6b0:	90 e0       	ldi	r25, 0x00	; 0
     6b2:	02 c0       	rjmp	.+4      	; 0x6b8 <DIO_write+0xda>
     6b4:	88 0f       	add	r24, r24
     6b6:	99 1f       	adc	r25, r25
     6b8:	ca 95       	dec	r28
     6ba:	e2 f7       	brpl	.-8      	; 0x6b4 <DIO_write+0xd6>
     6bc:	80 95       	com	r24
     6be:	82 23       	and	r24, r18
     6c0:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     6c2:	80 e0       	ldi	r24, 0x00	; 0
     6c4:	22 c0       	rjmp	.+68     	; 0x70a <DIO_write+0x12c>
				else {
					clear_bit(PORTC, pinNumber);
					}
				break;
			case PORT_D:
				if (state == HIGH) {
     6c6:	11 30       	cpi	r17, 0x01	; 1
     6c8:	61 f4       	brne	.+24     	; 0x6e2 <DIO_write+0x104>
					set_bit(PORTD, pinNumber);
     6ca:	22 b3       	in	r18, 0x12	; 18
     6cc:	81 e0       	ldi	r24, 0x01	; 1
     6ce:	90 e0       	ldi	r25, 0x00	; 0
     6d0:	02 c0       	rjmp	.+4      	; 0x6d6 <DIO_write+0xf8>
     6d2:	88 0f       	add	r24, r24
     6d4:	99 1f       	adc	r25, r25
     6d6:	ca 95       	dec	r28
     6d8:	e2 f7       	brpl	.-8      	; 0x6d2 <DIO_write+0xf4>
     6da:	82 2b       	or	r24, r18
     6dc:	82 bb       	out	0x12, r24	; 18
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     6de:	80 e0       	ldi	r24, 0x00	; 0
     6e0:	14 c0       	rjmp	.+40     	; 0x70a <DIO_write+0x12c>
			case PORT_D:
				if (state == HIGH) {
					set_bit(PORTD, pinNumber);
					}
				else {
					clear_bit(PORTD, pinNumber);
     6e2:	22 b3       	in	r18, 0x12	; 18
     6e4:	81 e0       	ldi	r24, 0x01	; 1
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	02 c0       	rjmp	.+4      	; 0x6ee <DIO_write+0x110>
     6ea:	88 0f       	add	r24, r24
     6ec:	99 1f       	adc	r25, r25
     6ee:	ca 95       	dec	r28
     6f0:	e2 f7       	brpl	.-8      	; 0x6ea <DIO_write+0x10c>
     6f2:	80 95       	com	r24
     6f4:	82 23       	and	r24, r18
     6f6:	82 bb       	out	0x12, r24	; 18
					}
				break;
		}
	return DIO_OK;
     6f8:	80 e0       	ldi	r24, 0x00	; 0
     6fa:	07 c0       	rjmp	.+14     	; 0x70a <DIO_write+0x12c>

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     6fc:	81 e0       	ldi	r24, 0x01	; 1
     6fe:	05 c0       	rjmp	.+10     	; 0x70a <DIO_write+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     700:	82 e0       	ldi	r24, 0x02	; 2
     702:	03 c0       	rjmp	.+6      	; 0x70a <DIO_write+0x12c>
		}
	// Validate the pin state
	if (!isValidState(state)) {
		return WRONG_STATE;
     704:	84 e0       	ldi	r24, 0x04	; 4
     706:	01 c0       	rjmp	.+2      	; 0x70a <DIO_write+0x12c>
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     708:	80 e0       	ldi	r24, 0x00	; 0
	}
     70a:	df 91       	pop	r29
     70c:	cf 91       	pop	r28
     70e:	1f 91       	pop	r17
     710:	08 95       	ret

00000712 <getCurrentStatus>:

EN_I2CMasterStatusCode_t I2C_repeatedStart() {   // Same as start, just a different name
  TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  while (read_bit(TWCR, TWINT) == 0);
  return getCurrentStatus();
  }
     712:	81 b1       	in	r24, 0x01	; 1
     714:	e8 2f       	mov	r30, r24
     716:	e8 7f       	andi	r30, 0xF8	; 248
     718:	8e 2f       	mov	r24, r30
     71a:	90 e0       	ldi	r25, 0x00	; 0
     71c:	fc 01       	movw	r30, r24
     71e:	38 97       	sbiw	r30, 0x08	; 8
     720:	e1 35       	cpi	r30, 0x51	; 81
     722:	f1 05       	cpc	r31, r1
     724:	c0 f4       	brcc	.+48     	; 0x756 <getCurrentStatus+0x44>
     726:	e6 5d       	subi	r30, 0xD6	; 214
     728:	ff 4f       	sbci	r31, 0xFF	; 255
     72a:	0c 94 c2 10 	jmp	0x2184	; 0x2184 <__tablejump2__>
     72e:	80 e0       	ldi	r24, 0x00	; 0
     730:	08 95       	ret
     732:	82 e0       	ldi	r24, 0x02	; 2
     734:	08 95       	ret
     736:	83 e0       	ldi	r24, 0x03	; 3
     738:	08 95       	ret
     73a:	84 e0       	ldi	r24, 0x04	; 4
     73c:	08 95       	ret
     73e:	85 e0       	ldi	r24, 0x05	; 5
     740:	08 95       	ret
     742:	86 e0       	ldi	r24, 0x06	; 6
     744:	08 95       	ret
     746:	87 e0       	ldi	r24, 0x07	; 7
     748:	08 95       	ret
     74a:	88 e0       	ldi	r24, 0x08	; 8
     74c:	08 95       	ret
     74e:	89 e0       	ldi	r24, 0x09	; 9
     750:	08 95       	ret
     752:	8a e0       	ldi	r24, 0x0A	; 10
     754:	08 95       	ret
     756:	8b e0       	ldi	r24, 0x0B	; 11
     758:	08 95       	ret
     75a:	81 e0       	ldi	r24, 0x01	; 1
     75c:	08 95       	ret

0000075e <I2C_init>:
     75e:	11 b8       	out	0x01, r1	; 1
     760:	8f ef       	ldi	r24, 0xFF	; 255
     762:	80 b9       	out	0x00, r24	; 0
     764:	08 95       	ret

00000766 <I2C_start>:
     766:	84 ea       	ldi	r24, 0xA4	; 164
     768:	86 bf       	out	0x36, r24	; 54
     76a:	06 b6       	in	r0, 0x36	; 54
     76c:	07 fe       	sbrs	r0, 7
     76e:	fd cf       	rjmp	.-6      	; 0x76a <I2C_start+0x4>
     770:	0e 94 89 03 	call	0x712	; 0x712 <getCurrentStatus>
     774:	08 95       	ret

00000776 <I2C_write>:

EN_I2CMasterStatusCode_t I2C_write(u8 data) {
  TWDR = data;
     776:	83 b9       	out	0x03, r24	; 3
  TWCR = (1 << TWEN) | (1 << TWINT);
     778:	84 e8       	ldi	r24, 0x84	; 132
     77a:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWINT) == 0);
     77c:	06 b6       	in	r0, 0x36	; 54
     77e:	07 fe       	sbrs	r0, 7
     780:	fd cf       	rjmp	.-6      	; 0x77c <I2C_write+0x6>
  return getCurrentStatus();
     782:	0e 94 89 03 	call	0x712	; 0x712 <getCurrentStatus>
  }
     786:	08 95       	ret

00000788 <I2C_read_Ack>:

EN_I2CMasterStatusCode_t I2C_read_Ack(u8* data) {
  TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWINT);
     788:	24 ec       	ldi	r18, 0xC4	; 196
     78a:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     78c:	06 b6       	in	r0, 0x36	; 54
     78e:	07 fe       	sbrs	r0, 7
     790:	fd cf       	rjmp	.-6      	; 0x78c <I2C_read_Ack+0x4>
  *data = TWDR;
     792:	23 b1       	in	r18, 0x03	; 3
     794:	fc 01       	movw	r30, r24
     796:	20 83       	st	Z, r18
  return getCurrentStatus();
     798:	0e 94 89 03 	call	0x712	; 0x712 <getCurrentStatus>
  }
     79c:	08 95       	ret

0000079e <I2C_read_Nack>:

EN_I2CMasterStatusCode_t I2C_read_Nack(u8* data) {
  TWCR = (1 << TWEN) | (1 << TWINT);
     79e:	24 e8       	ldi	r18, 0x84	; 132
     7a0:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     7a2:	06 b6       	in	r0, 0x36	; 54
     7a4:	07 fe       	sbrs	r0, 7
     7a6:	fd cf       	rjmp	.-6      	; 0x7a2 <I2C_read_Nack+0x4>
  *data = TWDR;
     7a8:	23 b1       	in	r18, 0x03	; 3
     7aa:	fc 01       	movw	r30, r24
     7ac:	20 83       	st	Z, r18
  return getCurrentStatus();
     7ae:	0e 94 89 03 	call	0x712	; 0x712 <getCurrentStatus>
  }
     7b2:	08 95       	ret

000007b4 <I2C_stop>:

void I2C_stop(void) {
  TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
     7b4:	84 e9       	ldi	r24, 0x94	; 148
     7b6:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWSTO));	// Wait until stop condition finishes
     7b8:	06 b6       	in	r0, 0x36	; 54
     7ba:	04 fc       	sbrc	r0, 4
     7bc:	fd cf       	rjmp	.-6      	; 0x7b8 <I2C_stop+0x4>
  }
     7be:	08 95       	ret

000007c0 <INT0_init>:
// Initialize the ADC conversion complete interrupt
EN_INT_init_Status_t ADC_INT_init(void) {
  // Enable the ADC conversion complete interrupt
  set_bit(ADCSRA, ADIE);
  return INTERRUPT_INIT_OK;
  }
     7c0:	84 30       	cpi	r24, 0x04	; 4
     7c2:	c8 f4       	brcc	.+50     	; 0x7f6 <INT0_init+0x36>
     7c4:	82 30       	cpi	r24, 0x02	; 2
     7c6:	41 f0       	breq	.+16     	; 0x7d8 <INT0_init+0x18>
     7c8:	83 30       	cpi	r24, 0x03	; 3
     7ca:	51 f0       	breq	.+20     	; 0x7e0 <INT0_init+0x20>
     7cc:	81 30       	cpi	r24, 0x01	; 1
     7ce:	71 f4       	brne	.+28     	; 0x7ec <INT0_init+0x2c>
     7d0:	85 b7       	in	r24, 0x35	; 53
     7d2:	81 60       	ori	r24, 0x01	; 1
     7d4:	85 bf       	out	0x35, r24	; 53
     7d6:	0a c0       	rjmp	.+20     	; 0x7ec <INT0_init+0x2c>
     7d8:	85 b7       	in	r24, 0x35	; 53
     7da:	82 60       	ori	r24, 0x02	; 2
     7dc:	85 bf       	out	0x35, r24	; 53
     7de:	06 c0       	rjmp	.+12     	; 0x7ec <INT0_init+0x2c>
     7e0:	85 b7       	in	r24, 0x35	; 53
     7e2:	81 60       	ori	r24, 0x01	; 1
     7e4:	85 bf       	out	0x35, r24	; 53
     7e6:	85 b7       	in	r24, 0x35	; 53
     7e8:	82 60       	ori	r24, 0x02	; 2
     7ea:	85 bf       	out	0x35, r24	; 53
     7ec:	8b b7       	in	r24, 0x3b	; 59
     7ee:	80 64       	ori	r24, 0x40	; 64
     7f0:	8b bf       	out	0x3b, r24	; 59
     7f2:	80 e0       	ldi	r24, 0x00	; 0
     7f4:	08 95       	ret
     7f6:	81 e0       	ldi	r24, 0x01	; 1
     7f8:	08 95       	ret

000007fa <UART_RXC_INT_init>:

// Initialize the UART RX complete interrupt
EN_INT_init_Status_t UART_RXC_INT_init(void) {
  // Enable the UART RX complete interrupt
  set_bit(UCSRB, RXCIE);
     7fa:	8a b1       	in	r24, 0x0a	; 10
     7fc:	80 68       	ori	r24, 0x80	; 128
     7fe:	8a b9       	out	0x0a, r24	; 10
  return INTERRUPT_INIT_OK;
     800:	80 e0       	ldi	r24, 0x00	; 0
     802:	08 95       	ret

00000804 <isValidTimer>:
        clear_bit(TCCR2, COM21);
        set_prescalar(TIMER_2, 0);
        break;
    }
  return TIMER_OK;
  }
     804:	83 30       	cpi	r24, 0x03	; 3
     806:	10 f4       	brcc	.+4      	; 0x80c <isValidTimer+0x8>
     808:	81 e0       	ldi	r24, 0x01	; 1
     80a:	08 95       	ret
     80c:	80 e0       	ldi	r24, 0x00	; 0
     80e:	08 95       	ret

00000810 <set_prescalar>:
     810:	1f 93       	push	r17
     812:	cf 93       	push	r28
     814:	df 93       	push	r29
     816:	18 2f       	mov	r17, r24
     818:	eb 01       	movw	r28, r22
     81a:	0e 94 02 04 	call	0x804	; 0x804 <isValidTimer>
     81e:	88 23       	and	r24, r24
     820:	09 f4       	brne	.+2      	; 0x824 <set_prescalar+0x14>
     822:	6a c1       	rjmp	.+724    	; 0xaf8 <__stack+0x299>
     824:	11 30       	cpi	r17, 0x01	; 1
     826:	09 f4       	brne	.+2      	; 0x82a <set_prescalar+0x1a>
     828:	6f c0       	rjmp	.+222    	; 0x908 <__stack+0xa9>
     82a:	20 f0       	brcs	.+8      	; 0x834 <set_prescalar+0x24>
     82c:	12 30       	cpi	r17, 0x02	; 2
     82e:	09 f4       	brne	.+2      	; 0x832 <set_prescalar+0x22>
     830:	d5 c0       	rjmp	.+426    	; 0x9dc <__stack+0x17d>
     832:	64 c1       	rjmp	.+712    	; 0xafc <__stack+0x29d>
     834:	c2 30       	cpi	r28, 0x02	; 2
     836:	d1 05       	cpc	r29, r1
     838:	78 f0       	brcs	.+30     	; 0x858 <set_prescalar+0x48>
     83a:	c8 30       	cpi	r28, 0x08	; 8
     83c:	d1 05       	cpc	r29, r1
     83e:	61 f0       	breq	.+24     	; 0x858 <set_prescalar+0x48>
     840:	c0 34       	cpi	r28, 0x40	; 64
     842:	d1 05       	cpc	r29, r1
     844:	49 f0       	breq	.+18     	; 0x858 <set_prescalar+0x48>
     846:	c1 15       	cp	r28, r1
     848:	81 e0       	ldi	r24, 0x01	; 1
     84a:	d8 07       	cpc	r29, r24
     84c:	29 f0       	breq	.+10     	; 0x858 <set_prescalar+0x48>
     84e:	c1 15       	cp	r28, r1
     850:	84 e0       	ldi	r24, 0x04	; 4
     852:	d8 07       	cpc	r29, r24
     854:	09 f0       	breq	.+2      	; 0x858 <set_prescalar+0x48>
     856:	54 c1       	rjmp	.+680    	; 0xb00 <__stack+0x2a1>
     858:	c8 30       	cpi	r28, 0x08	; 8
     85a:	d1 05       	cpc	r29, r1
     85c:	49 f1       	breq	.+82     	; 0x8b0 <__stack+0x51>
     85e:	28 f4       	brcc	.+10     	; 0x86a <__stack+0xb>
     860:	20 97       	sbiw	r28, 0x00	; 0
     862:	81 f0       	breq	.+32     	; 0x884 <__stack+0x25>
     864:	21 97       	sbiw	r28, 0x01	; 1
     866:	c9 f0       	breq	.+50     	; 0x89a <__stack+0x3b>
     868:	4d c1       	rjmp	.+666    	; 0xb04 <__stack+0x2a5>
     86a:	c1 15       	cp	r28, r1
     86c:	81 e0       	ldi	r24, 0x01	; 1
     86e:	d8 07       	cpc	r29, r24
     870:	a9 f1       	breq	.+106    	; 0x8dc <__stack+0x7d>
     872:	c1 15       	cp	r28, r1
     874:	84 e0       	ldi	r24, 0x04	; 4
     876:	d8 07       	cpc	r29, r24
     878:	e1 f1       	breq	.+120    	; 0x8f2 <__stack+0x93>
     87a:	c0 34       	cpi	r28, 0x40	; 64
     87c:	d1 05       	cpc	r29, r1
     87e:	09 f0       	breq	.+2      	; 0x882 <__stack+0x23>
     880:	41 c1       	rjmp	.+642    	; 0xb04 <__stack+0x2a5>
     882:	21 c0       	rjmp	.+66     	; 0x8c6 <__stack+0x67>
     884:	83 b7       	in	r24, 0x33	; 51
     886:	8e 7f       	andi	r24, 0xFE	; 254
     888:	83 bf       	out	0x33, r24	; 51
     88a:	83 b7       	in	r24, 0x33	; 51
     88c:	8d 7f       	andi	r24, 0xFD	; 253
     88e:	83 bf       	out	0x33, r24	; 51
     890:	83 b7       	in	r24, 0x33	; 51
     892:	8b 7f       	andi	r24, 0xFB	; 251
     894:	83 bf       	out	0x33, r24	; 51
     896:	80 e0       	ldi	r24, 0x00	; 0
     898:	3e c1       	rjmp	.+636    	; 0xb16 <__stack+0x2b7>
     89a:	83 b7       	in	r24, 0x33	; 51
     89c:	81 60       	ori	r24, 0x01	; 1
     89e:	83 bf       	out	0x33, r24	; 51
     8a0:	83 b7       	in	r24, 0x33	; 51
     8a2:	8d 7f       	andi	r24, 0xFD	; 253
     8a4:	83 bf       	out	0x33, r24	; 51
     8a6:	83 b7       	in	r24, 0x33	; 51
     8a8:	8b 7f       	andi	r24, 0xFB	; 251
     8aa:	83 bf       	out	0x33, r24	; 51
     8ac:	80 e0       	ldi	r24, 0x00	; 0
     8ae:	33 c1       	rjmp	.+614    	; 0xb16 <__stack+0x2b7>
     8b0:	83 b7       	in	r24, 0x33	; 51
     8b2:	8e 7f       	andi	r24, 0xFE	; 254
     8b4:	83 bf       	out	0x33, r24	; 51
     8b6:	83 b7       	in	r24, 0x33	; 51
     8b8:	82 60       	ori	r24, 0x02	; 2
     8ba:	83 bf       	out	0x33, r24	; 51
     8bc:	83 b7       	in	r24, 0x33	; 51
     8be:	8b 7f       	andi	r24, 0xFB	; 251
     8c0:	83 bf       	out	0x33, r24	; 51
     8c2:	80 e0       	ldi	r24, 0x00	; 0
     8c4:	28 c1       	rjmp	.+592    	; 0xb16 <__stack+0x2b7>
     8c6:	83 b7       	in	r24, 0x33	; 51
     8c8:	81 60       	ori	r24, 0x01	; 1
     8ca:	83 bf       	out	0x33, r24	; 51
     8cc:	83 b7       	in	r24, 0x33	; 51
     8ce:	82 60       	ori	r24, 0x02	; 2
     8d0:	83 bf       	out	0x33, r24	; 51
     8d2:	83 b7       	in	r24, 0x33	; 51
     8d4:	8b 7f       	andi	r24, 0xFB	; 251
     8d6:	83 bf       	out	0x33, r24	; 51
     8d8:	80 e0       	ldi	r24, 0x00	; 0
     8da:	1d c1       	rjmp	.+570    	; 0xb16 <__stack+0x2b7>
     8dc:	83 b7       	in	r24, 0x33	; 51
     8de:	8e 7f       	andi	r24, 0xFE	; 254
     8e0:	83 bf       	out	0x33, r24	; 51
     8e2:	83 b7       	in	r24, 0x33	; 51
     8e4:	8d 7f       	andi	r24, 0xFD	; 253
     8e6:	83 bf       	out	0x33, r24	; 51
     8e8:	83 b7       	in	r24, 0x33	; 51
     8ea:	84 60       	ori	r24, 0x04	; 4
     8ec:	83 bf       	out	0x33, r24	; 51
     8ee:	80 e0       	ldi	r24, 0x00	; 0
     8f0:	12 c1       	rjmp	.+548    	; 0xb16 <__stack+0x2b7>
     8f2:	83 b7       	in	r24, 0x33	; 51
     8f4:	81 60       	ori	r24, 0x01	; 1
     8f6:	83 bf       	out	0x33, r24	; 51
     8f8:	83 b7       	in	r24, 0x33	; 51
     8fa:	8d 7f       	andi	r24, 0xFD	; 253
     8fc:	83 bf       	out	0x33, r24	; 51
     8fe:	83 b7       	in	r24, 0x33	; 51
     900:	84 60       	ori	r24, 0x04	; 4
     902:	83 bf       	out	0x33, r24	; 51
     904:	80 e0       	ldi	r24, 0x00	; 0
     906:	07 c1       	rjmp	.+526    	; 0xb16 <__stack+0x2b7>
     908:	c2 30       	cpi	r28, 0x02	; 2
     90a:	d1 05       	cpc	r29, r1
     90c:	78 f0       	brcs	.+30     	; 0x92c <__stack+0xcd>
     90e:	c8 30       	cpi	r28, 0x08	; 8
     910:	d1 05       	cpc	r29, r1
     912:	61 f0       	breq	.+24     	; 0x92c <__stack+0xcd>
     914:	c0 34       	cpi	r28, 0x40	; 64
     916:	d1 05       	cpc	r29, r1
     918:	49 f0       	breq	.+18     	; 0x92c <__stack+0xcd>
     91a:	c1 15       	cp	r28, r1
     91c:	81 e0       	ldi	r24, 0x01	; 1
     91e:	d8 07       	cpc	r29, r24
     920:	29 f0       	breq	.+10     	; 0x92c <__stack+0xcd>
     922:	c1 15       	cp	r28, r1
     924:	84 e0       	ldi	r24, 0x04	; 4
     926:	d8 07       	cpc	r29, r24
     928:	09 f0       	breq	.+2      	; 0x92c <__stack+0xcd>
     92a:	ee c0       	rjmp	.+476    	; 0xb08 <__stack+0x2a9>
     92c:	c8 30       	cpi	r28, 0x08	; 8
     92e:	d1 05       	cpc	r29, r1
     930:	49 f1       	breq	.+82     	; 0x984 <__stack+0x125>
     932:	28 f4       	brcc	.+10     	; 0x93e <__stack+0xdf>
     934:	20 97       	sbiw	r28, 0x00	; 0
     936:	81 f0       	breq	.+32     	; 0x958 <__stack+0xf9>
     938:	21 97       	sbiw	r28, 0x01	; 1
     93a:	c9 f0       	breq	.+50     	; 0x96e <__stack+0x10f>
     93c:	e7 c0       	rjmp	.+462    	; 0xb0c <__stack+0x2ad>
     93e:	c1 15       	cp	r28, r1
     940:	81 e0       	ldi	r24, 0x01	; 1
     942:	d8 07       	cpc	r29, r24
     944:	a9 f1       	breq	.+106    	; 0x9b0 <__stack+0x151>
     946:	c1 15       	cp	r28, r1
     948:	84 e0       	ldi	r24, 0x04	; 4
     94a:	d8 07       	cpc	r29, r24
     94c:	e1 f1       	breq	.+120    	; 0x9c6 <__stack+0x167>
     94e:	c0 34       	cpi	r28, 0x40	; 64
     950:	d1 05       	cpc	r29, r1
     952:	09 f0       	breq	.+2      	; 0x956 <__stack+0xf7>
     954:	db c0       	rjmp	.+438    	; 0xb0c <__stack+0x2ad>
     956:	21 c0       	rjmp	.+66     	; 0x99a <__stack+0x13b>
     958:	8e b5       	in	r24, 0x2e	; 46
     95a:	8e 7f       	andi	r24, 0xFE	; 254
     95c:	8e bd       	out	0x2e, r24	; 46
     95e:	8e b5       	in	r24, 0x2e	; 46
     960:	8d 7f       	andi	r24, 0xFD	; 253
     962:	8e bd       	out	0x2e, r24	; 46
     964:	8e b5       	in	r24, 0x2e	; 46
     966:	8b 7f       	andi	r24, 0xFB	; 251
     968:	8e bd       	out	0x2e, r24	; 46
     96a:	80 e0       	ldi	r24, 0x00	; 0
     96c:	d4 c0       	rjmp	.+424    	; 0xb16 <__stack+0x2b7>
     96e:	8e b5       	in	r24, 0x2e	; 46
     970:	81 60       	ori	r24, 0x01	; 1
     972:	8e bd       	out	0x2e, r24	; 46
     974:	8e b5       	in	r24, 0x2e	; 46
     976:	8d 7f       	andi	r24, 0xFD	; 253
     978:	8e bd       	out	0x2e, r24	; 46
     97a:	8e b5       	in	r24, 0x2e	; 46
     97c:	8b 7f       	andi	r24, 0xFB	; 251
     97e:	8e bd       	out	0x2e, r24	; 46
     980:	80 e0       	ldi	r24, 0x00	; 0
     982:	c9 c0       	rjmp	.+402    	; 0xb16 <__stack+0x2b7>
     984:	8e b5       	in	r24, 0x2e	; 46
     986:	8e 7f       	andi	r24, 0xFE	; 254
     988:	8e bd       	out	0x2e, r24	; 46
     98a:	8e b5       	in	r24, 0x2e	; 46
     98c:	82 60       	ori	r24, 0x02	; 2
     98e:	8e bd       	out	0x2e, r24	; 46
     990:	8e b5       	in	r24, 0x2e	; 46
     992:	8b 7f       	andi	r24, 0xFB	; 251
     994:	8e bd       	out	0x2e, r24	; 46
     996:	80 e0       	ldi	r24, 0x00	; 0
     998:	be c0       	rjmp	.+380    	; 0xb16 <__stack+0x2b7>
     99a:	8e b5       	in	r24, 0x2e	; 46
     99c:	81 60       	ori	r24, 0x01	; 1
     99e:	8e bd       	out	0x2e, r24	; 46
     9a0:	8e b5       	in	r24, 0x2e	; 46
     9a2:	82 60       	ori	r24, 0x02	; 2
     9a4:	8e bd       	out	0x2e, r24	; 46
     9a6:	8e b5       	in	r24, 0x2e	; 46
     9a8:	8b 7f       	andi	r24, 0xFB	; 251
     9aa:	8e bd       	out	0x2e, r24	; 46
     9ac:	80 e0       	ldi	r24, 0x00	; 0
     9ae:	b3 c0       	rjmp	.+358    	; 0xb16 <__stack+0x2b7>
     9b0:	8e b5       	in	r24, 0x2e	; 46
     9b2:	8e 7f       	andi	r24, 0xFE	; 254
     9b4:	8e bd       	out	0x2e, r24	; 46
     9b6:	8e b5       	in	r24, 0x2e	; 46
     9b8:	8d 7f       	andi	r24, 0xFD	; 253
     9ba:	8e bd       	out	0x2e, r24	; 46
     9bc:	8e b5       	in	r24, 0x2e	; 46
     9be:	84 60       	ori	r24, 0x04	; 4
     9c0:	8e bd       	out	0x2e, r24	; 46
     9c2:	80 e0       	ldi	r24, 0x00	; 0
     9c4:	a8 c0       	rjmp	.+336    	; 0xb16 <__stack+0x2b7>
     9c6:	8e b5       	in	r24, 0x2e	; 46
     9c8:	81 60       	ori	r24, 0x01	; 1
     9ca:	8e bd       	out	0x2e, r24	; 46
     9cc:	8e b5       	in	r24, 0x2e	; 46
     9ce:	8d 7f       	andi	r24, 0xFD	; 253
     9d0:	8e bd       	out	0x2e, r24	; 46
     9d2:	8e b5       	in	r24, 0x2e	; 46
     9d4:	84 60       	ori	r24, 0x04	; 4
     9d6:	8e bd       	out	0x2e, r24	; 46
     9d8:	80 e0       	ldi	r24, 0x00	; 0
     9da:	9d c0       	rjmp	.+314    	; 0xb16 <__stack+0x2b7>
     9dc:	c2 30       	cpi	r28, 0x02	; 2
     9de:	d1 05       	cpc	r29, r1
     9e0:	a8 f0       	brcs	.+42     	; 0xa0c <__stack+0x1ad>
     9e2:	c8 30       	cpi	r28, 0x08	; 8
     9e4:	d1 05       	cpc	r29, r1
     9e6:	91 f0       	breq	.+36     	; 0xa0c <__stack+0x1ad>
     9e8:	c0 32       	cpi	r28, 0x20	; 32
     9ea:	d1 05       	cpc	r29, r1
     9ec:	79 f0       	breq	.+30     	; 0xa0c <__stack+0x1ad>
     9ee:	c0 34       	cpi	r28, 0x40	; 64
     9f0:	d1 05       	cpc	r29, r1
     9f2:	61 f0       	breq	.+24     	; 0xa0c <__stack+0x1ad>
     9f4:	c0 38       	cpi	r28, 0x80	; 128
     9f6:	d1 05       	cpc	r29, r1
     9f8:	49 f0       	breq	.+18     	; 0xa0c <__stack+0x1ad>
     9fa:	c1 15       	cp	r28, r1
     9fc:	81 e0       	ldi	r24, 0x01	; 1
     9fe:	d8 07       	cpc	r29, r24
     a00:	29 f0       	breq	.+10     	; 0xa0c <__stack+0x1ad>
     a02:	c1 15       	cp	r28, r1
     a04:	84 e0       	ldi	r24, 0x04	; 4
     a06:	d8 07       	cpc	r29, r24
     a08:	09 f0       	breq	.+2      	; 0xa0c <__stack+0x1ad>
     a0a:	82 c0       	rjmp	.+260    	; 0xb10 <__stack+0x2b1>
     a0c:	c0 32       	cpi	r28, 0x20	; 32
     a0e:	d1 05       	cpc	r29, r1
     a10:	e1 f1       	breq	.+120    	; 0xa8a <__stack+0x22b>
     a12:	38 f4       	brcc	.+14     	; 0xa22 <__stack+0x1c3>
     a14:	c1 30       	cpi	r28, 0x01	; 1
     a16:	d1 05       	cpc	r29, r1
     a18:	11 f1       	breq	.+68     	; 0xa5e <__stack+0x1ff>
     a1a:	b0 f0       	brcs	.+44     	; 0xa48 <__stack+0x1e9>
     a1c:	28 97       	sbiw	r28, 0x08	; 8
     a1e:	51 f1       	breq	.+84     	; 0xa74 <__stack+0x215>
     a20:	79 c0       	rjmp	.+242    	; 0xb14 <__stack+0x2b5>
     a22:	c0 38       	cpi	r28, 0x80	; 128
     a24:	d1 05       	cpc	r29, r1
     a26:	09 f4       	brne	.+2      	; 0xa2a <__stack+0x1cb>
     a28:	46 c0       	rjmp	.+140    	; 0xab6 <__stack+0x257>
     a2a:	20 f4       	brcc	.+8      	; 0xa34 <__stack+0x1d5>
     a2c:	c0 34       	cpi	r28, 0x40	; 64
     a2e:	d1 05       	cpc	r29, r1
     a30:	b9 f1       	breq	.+110    	; 0xaa0 <__stack+0x241>
     a32:	70 c0       	rjmp	.+224    	; 0xb14 <__stack+0x2b5>
     a34:	c1 15       	cp	r28, r1
     a36:	81 e0       	ldi	r24, 0x01	; 1
     a38:	d8 07       	cpc	r29, r24
     a3a:	09 f4       	brne	.+2      	; 0xa3e <__stack+0x1df>
     a3c:	47 c0       	rjmp	.+142    	; 0xacc <__stack+0x26d>
     a3e:	c1 15       	cp	r28, r1
     a40:	d4 40       	sbci	r29, 0x04	; 4
     a42:	09 f4       	brne	.+2      	; 0xa46 <__stack+0x1e7>
     a44:	4e c0       	rjmp	.+156    	; 0xae2 <__stack+0x283>
     a46:	66 c0       	rjmp	.+204    	; 0xb14 <__stack+0x2b5>
     a48:	85 b5       	in	r24, 0x25	; 37
     a4a:	8e 7f       	andi	r24, 0xFE	; 254
     a4c:	85 bd       	out	0x25, r24	; 37
     a4e:	85 b5       	in	r24, 0x25	; 37
     a50:	8d 7f       	andi	r24, 0xFD	; 253
     a52:	85 bd       	out	0x25, r24	; 37
     a54:	85 b5       	in	r24, 0x25	; 37
     a56:	8b 7f       	andi	r24, 0xFB	; 251
     a58:	85 bd       	out	0x25, r24	; 37
     a5a:	80 e0       	ldi	r24, 0x00	; 0
     a5c:	5c c0       	rjmp	.+184    	; 0xb16 <__stack+0x2b7>
     a5e:	85 b5       	in	r24, 0x25	; 37
     a60:	81 60       	ori	r24, 0x01	; 1
     a62:	85 bd       	out	0x25, r24	; 37
     a64:	85 b5       	in	r24, 0x25	; 37
     a66:	8d 7f       	andi	r24, 0xFD	; 253
     a68:	85 bd       	out	0x25, r24	; 37
     a6a:	85 b5       	in	r24, 0x25	; 37
     a6c:	8b 7f       	andi	r24, 0xFB	; 251
     a6e:	85 bd       	out	0x25, r24	; 37
     a70:	80 e0       	ldi	r24, 0x00	; 0
     a72:	51 c0       	rjmp	.+162    	; 0xb16 <__stack+0x2b7>
     a74:	85 b5       	in	r24, 0x25	; 37
     a76:	8e 7f       	andi	r24, 0xFE	; 254
     a78:	85 bd       	out	0x25, r24	; 37
     a7a:	85 b5       	in	r24, 0x25	; 37
     a7c:	82 60       	ori	r24, 0x02	; 2
     a7e:	85 bd       	out	0x25, r24	; 37
     a80:	85 b5       	in	r24, 0x25	; 37
     a82:	8b 7f       	andi	r24, 0xFB	; 251
     a84:	85 bd       	out	0x25, r24	; 37
     a86:	80 e0       	ldi	r24, 0x00	; 0
     a88:	46 c0       	rjmp	.+140    	; 0xb16 <__stack+0x2b7>
     a8a:	85 b5       	in	r24, 0x25	; 37
     a8c:	81 60       	ori	r24, 0x01	; 1
     a8e:	85 bd       	out	0x25, r24	; 37
     a90:	85 b5       	in	r24, 0x25	; 37
     a92:	82 60       	ori	r24, 0x02	; 2
     a94:	85 bd       	out	0x25, r24	; 37
     a96:	85 b5       	in	r24, 0x25	; 37
     a98:	8b 7f       	andi	r24, 0xFB	; 251
     a9a:	85 bd       	out	0x25, r24	; 37
     a9c:	80 e0       	ldi	r24, 0x00	; 0
     a9e:	3b c0       	rjmp	.+118    	; 0xb16 <__stack+0x2b7>
     aa0:	85 b5       	in	r24, 0x25	; 37
     aa2:	8e 7f       	andi	r24, 0xFE	; 254
     aa4:	85 bd       	out	0x25, r24	; 37
     aa6:	85 b5       	in	r24, 0x25	; 37
     aa8:	8d 7f       	andi	r24, 0xFD	; 253
     aaa:	85 bd       	out	0x25, r24	; 37
     aac:	85 b5       	in	r24, 0x25	; 37
     aae:	84 60       	ori	r24, 0x04	; 4
     ab0:	85 bd       	out	0x25, r24	; 37
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	30 c0       	rjmp	.+96     	; 0xb16 <__stack+0x2b7>
     ab6:	85 b5       	in	r24, 0x25	; 37
     ab8:	81 60       	ori	r24, 0x01	; 1
     aba:	85 bd       	out	0x25, r24	; 37
     abc:	85 b5       	in	r24, 0x25	; 37
     abe:	8d 7f       	andi	r24, 0xFD	; 253
     ac0:	85 bd       	out	0x25, r24	; 37
     ac2:	85 b5       	in	r24, 0x25	; 37
     ac4:	84 60       	ori	r24, 0x04	; 4
     ac6:	85 bd       	out	0x25, r24	; 37
     ac8:	80 e0       	ldi	r24, 0x00	; 0
     aca:	25 c0       	rjmp	.+74     	; 0xb16 <__stack+0x2b7>
     acc:	85 b5       	in	r24, 0x25	; 37
     ace:	8e 7f       	andi	r24, 0xFE	; 254
     ad0:	85 bd       	out	0x25, r24	; 37
     ad2:	85 b5       	in	r24, 0x25	; 37
     ad4:	82 60       	ori	r24, 0x02	; 2
     ad6:	85 bd       	out	0x25, r24	; 37
     ad8:	85 b5       	in	r24, 0x25	; 37
     ada:	84 60       	ori	r24, 0x04	; 4
     adc:	85 bd       	out	0x25, r24	; 37
     ade:	80 e0       	ldi	r24, 0x00	; 0
     ae0:	1a c0       	rjmp	.+52     	; 0xb16 <__stack+0x2b7>
     ae2:	85 b5       	in	r24, 0x25	; 37
     ae4:	81 60       	ori	r24, 0x01	; 1
     ae6:	85 bd       	out	0x25, r24	; 37
     ae8:	85 b5       	in	r24, 0x25	; 37
     aea:	82 60       	ori	r24, 0x02	; 2
     aec:	85 bd       	out	0x25, r24	; 37
     aee:	85 b5       	in	r24, 0x25	; 37
     af0:	84 60       	ori	r24, 0x04	; 4
     af2:	85 bd       	out	0x25, r24	; 37
     af4:	80 e0       	ldi	r24, 0x00	; 0
     af6:	0f c0       	rjmp	.+30     	; 0xb16 <__stack+0x2b7>
     af8:	81 e0       	ldi	r24, 0x01	; 1
     afa:	0d c0       	rjmp	.+26     	; 0xb16 <__stack+0x2b7>
     afc:	80 e0       	ldi	r24, 0x00	; 0
     afe:	0b c0       	rjmp	.+22     	; 0xb16 <__stack+0x2b7>
     b00:	82 e0       	ldi	r24, 0x02	; 2
     b02:	09 c0       	rjmp	.+18     	; 0xb16 <__stack+0x2b7>
     b04:	80 e0       	ldi	r24, 0x00	; 0
     b06:	07 c0       	rjmp	.+14     	; 0xb16 <__stack+0x2b7>
     b08:	82 e0       	ldi	r24, 0x02	; 2
     b0a:	05 c0       	rjmp	.+10     	; 0xb16 <__stack+0x2b7>
     b0c:	80 e0       	ldi	r24, 0x00	; 0
     b0e:	03 c0       	rjmp	.+6      	; 0xb16 <__stack+0x2b7>
     b10:	82 e0       	ldi	r24, 0x02	; 2
     b12:	01 c0       	rjmp	.+2      	; 0xb16 <__stack+0x2b7>
     b14:	80 e0       	ldi	r24, 0x00	; 0
     b16:	df 91       	pop	r29
     b18:	cf 91       	pop	r28
     b1a:	1f 91       	pop	r17
     b1c:	08 95       	ret

00000b1e <Timer_start>:
     b1e:	0f 93       	push	r16
     b20:	1f 93       	push	r17
     b22:	cf 93       	push	r28
     b24:	c8 2f       	mov	r28, r24
     b26:	8b 01       	movw	r16, r22
     b28:	0e 94 02 04 	call	0x804	; 0x804 <isValidTimer>
     b2c:	88 23       	and	r24, r24
     b2e:	31 f0       	breq	.+12     	; 0xb3c <Timer_start+0x1e>
     b30:	b8 01       	movw	r22, r16
     b32:	8c 2f       	mov	r24, r28
     b34:	0e 94 08 04 	call	0x810	; 0x810 <set_prescalar>
     b38:	80 e0       	ldi	r24, 0x00	; 0
     b3a:	01 c0       	rjmp	.+2      	; 0xb3e <Timer_start+0x20>
     b3c:	81 e0       	ldi	r24, 0x01	; 1
     b3e:	cf 91       	pop	r28
     b40:	1f 91       	pop	r17
     b42:	0f 91       	pop	r16
     b44:	08 95       	ret

00000b46 <PWM_OCP_disconnect>:

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
     b46:	84 30       	cpi	r24, 0x04	; 4
     b48:	40 f5       	brcc	.+80     	; 0xb9a <PWM_OCP_disconnect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
     b4a:	81 30       	cpi	r24, 0x01	; 1
     b4c:	71 f0       	breq	.+28     	; 0xb6a <PWM_OCP_disconnect+0x24>
     b4e:	28 f0       	brcs	.+10     	; 0xb5a <PWM_OCP_disconnect+0x14>
     b50:	82 30       	cpi	r24, 0x02	; 2
     b52:	99 f0       	breq	.+38     	; 0xb7a <PWM_OCP_disconnect+0x34>
     b54:	83 30       	cpi	r24, 0x03	; 3
     b56:	c9 f0       	breq	.+50     	; 0xb8a <PWM_OCP_disconnect+0x44>
     b58:	22 c0       	rjmp	.+68     	; 0xb9e <PWM_OCP_disconnect+0x58>
      case OC_0:
        clear_bit(TCCR0, COM00);
     b5a:	83 b7       	in	r24, 0x33	; 51
     b5c:	8f 7e       	andi	r24, 0xEF	; 239
     b5e:	83 bf       	out	0x33, r24	; 51
        clear_bit(TCCR0, COM01);
     b60:	83 b7       	in	r24, 0x33	; 51
     b62:	8f 7d       	andi	r24, 0xDF	; 223
     b64:	83 bf       	out	0x33, r24	; 51
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
     b66:	80 e0       	ldi	r24, 0x00	; 0
    }
  switch (pwmPin) {
      case OC_0:
        clear_bit(TCCR0, COM00);
        clear_bit(TCCR0, COM01);
        break;
     b68:	08 95       	ret
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
     b6a:	8f b5       	in	r24, 0x2f	; 47
     b6c:	8f 7b       	andi	r24, 0xBF	; 191
     b6e:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1A1);
     b70:	8f b5       	in	r24, 0x2f	; 47
     b72:	8f 77       	andi	r24, 0x7F	; 127
     b74:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
     b76:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR0, COM01);
        break;
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
        clear_bit(TCCR1A, COM1A1);
        break;
     b78:	08 95       	ret
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
     b7a:	8f b5       	in	r24, 0x2f	; 47
     b7c:	8f 7e       	andi	r24, 0xEF	; 239
     b7e:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1B1);
     b80:	8f b5       	in	r24, 0x2f	; 47
     b82:	8f 7d       	andi	r24, 0xDF	; 223
     b84:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
     b86:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1A1);
        break;
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
        clear_bit(TCCR1A, COM1B1);
        break;
     b88:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
     b8a:	85 b5       	in	r24, 0x25	; 37
     b8c:	8f 7e       	andi	r24, 0xEF	; 239
     b8e:	85 bd       	out	0x25, r24	; 37
        clear_bit(TCCR2, COM21);
     b90:	85 b5       	in	r24, 0x25	; 37
     b92:	8f 7d       	andi	r24, 0xDF	; 223
     b94:	85 bd       	out	0x25, r24	; 37
        break;
    }
  return TIMER_OK;
     b96:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1B1);
        break;
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
     b98:	08 95       	ret
  }

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
     b9a:	87 e0       	ldi	r24, 0x07	; 7
     b9c:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
     b9e:	80 e0       	ldi	r24, 0x00	; 0
  }
     ba0:	08 95       	ret

00000ba2 <PWM_OCP_connect>:

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
     ba2:	84 30       	cpi	r24, 0x04	; 4
     ba4:	40 f5       	brcc	.+80     	; 0xbf6 <PWM_OCP_connect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
     ba6:	81 30       	cpi	r24, 0x01	; 1
     ba8:	71 f0       	breq	.+28     	; 0xbc6 <PWM_OCP_connect+0x24>
     baa:	28 f0       	brcs	.+10     	; 0xbb6 <PWM_OCP_connect+0x14>
     bac:	82 30       	cpi	r24, 0x02	; 2
     bae:	99 f0       	breq	.+38     	; 0xbd6 <PWM_OCP_connect+0x34>
     bb0:	83 30       	cpi	r24, 0x03	; 3
     bb2:	c9 f0       	breq	.+50     	; 0xbe6 <PWM_OCP_connect+0x44>
     bb4:	22 c0       	rjmp	.+68     	; 0xbfa <PWM_OCP_connect+0x58>
      case OC_0:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR0, COM00);
     bb6:	83 b7       	in	r24, 0x33	; 51
     bb8:	8f 7e       	andi	r24, 0xEF	; 239
     bba:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR0, COM01);
     bbc:	83 b7       	in	r24, 0x33	; 51
     bbe:	80 62       	ori	r24, 0x20	; 32
     bc0:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
     bc2:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR0, COM01);
#else 
        set_bit(TCCR0, COM00);
        set_bit(TCCR0, COM01);
#endif
        break;
     bc4:	08 95       	ret
      case OC_1A:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1A0);
     bc6:	8f b5       	in	r24, 0x2f	; 47
     bc8:	8f 7b       	andi	r24, 0xBF	; 191
     bca:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1A1);
     bcc:	8f b5       	in	r24, 0x2f	; 47
     bce:	80 68       	ori	r24, 0x80	; 128
     bd0:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
     bd2:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1A1);
#else 
        set_bit(TCCR1A, COM1A0);
        set_bit(TCCR1A, COM1A1);
#endif
        break;
     bd4:	08 95       	ret
      case OC_1B:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1B0);
     bd6:	8f b5       	in	r24, 0x2f	; 47
     bd8:	8f 7e       	andi	r24, 0xEF	; 239
     bda:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1B1);
     bdc:	8f b5       	in	r24, 0x2f	; 47
     bde:	80 62       	ori	r24, 0x20	; 32
     be0:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
     be2:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1B1);
#else 
        set_bit(TCCR1A, COM1B0);
        set_bit(TCCR1A, COM1B1);
#endif
        break;
     be4:	08 95       	ret
      case OC_2:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR2, COM20);
     be6:	85 b5       	in	r24, 0x25	; 37
     be8:	8f 7e       	andi	r24, 0xEF	; 239
     bea:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM21);
     bec:	85 b5       	in	r24, 0x25	; 37
     bee:	80 62       	ori	r24, 0x20	; 32
     bf0:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
     bf2:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR2, COM21);
#else 
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
     bf4:	08 95       	ret
  }

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
     bf6:	87 e0       	ldi	r24, 0x07	; 7
     bf8:	08 95       	ret
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
     bfa:	80 e0       	ldi	r24, 0x00	; 0
  }
     bfc:	08 95       	ret

00000bfe <PWM_init>:
  return TIMER_OK;
  }

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
     bfe:	cf 92       	push	r12
     c00:	df 92       	push	r13
     c02:	ef 92       	push	r14
     c04:	ff 92       	push	r15
     c06:	cf 93       	push	r28
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
     c08:	84 30       	cpi	r24, 0x04	; 4
     c0a:	08 f0       	brcs	.+2      	; 0xc0e <PWM_init+0x10>
     c0c:	96 c0       	rjmp	.+300    	; 0xd3a <PWM_init+0x13c>
    return WRONG_PWM_PIN;
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
     c0e:	9f ef       	ldi	r25, 0xFF	; 255
     c10:	92 0f       	add	r25, r18
     c12:	92 30       	cpi	r25, 0x02	; 2
     c14:	08 f0       	brcs	.+2      	; 0xc18 <PWM_init+0x1a>
     c16:	93 c0       	rjmp	.+294    	; 0xd3e <PWM_init+0x140>
     c18:	6a 01       	movw	r12, r20
     c1a:	7b 01       	movw	r14, r22
     c1c:	c8 2f       	mov	r28, r24
    return WRONG_PWM_MODE;
    }
  switch (pwmPin) {
     c1e:	83 30       	cpi	r24, 0x03	; 3
     c20:	18 f4       	brcc	.+6      	; 0xc28 <PWM_init+0x2a>
     c22:	81 30       	cpi	r24, 0x01	; 1
     c24:	28 f0       	brcs	.+10     	; 0xc30 <PWM_init+0x32>
     c26:	22 c0       	rjmp	.+68     	; 0xc6c <PWM_init+0x6e>
     c28:	83 30       	cpi	r24, 0x03	; 3
     c2a:	09 f4       	brne	.+2      	; 0xc2e <PWM_init+0x30>
     c2c:	64 c0       	rjmp	.+200    	; 0xcf6 <PWM_init+0xf8>
     c2e:	80 c0       	rjmp	.+256    	; 0xd30 <PWM_init+0x132>
      case OC_0:
        switch (mode) {
     c30:	21 30       	cpi	r18, 0x01	; 1
     c32:	19 f0       	breq	.+6      	; 0xc3a <PWM_init+0x3c>
     c34:	22 30       	cpi	r18, 0x02	; 2
     c36:	41 f0       	breq	.+16     	; 0xc48 <PWM_init+0x4a>
     c38:	0d c0       	rjmp	.+26     	; 0xc54 <PWM_init+0x56>
            case PWM_FAST:
              set_bit(TCCR0, WGM00);
     c3a:	83 b7       	in	r24, 0x33	; 51
     c3c:	80 64       	ori	r24, 0x40	; 64
     c3e:	83 bf       	out	0x33, r24	; 51
              set_bit(TCCR0, WGM01);
     c40:	83 b7       	in	r24, 0x33	; 51
     c42:	88 60       	ori	r24, 0x08	; 8
     c44:	83 bf       	out	0x33, r24	; 51
              break;
     c46:	06 c0       	rjmp	.+12     	; 0xc54 <PWM_init+0x56>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR0, WGM00);
     c48:	83 b7       	in	r24, 0x33	; 51
     c4a:	80 64       	ori	r24, 0x40	; 64
     c4c:	83 bf       	out	0x33, r24	; 51
              clear_bit(TCCR0, WGM01);
     c4e:	83 b7       	in	r24, 0x33	; 51
     c50:	87 7f       	andi	r24, 0xF7	; 247
     c52:	83 bf       	out	0x33, r24	; 51
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR0 = (u8)(dutyCycle * 255);
     c54:	20 e0       	ldi	r18, 0x00	; 0
     c56:	30 e0       	ldi	r19, 0x00	; 0
     c58:	4f e7       	ldi	r20, 0x7F	; 127
     c5a:	53 e4       	ldi	r21, 0x43	; 67
     c5c:	c7 01       	movw	r24, r14
     c5e:	b6 01       	movw	r22, r12
     c60:	0e 94 55 10 	call	0x20aa	; 0x20aa <__mulsf3>
     c64:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <__fixunssfsi>
     c68:	6c bf       	out	0x3c, r22	; 60
        break;
     c6a:	62 c0       	rjmp	.+196    	; 0xd30 <PWM_init+0x132>
        //? The fix for this issue is to use ICR1 as TOP instead (mode 14 in fast pwm), thus allowing OCR1A and OCR1B to be used to set the duty cycle while ICR1 is used tyo set the frequency.
        //? Mode 15 can be used at the cost of disabling PWM on OC1A, but we get more glitch-free variable frequency PWM signal on OC1B due to the double buffering of OC1A, which ICR1 doesn't have.
        //? Since I don't need a variable frequency pwm signal, ICR1 will be used as TOP by default and set to MAX.
      case OC_1A:
      case OC_1B:
        switch (mode) {
     c6c:	21 30       	cpi	r18, 0x01	; 1
     c6e:	19 f0       	breq	.+6      	; 0xc76 <PWM_init+0x78>
     c70:	22 30       	cpi	r18, 0x02	; 2
     c72:	91 f0       	breq	.+36     	; 0xc98 <PWM_init+0x9a>
     c74:	21 c0       	rjmp	.+66     	; 0xcb8 <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
     c76:	8f b5       	in	r24, 0x2f	; 47
     c78:	8e 7f       	andi	r24, 0xFE	; 254
     c7a:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
     c7c:	8f b5       	in	r24, 0x2f	; 47
     c7e:	82 60       	ori	r24, 0x02	; 2
     c80:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1B, WGM12);
     c82:	8e b5       	in	r24, 0x2e	; 46
     c84:	88 60       	ori	r24, 0x08	; 8
     c86:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
     c88:	8e b5       	in	r24, 0x2e	; 46
     c8a:	80 61       	ori	r24, 0x10	; 16
     c8c:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
     c8e:	80 e2       	ldi	r24, 0x20	; 32
     c90:	9e e4       	ldi	r25, 0x4E	; 78
     c92:	97 bd       	out	0x27, r25	; 39
     c94:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              set_bit(TCCR1B, WGM13);
#endif
              break;
     c96:	10 c0       	rjmp	.+32     	; 0xcb8 <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              clear_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
     c98:	8f b5       	in	r24, 0x2f	; 47
     c9a:	8e 7f       	andi	r24, 0xFE	; 254
     c9c:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
     c9e:	8f b5       	in	r24, 0x2f	; 47
     ca0:	82 60       	ori	r24, 0x02	; 2
     ca2:	8f bd       	out	0x2f, r24	; 47
              clear_bit(TCCR1B, WGM12);
     ca4:	8e b5       	in	r24, 0x2e	; 46
     ca6:	87 7f       	andi	r24, 0xF7	; 247
     ca8:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
     caa:	8e b5       	in	r24, 0x2e	; 46
     cac:	80 61       	ori	r24, 0x10	; 16
     cae:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
     cb0:	80 e2       	ldi	r24, 0x20	; 32
     cb2:	9e e4       	ldi	r25, 0x4E	; 78
     cb4:	97 bd       	out	0x27, r25	; 39
     cb6:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1B, WGM13);
#endif
              break;
          }
        // Enable the PWM function of the OC pin.
        switch (pwmPin) {
     cb8:	c1 30       	cpi	r28, 0x01	; 1
     cba:	19 f0       	breq	.+6      	; 0xcc2 <PWM_init+0xc4>
     cbc:	c2 30       	cpi	r28, 0x02	; 2
     cbe:	71 f0       	breq	.+28     	; 0xcdc <PWM_init+0xde>
     cc0:	37 c0       	rjmp	.+110    	; 0xd30 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     cc2:	20 e0       	ldi	r18, 0x00	; 0
     cc4:	30 e4       	ldi	r19, 0x40	; 64
     cc6:	4c e9       	ldi	r20, 0x9C	; 156
     cc8:	56 e4       	ldi	r21, 0x46	; 70
     cca:	c7 01       	movw	r24, r14
     ccc:	b6 01       	movw	r22, r12
     cce:	0e 94 55 10 	call	0x20aa	; 0x20aa <__mulsf3>
     cd2:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <__fixunssfsi>
     cd6:	7b bd       	out	0x2b, r23	; 43
     cd8:	6a bd       	out	0x2a, r22	; 42
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1A = (u16)(dutyCycle * 65535);
#endif
              break;
     cda:	2a c0       	rjmp	.+84     	; 0xd30 <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     cdc:	20 e0       	ldi	r18, 0x00	; 0
     cde:	30 e4       	ldi	r19, 0x40	; 64
     ce0:	4c e9       	ldi	r20, 0x9C	; 156
     ce2:	56 e4       	ldi	r21, 0x46	; 70
     ce4:	c7 01       	movw	r24, r14
     ce6:	b6 01       	movw	r22, r12
     ce8:	0e 94 55 10 	call	0x20aa	; 0x20aa <__mulsf3>
     cec:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <__fixunssfsi>
     cf0:	79 bd       	out	0x29, r23	; 41
     cf2:	68 bd       	out	0x28, r22	; 40
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1B = (u16)(dutyCycle * 65535);
#endif
              break;
     cf4:	1d c0       	rjmp	.+58     	; 0xd30 <PWM_init+0x132>
          }
        break;
      case OC_2:
        switch (mode) {
     cf6:	21 30       	cpi	r18, 0x01	; 1
     cf8:	19 f0       	breq	.+6      	; 0xd00 <PWM_init+0x102>
     cfa:	22 30       	cpi	r18, 0x02	; 2
     cfc:	41 f0       	breq	.+16     	; 0xd0e <PWM_init+0x110>
     cfe:	0d c0       	rjmp	.+26     	; 0xd1a <PWM_init+0x11c>
            case PWM_FAST:
              set_bit(TCCR2, WGM20);
     d00:	85 b5       	in	r24, 0x25	; 37
     d02:	80 64       	ori	r24, 0x40	; 64
     d04:	85 bd       	out	0x25, r24	; 37
              set_bit(TCCR2, WGM21);
     d06:	85 b5       	in	r24, 0x25	; 37
     d08:	88 60       	ori	r24, 0x08	; 8
     d0a:	85 bd       	out	0x25, r24	; 37
              break;
     d0c:	06 c0       	rjmp	.+12     	; 0xd1a <PWM_init+0x11c>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR2, WGM20);
     d0e:	85 b5       	in	r24, 0x25	; 37
     d10:	80 64       	ori	r24, 0x40	; 64
     d12:	85 bd       	out	0x25, r24	; 37
              clear_bit(TCCR2, WGM21);
     d14:	85 b5       	in	r24, 0x25	; 37
     d16:	87 7f       	andi	r24, 0xF7	; 247
     d18:	85 bd       	out	0x25, r24	; 37
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR2 = (u8)(dutyCycle * 255);
     d1a:	20 e0       	ldi	r18, 0x00	; 0
     d1c:	30 e0       	ldi	r19, 0x00	; 0
     d1e:	4f e7       	ldi	r20, 0x7F	; 127
     d20:	53 e4       	ldi	r21, 0x43	; 67
     d22:	c7 01       	movw	r24, r14
     d24:	b6 01       	movw	r22, r12
     d26:	0e 94 55 10 	call	0x20aa	; 0x20aa <__mulsf3>
     d2a:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <__fixunssfsi>
     d2e:	63 bd       	out	0x23, r22	; 35
        break;
    }
  PWM_OCP_connect(pwmPin);
     d30:	8c 2f       	mov	r24, r28
     d32:	0e 94 d1 05 	call	0xba2	; 0xba2 <PWM_OCP_connect>
  return TIMER_OK;
     d36:	80 e0       	ldi	r24, 0x00	; 0
     d38:	03 c0       	rjmp	.+6      	; 0xd40 <PWM_init+0x142>

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
     d3a:	87 e0       	ldi	r24, 0x07	; 7
     d3c:	01 c0       	rjmp	.+2      	; 0xd40 <PWM_init+0x142>
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    return WRONG_PWM_MODE;
     d3e:	86 e0       	ldi	r24, 0x06	; 6
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  PWM_OCP_connect(pwmPin);
  return TIMER_OK;
  }
     d40:	cf 91       	pop	r28
     d42:	ff 90       	pop	r15
     d44:	ef 90       	pop	r14
     d46:	df 90       	pop	r13
     d48:	cf 90       	pop	r12
     d4a:	08 95       	ret

00000d4c <PWM_set_DC>:
    }
  return TIMER_OK;
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
     d4c:	28 2f       	mov	r18, r24
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
     d4e:	84 30       	cpi	r24, 0x04	; 4
     d50:	c0 f5       	brcc	.+112    	; 0xdc2 <PWM_set_DC+0x76>
     d52:	cb 01       	movw	r24, r22
     d54:	ba 01       	movw	r22, r20
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
     d56:	21 30       	cpi	r18, 0x01	; 1
     d58:	89 f0       	breq	.+34     	; 0xd7c <PWM_set_DC+0x30>
     d5a:	28 f0       	brcs	.+10     	; 0xd66 <PWM_set_DC+0x1a>
     d5c:	22 30       	cpi	r18, 0x02	; 2
     d5e:	d1 f0       	breq	.+52     	; 0xd94 <PWM_set_DC+0x48>
     d60:	23 30       	cpi	r18, 0x03	; 3
     d62:	21 f1       	breq	.+72     	; 0xdac <PWM_set_DC+0x60>
     d64:	30 c0       	rjmp	.+96     	; 0xdc6 <PWM_set_DC+0x7a>
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
     d66:	20 e0       	ldi	r18, 0x00	; 0
     d68:	30 e0       	ldi	r19, 0x00	; 0
     d6a:	4f e7       	ldi	r20, 0x7F	; 127
     d6c:	53 e4       	ldi	r21, 0x43	; 67
     d6e:	0e 94 55 10 	call	0x20aa	; 0x20aa <__mulsf3>
     d72:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <__fixunssfsi>
     d76:	6c bf       	out	0x3c, r22	; 60
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     d78:	80 e0       	ldi	r24, 0x00	; 0
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
        break;
     d7a:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     d7c:	20 e0       	ldi	r18, 0x00	; 0
     d7e:	30 e4       	ldi	r19, 0x40	; 64
     d80:	4c e9       	ldi	r20, 0x9C	; 156
     d82:	56 e4       	ldi	r21, 0x46	; 70
     d84:	0e 94 55 10 	call	0x20aa	; 0x20aa <__mulsf3>
     d88:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <__fixunssfsi>
     d8c:	7b bd       	out	0x2b, r23	; 43
     d8e:	6a bd       	out	0x2a, r22	; 42
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     d90:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1A = (u16)(dutyCycle * 65535);
#endif
        break;
     d92:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
     d94:	20 e0       	ldi	r18, 0x00	; 0
     d96:	30 e4       	ldi	r19, 0x40	; 64
     d98:	4c e9       	ldi	r20, 0x9C	; 156
     d9a:	56 e4       	ldi	r21, 0x46	; 70
     d9c:	0e 94 55 10 	call	0x20aa	; 0x20aa <__mulsf3>
     da0:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <__fixunssfsi>
     da4:	79 bd       	out	0x29, r23	; 41
     da6:	68 bd       	out	0x28, r22	; 40
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     da8:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
     daa:	08 95       	ret
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
     dac:	20 e0       	ldi	r18, 0x00	; 0
     dae:	30 e0       	ldi	r19, 0x00	; 0
     db0:	4f e7       	ldi	r20, 0x7F	; 127
     db2:	53 e4       	ldi	r21, 0x43	; 67
     db4:	0e 94 55 10 	call	0x20aa	; 0x20aa <__mulsf3>
     db8:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <__fixunssfsi>
     dbc:	63 bd       	out	0x23, r22	; 35
        break;
    }
  return TIMER_OK;
     dbe:	80 e0       	ldi	r24, 0x00	; 0
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
     dc0:	08 95       	ret
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
     dc2:	87 e0       	ldi	r24, 0x07	; 7
     dc4:	08 95       	ret
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
     dc6:	80 e0       	ldi	r24, 0x00	; 0
  }
     dc8:	08 95       	ret

00000dca <UART_init>:
  }

// Receive a Char using UART
void UART_receiveChar(s8* x) {
  while (!read_bit(UCSRA, RXC)); // Wait for the data to be received.
  *x = UDR;
     dca:	61 15       	cp	r22, r1
     dcc:	26 e9       	ldi	r18, 0x96	; 150
     dce:	72 07       	cpc	r23, r18
     dd0:	81 05       	cpc	r24, r1
     dd2:	91 05       	cpc	r25, r1
     dd4:	09 f4       	brne	.+2      	; 0xdd8 <UART_init+0xe>
     dd6:	72 c0       	rjmp	.+228    	; 0xebc <UART_init+0xf2>
     dd8:	58 f5       	brcc	.+86     	; 0xe30 <UART_init+0x66>
     dda:	60 38       	cpi	r22, 0x80	; 128
     ddc:	25 e2       	ldi	r18, 0x25	; 37
     dde:	72 07       	cpc	r23, r18
     de0:	81 05       	cpc	r24, r1
     de2:	91 05       	cpc	r25, r1
     de4:	09 f4       	brne	.+2      	; 0xde8 <UART_init+0x1e>
     de6:	5e c0       	rjmp	.+188    	; 0xea4 <UART_init+0xda>
     de8:	70 f4       	brcc	.+28     	; 0xe06 <UART_init+0x3c>
     dea:	60 36       	cpi	r22, 0x60	; 96
     dec:	29 e0       	ldi	r18, 0x09	; 9
     dee:	72 07       	cpc	r23, r18
     df0:	81 05       	cpc	r24, r1
     df2:	91 05       	cpc	r25, r1
     df4:	09 f4       	brne	.+2      	; 0xdf8 <UART_init+0x2e>
     df6:	4e c0       	rjmp	.+156    	; 0xe94 <UART_init+0xca>
     df8:	60 3c       	cpi	r22, 0xC0	; 192
     dfa:	72 41       	sbci	r23, 0x12	; 18
     dfc:	81 05       	cpc	r24, r1
     dfe:	91 05       	cpc	r25, r1
     e00:	09 f4       	brne	.+2      	; 0xe04 <UART_init+0x3a>
     e02:	4d c0       	rjmp	.+154    	; 0xe9e <UART_init+0xd4>
     e04:	82 c0       	rjmp	.+260    	; 0xf0a <UART_init+0x140>
     e06:	61 15       	cp	r22, r1
     e08:	2b e4       	ldi	r18, 0x4B	; 75
     e0a:	72 07       	cpc	r23, r18
     e0c:	81 05       	cpc	r24, r1
     e0e:	91 05       	cpc	r25, r1
     e10:	09 f4       	brne	.+2      	; 0xe14 <UART_init+0x4a>
     e12:	4e c0       	rjmp	.+156    	; 0xeb0 <UART_init+0xe6>
     e14:	60 38       	cpi	r22, 0x80	; 128
     e16:	20 e7       	ldi	r18, 0x70	; 112
     e18:	72 07       	cpc	r23, r18
     e1a:	81 05       	cpc	r24, r1
     e1c:	91 05       	cpc	r25, r1
     e1e:	09 f4       	brne	.+2      	; 0xe22 <UART_init+0x58>
     e20:	4a c0       	rjmp	.+148    	; 0xeb6 <UART_init+0xec>
     e22:	60 34       	cpi	r22, 0x40	; 64
     e24:	78 43       	sbci	r23, 0x38	; 56
     e26:	81 05       	cpc	r24, r1
     e28:	91 05       	cpc	r25, r1
     e2a:	09 f0       	breq	.+2      	; 0xe2e <UART_init+0x64>
     e2c:	6e c0       	rjmp	.+220    	; 0xf0a <UART_init+0x140>
     e2e:	3d c0       	rjmp	.+122    	; 0xeaa <UART_init+0xe0>
     e30:	61 15       	cp	r22, r1
     e32:	24 e8       	ldi	r18, 0x84	; 132
     e34:	72 07       	cpc	r23, r18
     e36:	23 e0       	ldi	r18, 0x03	; 3
     e38:	82 07       	cpc	r24, r18
     e3a:	91 05       	cpc	r25, r1
     e3c:	09 f4       	brne	.+2      	; 0xe40 <UART_init+0x76>
     e3e:	4a c0       	rjmp	.+148    	; 0xed4 <UART_init+0x10a>
     e40:	a8 f4       	brcc	.+42     	; 0xe6c <UART_init+0xa2>
     e42:	61 15       	cp	r22, r1
     e44:	2c e2       	ldi	r18, 0x2C	; 44
     e46:	72 07       	cpc	r23, r18
     e48:	21 e0       	ldi	r18, 0x01	; 1
     e4a:	82 07       	cpc	r24, r18
     e4c:	91 05       	cpc	r25, r1
     e4e:	e1 f1       	breq	.+120    	; 0xec8 <UART_init+0xfe>
     e50:	61 15       	cp	r22, r1
     e52:	22 ec       	ldi	r18, 0xC2	; 194
     e54:	72 07       	cpc	r23, r18
     e56:	21 e0       	ldi	r18, 0x01	; 1
     e58:	82 07       	cpc	r24, r18
     e5a:	91 05       	cpc	r25, r1
     e5c:	c1 f1       	breq	.+112    	; 0xece <UART_init+0x104>
     e5e:	61 15       	cp	r22, r1
     e60:	71 4e       	sbci	r23, 0xE1	; 225
     e62:	81 05       	cpc	r24, r1
     e64:	91 05       	cpc	r25, r1
     e66:	09 f0       	breq	.+2      	; 0xe6a <UART_init+0xa0>
     e68:	50 c0       	rjmp	.+160    	; 0xf0a <UART_init+0x140>
     e6a:	2b c0       	rjmp	.+86     	; 0xec2 <UART_init+0xf8>
     e6c:	60 32       	cpi	r22, 0x20	; 32
     e6e:	21 ea       	ldi	r18, 0xA1	; 161
     e70:	72 07       	cpc	r23, r18
     e72:	27 e0       	ldi	r18, 0x07	; 7
     e74:	82 07       	cpc	r24, r18
     e76:	91 05       	cpc	r25, r1
     e78:	99 f1       	breq	.+102    	; 0xee0 <UART_init+0x116>
     e7a:	60 34       	cpi	r22, 0x40	; 64
     e7c:	22 e4       	ldi	r18, 0x42	; 66
     e7e:	72 07       	cpc	r23, r18
     e80:	2f e0       	ldi	r18, 0x0F	; 15
     e82:	82 07       	cpc	r24, r18
     e84:	91 05       	cpc	r25, r1
     e86:	79 f1       	breq	.+94     	; 0xee6 <UART_init+0x11c>
     e88:	60 39       	cpi	r22, 0x90	; 144
     e8a:	70 4d       	sbci	r23, 0xD0	; 208
     e8c:	83 40       	sbci	r24, 0x03	; 3
     e8e:	91 05       	cpc	r25, r1
     e90:	e1 f5       	brne	.+120    	; 0xf0a <UART_init+0x140>
     e92:	23 c0       	rjmp	.+70     	; 0xeda <UART_init+0x110>
     e94:	81 e0       	ldi	r24, 0x01	; 1
     e96:	80 bd       	out	0x20, r24	; 32
     e98:	80 ea       	ldi	r24, 0xA0	; 160
     e9a:	89 b9       	out	0x09, r24	; 9
     e9c:	25 c0       	rjmp	.+74     	; 0xee8 <UART_init+0x11e>
     e9e:	8f ec       	ldi	r24, 0xCF	; 207
     ea0:	89 b9       	out	0x09, r24	; 9
     ea2:	22 c0       	rjmp	.+68     	; 0xee8 <UART_init+0x11e>
     ea4:	87 e6       	ldi	r24, 0x67	; 103
     ea6:	89 b9       	out	0x09, r24	; 9
     ea8:	1f c0       	rjmp	.+62     	; 0xee8 <UART_init+0x11e>
     eaa:	84 e4       	ldi	r24, 0x44	; 68
     eac:	89 b9       	out	0x09, r24	; 9
     eae:	1c c0       	rjmp	.+56     	; 0xee8 <UART_init+0x11e>
     eb0:	83 e3       	ldi	r24, 0x33	; 51
     eb2:	89 b9       	out	0x09, r24	; 9
     eb4:	19 c0       	rjmp	.+50     	; 0xee8 <UART_init+0x11e>
     eb6:	82 e2       	ldi	r24, 0x22	; 34
     eb8:	89 b9       	out	0x09, r24	; 9
     eba:	16 c0       	rjmp	.+44     	; 0xee8 <UART_init+0x11e>
     ebc:	89 e1       	ldi	r24, 0x19	; 25
     ebe:	89 b9       	out	0x09, r24	; 9
     ec0:	13 c0       	rjmp	.+38     	; 0xee8 <UART_init+0x11e>
     ec2:	80 e1       	ldi	r24, 0x10	; 16
     ec4:	89 b9       	out	0x09, r24	; 9
     ec6:	10 c0       	rjmp	.+32     	; 0xee8 <UART_init+0x11e>
     ec8:	8c e0       	ldi	r24, 0x0C	; 12
     eca:	89 b9       	out	0x09, r24	; 9
     ecc:	0d c0       	rjmp	.+26     	; 0xee8 <UART_init+0x11e>
     ece:	88 e0       	ldi	r24, 0x08	; 8
     ed0:	89 b9       	out	0x09, r24	; 9
     ed2:	0a c0       	rjmp	.+20     	; 0xee8 <UART_init+0x11e>
     ed4:	83 e0       	ldi	r24, 0x03	; 3
     ed6:	89 b9       	out	0x09, r24	; 9
     ed8:	07 c0       	rjmp	.+14     	; 0xee8 <UART_init+0x11e>
     eda:	83 e0       	ldi	r24, 0x03	; 3
     edc:	89 b9       	out	0x09, r24	; 9
     ede:	04 c0       	rjmp	.+8      	; 0xee8 <UART_init+0x11e>
     ee0:	81 e0       	ldi	r24, 0x01	; 1
     ee2:	89 b9       	out	0x09, r24	; 9
     ee4:	01 c0       	rjmp	.+2      	; 0xee8 <UART_init+0x11e>
     ee6:	19 b8       	out	0x09, r1	; 9
     ee8:	8a b1       	in	r24, 0x0a	; 10
     eea:	88 60       	ori	r24, 0x08	; 8
     eec:	8a b9       	out	0x0a, r24	; 10
     eee:	8a b1       	in	r24, 0x0a	; 10
     ef0:	80 61       	ori	r24, 0x10	; 16
     ef2:	8a b9       	out	0x0a, r24	; 10
     ef4:	80 b5       	in	r24, 0x20	; 32
     ef6:	80 68       	ori	r24, 0x80	; 128
     ef8:	80 bd       	out	0x20, r24	; 32
     efa:	80 b5       	in	r24, 0x20	; 32
     efc:	82 60       	ori	r24, 0x02	; 2
     efe:	80 bd       	out	0x20, r24	; 32
     f00:	80 b5       	in	r24, 0x20	; 32
     f02:	84 60       	ori	r24, 0x04	; 4
     f04:	80 bd       	out	0x20, r24	; 32
     f06:	80 e0       	ldi	r24, 0x00	; 0
     f08:	08 95       	ret
     f0a:	81 e0       	ldi	r24, 0x01	; 1
     f0c:	08 95       	ret

00000f0e <UART_sendChar>:
     f0e:	5d 9b       	sbis	0x0b, 5	; 11
     f10:	fe cf       	rjmp	.-4      	; 0xf0e <UART_sendChar>
     f12:	8c b9       	out	0x0c, r24	; 12
     f14:	5e 9b       	sbis	0x0b, 6	; 11
     f16:	fe cf       	rjmp	.-4      	; 0xf14 <UART_sendChar+0x6>
     f18:	08 95       	ret

00000f1a <UART_sendString>:
  }

void UART_sendString(s8* str) {
     f1a:	cf 92       	push	r12
     f1c:	df 92       	push	r13
     f1e:	ef 92       	push	r14
     f20:	ff 92       	push	r15
     f22:	cf 93       	push	r28
     f24:	df 93       	push	r29
     f26:	ec 01       	movw	r28, r24
  u32 i = 0;
     f28:	c1 2c       	mov	r12, r1
     f2a:	d1 2c       	mov	r13, r1
     f2c:	76 01       	movw	r14, r12
  while (str[i] != 0) {
     f2e:	07 c0       	rjmp	.+14     	; 0xf3e <UART_sendString+0x24>
    UART_sendChar(str[i]);
     f30:	0e 94 87 07 	call	0xf0e	; 0xf0e <UART_sendChar>
    i++;
     f34:	8f ef       	ldi	r24, 0xFF	; 255
     f36:	c8 1a       	sub	r12, r24
     f38:	d8 0a       	sbc	r13, r24
     f3a:	e8 0a       	sbc	r14, r24
     f3c:	f8 0a       	sbc	r15, r24
  *x = UDR;
  }

void UART_sendString(s8* str) {
  u32 i = 0;
  while (str[i] != 0) {
     f3e:	fe 01       	movw	r30, r28
     f40:	ec 0d       	add	r30, r12
     f42:	fd 1d       	adc	r31, r13
     f44:	80 81       	ld	r24, Z
     f46:	81 11       	cpse	r24, r1
     f48:	f3 cf       	rjmp	.-26     	; 0xf30 <UART_sendString+0x16>
    UART_sendChar(str[i]);
    i++;
    }
  UART_sendChar(0); // Send null to terminate the string
     f4a:	0e 94 87 07 	call	0xf0e	; 0xf0e <UART_sendChar>
  }
     f4e:	df 91       	pop	r29
     f50:	cf 91       	pop	r28
     f52:	ff 90       	pop	r15
     f54:	ef 90       	pop	r14
     f56:	df 90       	pop	r13
     f58:	cf 90       	pop	r12
     f5a:	08 95       	ret

00000f5c <Door_init>:

#include "door.h"

 // Initialize the servo for the door
void Door_init(void) {
  Servo_init();
     f5c:	0e 94 06 02 	call	0x40c	; 0x40c <Servo_init>
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
     f60:	80 e0       	ldi	r24, 0x00	; 0
     f62:	0e 94 19 02 	call	0x432	; 0x432 <Servo_move_to_angle>
     f66:	08 95       	ret

00000f68 <Door_open>:
  }

// Open the door by moving the servo to the open angle
void Door_open(void) {
  Servo_move_to_angle(DOOR_OPEN_ANGLE);
     f68:	84 eb       	ldi	r24, 0xB4	; 180
     f6a:	0e 94 19 02 	call	0x432	; 0x432 <Servo_move_to_angle>
     f6e:	08 95       	ret

00000f70 <Door_close>:
  }

// Close the door by moving the servo to the close angle
void Door_close(void) {
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
     f70:	80 e0       	ldi	r24, 0x00	; 0
     f72:	0e 94 19 02 	call	0x432	; 0x432 <Servo_move_to_angle>
     f76:	08 95       	ret

00000f78 <Lamps_init>:
      case LAMP_6:
        if (read_bit(TCCR2, COM21)) { // OC pin is connected and lamp6 is on
          Lamp_off(6);
          }
        else {
          Lamp_on(6);
     f78:	62 e0       	ldi	r22, 0x02	; 2
     f7a:	83 e4       	ldi	r24, 0x43	; 67
     f7c:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <LED_init>
     f80:	63 e0       	ldi	r22, 0x03	; 3
     f82:	83 e4       	ldi	r24, 0x43	; 67
     f84:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <LED_init>
     f88:	64 e0       	ldi	r22, 0x04	; 4
     f8a:	83 e4       	ldi	r24, 0x43	; 67
     f8c:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <LED_init>
     f90:	65 e0       	ldi	r22, 0x05	; 5
     f92:	83 e4       	ldi	r24, 0x43	; 67
     f94:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <LED_init>
     f98:	66 e0       	ldi	r22, 0x06	; 6
     f9a:	83 e4       	ldi	r24, 0x43	; 67
     f9c:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <LED_init>
     fa0:	67 e0       	ldi	r22, 0x07	; 7
     fa2:	84 e4       	ldi	r24, 0x44	; 68
     fa4:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <LED_init>
     fa8:	21 e0       	ldi	r18, 0x01	; 1
     faa:	40 e0       	ldi	r20, 0x00	; 0
     fac:	50 e0       	ldi	r21, 0x00	; 0
     fae:	ba 01       	movw	r22, r20
     fb0:	83 e0       	ldi	r24, 0x03	; 3
     fb2:	0e 94 ff 05 	call	0xbfe	; 0xbfe <PWM_init>
     fb6:	60 e0       	ldi	r22, 0x00	; 0
     fb8:	71 e0       	ldi	r23, 0x01	; 1
     fba:	82 e0       	ldi	r24, 0x02	; 2
     fbc:	0e 94 8f 05 	call	0xb1e	; 0xb1e <Timer_start>
     fc0:	08 95       	ret

00000fc2 <Lamp_on>:
     fc2:	83 30       	cpi	r24, 0x03	; 3
     fc4:	b1 f0       	breq	.+44     	; 0xff2 <Lamp_on+0x30>
     fc6:	28 f4       	brcc	.+10     	; 0xfd2 <Lamp_on+0x10>
     fc8:	81 30       	cpi	r24, 0x01	; 1
     fca:	49 f0       	breq	.+18     	; 0xfde <Lamp_on+0x1c>
     fcc:	82 30       	cpi	r24, 0x02	; 2
     fce:	61 f0       	breq	.+24     	; 0xfe8 <Lamp_on+0x26>
     fd0:	08 95       	ret
     fd2:	85 30       	cpi	r24, 0x05	; 5
     fd4:	c1 f0       	breq	.+48     	; 0x1006 <Lamp_on+0x44>
     fd6:	90 f0       	brcs	.+36     	; 0xffc <Lamp_on+0x3a>
     fd8:	86 30       	cpi	r24, 0x06	; 6
     fda:	d1 f0       	breq	.+52     	; 0x1010 <Lamp_on+0x4e>
     fdc:	08 95       	ret
     fde:	62 e0       	ldi	r22, 0x02	; 2
     fe0:	83 e4       	ldi	r24, 0x43	; 67
     fe2:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <LED_on>
     fe6:	08 95       	ret
     fe8:	63 e0       	ldi	r22, 0x03	; 3
     fea:	83 e4       	ldi	r24, 0x43	; 67
     fec:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <LED_on>
     ff0:	08 95       	ret
     ff2:	64 e0       	ldi	r22, 0x04	; 4
     ff4:	83 e4       	ldi	r24, 0x43	; 67
     ff6:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <LED_on>
     ffa:	08 95       	ret
     ffc:	65 e0       	ldi	r22, 0x05	; 5
     ffe:	83 e4       	ldi	r24, 0x43	; 67
    1000:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <LED_on>
    1004:	08 95       	ret
    1006:	66 e0       	ldi	r22, 0x06	; 6
    1008:	83 e4       	ldi	r24, 0x43	; 67
    100a:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <LED_on>
    100e:	08 95       	ret
    1010:	83 e0       	ldi	r24, 0x03	; 3
    1012:	0e 94 d1 05 	call	0xba2	; 0xba2 <PWM_OCP_connect>
    1016:	08 95       	ret

00001018 <Lamp_off>:
    1018:	83 30       	cpi	r24, 0x03	; 3
    101a:	b1 f0       	breq	.+44     	; 0x1048 <Lamp_off+0x30>
    101c:	28 f4       	brcc	.+10     	; 0x1028 <Lamp_off+0x10>
    101e:	81 30       	cpi	r24, 0x01	; 1
    1020:	49 f0       	breq	.+18     	; 0x1034 <Lamp_off+0x1c>
    1022:	82 30       	cpi	r24, 0x02	; 2
    1024:	61 f0       	breq	.+24     	; 0x103e <Lamp_off+0x26>
    1026:	08 95       	ret
    1028:	85 30       	cpi	r24, 0x05	; 5
    102a:	c1 f0       	breq	.+48     	; 0x105c <Lamp_off+0x44>
    102c:	90 f0       	brcs	.+36     	; 0x1052 <Lamp_off+0x3a>
    102e:	86 30       	cpi	r24, 0x06	; 6
    1030:	d1 f0       	breq	.+52     	; 0x1066 <Lamp_off+0x4e>
    1032:	08 95       	ret
    1034:	62 e0       	ldi	r22, 0x02	; 2
    1036:	83 e4       	ldi	r24, 0x43	; 67
    1038:	0e 94 fd 01 	call	0x3fa	; 0x3fa <LED_off>
    103c:	08 95       	ret
    103e:	63 e0       	ldi	r22, 0x03	; 3
    1040:	83 e4       	ldi	r24, 0x43	; 67
    1042:	0e 94 fd 01 	call	0x3fa	; 0x3fa <LED_off>
    1046:	08 95       	ret
    1048:	64 e0       	ldi	r22, 0x04	; 4
    104a:	83 e4       	ldi	r24, 0x43	; 67
    104c:	0e 94 fd 01 	call	0x3fa	; 0x3fa <LED_off>
    1050:	08 95       	ret
    1052:	65 e0       	ldi	r22, 0x05	; 5
    1054:	83 e4       	ldi	r24, 0x43	; 67
    1056:	0e 94 fd 01 	call	0x3fa	; 0x3fa <LED_off>
    105a:	08 95       	ret
    105c:	66 e0       	ldi	r22, 0x06	; 6
    105e:	83 e4       	ldi	r24, 0x43	; 67
    1060:	0e 94 fd 01 	call	0x3fa	; 0x3fa <LED_off>
    1064:	08 95       	ret
    1066:	83 e0       	ldi	r24, 0x03	; 3
    1068:	0e 94 a3 05 	call	0xb46	; 0xb46 <PWM_OCP_disconnect>
    106c:	08 95       	ret

0000106e <Lamp_dimmable_set_brightness>:
        break;
    }
  }

// Adjust the brightness of the dimmable lamp
void Lamp_dimmable_set_brightness(double brightness) {
    106e:	ab 01       	movw	r20, r22
    1070:	bc 01       	movw	r22, r24
  PWM_set_DC(LAMP_6_DIMMABLE_PWM_PIN, brightness);
    1072:	83 e0       	ldi	r24, 0x03	; 3
    1074:	0e 94 a6 06 	call	0xd4c	; 0xd4c <PWM_set_DC>
    1078:	08 95       	ret

0000107a <Remote_init>:
void add_user_prompt(void);
void initial_options_menu(void);
void print_initial_options_menu(void);
void remote_control(void);

void Remote_init(u32 baudRate) {
    107a:	cf 92       	push	r12
    107c:	df 92       	push	r13
    107e:	ef 92       	push	r14
    1080:	ff 92       	push	r15
    1082:	6b 01       	movw	r12, r22
    1084:	7c 01       	movw	r14, r24
  User_DB_init();
    1086:	0e 94 6d 0c 	call	0x18da	; 0x18da <User_DB_init>
  BT_init(baudRate);
    108a:	c7 01       	movw	r24, r14
    108c:	b6 01       	movw	r22, r12
    108e:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <BT_init>
  INT0_init(RISING_EDGE_INTERRUPT_REQUEST);
    1092:	83 e0       	ldi	r24, 0x03	; 3
    1094:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <INT0_init>
  UART_RXC_INT_init();
    1098:	0e 94 fd 03 	call	0x7fa	; 0x7fa <UART_RXC_INT_init>
  }
    109c:	ff 90       	pop	r15
    109e:	ef 90       	pop	r14
    10a0:	df 90       	pop	r13
    10a2:	cf 90       	pop	r12
    10a4:	08 95       	ret

000010a6 <println_msg>:

void println_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    10a6:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <BT_sendString>
  // Send CRLF - carriage return + new line
  BT_sendString("\r\n");
    10aa:	81 e6       	ldi	r24, 0x61	; 97
    10ac:	90 e0       	ldi	r25, 0x00	; 0
    10ae:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <BT_sendString>
    10b2:	08 95       	ret

000010b4 <print_msg>:
  }

void print_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    10b4:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <BT_sendString>
    10b8:	08 95       	ret

000010ba <request_user_input>:
  }

void request_user_input(s8 options[4], u8 msgLength) {
    10ba:	cf 93       	push	r28
    10bc:	c6 2f       	mov	r28, r22
  strcpy(user_dialog_tree, options);
    10be:	bc 01       	movw	r22, r24
    10c0:	8e ee       	ldi	r24, 0xEE	; 238
    10c2:	95 e0       	ldi	r25, 0x05	; 5
    10c4:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
  msg_length = msgLength;
    10c8:	c0 93 ed 05 	sts	0x05ED, r28	; 0x8005ed <msg_length>
  }
    10cc:	cf 91       	pop	r28
    10ce:	08 95       	ret

000010d0 <print_remote_control_menu>:
      }
    }
  }

void print_remote_control_menu(void) {
  println_msg("Select one of the following devices to control:\t");
    10d0:	84 e6       	ldi	r24, 0x64	; 100
    10d2:	90 e0       	ldi	r25, 0x00	; 0
    10d4:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
  println_msg("[1] Lamp 1");
    10d8:	85 e9       	ldi	r24, 0x95	; 149
    10da:	90 e0       	ldi	r25, 0x00	; 0
    10dc:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
  println_msg("[2] Lamp 2");
    10e0:	80 ea       	ldi	r24, 0xA0	; 160
    10e2:	90 e0       	ldi	r25, 0x00	; 0
    10e4:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
  println_msg("[3] Lamp 3");
    10e8:	8b ea       	ldi	r24, 0xAB	; 171
    10ea:	90 e0       	ldi	r25, 0x00	; 0
    10ec:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
  println_msg("[4] Lamp 4");
    10f0:	86 eb       	ldi	r24, 0xB6	; 182
    10f2:	90 e0       	ldi	r25, 0x00	; 0
    10f4:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
  println_msg("[5] Lamp 5");
    10f8:	81 ec       	ldi	r24, 0xC1	; 193
    10fa:	90 e0       	ldi	r25, 0x00	; 0
    10fc:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
  println_msg("[6] Lamp 6");
    1100:	8c ec       	ldi	r24, 0xCC	; 204
    1102:	90 e0       	ldi	r25, 0x00	; 0
    1104:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
  if (remote_user.isAdmin) {
    1108:	80 91 fa 05 	lds	r24, 0x05FA	; 0x8005fa <remote_user>
    110c:	88 23       	and	r24, r24
    110e:	21 f0       	breq	.+8      	; 0x1118 <print_remote_control_menu+0x48>
    println_msg("[7] The Door");
    1110:	87 ed       	ldi	r24, 0xD7	; 215
    1112:	90 e0       	ldi	r25, 0x00	; 0
    1114:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    1118:	08 95       	ret

0000111a <control_device>:
  }

// TODO: Send the status of each device to the user instead of just asking him to switch the device on or off.

void control_device(void) {
  u8 option = msg_buffer[0];
    111a:	60 91 de 05 	lds	r22, 0x05DE	; 0x8005de <msg_buffer>
  if (invalid_user_input || option < '0' || option > '9') {
    111e:	80 91 f9 05 	lds	r24, 0x05F9	; 0x8005f9 <invalid_user_input>
    1122:	81 11       	cpse	r24, r1
    1124:	04 c0       	rjmp	.+8      	; 0x112e <control_device+0x14>
    1126:	60 33       	cpi	r22, 0x30	; 48
    1128:	10 f0       	brcs	.+4      	; 0x112e <control_device+0x14>
    112a:	6a 33       	cpi	r22, 0x3A	; 58
    112c:	60 f0       	brcs	.+24     	; 0x1146 <control_device+0x2c>
    println_msg("\r\nInvalid input!!\t");
    112e:	84 ee       	ldi	r24, 0xE4	; 228
    1130:	90 e0       	ldi	r25, 0x00	; 0
    1132:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    print_remote_control_menu();
    1136:	0e 94 68 08 	call	0x10d0	; 0x10d0 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    113a:	62 e0       	ldi	r22, 0x02	; 2
    113c:	86 ee       	ldi	r24, 0xE6	; 230
    113e:	98 e0       	ldi	r25, 0x08	; 8
    1140:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    1144:	08 95       	ret
    }
  else {
    if (device_number < 6) {
    1146:	80 91 3c 06 	lds	r24, 0x063C	; 0x80063c <device_number>
    114a:	86 30       	cpi	r24, 0x06	; 6
    114c:	80 f4       	brcc	.+32     	; 0x116e <control_device+0x54>
      if (option == '1') {
    114e:	61 33       	cpi	r22, 0x31	; 49
    1150:	39 f4       	brne	.+14     	; 0x1160 <control_device+0x46>
        Lamp_on(device_number);
    1152:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <Lamp_on>
        println_msg("The device has been turned on!");
    1156:	87 ef       	ldi	r24, 0xF7	; 247
    1158:	90 e0       	ldi	r25, 0x00	; 0
    115a:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    115e:	2e c0       	rjmp	.+92     	; 0x11bc <control_device+0xa2>
        }
      else {
        Lamp_off(device_number);
    1160:	0e 94 0c 08 	call	0x1018	; 0x1018 <Lamp_off>
        println_msg("The device has been turned off!");
    1164:	86 e1       	ldi	r24, 0x16	; 22
    1166:	91 e0       	ldi	r25, 0x01	; 1
    1168:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    116c:	27 c0       	rjmp	.+78     	; 0x11bc <control_device+0xa2>
        }
      }
    else if (device_number == 6) { // Dimmable led
    116e:	86 30       	cpi	r24, 0x06	; 6
    1170:	b1 f4       	brne	.+44     	; 0x119e <control_device+0x84>
      Lamp_dimmable_set_brightness(((double)(option - 48) / 9.0));
    1172:	70 e0       	ldi	r23, 0x00	; 0
    1174:	60 53       	subi	r22, 0x30	; 48
    1176:	71 09       	sbc	r23, r1
    1178:	07 2e       	mov	r0, r23
    117a:	00 0c       	add	r0, r0
    117c:	88 0b       	sbc	r24, r24
    117e:	99 0b       	sbc	r25, r25
    1180:	0e 94 c9 0f 	call	0x1f92	; 0x1f92 <__floatsisf>
    1184:	20 e0       	ldi	r18, 0x00	; 0
    1186:	30 e0       	ldi	r19, 0x00	; 0
    1188:	40 e1       	ldi	r20, 0x10	; 16
    118a:	51 e4       	ldi	r21, 0x41	; 65
    118c:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <__divsf3>
    1190:	0e 94 37 08 	call	0x106e	; 0x106e <Lamp_dimmable_set_brightness>
      println_msg("The brightness has been adjusted!");
    1194:	86 e3       	ldi	r24, 0x36	; 54
    1196:	91 e0       	ldi	r25, 0x01	; 1
    1198:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    119c:	0f c0       	rjmp	.+30     	; 0x11bc <control_device+0xa2>
      }
    else {
      if (option == '1') {
    119e:	61 33       	cpi	r22, 0x31	; 49
    11a0:	39 f4       	brne	.+14     	; 0x11b0 <control_device+0x96>
        Door_open();
    11a2:	0e 94 b4 07 	call	0xf68	; 0xf68 <Door_open>
        println_msg("The Door is open now.");
    11a6:	88 e5       	ldi	r24, 0x58	; 88
    11a8:	91 e0       	ldi	r25, 0x01	; 1
    11aa:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    11ae:	06 c0       	rjmp	.+12     	; 0x11bc <control_device+0xa2>
        }
      else {
        Door_close();
    11b0:	0e 94 b8 07 	call	0xf70	; 0xf70 <Door_close>
        println_msg("The Door is closed now.");
    11b4:	8e e6       	ldi	r24, 0x6E	; 110
    11b6:	91 e0       	ldi	r25, 0x01	; 1
    11b8:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
        }
      }
    print_remote_control_menu();
    11bc:	0e 94 68 08 	call	0x10d0	; 0x10d0 <print_remote_control_menu>
    request_user_input(remote_control, 2);
    11c0:	62 e0       	ldi	r22, 0x02	; 2
    11c2:	86 ee       	ldi	r24, 0xE6	; 230
    11c4:	98 e0       	ldi	r25, 0x08	; 8
    11c6:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    11ca:	08 95       	ret

000011cc <remote_control>:
    }
  }

void remote_control(void) {
    11cc:	cf 93       	push	r28
  u8 option = msg_buffer[0];
    11ce:	c0 91 de 05 	lds	r28, 0x05DE	; 0x8005de <msg_buffer>
  if (remote_user.isAdmin) {
    11d2:	80 91 fa 05 	lds	r24, 0x05FA	; 0x8005fa <remote_user>
    11d6:	88 23       	and	r24, r24
    11d8:	49 f1       	breq	.+82     	; 0x122c <remote_control+0x60>
    if (invalid_user_input || option < '1' || option > '7') {
    11da:	80 91 f9 05 	lds	r24, 0x05F9	; 0x8005f9 <invalid_user_input>
    11de:	81 11       	cpse	r24, r1
    11e0:	04 c0       	rjmp	.+8      	; 0x11ea <remote_control+0x1e>
    11e2:	c1 33       	cpi	r28, 0x31	; 49
    11e4:	10 f0       	brcs	.+4      	; 0x11ea <remote_control+0x1e>
    11e6:	c8 33       	cpi	r28, 0x38	; 56
    11e8:	60 f0       	brcs	.+24     	; 0x1202 <remote_control+0x36>
      println_msg("Invalid option!\t");
    11ea:	86 e8       	ldi	r24, 0x86	; 134
    11ec:	91 e0       	ldi	r25, 0x01	; 1
    11ee:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      print_remote_control_menu();
    11f2:	0e 94 68 08 	call	0x10d0	; 0x10d0 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    11f6:	62 e0       	ldi	r22, 0x02	; 2
    11f8:	86 ee       	ldi	r24, 0xE6	; 230
    11fa:	98 e0       	ldi	r25, 0x08	; 8
    11fc:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    1200:	3d c0       	rjmp	.+122    	; 0x127c <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    1202:	87 e9       	ldi	r24, 0x97	; 151
    1204:	91 e0       	ldi	r25, 0x01	; 1
    1206:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    120a:	8d ee       	ldi	r24, 0xED	; 237
    120c:	91 e0       	ldi	r25, 0x01	; 1
    120e:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    1212:	86 e2       	ldi	r24, 0x26	; 38
    1214:	92 e0       	ldi	r25, 0x02	; 2
    1216:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      request_user_input(control_device, 2);
    121a:	62 e0       	ldi	r22, 0x02	; 2
    121c:	8d e8       	ldi	r24, 0x8D	; 141
    121e:	98 e0       	ldi	r25, 0x08	; 8
    1220:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
      device_number = option - 48;
    1224:	c0 53       	subi	r28, 0x30	; 48
    1226:	c0 93 3c 06 	sts	0x063C, r28	; 0x80063c <device_number>
    122a:	28 c0       	rjmp	.+80     	; 0x127c <remote_control+0xb0>
      }
    }
  else {
    if (invalid_user_input || option < '1' || option > '6') {
    122c:	80 91 f9 05 	lds	r24, 0x05F9	; 0x8005f9 <invalid_user_input>
    1230:	81 11       	cpse	r24, r1
    1232:	04 c0       	rjmp	.+8      	; 0x123c <remote_control+0x70>
    1234:	c1 33       	cpi	r28, 0x31	; 49
    1236:	10 f0       	brcs	.+4      	; 0x123c <remote_control+0x70>
    1238:	c7 33       	cpi	r28, 0x37	; 55
    123a:	60 f0       	brcs	.+24     	; 0x1254 <remote_control+0x88>
      println_msg("Invalid option!\t");
    123c:	86 e8       	ldi	r24, 0x86	; 134
    123e:	91 e0       	ldi	r25, 0x01	; 1
    1240:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      print_remote_control_menu();
    1244:	0e 94 68 08 	call	0x10d0	; 0x10d0 <print_remote_control_menu>
      request_user_input(remote_control, 2);
    1248:	62 e0       	ldi	r22, 0x02	; 2
    124a:	86 ee       	ldi	r24, 0xE6	; 230
    124c:	98 e0       	ldi	r25, 0x08	; 8
    124e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    1252:	14 c0       	rjmp	.+40     	; 0x127c <remote_control+0xb0>
      }
    else {
      println_msg("Do you want to switch the device on or off? (Enter 1 to turn it on. 0 to turn it off)");
    1254:	87 e9       	ldi	r24, 0x97	; 151
    1256:	91 e0       	ldi	r25, 0x01	; 1
    1258:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      println_msg("For dimmable lamp the brightness levels are from 0 to 9.");
    125c:	8d ee       	ldi	r24, 0xED	; 237
    125e:	91 e0       	ldi	r25, 0x01	; 1
    1260:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      println_msg("If you slected the door, entr 1 to open and 0 to close.");
    1264:	86 e2       	ldi	r24, 0x26	; 38
    1266:	92 e0       	ldi	r25, 0x02	; 2
    1268:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      request_user_input(control_device, 2);
    126c:	62 e0       	ldi	r22, 0x02	; 2
    126e:	8d e8       	ldi	r24, 0x8D	; 141
    1270:	98 e0       	ldi	r25, 0x08	; 8
    1272:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
      device_number = option - 48;
    1276:	c0 53       	subi	r28, 0x30	; 48
    1278:	c0 93 3c 06 	sts	0x063C, r28	; 0x80063c <device_number>
      }
    }
  }
    127c:	cf 91       	pop	r28
    127e:	08 95       	ret

00001280 <print_initial_options_menu>:

void print_initial_options_menu(void) {
  if (remote_user.isAdmin) {
    1280:	80 91 fa 05 	lds	r24, 0x05FA	; 0x8005fa <remote_user>
    1284:	88 23       	and	r24, r24
    1286:	a9 f0       	breq	.+42     	; 0x12b2 <print_initial_options_menu+0x32>
    println_msg("Select one of the following options(by entering its number):\t");
    1288:	8e e5       	ldi	r24, 0x5E	; 94
    128a:	92 e0       	ldi	r25, 0x02	; 2
    128c:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    println_msg("[1] Add user\t");
    1290:	8c e9       	ldi	r24, 0x9C	; 156
    1292:	92 e0       	ldi	r25, 0x02	; 2
    1294:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    println_msg("[2] Delete user\t");
    1298:	8a ea       	ldi	r24, 0xAA	; 170
    129a:	92 e0       	ldi	r25, 0x02	; 2
    129c:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    println_msg("[3] Control a device\t");
    12a0:	8b eb       	ldi	r24, 0xBB	; 187
    12a2:	92 e0       	ldi	r25, 0x02	; 2
    12a4:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    println_msg("[4] Log out\t");
    12a8:	81 ed       	ldi	r24, 0xD1	; 209
    12aa:	92 e0       	ldi	r25, 0x02	; 2
    12ac:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    12b0:	08 95       	ret
    }
  else {
    println_msg("Select one of the following options(by entering its number):\t");
    12b2:	8e e5       	ldi	r24, 0x5E	; 94
    12b4:	92 e0       	ldi	r25, 0x02	; 2
    12b6:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    println_msg("[1] Control a device\t");
    12ba:	8e ed       	ldi	r24, 0xDE	; 222
    12bc:	92 e0       	ldi	r25, 0x02	; 2
    12be:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    println_msg("[2] Log out\t");
    12c2:	84 ef       	ldi	r24, 0xF4	; 244
    12c4:	92 e0       	ldi	r25, 0x02	; 2
    12c6:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    12ca:	08 95       	ret

000012cc <delete_user_prompt>:
  strcpy(user_dialog_tree, options);
  msg_length = msgLength;
  }

void delete_user_prompt(void) {
  if (invalid_user_input) {
    12cc:	80 91 f9 05 	lds	r24, 0x05F9	; 0x8005f9 <invalid_user_input>
    12d0:	88 23       	and	r24, r24
    12d2:	61 f0       	breq	.+24     	; 0x12ec <delete_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    12d4:	81 e0       	ldi	r24, 0x01	; 1
    12d6:	93 e0       	ldi	r25, 0x03	; 3
    12d8:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    12dc:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    12e0:	62 e0       	ldi	r22, 0x02	; 2
    12e2:	8a e9       	ldi	r24, 0x9A	; 154
    12e4:	99 e0       	ldi	r25, 0x09	; 9
    12e6:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    12ea:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    12ec:	6a e1       	ldi	r22, 0x1A	; 26
    12ee:	76 e0       	ldi	r23, 0x06	; 6
    12f0:	8e ed       	ldi	r24, 0xDE	; 222
    12f2:	95 e0       	ldi	r25, 0x05	; 5
    12f4:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    12f8:	83 30       	cpi	r24, 0x03	; 3
    12fa:	61 f4       	brne	.+24     	; 0x1314 <delete_user_prompt+0x48>
      println_msg("\rError! User not found. Returning to the main menu...");
    12fc:	87 e1       	ldi	r24, 0x17	; 23
    12fe:	93 e0       	ldi	r25, 0x03	; 3
    1300:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      print_initial_options_menu();
    1304:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1308:	62 e0       	ldi	r22, 0x02	; 2
    130a:	8a e9       	ldi	r24, 0x9A	; 154
    130c:	99 e0       	ldi	r25, 0x09	; 9
    130e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    1312:	08 95       	ret
      }
    else {
      // Delete the user
      delete_user(&temp_user);
    1314:	8a e1       	ldi	r24, 0x1A	; 26
    1316:	96 e0       	ldi	r25, 0x06	; 6
    1318:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <delete_user>
      println_msg("The user has been deleted successfully!\t");
    131c:	8d e4       	ldi	r24, 0x4D	; 77
    131e:	93 e0       	ldi	r25, 0x03	; 3
    1320:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1324:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1328:	62 e0       	ldi	r22, 0x02	; 2
    132a:	8a e9       	ldi	r24, 0x9A	; 154
    132c:	99 e0       	ldi	r25, 0x09	; 9
    132e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    1332:	08 95       	ret

00001334 <initial_options_menu>:
    println_msg("[2] Log out\t");
    }
  }

void initial_options_menu() {
  if (remote_user.isAdmin) {
    1334:	80 91 fa 05 	lds	r24, 0x05FA	; 0x8005fa <remote_user>
    1338:	88 23       	and	r24, r24
    133a:	09 f4       	brne	.+2      	; 0x133e <initial_options_menu+0xa>
    133c:	4b c0       	rjmp	.+150    	; 0x13d4 <initial_options_menu+0xa0>
    u8 option = msg_buffer[0];
    133e:	80 91 de 05 	lds	r24, 0x05DE	; 0x8005de <msg_buffer>
    if (invalid_user_input || option < '1' || option > '4') {
    1342:	90 91 f9 05 	lds	r25, 0x05F9	; 0x8005f9 <invalid_user_input>
    1346:	91 11       	cpse	r25, r1
    1348:	04 c0       	rjmp	.+8      	; 0x1352 <initial_options_menu+0x1e>
    134a:	81 33       	cpi	r24, 0x31	; 49
    134c:	10 f0       	brcs	.+4      	; 0x1352 <initial_options_menu+0x1e>
    134e:	85 33       	cpi	r24, 0x35	; 53
    1350:	60 f0       	brcs	.+24     	; 0x136a <initial_options_menu+0x36>
      println_msg("Invalid option!\t");
    1352:	86 e8       	ldi	r24, 0x86	; 134
    1354:	91 e0       	ldi	r25, 0x01	; 1
    1356:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      print_initial_options_menu();
    135a:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    135e:	62 e0       	ldi	r22, 0x02	; 2
    1360:	8a e9       	ldi	r24, 0x9A	; 154
    1362:	99 e0       	ldi	r25, 0x09	; 9
    1364:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    1368:	08 95       	ret
      }
    else {
      switch (option) {
    136a:	82 33       	cpi	r24, 0x32	; 50
    136c:	99 f0       	breq	.+38     	; 0x1394 <initial_options_menu+0x60>
    136e:	18 f4       	brcc	.+6      	; 0x1376 <initial_options_menu+0x42>
    1370:	81 33       	cpi	r24, 0x31	; 49
    1372:	31 f0       	breq	.+12     	; 0x1380 <initial_options_menu+0x4c>
    1374:	08 95       	ret
    1376:	83 33       	cpi	r24, 0x33	; 51
    1378:	b9 f0       	breq	.+46     	; 0x13a8 <initial_options_menu+0x74>
    137a:	84 33       	cpi	r24, 0x34	; 52
    137c:	e9 f0       	breq	.+58     	; 0x13b8 <initial_options_menu+0x84>
    137e:	08 95       	ret
          case '1':
            print_msg("Enter the user name: ");
    1380:	86 e7       	ldi	r24, 0x76	; 118
    1382:	93 e0       	ldi	r25, 0x03	; 3
    1384:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
            request_user_input(add_user_prompt, 13);
    1388:	6d e0       	ldi	r22, 0x0D	; 13
    138a:	8c e9       	ldi	r24, 0x9C	; 156
    138c:	9a e0       	ldi	r25, 0x0A	; 10
    138e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
            break;
    1392:	08 95       	ret
          case '2':
            print_msg("Enter the user name: ");
    1394:	86 e7       	ldi	r24, 0x76	; 118
    1396:	93 e0       	ldi	r25, 0x03	; 3
    1398:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
            request_user_input(delete_user_prompt, 13);
    139c:	6d e0       	ldi	r22, 0x0D	; 13
    139e:	86 e6       	ldi	r24, 0x66	; 102
    13a0:	99 e0       	ldi	r25, 0x09	; 9
    13a2:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
            break;
    13a6:	08 95       	ret
          case '3':
            print_remote_control_menu();
    13a8:	0e 94 68 08 	call	0x10d0	; 0x10d0 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    13ac:	62 e0       	ldi	r22, 0x02	; 2
    13ae:	86 ee       	ldi	r24, 0xE6	; 230
    13b0:	98 e0       	ldi	r25, 0x08	; 8
    13b2:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
            break;
    13b6:	08 95       	ret
          case '4':
            remote_user_loggedin = true;
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	80 93 db 05 	sts	0x05DB, r24	; 0x8005db <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    13be:	8c e8       	ldi	r24, 0x8C	; 140
    13c0:	93 e0       	ldi	r25, 0x03	; 3
    13c2:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
            println_msg("You have successfully logged out...");
    13c6:	84 ed       	ldi	r24, 0xD4	; 212
    13c8:	93 e0       	ldi	r25, 0x03	; 3
    13ca:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
            msg_length = 0;
    13ce:	10 92 ed 05 	sts	0x05ED, r1	; 0x8005ed <msg_length>
            break;
    13d2:	08 95       	ret
        }
      }
    }
  else {
    u8 option = msg_buffer[0];
    13d4:	80 91 de 05 	lds	r24, 0x05DE	; 0x8005de <msg_buffer>
    if (invalid_user_input || option < '1' || option > '2') {
    13d8:	90 91 f9 05 	lds	r25, 0x05F9	; 0x8005f9 <invalid_user_input>
    13dc:	91 11       	cpse	r25, r1
    13de:	04 c0       	rjmp	.+8      	; 0x13e8 <initial_options_menu+0xb4>
    13e0:	81 33       	cpi	r24, 0x31	; 49
    13e2:	10 f0       	brcs	.+4      	; 0x13e8 <initial_options_menu+0xb4>
    13e4:	83 33       	cpi	r24, 0x33	; 51
    13e6:	60 f0       	brcs	.+24     	; 0x1400 <initial_options_menu+0xcc>
      println_msg("Invalid option!\t");
    13e8:	86 e8       	ldi	r24, 0x86	; 134
    13ea:	91 e0       	ldi	r25, 0x01	; 1
    13ec:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      print_initial_options_menu();
    13f0:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    13f4:	62 e0       	ldi	r22, 0x02	; 2
    13f6:	8a e9       	ldi	r24, 0x9A	; 154
    13f8:	99 e0       	ldi	r25, 0x09	; 9
    13fa:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    13fe:	08 95       	ret
      }
    else {
      switch (option) {
    1400:	81 33       	cpi	r24, 0x31	; 49
    1402:	19 f0       	breq	.+6      	; 0x140a <initial_options_menu+0xd6>
    1404:	82 33       	cpi	r24, 0x32	; 50
    1406:	49 f0       	breq	.+18     	; 0x141a <initial_options_menu+0xe6>
    1408:	08 95       	ret
          case '1':
            print_remote_control_menu();
    140a:	0e 94 68 08 	call	0x10d0	; 0x10d0 <print_remote_control_menu>
            request_user_input(remote_control, 2);
    140e:	62 e0       	ldi	r22, 0x02	; 2
    1410:	86 ee       	ldi	r24, 0xE6	; 230
    1412:	98 e0       	ldi	r25, 0x08	; 8
    1414:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
            break;
    1418:	08 95       	ret
          case '2':
            remote_user_loggedin = true;
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	80 93 db 05 	sts	0x05DB, r24	; 0x8005db <remote_user_loggedin>
            println_msg("To login again you have to disconnect and reconnect to the BT module...");
    1420:	8c e8       	ldi	r24, 0x8C	; 140
    1422:	93 e0       	ldi	r25, 0x03	; 3
    1424:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
            println_msg("You have successfully logged out...");
    1428:	84 ed       	ldi	r24, 0xD4	; 212
    142a:	93 e0       	ldi	r25, 0x03	; 3
    142c:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
            msg_length = 0;
    1430:	10 92 ed 05 	sts	0x05ED, r1	; 0x8005ed <msg_length>
    1434:	08 95       	ret

00001436 <add_user_isAdmin_prompt>:
      }
    }
  }

void add_user_isAdmin_prompt(void) {
  if (invalid_user_input) {
    1436:	80 91 f9 05 	lds	r24, 0x05F9	; 0x8005f9 <invalid_user_input>
    143a:	88 23       	and	r24, r24
    143c:	61 f0       	breq	.+24     	; 0x1456 <add_user_isAdmin_prompt+0x20>
    println_msg("\r\nInvalid input!!\t");
    143e:	84 ee       	ldi	r24, 0xE4	; 228
    1440:	90 e0       	ldi	r25, 0x00	; 0
    1442:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    //! The system should ask the user wether he wants to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1446:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    144a:	62 e0       	ldi	r22, 0x02	; 2
    144c:	8a e9       	ldi	r24, 0x9A	; 154
    144e:	99 e0       	ldi	r25, 0x09	; 9
    1450:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    1454:	08 95       	ret
    }
  else {
    new_user.isAdmin = (msg_buffer[0] == 'y' || msg_buffer[0] == 'Y');
    1456:	80 91 de 05 	lds	r24, 0x05DE	; 0x8005de <msg_buffer>
    145a:	89 37       	cpi	r24, 0x79	; 121
    145c:	21 f0       	breq	.+8      	; 0x1466 <add_user_isAdmin_prompt+0x30>
    145e:	89 35       	cpi	r24, 0x59	; 89
    1460:	21 f4       	brne	.+8      	; 0x146a <add_user_isAdmin_prompt+0x34>
    1462:	81 e0       	ldi	r24, 0x01	; 1
    1464:	03 c0       	rjmp	.+6      	; 0x146c <add_user_isAdmin_prompt+0x36>
    1466:	81 e0       	ldi	r24, 0x01	; 1
    1468:	01 c0       	rjmp	.+2      	; 0x146c <add_user_isAdmin_prompt+0x36>
    146a:	80 e0       	ldi	r24, 0x00	; 0
    146c:	80 93 3d 06 	sts	0x063D, r24	; 0x80063d <new_user>
    add_user(&new_user);
    1470:	8d e3       	ldi	r24, 0x3D	; 61
    1472:	96 e0       	ldi	r25, 0x06	; 6
    1474:	0e 94 0b 0e 	call	0x1c16	; 0x1c16 <add_user>
    println_msg("User has been added successfully!");
    1478:	88 ef       	ldi	r24, 0xF8	; 248
    147a:	93 e0       	ldi	r25, 0x03	; 3
    147c:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    //! Return to the main menu
    print_initial_options_menu();
    1480:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    1484:	62 e0       	ldi	r22, 0x02	; 2
    1486:	8a e9       	ldi	r24, 0x9A	; 154
    1488:	99 e0       	ldi	r25, 0x09	; 9
    148a:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    148e:	08 95       	ret

00001490 <add_user_password_prompt>:
    }
  }

void add_user_password_prompt(void) {
  if (invalid_user_input) {
    1490:	80 91 f9 05 	lds	r24, 0x05F9	; 0x8005f9 <invalid_user_input>
    1494:	88 23       	and	r24, r24
    1496:	61 f0       	breq	.+24     	; 0x14b0 <add_user_password_prompt+0x20>
    println_msg("\r\nPassword too long!!\t");
    1498:	8a e1       	ldi	r24, 0x1A	; 26
    149a:	94 e0       	ldi	r25, 0x04	; 4
    149c:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    14a0:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    14a4:	62 e0       	ldi	r22, 0x02	; 2
    14a6:	8a e9       	ldi	r24, 0x9A	; 154
    14a8:	99 e0       	ldi	r25, 0x09	; 9
    14aa:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    14ae:	08 95       	ret
    }
  else {
    strcpy(new_user.password, msg_buffer);
    14b0:	6e ed       	ldi	r22, 0xDE	; 222
    14b2:	75 e0       	ldi	r23, 0x05	; 5
    14b4:	82 e5       	ldi	r24, 0x52	; 82
    14b6:	96 e0       	ldi	r25, 0x06	; 6
    14b8:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
    print_msg("Do you want to make the new user an admin? (y/n) ");
    14bc:	81 e3       	ldi	r24, 0x31	; 49
    14be:	94 e0       	ldi	r25, 0x04	; 4
    14c0:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
    request_user_input(add_user_isAdmin_prompt, 2);
    14c4:	62 e0       	ldi	r22, 0x02	; 2
    14c6:	8b e1       	ldi	r24, 0x1B	; 27
    14c8:	9a e0       	ldi	r25, 0x0A	; 10
    14ca:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    14ce:	08 95       	ret

000014d0 <add_user_code_prompt>:
    }
  }

void add_user_code_prompt(void) {
  if (invalid_user_input) {
    14d0:	80 91 f9 05 	lds	r24, 0x05F9	; 0x8005f9 <invalid_user_input>
    14d4:	88 23       	and	r24, r24
    14d6:	61 f0       	breq	.+24     	; 0x14f0 <add_user_code_prompt+0x20>
    println_msg("\r\nInvalid user code!\t");
    14d8:	83 e6       	ldi	r24, 0x63	; 99
    14da:	94 e0       	ldi	r25, 0x04	; 4
    14dc:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    14e0:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    14e4:	62 e0       	ldi	r22, 0x02	; 2
    14e6:	8a e9       	ldi	r24, 0x9A	; 154
    14e8:	99 e0       	ldi	r25, 0x09	; 9
    14ea:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    14ee:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByCode(msg_buffer, &temp_user);
    14f0:	6a e1       	ldi	r22, 0x1A	; 26
    14f2:	76 e0       	ldi	r23, 0x06	; 6
    14f4:	8e ed       	ldi	r24, 0xDE	; 222
    14f6:	95 e0       	ldi	r25, 0x05	; 5
    14f8:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <getUserByCode>
    if (userExists == USER_NOT_FOUND) {
    14fc:	83 30       	cpi	r24, 0x03	; 3
    14fe:	81 f4       	brne	.+32     	; 0x1520 <add_user_code_prompt+0x50>
      strcpy(new_user.code, msg_buffer);
    1500:	6e ed       	ldi	r22, 0xDE	; 222
    1502:	75 e0       	ldi	r23, 0x05	; 5
    1504:	8b e4       	ldi	r24, 0x4B	; 75
    1506:	96 e0       	ldi	r25, 0x06	; 6
    1508:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
      print_msg("Enter the new user's password: ");
    150c:	89 e7       	ldi	r24, 0x79	; 121
    150e:	94 e0       	ldi	r25, 0x04	; 4
    1510:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
      request_user_input(add_user_password_prompt, 11);
    1514:	6b e0       	ldi	r22, 0x0B	; 11
    1516:	88 e4       	ldi	r24, 0x48	; 72
    1518:	9a e0       	ldi	r25, 0x0A	; 10
    151a:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    151e:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      println_msg("\rThe user code already exists!\t");
    1520:	89 e9       	ldi	r24, 0x99	; 153
    1522:	94 e0       	ldi	r25, 0x04	; 4
    1524:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1528:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    152c:	62 e0       	ldi	r22, 0x02	; 2
    152e:	8a e9       	ldi	r24, 0x9A	; 154
    1530:	99 e0       	ldi	r25, 0x09	; 9
    1532:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    1536:	08 95       	ret

00001538 <add_user_prompt>:
      }
    }
  }

void add_user_prompt(void) {
  if (invalid_user_input) {
    1538:	80 91 f9 05 	lds	r24, 0x05F9	; 0x8005f9 <invalid_user_input>
    153c:	88 23       	and	r24, r24
    153e:	61 f0       	breq	.+24     	; 0x1558 <add_user_prompt+0x20>
    println_msg("\r\nInvalid user name!\t");
    1540:	81 e0       	ldi	r24, 0x01	; 1
    1542:	93 e0       	ldi	r25, 0x03	; 3
    1544:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    //! The system should ask the user wether he want s to continue or not, and continue to validate his input. 
    //! But due to close deadline, the user will be returned to the initial menu.
    print_initial_options_menu();
    1548:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2);
    154c:	62 e0       	ldi	r22, 0x02	; 2
    154e:	8a e9       	ldi	r24, 0x9A	; 154
    1550:	99 e0       	ldi	r25, 0x09	; 9
    1552:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    1556:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    1558:	6a e1       	ldi	r22, 0x1A	; 26
    155a:	76 e0       	ldi	r23, 0x06	; 6
    155c:	8e ed       	ldi	r24, 0xDE	; 222
    155e:	95 e0       	ldi	r25, 0x05	; 5
    1560:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    1564:	83 30       	cpi	r24, 0x03	; 3
    1566:	81 f4       	brne	.+32     	; 0x1588 <add_user_prompt+0x50>
      strcpy(new_user.name, msg_buffer);
    1568:	6e ed       	ldi	r22, 0xDE	; 222
    156a:	75 e0       	ldi	r23, 0x05	; 5
    156c:	8e e3       	ldi	r24, 0x3E	; 62
    156e:	96 e0       	ldi	r25, 0x06	; 6
    1570:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
      print_msg("Enter the new user's code(must be a unique six digit code): ");
    1574:	89 eb       	ldi	r24, 0xB9	; 185
    1576:	94 e0       	ldi	r25, 0x04	; 4
    1578:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
      request_user_input(add_user_code_prompt, 7);
    157c:	67 e0       	ldi	r22, 0x07	; 7
    157e:	88 e6       	ldi	r24, 0x68	; 104
    1580:	9a e0       	ldi	r25, 0x0A	; 10
    1582:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    1586:	08 95       	ret
      }
    else {
      // Prompt the user to enter the user code
      println_msg("\rThe user already exists!\t");
    1588:	86 ef       	ldi	r24, 0xF6	; 246
    158a:	94 e0       	ldi	r25, 0x04	; 4
    158c:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      //! Return to the main menu
      print_initial_options_menu();
    1590:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1594:	62 e0       	ldi	r22, 0x02	; 2
    1596:	8a e9       	ldi	r24, 0x9A	; 154
    1598:	99 e0       	ldi	r25, 0x09	; 9
    159a:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    159e:	08 95       	ret

000015a0 <invalid_remote_login_attempt>:
      }
    }
  }

void invalid_remote_login_attempt(void) {
    15a0:	0f 93       	push	r16
    15a2:	1f 93       	push	r17
    15a4:	cf 93       	push	r28
    15a6:	df 93       	push	r29
    15a8:	cd b7       	in	r28, 0x3d	; 61
    15aa:	de b7       	in	r29, 0x3e	; 62
    15ac:	e2 97       	sbiw	r28, 0x32	; 50
    15ae:	0f b6       	in	r0, 0x3f	; 63
    15b0:	f8 94       	cli
    15b2:	de bf       	out	0x3e, r29	; 62
    15b4:	0f be       	out	0x3f, r0	; 63
    15b6:	cd bf       	out	0x3d, r28	; 61
  invalid_trails++;
    15b8:	80 91 da 05 	lds	r24, 0x05DA	; 0x8005da <__data_end>
    15bc:	8f 5f       	subi	r24, 0xFF	; 255
    15be:	80 93 da 05 	sts	0x05DA, r24	; 0x8005da <__data_end>
  if (invalid_trails < 3) {
    15c2:	83 30       	cpi	r24, 0x03	; 3
    15c4:	e8 f4       	brcc	.+58     	; 0x1600 <invalid_remote_login_attempt+0x60>
    s8 msg[50];
    sprintf(msg, "\r\nInvalid login attempt! \r\n%d attempts remaining.", 3 - invalid_trails);
    15c6:	23 e0       	ldi	r18, 0x03	; 3
    15c8:	30 e0       	ldi	r19, 0x00	; 0
    15ca:	a9 01       	movw	r20, r18
    15cc:	48 1b       	sub	r20, r24
    15ce:	51 09       	sbc	r21, r1
    15d0:	ca 01       	movw	r24, r20
    15d2:	9f 93       	push	r25
    15d4:	4f 93       	push	r20
    15d6:	81 e1       	ldi	r24, 0x11	; 17
    15d8:	95 e0       	ldi	r25, 0x05	; 5
    15da:	9f 93       	push	r25
    15dc:	8f 93       	push	r24
    15de:	8e 01       	movw	r16, r28
    15e0:	0f 5f       	subi	r16, 0xFF	; 255
    15e2:	1f 4f       	sbci	r17, 0xFF	; 255
    15e4:	1f 93       	push	r17
    15e6:	0f 93       	push	r16
    15e8:	0e 94 d8 10 	call	0x21b0	; 0x21b0 <sprintf>
    println_msg(msg);
    15ec:	c8 01       	movw	r24, r16
    15ee:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
    15f2:	0f 90       	pop	r0
    15f4:	0f 90       	pop	r0
    15f6:	0f 90       	pop	r0
    15f8:	0f 90       	pop	r0
    15fa:	0f 90       	pop	r0
    15fc:	0f 90       	pop	r0
    15fe:	04 c0       	rjmp	.+8      	; 0x1608 <invalid_remote_login_attempt+0x68>
    return;
    }
  Alarm_set();
    1600:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <Alarm_set>
  run_system = false;
    1604:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
  }
    1608:	e2 96       	adiw	r28, 0x32	; 50
    160a:	0f b6       	in	r0, 0x3f	; 63
    160c:	f8 94       	cli
    160e:	de bf       	out	0x3e, r29	; 62
    1610:	0f be       	out	0x3f, r0	; 63
    1612:	cd bf       	out	0x3d, r28	; 61
    1614:	df 91       	pop	r29
    1616:	cf 91       	pop	r28
    1618:	1f 91       	pop	r17
    161a:	0f 91       	pop	r16
    161c:	08 95       	ret

0000161e <userPassword_prompt_handler>:

void userPassword_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    161e:	80 91 f9 05 	lds	r24, 0x05F9	; 0x8005f9 <invalid_user_input>
    1622:	88 23       	and	r24, r24
    1624:	61 f0       	breq	.+24     	; 0x163e <userPassword_prompt_handler+0x20>
    invalid_remote_login_attempt();
    1626:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <invalid_remote_login_attempt>
    print_msg("Enter your password:\t");
    162a:	83 e4       	ldi	r24, 0x43	; 67
    162c:	95 e0       	ldi	r25, 0x05	; 5
    162e:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
    request_user_input(userPassword_prompt_handler, 11);
    1632:	6b e0       	ldi	r22, 0x0B	; 11
    1634:	8f e0       	ldi	r24, 0x0F	; 15
    1636:	9b e0       	ldi	r25, 0x0B	; 11
    1638:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    163c:	08 95       	ret
    }
  else {
    if (strcmp(remote_user.password, msg_buffer)) { // Wrong password
    163e:	6e ed       	ldi	r22, 0xDE	; 222
    1640:	75 e0       	ldi	r23, 0x05	; 5
    1642:	8f e0       	ldi	r24, 0x0F	; 15
    1644:	96 e0       	ldi	r25, 0x06	; 6
    1646:	0e 94 c8 10 	call	0x2190	; 0x2190 <strcmp>
    164a:	89 2b       	or	r24, r25
    164c:	81 f0       	breq	.+32     	; 0x166e <userPassword_prompt_handler+0x50>
      print_msg("Wrong password!");
    164e:	89 e5       	ldi	r24, 0x59	; 89
    1650:	95 e0       	ldi	r25, 0x05	; 5
    1652:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
      invalid_remote_login_attempt();
    1656:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <invalid_remote_login_attempt>
      print_msg("Enter your password:\t");
    165a:	83 e4       	ldi	r24, 0x43	; 67
    165c:	95 e0       	ldi	r25, 0x05	; 5
    165e:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    1662:	6b e0       	ldi	r22, 0x0B	; 11
    1664:	8f e0       	ldi	r24, 0x0F	; 15
    1666:	9b e0       	ldi	r25, 0x0B	; 11
    1668:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    166c:	08 95       	ret
      }
    else {
      remote_user_loggedin = true;
    166e:	81 e0       	ldi	r24, 0x01	; 1
    1670:	80 93 db 05 	sts	0x05DB, r24	; 0x8005db <remote_user_loggedin>
      print_msg("Welcome ");
    1674:	89 e6       	ldi	r24, 0x69	; 105
    1676:	95 e0       	ldi	r25, 0x05	; 5
    1678:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
      print_msg(remote_user.name);
    167c:	8b ef       	ldi	r24, 0xFB	; 251
    167e:	95 e0       	ldi	r25, 0x05	; 5
    1680:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
      println_msg("!");
    1684:	86 e5       	ldi	r24, 0x56	; 86
    1686:	91 e0       	ldi	r25, 0x01	; 1
    1688:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
      // Show the options menu
      print_initial_options_menu();
    168c:	0e 94 40 09 	call	0x1280	; 0x1280 <print_initial_options_menu>
      request_user_input(initial_options_menu, 2);
    1690:	62 e0       	ldi	r22, 0x02	; 2
    1692:	8a e9       	ldi	r24, 0x9A	; 154
    1694:	99 e0       	ldi	r25, 0x09	; 9
    1696:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    169a:	08 95       	ret

0000169c <userName_prompt_handler>:
    }
  }

void userName_prompt_handler(void) {
  // Validate the given username (length and syntax)
  if (invalid_user_input) {
    169c:	80 91 f9 05 	lds	r24, 0x05F9	; 0x8005f9 <invalid_user_input>
    16a0:	88 23       	and	r24, r24
    16a2:	61 f0       	breq	.+24     	; 0x16bc <userName_prompt_handler+0x20>
    invalid_remote_login_attempt();
    16a4:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <invalid_remote_login_attempt>
    print_msg("Enter your user name:\t");
    16a8:	82 e7       	ldi	r24, 0x72	; 114
    16aa:	95 e0       	ldi	r25, 0x05	; 5
    16ac:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
    request_user_input(userName_prompt_handler, 13);
    16b0:	6d e0       	ldi	r22, 0x0D	; 13
    16b2:	8e e4       	ldi	r24, 0x4E	; 78
    16b4:	9b e0       	ldi	r25, 0x0B	; 11
    16b6:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    16ba:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &remote_user);
    16bc:	6a ef       	ldi	r22, 0xFA	; 250
    16be:	75 e0       	ldi	r23, 0x05	; 5
    16c0:	8e ed       	ldi	r24, 0xDE	; 222
    16c2:	95 e0       	ldi	r25, 0x05	; 5
    16c4:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    16c8:	83 30       	cpi	r24, 0x03	; 3
    16ca:	81 f4       	brne	.+32     	; 0x16ec <userName_prompt_handler+0x50>
      print_msg("User doesn't exist!");
    16cc:	89 e8       	ldi	r24, 0x89	; 137
    16ce:	95 e0       	ldi	r25, 0x05	; 5
    16d0:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
      invalid_remote_login_attempt();
    16d4:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <invalid_remote_login_attempt>
      print_msg("Enter your user name:\t");
    16d8:	82 e7       	ldi	r24, 0x72	; 114
    16da:	95 e0       	ldi	r25, 0x05	; 5
    16dc:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
      request_user_input(userName_prompt_handler, 13);
    16e0:	6d e0       	ldi	r22, 0x0D	; 13
    16e2:	8e e4       	ldi	r24, 0x4E	; 78
    16e4:	9b e0       	ldi	r25, 0x0B	; 11
    16e6:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    16ea:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      print_msg("Enter your password:\t");
    16ec:	83 e4       	ldi	r24, 0x43	; 67
    16ee:	95 e0       	ldi	r25, 0x05	; 5
    16f0:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
      request_user_input(userPassword_prompt_handler, 11);
    16f4:	6b e0       	ldi	r22, 0x0B	; 11
    16f6:	8f e0       	ldi	r24, 0x0F	; 15
    16f8:	9b e0       	ldi	r25, 0x0B	; 11
    16fa:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    16fe:	08 95       	ret

00001700 <remote_login_prompt>:
      }
    }
  }

void remote_login_prompt(void) {
  println_msg("Welcome to the Smart Home System!");
    1700:	8d e9       	ldi	r24, 0x9D	; 157
    1702:	95 e0       	ldi	r25, 0x05	; 5
    1704:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
  println_msg("To proceed, please login.");
    1708:	8f eb       	ldi	r24, 0xBF	; 191
    170a:	95 e0       	ldi	r25, 0x05	; 5
    170c:	0e 94 53 08 	call	0x10a6	; 0x10a6 <println_msg>
  print_msg("Enter your user name:\t");
    1710:	82 e7       	ldi	r24, 0x72	; 114
    1712:	95 e0       	ldi	r25, 0x05	; 5
    1714:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <print_msg>
  request_user_input(userName_prompt_handler, 13);
    1718:	6d e0       	ldi	r22, 0x0D	; 13
    171a:	8e e4       	ldi	r24, 0x4E	; 78
    171c:	9b e0       	ldi	r25, 0x0B	; 11
    171e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <request_user_input>
    1722:	08 95       	ret

00001724 <__vector_13>:
  }

// Handles the user input asynchronously.
ISR(USART_RXC_vect) {
    1724:	1f 92       	push	r1
    1726:	0f 92       	push	r0
    1728:	0f b6       	in	r0, 0x3f	; 63
    172a:	0f 92       	push	r0
    172c:	11 24       	eor	r1, r1
    172e:	2f 93       	push	r18
    1730:	3f 93       	push	r19
    1732:	4f 93       	push	r20
    1734:	5f 93       	push	r21
    1736:	6f 93       	push	r22
    1738:	7f 93       	push	r23
    173a:	8f 93       	push	r24
    173c:	9f 93       	push	r25
    173e:	af 93       	push	r26
    1740:	bf 93       	push	r27
    1742:	ef 93       	push	r30
    1744:	ff 93       	push	r31
#if UART_COMMUNICATION_INTERFACE ==  PROTEUS_VIRTUAL_TERMINAL
  // Read the UDR to clear the RXC bit
  udr_temp = UDR;
    1746:	8c b1       	in	r24, 0x0c	; 12
    1748:	80 93 3b 06 	sts	0x063B, r24	; 0x80063b <udr_temp>

  // If no input requested, ignore the input. No input requested is indicated by msg length of zero
  if (msg_length == 0) return;
    174c:	90 91 ed 05 	lds	r25, 0x05ED	; 0x8005ed <msg_length>
    1750:	99 23       	and	r25, r25
    1752:	09 f4       	brne	.+2      	; 0x1756 <__vector_13+0x32>
    1754:	4d c0       	rjmp	.+154    	; 0x17f0 <__vector_13+0xcc>

  // Handling backspaces
  if (udr_temp == '\b') {
    1756:	88 30       	cpi	r24, 0x08	; 8
    1758:	59 f4       	brne	.+22     	; 0x1770 <__vector_13+0x4c>
    if (msg_buffer_pointer > 0) {
    175a:	90 91 dc 05 	lds	r25, 0x05DC	; 0x8005dc <msg_buffer_pointer>
    175e:	99 23       	and	r25, r25
    1760:	09 f4       	brne	.+2      	; 0x1764 <__vector_13+0x40>
    1762:	46 c0       	rjmp	.+140    	; 0x17f0 <__vector_13+0xcc>
      msg_buffer_pointer--;
    1764:	91 50       	subi	r25, 0x01	; 1
    1766:	90 93 dc 05 	sts	0x05DC, r25	; 0x8005dc <msg_buffer_pointer>
      BT_sendChar(udr_temp);
    176a:	0e 94 e5 01 	call	0x3ca	; 0x3ca <BT_sendChar>
    176e:	40 c0       	rjmp	.+128    	; 0x17f0 <__vector_13+0xcc>
      }
    return;
    }

  msg_buffer[msg_buffer_pointer] = udr_temp;
    1770:	90 91 dc 05 	lds	r25, 0x05DC	; 0x8005dc <msg_buffer_pointer>
    1774:	e9 2f       	mov	r30, r25
    1776:	f0 e0       	ldi	r31, 0x00	; 0
    1778:	e2 52       	subi	r30, 0x22	; 34
    177a:	fa 4f       	sbci	r31, 0xFA	; 250
    177c:	80 83       	st	Z, r24
  msg_buffer_pointer++;
    177e:	9f 5f       	subi	r25, 0xFF	; 255
    1780:	90 93 dc 05 	sts	0x05DC, r25	; 0x8005dc <msg_buffer_pointer>

  // Msg is empty
  // Ignore null msgs
  if (msg_buffer_pointer == 1) {
    1784:	91 30       	cpi	r25, 0x01	; 1
    1786:	39 f4       	brne	.+14     	; 0x1796 <__vector_13+0x72>
    if (msg_buffer[0] == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    1788:	90 91 de 05 	lds	r25, 0x05DE	; 0x8005de <msg_buffer>
    178c:	9d 30       	cpi	r25, 0x0D	; 13
    178e:	19 f4       	brne	.+6      	; 0x1796 <__vector_13+0x72>
      msg_buffer_pointer = 0;
    1790:	10 92 dc 05 	sts	0x05DC, r1	; 0x8005dc <msg_buffer_pointer>
      return;
    1794:	2d c0       	rjmp	.+90     	; 0x17f0 <__vector_13+0xcc>
      }
    }

  // Echo the sent char on the terminal
  //! Proteus virtual terminal doesn't send a line feed char (ASCII code: 10). Instead it sends a carriage return (ASCII code: 13).
  if (udr_temp != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER)
    1796:	8d 30       	cpi	r24, 0x0D	; 13
    1798:	11 f0       	breq	.+4      	; 0x179e <__vector_13+0x7a>
    BT_sendChar(udr_temp);
    179a:	0e 94 e5 01 	call	0x3ca	; 0x3ca <BT_sendChar>

  // Msg is longer than required
  if (msg_buffer_pointer == msg_length) {
    179e:	e0 91 dc 05 	lds	r30, 0x05DC	; 0x8005dc <msg_buffer_pointer>
    17a2:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <msg_length>
    17a6:	e8 13       	cpse	r30, r24
    17a8:	10 c0       	rjmp	.+32     	; 0x17ca <__vector_13+0xa6>
    if (msg_buffer[msg_buffer_pointer - 1] != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    17aa:	f0 e0       	ldi	r31, 0x00	; 0
    17ac:	e3 52       	subi	r30, 0x23	; 35
    17ae:	fa 4f       	sbci	r31, 0xFA	; 250
    17b0:	80 81       	ld	r24, Z
    17b2:	8d 30       	cpi	r24, 0x0D	; 13
    17b4:	51 f0       	breq	.+20     	; 0x17ca <__vector_13+0xa6>
      invalid_user_input = true;
    17b6:	81 e0       	ldi	r24, 0x01	; 1
    17b8:	80 93 f9 05 	sts	0x05F9, r24	; 0x8005f9 <invalid_user_input>
      dump_invalid_data = true;
    17bc:	80 93 3a 06 	sts	0x063A, r24	; 0x80063a <dump_invalid_data>
      msg_buffer_pointer = 0;
    17c0:	10 92 dc 05 	sts	0x05DC, r1	; 0x8005dc <msg_buffer_pointer>
      BT_sendChar('\r');
    17c4:	8d e0       	ldi	r24, 0x0D	; 13
    17c6:	0e 94 e5 01 	call	0x3ca	; 0x3ca <BT_sendChar>
      Remote_control_interface(user_dialog_tree);
      }
    }

  // Msg has ended and is within the required length
  if (udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    17ca:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <udr_temp>
    17ce:	8d 30       	cpi	r24, 0x0D	; 13
    17d0:	79 f4       	brne	.+30     	; 0x17f0 <__vector_13+0xcc>
    if (msg_buffer_pointer <= msg_length) {
    17d2:	e0 91 dc 05 	lds	r30, 0x05DC	; 0x8005dc <msg_buffer_pointer>
    17d6:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <msg_length>
    17da:	8e 17       	cp	r24, r30
    17dc:	48 f0       	brcs	.+18     	; 0x17f0 <__vector_13+0xcc>
      // Replace the carriage return with null to terminate the string correctly
      msg_buffer[msg_buffer_pointer - 1] = '\0';
    17de:	f0 e0       	ldi	r31, 0x00	; 0
    17e0:	e3 52       	subi	r30, 0x23	; 35
    17e2:	fa 4f       	sbci	r31, 0xFA	; 250
    17e4:	10 82       	st	Z, r1
      BT_sendChar('\r');
    17e6:	8d e0       	ldi	r24, 0x0D	; 13
    17e8:	0e 94 e5 01 	call	0x3ca	; 0x3ca <BT_sendChar>
      Remote_control_interface(user_dialog_tree);
      msg_buffer_pointer = 0;
    17ec:	10 92 dc 05 	sts	0x05DC, r1	; 0x8005dc <msg_buffer_pointer>
      Remote_control_interface(user_dialog_tree);
      msg_buffer_pointer = 0;
      }
    }
#endif
  }
    17f0:	ff 91       	pop	r31
    17f2:	ef 91       	pop	r30
    17f4:	bf 91       	pop	r27
    17f6:	af 91       	pop	r26
    17f8:	9f 91       	pop	r25
    17fa:	8f 91       	pop	r24
    17fc:	7f 91       	pop	r23
    17fe:	6f 91       	pop	r22
    1800:	5f 91       	pop	r21
    1802:	4f 91       	pop	r20
    1804:	3f 91       	pop	r19
    1806:	2f 91       	pop	r18
    1808:	0f 90       	pop	r0
    180a:	0f be       	out	0x3f, r0	; 63
    180c:	0f 90       	pop	r0
    180e:	1f 90       	pop	r1
    1810:	18 95       	reti

00001812 <__vector_1>:

ISR(INT0_vect) {
    1812:	1f 92       	push	r1
    1814:	0f 92       	push	r0
    1816:	0f b6       	in	r0, 0x3f	; 63
    1818:	0f 92       	push	r0
    181a:	11 24       	eor	r1, r1
    181c:	2f 93       	push	r18
    181e:	3f 93       	push	r19
    1820:	4f 93       	push	r20
    1822:	5f 93       	push	r21
    1824:	6f 93       	push	r22
    1826:	7f 93       	push	r23
    1828:	8f 93       	push	r24
    182a:	9f 93       	push	r25
    182c:	af 93       	push	r26
    182e:	bf 93       	push	r27
    1830:	ef 93       	push	r30
    1832:	ff 93       	push	r31
  // Initialize communication with the user
  // Request user login credentials
  remote_login_prompt();
    1834:	0e 94 80 0b 	call	0x1700	; 0x1700 <remote_login_prompt>
  }
    1838:	ff 91       	pop	r31
    183a:	ef 91       	pop	r30
    183c:	bf 91       	pop	r27
    183e:	af 91       	pop	r26
    1840:	9f 91       	pop	r25
    1842:	8f 91       	pop	r24
    1844:	7f 91       	pop	r23
    1846:	6f 91       	pop	r22
    1848:	5f 91       	pop	r21
    184a:	4f 91       	pop	r20
    184c:	3f 91       	pop	r19
    184e:	2f 91       	pop	r18
    1850:	0f 90       	pop	r0
    1852:	0f be       	out	0x3f, r0	; 63
    1854:	0f 90       	pop	r0
    1856:	1f 90       	pop	r1
    1858:	18 95       	reti

0000185a <__vector_16>:
#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_BY_ACTIVATING_TIMER0_OVF_INT
// To reset the TOV0 flag. Alternatively, it can be reset in the ADC complete interrupt.
ISR(TIMER0_OVF_vect) {}
#endif

ISR(ADC_vect) {
    185a:	1f 92       	push	r1
    185c:	0f 92       	push	r0
    185e:	0f b6       	in	r0, 0x3f	; 63
    1860:	0f 92       	push	r0
    1862:	11 24       	eor	r1, r1
    1864:	2f 93       	push	r18
    1866:	3f 93       	push	r19
    1868:	4f 93       	push	r20
    186a:	5f 93       	push	r21
    186c:	6f 93       	push	r22
    186e:	7f 93       	push	r23
    1870:	8f 93       	push	r24
    1872:	9f 93       	push	r25
    1874:	af 93       	push	r26
    1876:	bf 93       	push	r27
    1878:	cf 93       	push	r28
    187a:	df 93       	push	r29
    187c:	ef 93       	push	r30
    187e:	ff 93       	push	r31
  u16 temperature;
  temperature = ADCL + (ADCH << 8);
    1880:	84 b1       	in	r24, 0x04	; 4
    1882:	c5 b1       	in	r28, 0x05	; 5
    1884:	d0 e0       	ldi	r29, 0x00	; 0
    1886:	dc 2f       	mov	r29, r28
    1888:	cc 27       	eor	r28, r28
    188a:	c8 0f       	add	r28, r24
    188c:	d1 1d       	adc	r29, r1
  // Since the ADC is set to use the internal VREF of 2.56 V, the resolution of the ADC is 2.5 mV. This resolution allows to measure the temperature
  // out of the LM35 with a resolution of 0.25 degree celsius, since each 10mV  increment on the LM35 output is 1 degree C.
  // If the temperature is higher than the maximum specified temperature, turn on the AC.
  if (temperature > AMBIENT_HIGH_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, HIGH);
    188e:	c1 37       	cpi	r28, 0x71	; 113
    1890:	d1 05       	cpc	r29, r1
    1892:	28 f0       	brcs	.+10     	; 0x189e <__vector_16+0x44>
    1894:	41 e0       	ldi	r20, 0x01	; 1
    1896:	63 e4       	ldi	r22, 0x43	; 67
    1898:	87 e0       	ldi	r24, 0x07	; 7
    189a:	0e 94 ef 02 	call	0x5de	; 0x5de <DIO_write>
  // If the temperature became below the minimum specified temperature turn off the AC.
  if (temperature < AMBIENT_LOW_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, LOW);
    189e:	c4 35       	cpi	r28, 0x54	; 84
    18a0:	d1 05       	cpc	r29, r1
    18a2:	28 f4       	brcc	.+10     	; 0x18ae <__vector_16+0x54>
    18a4:	40 e0       	ldi	r20, 0x00	; 0
    18a6:	63 e4       	ldi	r22, 0x43	; 67
    18a8:	87 e0       	ldi	r24, 0x07	; 7
    18aa:	0e 94 ef 02 	call	0x5de	; 0x5de <DIO_write>

#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_VIA_ADC_COMPLETE_INTERRUPT
  // Since the ADC is configured in auto trigger mode with timer 0 overflow as the trigger, 
  // The overflow interrupt flag bit must be cleared by software if timer 0 overflow interrupt isn't used. 
  // Otherwise the triggering won't work and the ADC will halt.
  set_bit(TIFR, TOV0);
    18ae:	88 b7       	in	r24, 0x38	; 56
    18b0:	81 60       	ori	r24, 0x01	; 1
    18b2:	88 bf       	out	0x38, r24	; 56
#endif
    18b4:	ff 91       	pop	r31
    18b6:	ef 91       	pop	r30
    18b8:	df 91       	pop	r29
    18ba:	cf 91       	pop	r28
    18bc:	bf 91       	pop	r27
    18be:	af 91       	pop	r26
    18c0:	9f 91       	pop	r25
    18c2:	8f 91       	pop	r24
    18c4:	7f 91       	pop	r23
    18c6:	6f 91       	pop	r22
    18c8:	5f 91       	pop	r21
    18ca:	4f 91       	pop	r20
    18cc:	3f 91       	pop	r19
    18ce:	2f 91       	pop	r18
    18d0:	0f 90       	pop	r0
    18d2:	0f be       	out	0x3f, r0	; 63
    18d4:	0f 90       	pop	r0
    18d6:	1f 90       	pop	r1
    18d8:	18 95       	reti

000018da <User_DB_init>:
    return getUserByName(user_code_or_name, user);
    }
  else {
    return getUserByCode(user_code_or_name, user);
    }
  }
    18da:	0e 94 a3 00 	call	0x146	; 0x146 <EEPROM_init>
    18de:	08 95       	ret

000018e0 <getUserByName>:
    18e0:	9f 92       	push	r9
    18e2:	af 92       	push	r10
    18e4:	bf 92       	push	r11
    18e6:	cf 92       	push	r12
    18e8:	df 92       	push	r13
    18ea:	ef 92       	push	r14
    18ec:	ff 92       	push	r15
    18ee:	0f 93       	push	r16
    18f0:	1f 93       	push	r17
    18f2:	cf 93       	push	r28
    18f4:	df 93       	push	r29
    18f6:	cd b7       	in	r28, 0x3d	; 61
    18f8:	de b7       	in	r29, 0x3e	; 62
    18fa:	6d 97       	sbiw	r28, 0x1d	; 29
    18fc:	0f b6       	in	r0, 0x3f	; 63
    18fe:	f8 94       	cli
    1900:	de bf       	out	0x3e, r29	; 62
    1902:	0f be       	out	0x3f, r0	; 63
    1904:	cd bf       	out	0x3d, r28	; 61
    1906:	7c 01       	movw	r14, r24
    1908:	6b 01       	movw	r12, r22
    190a:	91 2c       	mov	r9, r1
    190c:	6b c0       	rjmp	.+214    	; 0x19e4 <getUserByName+0x104>
    190e:	ae 01       	movw	r20, r28
    1910:	4f 5f       	subi	r20, 0xFF	; 255
    1912:	5f 4f       	sbci	r21, 0xFF	; 255
    1914:	60 e0       	ldi	r22, 0x00	; 0
    1916:	89 2d       	mov	r24, r9
    1918:	0e 94 a6 00 	call	0x14c	; 0x14c <EEPROM_read_byte>
    191c:	ae 01       	movw	r20, r28
    191e:	4e 5f       	subi	r20, 0xFE	; 254
    1920:	5f 4f       	sbci	r21, 0xFF	; 255
    1922:	61 e0       	ldi	r22, 0x01	; 1
    1924:	89 2d       	mov	r24, r9
    1926:	0e 94 a6 00 	call	0x14c	; 0x14c <EEPROM_read_byte>
    192a:	b1 2c       	mov	r11, r1
    192c:	56 c0       	rjmp	.+172    	; 0x19da <getUserByName+0xfa>
    192e:	89 81       	ldd	r24, Y+1	; 0x01
    1930:	90 e0       	ldi	r25, 0x00	; 0
    1932:	0b 2c       	mov	r0, r11
    1934:	02 c0       	rjmp	.+4      	; 0x193a <getUserByName+0x5a>
    1936:	95 95       	asr	r25
    1938:	87 95       	ror	r24
    193a:	0a 94       	dec	r0
    193c:	e2 f7       	brpl	.-8      	; 0x1936 <getUserByName+0x56>
    193e:	80 ff       	sbrs	r24, 0
    1940:	4b c0       	rjmp	.+150    	; 0x19d8 <getUserByName+0xf8>
    1942:	6f e1       	ldi	r22, 0x1F	; 31
    1944:	b6 9e       	mul	r11, r22
    1946:	a0 2c       	mov	r10, r0
    1948:	11 24       	eor	r1, r1
    194a:	68 e0       	ldi	r22, 0x08	; 8
    194c:	6a 0d       	add	r22, r10
    194e:	9e 01       	movw	r18, r28
    1950:	2d 5f       	subi	r18, 0xFD	; 253
    1952:	3f 4f       	sbci	r19, 0xFF	; 255
    1954:	4d e0       	ldi	r20, 0x0D	; 13
    1956:	50 e0       	ldi	r21, 0x00	; 0
    1958:	89 2d       	mov	r24, r9
    195a:	0e 94 c7 00 	call	0x18e	; 0x18e <EEPROM_read_block>
    195e:	be 01       	movw	r22, r28
    1960:	6d 5f       	subi	r22, 0xFD	; 253
    1962:	7f 4f       	sbci	r23, 0xFF	; 255
    1964:	c7 01       	movw	r24, r14
    1966:	0e 94 c8 10 	call	0x2190	; 0x2190 <strcmp>
    196a:	89 2b       	or	r24, r25
    196c:	a9 f5       	brne	.+106    	; 0x19d8 <getUserByName+0xf8>
    196e:	65 e1       	ldi	r22, 0x15	; 21
    1970:	6a 0d       	add	r22, r10
    1972:	9e 01       	movw	r18, r28
    1974:	20 5f       	subi	r18, 0xF0	; 240
    1976:	3f 4f       	sbci	r19, 0xFF	; 255
    1978:	47 e0       	ldi	r20, 0x07	; 7
    197a:	50 e0       	ldi	r21, 0x00	; 0
    197c:	89 2d       	mov	r24, r9
    197e:	0e 94 c7 00 	call	0x18e	; 0x18e <EEPROM_read_block>
    1982:	6c e1       	ldi	r22, 0x1C	; 28
    1984:	6a 0d       	add	r22, r10
    1986:	9e 01       	movw	r18, r28
    1988:	29 5e       	subi	r18, 0xE9	; 233
    198a:	3f 4f       	sbci	r19, 0xFF	; 255
    198c:	47 e0       	ldi	r20, 0x07	; 7
    198e:	50 e0       	ldi	r21, 0x00	; 0
    1990:	89 2d       	mov	r24, r9
    1992:	0e 94 c7 00 	call	0x18e	; 0x18e <EEPROM_read_block>
    1996:	8a 81       	ldd	r24, Y+2	; 0x02
    1998:	90 e0       	ldi	r25, 0x00	; 0
    199a:	02 c0       	rjmp	.+4      	; 0x19a0 <getUserByName+0xc0>
    199c:	95 95       	asr	r25
    199e:	87 95       	ror	r24
    19a0:	ba 94       	dec	r11
    19a2:	e2 f7       	brpl	.-8      	; 0x199c <getUserByName+0xbc>
    19a4:	98 2f       	mov	r25, r24
    19a6:	91 70       	andi	r25, 0x01	; 1
    19a8:	f6 01       	movw	r30, r12
    19aa:	91 93       	st	Z+, r25
    19ac:	be 01       	movw	r22, r28
    19ae:	6d 5f       	subi	r22, 0xFD	; 253
    19b0:	7f 4f       	sbci	r23, 0xFF	; 255
    19b2:	cf 01       	movw	r24, r30
    19b4:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
    19b8:	be 01       	movw	r22, r28
    19ba:	60 5f       	subi	r22, 0xF0	; 240
    19bc:	7f 4f       	sbci	r23, 0xFF	; 255
    19be:	c6 01       	movw	r24, r12
    19c0:	0e 96       	adiw	r24, 0x0e	; 14
    19c2:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
    19c6:	be 01       	movw	r22, r28
    19c8:	69 5e       	subi	r22, 0xE9	; 233
    19ca:	7f 4f       	sbci	r23, 0xFF	; 255
    19cc:	c6 01       	movw	r24, r12
    19ce:	45 96       	adiw	r24, 0x15	; 21
    19d0:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
    19d4:	82 e0       	ldi	r24, 0x02	; 2
    19d6:	0b c0       	rjmp	.+22     	; 0x19ee <getUserByName+0x10e>
    19d8:	b3 94       	inc	r11
    19da:	87 e0       	ldi	r24, 0x07	; 7
    19dc:	8b 15       	cp	r24, r11
    19de:	08 f0       	brcs	.+2      	; 0x19e2 <getUserByName+0x102>
    19e0:	a6 cf       	rjmp	.-180    	; 0x192e <getUserByName+0x4e>
    19e2:	93 94       	inc	r9
    19e4:	87 e0       	ldi	r24, 0x07	; 7
    19e6:	89 15       	cp	r24, r9
    19e8:	08 f0       	brcs	.+2      	; 0x19ec <getUserByName+0x10c>
    19ea:	91 cf       	rjmp	.-222    	; 0x190e <getUserByName+0x2e>
    19ec:	83 e0       	ldi	r24, 0x03	; 3
    19ee:	6d 96       	adiw	r28, 0x1d	; 29
    19f0:	0f b6       	in	r0, 0x3f	; 63
    19f2:	f8 94       	cli
    19f4:	de bf       	out	0x3e, r29	; 62
    19f6:	0f be       	out	0x3f, r0	; 63
    19f8:	cd bf       	out	0x3d, r28	; 61
    19fa:	df 91       	pop	r29
    19fc:	cf 91       	pop	r28
    19fe:	1f 91       	pop	r17
    1a00:	0f 91       	pop	r16
    1a02:	ff 90       	pop	r15
    1a04:	ef 90       	pop	r14
    1a06:	df 90       	pop	r13
    1a08:	cf 90       	pop	r12
    1a0a:	bf 90       	pop	r11
    1a0c:	af 90       	pop	r10
    1a0e:	9f 90       	pop	r9
    1a10:	08 95       	ret

00001a12 <getUserByCode>:
    1a12:	9f 92       	push	r9
    1a14:	af 92       	push	r10
    1a16:	bf 92       	push	r11
    1a18:	cf 92       	push	r12
    1a1a:	df 92       	push	r13
    1a1c:	ef 92       	push	r14
    1a1e:	ff 92       	push	r15
    1a20:	0f 93       	push	r16
    1a22:	1f 93       	push	r17
    1a24:	cf 93       	push	r28
    1a26:	df 93       	push	r29
    1a28:	cd b7       	in	r28, 0x3d	; 61
    1a2a:	de b7       	in	r29, 0x3e	; 62
    1a2c:	6d 97       	sbiw	r28, 0x1d	; 29
    1a2e:	0f b6       	in	r0, 0x3f	; 63
    1a30:	f8 94       	cli
    1a32:	de bf       	out	0x3e, r29	; 62
    1a34:	0f be       	out	0x3f, r0	; 63
    1a36:	cd bf       	out	0x3d, r28	; 61
    1a38:	7c 01       	movw	r14, r24
    1a3a:	6b 01       	movw	r12, r22
    1a3c:	91 2c       	mov	r9, r1
    1a3e:	6b c0       	rjmp	.+214    	; 0x1b16 <getUserByCode+0x104>
    1a40:	ae 01       	movw	r20, r28
    1a42:	4f 5f       	subi	r20, 0xFF	; 255
    1a44:	5f 4f       	sbci	r21, 0xFF	; 255
    1a46:	60 e0       	ldi	r22, 0x00	; 0
    1a48:	89 2d       	mov	r24, r9
    1a4a:	0e 94 a6 00 	call	0x14c	; 0x14c <EEPROM_read_byte>
    1a4e:	ae 01       	movw	r20, r28
    1a50:	4e 5f       	subi	r20, 0xFE	; 254
    1a52:	5f 4f       	sbci	r21, 0xFF	; 255
    1a54:	61 e0       	ldi	r22, 0x01	; 1
    1a56:	89 2d       	mov	r24, r9
    1a58:	0e 94 a6 00 	call	0x14c	; 0x14c <EEPROM_read_byte>
    1a5c:	b1 2c       	mov	r11, r1
    1a5e:	56 c0       	rjmp	.+172    	; 0x1b0c <getUserByCode+0xfa>
    1a60:	89 81       	ldd	r24, Y+1	; 0x01
    1a62:	90 e0       	ldi	r25, 0x00	; 0
    1a64:	0b 2c       	mov	r0, r11
    1a66:	02 c0       	rjmp	.+4      	; 0x1a6c <getUserByCode+0x5a>
    1a68:	95 95       	asr	r25
    1a6a:	87 95       	ror	r24
    1a6c:	0a 94       	dec	r0
    1a6e:	e2 f7       	brpl	.-8      	; 0x1a68 <getUserByCode+0x56>
    1a70:	80 ff       	sbrs	r24, 0
    1a72:	4b c0       	rjmp	.+150    	; 0x1b0a <getUserByCode+0xf8>
    1a74:	6f e1       	ldi	r22, 0x1F	; 31
    1a76:	b6 9e       	mul	r11, r22
    1a78:	a0 2c       	mov	r10, r0
    1a7a:	11 24       	eor	r1, r1
    1a7c:	65 e1       	ldi	r22, 0x15	; 21
    1a7e:	6a 0d       	add	r22, r10
    1a80:	9e 01       	movw	r18, r28
    1a82:	20 5f       	subi	r18, 0xF0	; 240
    1a84:	3f 4f       	sbci	r19, 0xFF	; 255
    1a86:	47 e0       	ldi	r20, 0x07	; 7
    1a88:	50 e0       	ldi	r21, 0x00	; 0
    1a8a:	89 2d       	mov	r24, r9
    1a8c:	0e 94 c7 00 	call	0x18e	; 0x18e <EEPROM_read_block>
    1a90:	be 01       	movw	r22, r28
    1a92:	60 5f       	subi	r22, 0xF0	; 240
    1a94:	7f 4f       	sbci	r23, 0xFF	; 255
    1a96:	c7 01       	movw	r24, r14
    1a98:	0e 94 c8 10 	call	0x2190	; 0x2190 <strcmp>
    1a9c:	89 2b       	or	r24, r25
    1a9e:	a9 f5       	brne	.+106    	; 0x1b0a <getUserByCode+0xf8>
    1aa0:	68 e0       	ldi	r22, 0x08	; 8
    1aa2:	6a 0d       	add	r22, r10
    1aa4:	9e 01       	movw	r18, r28
    1aa6:	2d 5f       	subi	r18, 0xFD	; 253
    1aa8:	3f 4f       	sbci	r19, 0xFF	; 255
    1aaa:	4d e0       	ldi	r20, 0x0D	; 13
    1aac:	50 e0       	ldi	r21, 0x00	; 0
    1aae:	89 2d       	mov	r24, r9
    1ab0:	0e 94 c7 00 	call	0x18e	; 0x18e <EEPROM_read_block>
    1ab4:	6c e1       	ldi	r22, 0x1C	; 28
    1ab6:	6a 0d       	add	r22, r10
    1ab8:	9e 01       	movw	r18, r28
    1aba:	29 5e       	subi	r18, 0xE9	; 233
    1abc:	3f 4f       	sbci	r19, 0xFF	; 255
    1abe:	47 e0       	ldi	r20, 0x07	; 7
    1ac0:	50 e0       	ldi	r21, 0x00	; 0
    1ac2:	89 2d       	mov	r24, r9
    1ac4:	0e 94 c7 00 	call	0x18e	; 0x18e <EEPROM_read_block>
    1ac8:	8a 81       	ldd	r24, Y+2	; 0x02
    1aca:	90 e0       	ldi	r25, 0x00	; 0
    1acc:	02 c0       	rjmp	.+4      	; 0x1ad2 <getUserByCode+0xc0>
    1ace:	95 95       	asr	r25
    1ad0:	87 95       	ror	r24
    1ad2:	ba 94       	dec	r11
    1ad4:	e2 f7       	brpl	.-8      	; 0x1ace <getUserByCode+0xbc>
    1ad6:	98 2f       	mov	r25, r24
    1ad8:	91 70       	andi	r25, 0x01	; 1
    1ada:	f6 01       	movw	r30, r12
    1adc:	91 93       	st	Z+, r25
    1ade:	be 01       	movw	r22, r28
    1ae0:	6d 5f       	subi	r22, 0xFD	; 253
    1ae2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ae4:	cf 01       	movw	r24, r30
    1ae6:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
    1aea:	be 01       	movw	r22, r28
    1aec:	60 5f       	subi	r22, 0xF0	; 240
    1aee:	7f 4f       	sbci	r23, 0xFF	; 255
    1af0:	c6 01       	movw	r24, r12
    1af2:	0e 96       	adiw	r24, 0x0e	; 14
    1af4:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
    1af8:	be 01       	movw	r22, r28
    1afa:	69 5e       	subi	r22, 0xE9	; 233
    1afc:	7f 4f       	sbci	r23, 0xFF	; 255
    1afe:	c6 01       	movw	r24, r12
    1b00:	45 96       	adiw	r24, 0x15	; 21
    1b02:	0e 94 d1 10 	call	0x21a2	; 0x21a2 <strcpy>
    1b06:	82 e0       	ldi	r24, 0x02	; 2
    1b08:	0b c0       	rjmp	.+22     	; 0x1b20 <getUserByCode+0x10e>
    1b0a:	b3 94       	inc	r11
    1b0c:	87 e0       	ldi	r24, 0x07	; 7
    1b0e:	8b 15       	cp	r24, r11
    1b10:	08 f0       	brcs	.+2      	; 0x1b14 <getUserByCode+0x102>
    1b12:	a6 cf       	rjmp	.-180    	; 0x1a60 <getUserByCode+0x4e>
    1b14:	93 94       	inc	r9
    1b16:	87 e0       	ldi	r24, 0x07	; 7
    1b18:	89 15       	cp	r24, r9
    1b1a:	08 f0       	brcs	.+2      	; 0x1b1e <getUserByCode+0x10c>
    1b1c:	91 cf       	rjmp	.-222    	; 0x1a40 <getUserByCode+0x2e>
    1b1e:	83 e0       	ldi	r24, 0x03	; 3
    1b20:	6d 96       	adiw	r28, 0x1d	; 29
    1b22:	0f b6       	in	r0, 0x3f	; 63
    1b24:	f8 94       	cli
    1b26:	de bf       	out	0x3e, r29	; 62
    1b28:	0f be       	out	0x3f, r0	; 63
    1b2a:	cd bf       	out	0x3d, r28	; 61
    1b2c:	df 91       	pop	r29
    1b2e:	cf 91       	pop	r28
    1b30:	1f 91       	pop	r17
    1b32:	0f 91       	pop	r16
    1b34:	ff 90       	pop	r15
    1b36:	ef 90       	pop	r14
    1b38:	df 90       	pop	r13
    1b3a:	cf 90       	pop	r12
    1b3c:	bf 90       	pop	r11
    1b3e:	af 90       	pop	r10
    1b40:	9f 90       	pop	r9
    1b42:	08 95       	ret

00001b44 <Alarm_set>:

void Alarm_set(void) {
  Buzzer_on(BUZZER_PORT, BUZZER_PIN);
    1b44:	66 e0       	ldi	r22, 0x06	; 6
    1b46:	84 e4       	ldi	r24, 0x44	; 68
    1b48:	0e 94 9a 00 	call	0x134	; 0x134 <Buzzer_on>
    1b4c:	08 95       	ret

00001b4e <write_user>:
  }

void write_user(u8 userBlockIndex, ST_User_t* user) {
    1b4e:	ef 92       	push	r14
    1b50:	ff 92       	push	r15
    1b52:	0f 93       	push	r16
    1b54:	1f 93       	push	r17
    1b56:	cf 93       	push	r28
    1b58:	df 93       	push	r29
    1b5a:	00 d0       	rcall	.+0      	; 0x1b5c <write_user+0xe>
    1b5c:	cd b7       	in	r28, 0x3d	; 61
    1b5e:	de b7       	in	r29, 0x3e	; 62
    1b60:	7b 01       	movw	r14, r22
  // Get the user block location (page - index)
  u8 page = userBlockIndex / 8;
    1b62:	08 2f       	mov	r16, r24
    1b64:	06 95       	lsr	r16
    1b66:	06 95       	lsr	r16
    1b68:	06 95       	lsr	r16
  u8 blockNumber = userBlockIndex % 8;
    1b6a:	18 2f       	mov	r17, r24
    1b6c:	17 70       	andi	r17, 0x07	; 7
  // Read and update the block status (reserve the block). And update the user authority level flag if the user is admin
  u8 usersBlockStatus, usersAuthorityLevel;
  EEPROM_read_byte(page, 0, &usersBlockStatus);
    1b6e:	ae 01       	movw	r20, r28
    1b70:	4f 5f       	subi	r20, 0xFF	; 255
    1b72:	5f 4f       	sbci	r21, 0xFF	; 255
    1b74:	60 e0       	ldi	r22, 0x00	; 0
    1b76:	80 2f       	mov	r24, r16
    1b78:	0e 94 a6 00 	call	0x14c	; 0x14c <EEPROM_read_byte>
  EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    1b7c:	ae 01       	movw	r20, r28
    1b7e:	4e 5f       	subi	r20, 0xFE	; 254
    1b80:	5f 4f       	sbci	r21, 0xFF	; 255
    1b82:	61 e0       	ldi	r22, 0x01	; 1
    1b84:	80 2f       	mov	r24, r16
    1b86:	0e 94 a6 00 	call	0x14c	; 0x14c <EEPROM_read_byte>
  set_bit(usersBlockStatus, blockNumber);
    1b8a:	81 e0       	ldi	r24, 0x01	; 1
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	01 2e       	mov	r0, r17
    1b90:	02 c0       	rjmp	.+4      	; 0x1b96 <write_user+0x48>
    1b92:	88 0f       	add	r24, r24
    1b94:	99 1f       	adc	r25, r25
    1b96:	0a 94       	dec	r0
    1b98:	e2 f7       	brpl	.-8      	; 0x1b92 <write_user+0x44>
    1b9a:	49 81       	ldd	r20, Y+1	; 0x01
    1b9c:	48 2b       	or	r20, r24
    1b9e:	49 83       	std	Y+1, r20	; 0x01
  if (user->isAdmin) set_bit(usersAuthorityLevel, blockNumber);
    1ba0:	f7 01       	movw	r30, r14
    1ba2:	20 81       	ld	r18, Z
    1ba4:	22 23       	and	r18, r18
    1ba6:	19 f0       	breq	.+6      	; 0x1bae <write_user+0x60>
    1ba8:	9a 81       	ldd	r25, Y+2	; 0x02
    1baa:	89 2b       	or	r24, r25
    1bac:	8a 83       	std	Y+2, r24	; 0x02
  EEPROM_write_byte(page, 0, usersBlockStatus);
    1bae:	60 e0       	ldi	r22, 0x00	; 0
    1bb0:	80 2f       	mov	r24, r16
    1bb2:	0e 94 fd 00 	call	0x1fa	; 0x1fa <EEPROM_write_byte>
  EEPROM_write_byte(page, 1, usersAuthorityLevel);
    1bb6:	4a 81       	ldd	r20, Y+2	; 0x02
    1bb8:	61 e0       	ldi	r22, 0x01	; 1
    1bba:	80 2f       	mov	r24, r16
    1bbc:	0e 94 fd 00 	call	0x1fa	; 0x1fa <EEPROM_write_byte>
  // Write the user data
  EEPROM_write_block(page, 8 + 31 * blockNumber, 13, user->name);
    1bc0:	97 01       	movw	r18, r14
    1bc2:	2f 5f       	subi	r18, 0xFF	; 255
    1bc4:	3f 4f       	sbci	r19, 0xFF	; 255
    1bc6:	6f e1       	ldi	r22, 0x1F	; 31
    1bc8:	16 9f       	mul	r17, r22
    1bca:	10 2d       	mov	r17, r0
    1bcc:	11 24       	eor	r1, r1
    1bce:	68 e0       	ldi	r22, 0x08	; 8
    1bd0:	61 0f       	add	r22, r17
    1bd2:	4d e0       	ldi	r20, 0x0D	; 13
    1bd4:	50 e0       	ldi	r21, 0x00	; 0
    1bd6:	80 2f       	mov	r24, r16
    1bd8:	0e 94 1c 01 	call	0x238	; 0x238 <EEPROM_write_block>
  EEPROM_write_block(page, 21 + 31 * blockNumber, 7, user->code);
    1bdc:	97 01       	movw	r18, r14
    1bde:	22 5f       	subi	r18, 0xF2	; 242
    1be0:	3f 4f       	sbci	r19, 0xFF	; 255
    1be2:	65 e1       	ldi	r22, 0x15	; 21
    1be4:	61 0f       	add	r22, r17
    1be6:	47 e0       	ldi	r20, 0x07	; 7
    1be8:	50 e0       	ldi	r21, 0x00	; 0
    1bea:	80 2f       	mov	r24, r16
    1bec:	0e 94 1c 01 	call	0x238	; 0x238 <EEPROM_write_block>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
    1bf0:	97 01       	movw	r18, r14
    1bf2:	2b 5e       	subi	r18, 0xEB	; 235
    1bf4:	3f 4f       	sbci	r19, 0xFF	; 255
    1bf6:	6c e1       	ldi	r22, 0x1C	; 28
    1bf8:	61 0f       	add	r22, r17
    1bfa:	4b e0       	ldi	r20, 0x0B	; 11
    1bfc:	50 e0       	ldi	r21, 0x00	; 0
    1bfe:	80 2f       	mov	r24, r16
    1c00:	0e 94 1c 01 	call	0x238	; 0x238 <EEPROM_write_block>
  }
    1c04:	0f 90       	pop	r0
    1c06:	0f 90       	pop	r0
    1c08:	df 91       	pop	r29
    1c0a:	cf 91       	pop	r28
    1c0c:	1f 91       	pop	r17
    1c0e:	0f 91       	pop	r16
    1c10:	ff 90       	pop	r15
    1c12:	ef 90       	pop	r14
    1c14:	08 95       	ret

00001c16 <add_user>:

EN_UserStatusCode_t add_user(ST_User_t* user) {
    1c16:	ef 92       	push	r14
    1c18:	ff 92       	push	r15
    1c1a:	1f 93       	push	r17
    1c1c:	cf 93       	push	r28
    1c1e:	df 93       	push	r29
    1c20:	1f 92       	push	r1
    1c22:	cd b7       	in	r28, 0x3d	; 61
    1c24:	de b7       	in	r29, 0x3e	; 62
    1c26:	7c 01       	movw	r14, r24
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    1c28:	10 e0       	ldi	r17, 0x00	; 0
    1c2a:	1a c0       	rjmp	.+52     	; 0x1c60 <add_user+0x4a>
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    1c2c:	ae 01       	movw	r20, r28
    1c2e:	4f 5f       	subi	r20, 0xFF	; 255
    1c30:	5f 4f       	sbci	r21, 0xFF	; 255
    1c32:	60 e0       	ldi	r22, 0x00	; 0
    1c34:	81 2f       	mov	r24, r17
    1c36:	0e 94 a6 00 	call	0x14c	; 0x14c <EEPROM_read_byte>
    if (usersBlockStatus != 0xFF) {
    1c3a:	99 81       	ldd	r25, Y+1	; 0x01
    1c3c:	9f 3f       	cpi	r25, 0xFF	; 255
    1c3e:	79 f0       	breq	.+30     	; 0x1c5e <add_user+0x48>
    1c40:	02 c0       	rjmp	.+4      	; 0x1c46 <add_user+0x30>
      // Find the block number in the page
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
    1c42:	8f 5f       	subi	r24, 0xFF	; 255
    1c44:	01 c0       	rjmp	.+2      	; 0x1c48 <add_user+0x32>
    1c46:	80 e0       	ldi	r24, 0x00	; 0
    1c48:	29 2f       	mov	r18, r25
    1c4a:	30 e0       	ldi	r19, 0x00	; 0
    1c4c:	08 2e       	mov	r0, r24
    1c4e:	02 c0       	rjmp	.+4      	; 0x1c54 <add_user+0x3e>
    1c50:	35 95       	asr	r19
    1c52:	27 95       	ror	r18
    1c54:	0a 94       	dec	r0
    1c56:	e2 f7       	brpl	.-8      	; 0x1c50 <add_user+0x3a>
    1c58:	20 fd       	sbrc	r18, 0
    1c5a:	f3 cf       	rjmp	.-26     	; 0x1c42 <add_user+0x2c>
    1c5c:	04 c0       	rjmp	.+8      	; 0x1c66 <add_user+0x50>
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    1c5e:	1f 5f       	subi	r17, 0xFF	; 255
    1c60:	18 30       	cpi	r17, 0x08	; 8
    1c62:	20 f3       	brcs	.-56     	; 0x1c2c <add_user+0x16>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
    1c64:	80 e0       	ldi	r24, 0x00	; 0
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    1c66:	18 30       	cpi	r17, 0x08	; 8
    1c68:	49 f0       	breq	.+18     	; 0x1c7c <add_user+0x66>
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
    1c6a:	11 0f       	add	r17, r17
    1c6c:	11 0f       	add	r17, r17
    1c6e:	11 0f       	add	r17, r17
  write_user(availableUserBlockIndex, user);
    1c70:	b7 01       	movw	r22, r14
    1c72:	81 0f       	add	r24, r17
    1c74:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <write_user>
  return USER_ADDED_SUCCESSFULLY;
    1c78:	89 e0       	ldi	r24, 0x09	; 9
    1c7a:	01 c0       	rjmp	.+2      	; 0x1c7e <add_user+0x68>
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    1c7c:	8b e0       	ldi	r24, 0x0B	; 11
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
  write_user(availableUserBlockIndex, user);
  return USER_ADDED_SUCCESSFULLY;
  }
    1c7e:	0f 90       	pop	r0
    1c80:	df 91       	pop	r29
    1c82:	cf 91       	pop	r28
    1c84:	1f 91       	pop	r17
    1c86:	ff 90       	pop	r15
    1c88:	ef 90       	pop	r14
    1c8a:	08 95       	ret

00001c8c <delete_user>:

EN_UserStatusCode_t delete_user(ST_User_t* user) {
    1c8c:	cf 92       	push	r12
    1c8e:	df 92       	push	r13
    1c90:	ef 92       	push	r14
    1c92:	ff 92       	push	r15
    1c94:	0f 93       	push	r16
    1c96:	1f 93       	push	r17
    1c98:	cf 93       	push	r28
    1c9a:	df 93       	push	r29
    1c9c:	cd b7       	in	r28, 0x3d	; 61
    1c9e:	de b7       	in	r29, 0x3e	; 62
    1ca0:	29 97       	sbiw	r28, 0x09	; 9
    1ca2:	0f b6       	in	r0, 0x3f	; 63
    1ca4:	f8 94       	cli
    1ca6:	de bf       	out	0x3e, r29	; 62
    1ca8:	0f be       	out	0x3f, r0	; 63
    1caa:	cd bf       	out	0x3d, r28	; 61
    1cac:	6c 01       	movw	r12, r24
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    1cae:	00 e0       	ldi	r16, 0x00	; 0
    1cb0:	4d c0       	rjmp	.+154    	; 0x1d4c <delete_user+0xc0>
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    1cb2:	ae 01       	movw	r20, r28
    1cb4:	4f 5f       	subi	r20, 0xFF	; 255
    1cb6:	5f 4f       	sbci	r21, 0xFF	; 255
    1cb8:	60 e0       	ldi	r22, 0x00	; 0
    1cba:	80 2f       	mov	r24, r16
    1cbc:	0e 94 a6 00 	call	0x14c	; 0x14c <EEPROM_read_byte>
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    1cc0:	ae 01       	movw	r20, r28
    1cc2:	4e 5f       	subi	r20, 0xFE	; 254
    1cc4:	5f 4f       	sbci	r21, 0xFF	; 255
    1cc6:	61 e0       	ldi	r22, 0x01	; 1
    1cc8:	80 2f       	mov	r24, r16
    1cca:	0e 94 a6 00 	call	0x14c	; 0x14c <EEPROM_read_byte>
    for (userIndex = 0; userIndex < 8;userIndex++) {
    1cce:	10 e0       	ldi	r17, 0x00	; 0
    1cd0:	3a c0       	rjmp	.+116    	; 0x1d46 <delete_user+0xba>
      if (read_bit(usersBlockStatus, userIndex)) {  // If the user isn't deleted
    1cd2:	89 81       	ldd	r24, Y+1	; 0x01
    1cd4:	90 e0       	ldi	r25, 0x00	; 0
    1cd6:	01 2e       	mov	r0, r17
    1cd8:	02 c0       	rjmp	.+4      	; 0x1cde <delete_user+0x52>
    1cda:	95 95       	asr	r25
    1cdc:	87 95       	ror	r24
    1cde:	0a 94       	dec	r0
    1ce0:	e2 f7       	brpl	.-8      	; 0x1cda <delete_user+0x4e>
    1ce2:	80 ff       	sbrs	r24, 0
    1ce4:	2f c0       	rjmp	.+94     	; 0x1d44 <delete_user+0xb8>
        EEPROM_read_block(page, 21 + 31 * userIndex, 7, tempUserCode);
    1ce6:	6f e1       	ldi	r22, 0x1F	; 31
    1ce8:	16 9f       	mul	r17, r22
    1cea:	60 2d       	mov	r22, r0
    1cec:	11 24       	eor	r1, r1
    1cee:	6b 5e       	subi	r22, 0xEB	; 235
    1cf0:	9e 01       	movw	r18, r28
    1cf2:	2d 5f       	subi	r18, 0xFD	; 253
    1cf4:	3f 4f       	sbci	r19, 0xFF	; 255
    1cf6:	47 e0       	ldi	r20, 0x07	; 7
    1cf8:	50 e0       	ldi	r21, 0x00	; 0
    1cfa:	80 2f       	mov	r24, r16
    1cfc:	0e 94 c7 00 	call	0x18e	; 0x18e <EEPROM_read_block>
        if (strcmp(user->code, tempUserCode) == 0) { // User has been found
    1d00:	be 01       	movw	r22, r28
    1d02:	6d 5f       	subi	r22, 0xFD	; 253
    1d04:	7f 4f       	sbci	r23, 0xFF	; 255
    1d06:	c6 01       	movw	r24, r12
    1d08:	0e 96       	adiw	r24, 0x0e	; 14
    1d0a:	0e 94 c8 10 	call	0x2190	; 0x2190 <strcmp>
    1d0e:	89 2b       	or	r24, r25
    1d10:	c9 f4       	brne	.+50     	; 0x1d44 <delete_user+0xb8>
          // Mark it as deleted
          clear_bit(usersBlockStatus, userIndex);
    1d12:	81 e0       	ldi	r24, 0x01	; 1
    1d14:	90 e0       	ldi	r25, 0x00	; 0
    1d16:	02 c0       	rjmp	.+4      	; 0x1d1c <delete_user+0x90>
    1d18:	88 0f       	add	r24, r24
    1d1a:	99 1f       	adc	r25, r25
    1d1c:	1a 95       	dec	r17
    1d1e:	e2 f7       	brpl	.-8      	; 0x1d18 <delete_user+0x8c>
    1d20:	80 95       	com	r24
    1d22:	49 81       	ldd	r20, Y+1	; 0x01
    1d24:	48 23       	and	r20, r24
    1d26:	49 83       	std	Y+1, r20	; 0x01
          clear_bit(usersAuthorityLevel, userIndex);
    1d28:	9a 81       	ldd	r25, Y+2	; 0x02
    1d2a:	89 23       	and	r24, r25
    1d2c:	8a 83       	std	Y+2, r24	; 0x02
          EEPROM_write_byte(page, 0, usersBlockStatus);
    1d2e:	60 e0       	ldi	r22, 0x00	; 0
    1d30:	80 2f       	mov	r24, r16
    1d32:	0e 94 fd 00 	call	0x1fa	; 0x1fa <EEPROM_write_byte>
          EEPROM_write_byte(page, 1, usersAuthorityLevel);
    1d36:	4a 81       	ldd	r20, Y+2	; 0x02
    1d38:	61 e0       	ldi	r22, 0x01	; 1
    1d3a:	80 2f       	mov	r24, r16
    1d3c:	0e 94 fd 00 	call	0x1fa	; 0x1fa <EEPROM_write_byte>
          return USER_DELETED_SUCCESSFULLY;
    1d40:	8a e0       	ldi	r24, 0x0A	; 10
    1d42:	08 c0       	rjmp	.+16     	; 0x1d54 <delete_user+0xc8>
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    for (userIndex = 0; userIndex < 8;userIndex++) {
    1d44:	1f 5f       	subi	r17, 0xFF	; 255
    1d46:	18 30       	cpi	r17, 0x08	; 8
    1d48:	20 f2       	brcs	.-120    	; 0x1cd2 <delete_user+0x46>
EN_UserStatusCode_t delete_user(ST_User_t* user) {
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    1d4a:	0f 5f       	subi	r16, 0xFF	; 255
    1d4c:	08 30       	cpi	r16, 0x08	; 8
    1d4e:	08 f4       	brcc	.+2      	; 0x1d52 <delete_user+0xc6>
    1d50:	b0 cf       	rjmp	.-160    	; 0x1cb2 <delete_user+0x26>
          return USER_DELETED_SUCCESSFULLY;
          }
        }
      }
    }
  return USER_NOT_FOUND;
    1d52:	83 e0       	ldi	r24, 0x03	; 3
  }
    1d54:	29 96       	adiw	r28, 0x09	; 9
    1d56:	0f b6       	in	r0, 0x3f	; 63
    1d58:	f8 94       	cli
    1d5a:	de bf       	out	0x3e, r29	; 62
    1d5c:	0f be       	out	0x3f, r0	; 63
    1d5e:	cd bf       	out	0x3d, r28	; 61
    1d60:	df 91       	pop	r29
    1d62:	cf 91       	pop	r28
    1d64:	1f 91       	pop	r17
    1d66:	0f 91       	pop	r16
    1d68:	ff 90       	pop	r15
    1d6a:	ef 90       	pop	r14
    1d6c:	df 90       	pop	r13
    1d6e:	cf 90       	pop	r12
    1d70:	08 95       	ret

00001d72 <__subsf3>:
    1d72:	50 58       	subi	r21, 0x80	; 128

00001d74 <__addsf3>:
    1d74:	bb 27       	eor	r27, r27
    1d76:	aa 27       	eor	r26, r26
    1d78:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <__addsf3x>
    1d7c:	0c 94 1b 10 	jmp	0x2036	; 0x2036 <__fp_round>
    1d80:	0e 94 0d 10 	call	0x201a	; 0x201a <__fp_pscA>
    1d84:	38 f0       	brcs	.+14     	; 0x1d94 <__addsf3+0x20>
    1d86:	0e 94 14 10 	call	0x2028	; 0x2028 <__fp_pscB>
    1d8a:	20 f0       	brcs	.+8      	; 0x1d94 <__addsf3+0x20>
    1d8c:	39 f4       	brne	.+14     	; 0x1d9c <__addsf3+0x28>
    1d8e:	9f 3f       	cpi	r25, 0xFF	; 255
    1d90:	19 f4       	brne	.+6      	; 0x1d98 <__addsf3+0x24>
    1d92:	26 f4       	brtc	.+8      	; 0x1d9c <__addsf3+0x28>
    1d94:	0c 94 0a 10 	jmp	0x2014	; 0x2014 <__fp_nan>
    1d98:	0e f4       	brtc	.+2      	; 0x1d9c <__addsf3+0x28>
    1d9a:	e0 95       	com	r30
    1d9c:	e7 fb       	bst	r30, 7
    1d9e:	0c 94 04 10 	jmp	0x2008	; 0x2008 <__fp_inf>

00001da2 <__addsf3x>:
    1da2:	e9 2f       	mov	r30, r25
    1da4:	0e 94 2c 10 	call	0x2058	; 0x2058 <__fp_split3>
    1da8:	58 f3       	brcs	.-42     	; 0x1d80 <__addsf3+0xc>
    1daa:	ba 17       	cp	r27, r26
    1dac:	62 07       	cpc	r22, r18
    1dae:	73 07       	cpc	r23, r19
    1db0:	84 07       	cpc	r24, r20
    1db2:	95 07       	cpc	r25, r21
    1db4:	20 f0       	brcs	.+8      	; 0x1dbe <__addsf3x+0x1c>
    1db6:	79 f4       	brne	.+30     	; 0x1dd6 <__addsf3x+0x34>
    1db8:	a6 f5       	brtc	.+104    	; 0x1e22 <__addsf3x+0x80>
    1dba:	0c 94 4e 10 	jmp	0x209c	; 0x209c <__fp_zero>
    1dbe:	0e f4       	brtc	.+2      	; 0x1dc2 <__addsf3x+0x20>
    1dc0:	e0 95       	com	r30
    1dc2:	0b 2e       	mov	r0, r27
    1dc4:	ba 2f       	mov	r27, r26
    1dc6:	a0 2d       	mov	r26, r0
    1dc8:	0b 01       	movw	r0, r22
    1dca:	b9 01       	movw	r22, r18
    1dcc:	90 01       	movw	r18, r0
    1dce:	0c 01       	movw	r0, r24
    1dd0:	ca 01       	movw	r24, r20
    1dd2:	a0 01       	movw	r20, r0
    1dd4:	11 24       	eor	r1, r1
    1dd6:	ff 27       	eor	r31, r31
    1dd8:	59 1b       	sub	r21, r25
    1dda:	99 f0       	breq	.+38     	; 0x1e02 <__addsf3x+0x60>
    1ddc:	59 3f       	cpi	r21, 0xF9	; 249
    1dde:	50 f4       	brcc	.+20     	; 0x1df4 <__addsf3x+0x52>
    1de0:	50 3e       	cpi	r21, 0xE0	; 224
    1de2:	68 f1       	brcs	.+90     	; 0x1e3e <__addsf3x+0x9c>
    1de4:	1a 16       	cp	r1, r26
    1de6:	f0 40       	sbci	r31, 0x00	; 0
    1de8:	a2 2f       	mov	r26, r18
    1dea:	23 2f       	mov	r18, r19
    1dec:	34 2f       	mov	r19, r20
    1dee:	44 27       	eor	r20, r20
    1df0:	58 5f       	subi	r21, 0xF8	; 248
    1df2:	f3 cf       	rjmp	.-26     	; 0x1dda <__addsf3x+0x38>
    1df4:	46 95       	lsr	r20
    1df6:	37 95       	ror	r19
    1df8:	27 95       	ror	r18
    1dfa:	a7 95       	ror	r26
    1dfc:	f0 40       	sbci	r31, 0x00	; 0
    1dfe:	53 95       	inc	r21
    1e00:	c9 f7       	brne	.-14     	; 0x1df4 <__addsf3x+0x52>
    1e02:	7e f4       	brtc	.+30     	; 0x1e22 <__addsf3x+0x80>
    1e04:	1f 16       	cp	r1, r31
    1e06:	ba 0b       	sbc	r27, r26
    1e08:	62 0b       	sbc	r22, r18
    1e0a:	73 0b       	sbc	r23, r19
    1e0c:	84 0b       	sbc	r24, r20
    1e0e:	ba f0       	brmi	.+46     	; 0x1e3e <__addsf3x+0x9c>
    1e10:	91 50       	subi	r25, 0x01	; 1
    1e12:	a1 f0       	breq	.+40     	; 0x1e3c <__addsf3x+0x9a>
    1e14:	ff 0f       	add	r31, r31
    1e16:	bb 1f       	adc	r27, r27
    1e18:	66 1f       	adc	r22, r22
    1e1a:	77 1f       	adc	r23, r23
    1e1c:	88 1f       	adc	r24, r24
    1e1e:	c2 f7       	brpl	.-16     	; 0x1e10 <__addsf3x+0x6e>
    1e20:	0e c0       	rjmp	.+28     	; 0x1e3e <__addsf3x+0x9c>
    1e22:	ba 0f       	add	r27, r26
    1e24:	62 1f       	adc	r22, r18
    1e26:	73 1f       	adc	r23, r19
    1e28:	84 1f       	adc	r24, r20
    1e2a:	48 f4       	brcc	.+18     	; 0x1e3e <__addsf3x+0x9c>
    1e2c:	87 95       	ror	r24
    1e2e:	77 95       	ror	r23
    1e30:	67 95       	ror	r22
    1e32:	b7 95       	ror	r27
    1e34:	f7 95       	ror	r31
    1e36:	9e 3f       	cpi	r25, 0xFE	; 254
    1e38:	08 f0       	brcs	.+2      	; 0x1e3c <__addsf3x+0x9a>
    1e3a:	b0 cf       	rjmp	.-160    	; 0x1d9c <__addsf3+0x28>
    1e3c:	93 95       	inc	r25
    1e3e:	88 0f       	add	r24, r24
    1e40:	08 f0       	brcs	.+2      	; 0x1e44 <__addsf3x+0xa2>
    1e42:	99 27       	eor	r25, r25
    1e44:	ee 0f       	add	r30, r30
    1e46:	97 95       	ror	r25
    1e48:	87 95       	ror	r24
    1e4a:	08 95       	ret

00001e4c <__divsf3>:
    1e4c:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <__divsf3x>
    1e50:	0c 94 1b 10 	jmp	0x2036	; 0x2036 <__fp_round>
    1e54:	0e 94 14 10 	call	0x2028	; 0x2028 <__fp_pscB>
    1e58:	58 f0       	brcs	.+22     	; 0x1e70 <__divsf3+0x24>
    1e5a:	0e 94 0d 10 	call	0x201a	; 0x201a <__fp_pscA>
    1e5e:	40 f0       	brcs	.+16     	; 0x1e70 <__divsf3+0x24>
    1e60:	29 f4       	brne	.+10     	; 0x1e6c <__divsf3+0x20>
    1e62:	5f 3f       	cpi	r21, 0xFF	; 255
    1e64:	29 f0       	breq	.+10     	; 0x1e70 <__divsf3+0x24>
    1e66:	0c 94 04 10 	jmp	0x2008	; 0x2008 <__fp_inf>
    1e6a:	51 11       	cpse	r21, r1
    1e6c:	0c 94 4f 10 	jmp	0x209e	; 0x209e <__fp_szero>
    1e70:	0c 94 0a 10 	jmp	0x2014	; 0x2014 <__fp_nan>

00001e74 <__divsf3x>:
    1e74:	0e 94 2c 10 	call	0x2058	; 0x2058 <__fp_split3>
    1e78:	68 f3       	brcs	.-38     	; 0x1e54 <__divsf3+0x8>

00001e7a <__divsf3_pse>:
    1e7a:	99 23       	and	r25, r25
    1e7c:	b1 f3       	breq	.-20     	; 0x1e6a <__divsf3+0x1e>
    1e7e:	55 23       	and	r21, r21
    1e80:	91 f3       	breq	.-28     	; 0x1e66 <__divsf3+0x1a>
    1e82:	95 1b       	sub	r25, r21
    1e84:	55 0b       	sbc	r21, r21
    1e86:	bb 27       	eor	r27, r27
    1e88:	aa 27       	eor	r26, r26
    1e8a:	62 17       	cp	r22, r18
    1e8c:	73 07       	cpc	r23, r19
    1e8e:	84 07       	cpc	r24, r20
    1e90:	38 f0       	brcs	.+14     	; 0x1ea0 <__divsf3_pse+0x26>
    1e92:	9f 5f       	subi	r25, 0xFF	; 255
    1e94:	5f 4f       	sbci	r21, 0xFF	; 255
    1e96:	22 0f       	add	r18, r18
    1e98:	33 1f       	adc	r19, r19
    1e9a:	44 1f       	adc	r20, r20
    1e9c:	aa 1f       	adc	r26, r26
    1e9e:	a9 f3       	breq	.-22     	; 0x1e8a <__divsf3_pse+0x10>
    1ea0:	35 d0       	rcall	.+106    	; 0x1f0c <__divsf3_pse+0x92>
    1ea2:	0e 2e       	mov	r0, r30
    1ea4:	3a f0       	brmi	.+14     	; 0x1eb4 <__divsf3_pse+0x3a>
    1ea6:	e0 e8       	ldi	r30, 0x80	; 128
    1ea8:	32 d0       	rcall	.+100    	; 0x1f0e <__divsf3_pse+0x94>
    1eaa:	91 50       	subi	r25, 0x01	; 1
    1eac:	50 40       	sbci	r21, 0x00	; 0
    1eae:	e6 95       	lsr	r30
    1eb0:	00 1c       	adc	r0, r0
    1eb2:	ca f7       	brpl	.-14     	; 0x1ea6 <__divsf3_pse+0x2c>
    1eb4:	2b d0       	rcall	.+86     	; 0x1f0c <__divsf3_pse+0x92>
    1eb6:	fe 2f       	mov	r31, r30
    1eb8:	29 d0       	rcall	.+82     	; 0x1f0c <__divsf3_pse+0x92>
    1eba:	66 0f       	add	r22, r22
    1ebc:	77 1f       	adc	r23, r23
    1ebe:	88 1f       	adc	r24, r24
    1ec0:	bb 1f       	adc	r27, r27
    1ec2:	26 17       	cp	r18, r22
    1ec4:	37 07       	cpc	r19, r23
    1ec6:	48 07       	cpc	r20, r24
    1ec8:	ab 07       	cpc	r26, r27
    1eca:	b0 e8       	ldi	r27, 0x80	; 128
    1ecc:	09 f0       	breq	.+2      	; 0x1ed0 <__divsf3_pse+0x56>
    1ece:	bb 0b       	sbc	r27, r27
    1ed0:	80 2d       	mov	r24, r0
    1ed2:	bf 01       	movw	r22, r30
    1ed4:	ff 27       	eor	r31, r31
    1ed6:	93 58       	subi	r25, 0x83	; 131
    1ed8:	5f 4f       	sbci	r21, 0xFF	; 255
    1eda:	3a f0       	brmi	.+14     	; 0x1eea <__divsf3_pse+0x70>
    1edc:	9e 3f       	cpi	r25, 0xFE	; 254
    1ede:	51 05       	cpc	r21, r1
    1ee0:	78 f0       	brcs	.+30     	; 0x1f00 <__divsf3_pse+0x86>
    1ee2:	0c 94 04 10 	jmp	0x2008	; 0x2008 <__fp_inf>
    1ee6:	0c 94 4f 10 	jmp	0x209e	; 0x209e <__fp_szero>
    1eea:	5f 3f       	cpi	r21, 0xFF	; 255
    1eec:	e4 f3       	brlt	.-8      	; 0x1ee6 <__divsf3_pse+0x6c>
    1eee:	98 3e       	cpi	r25, 0xE8	; 232
    1ef0:	d4 f3       	brlt	.-12     	; 0x1ee6 <__divsf3_pse+0x6c>
    1ef2:	86 95       	lsr	r24
    1ef4:	77 95       	ror	r23
    1ef6:	67 95       	ror	r22
    1ef8:	b7 95       	ror	r27
    1efa:	f7 95       	ror	r31
    1efc:	9f 5f       	subi	r25, 0xFF	; 255
    1efe:	c9 f7       	brne	.-14     	; 0x1ef2 <__divsf3_pse+0x78>
    1f00:	88 0f       	add	r24, r24
    1f02:	91 1d       	adc	r25, r1
    1f04:	96 95       	lsr	r25
    1f06:	87 95       	ror	r24
    1f08:	97 f9       	bld	r25, 7
    1f0a:	08 95       	ret
    1f0c:	e1 e0       	ldi	r30, 0x01	; 1
    1f0e:	66 0f       	add	r22, r22
    1f10:	77 1f       	adc	r23, r23
    1f12:	88 1f       	adc	r24, r24
    1f14:	bb 1f       	adc	r27, r27
    1f16:	62 17       	cp	r22, r18
    1f18:	73 07       	cpc	r23, r19
    1f1a:	84 07       	cpc	r24, r20
    1f1c:	ba 07       	cpc	r27, r26
    1f1e:	20 f0       	brcs	.+8      	; 0x1f28 <__divsf3_pse+0xae>
    1f20:	62 1b       	sub	r22, r18
    1f22:	73 0b       	sbc	r23, r19
    1f24:	84 0b       	sbc	r24, r20
    1f26:	ba 0b       	sbc	r27, r26
    1f28:	ee 1f       	adc	r30, r30
    1f2a:	88 f7       	brcc	.-30     	; 0x1f0e <__divsf3_pse+0x94>
    1f2c:	e0 95       	com	r30
    1f2e:	08 95       	ret

00001f30 <__fixunssfsi>:
    1f30:	0e 94 34 10 	call	0x2068	; 0x2068 <__fp_splitA>
    1f34:	88 f0       	brcs	.+34     	; 0x1f58 <__fixunssfsi+0x28>
    1f36:	9f 57       	subi	r25, 0x7F	; 127
    1f38:	98 f0       	brcs	.+38     	; 0x1f60 <__fixunssfsi+0x30>
    1f3a:	b9 2f       	mov	r27, r25
    1f3c:	99 27       	eor	r25, r25
    1f3e:	b7 51       	subi	r27, 0x17	; 23
    1f40:	b0 f0       	brcs	.+44     	; 0x1f6e <__fixunssfsi+0x3e>
    1f42:	e1 f0       	breq	.+56     	; 0x1f7c <__fixunssfsi+0x4c>
    1f44:	66 0f       	add	r22, r22
    1f46:	77 1f       	adc	r23, r23
    1f48:	88 1f       	adc	r24, r24
    1f4a:	99 1f       	adc	r25, r25
    1f4c:	1a f0       	brmi	.+6      	; 0x1f54 <__fixunssfsi+0x24>
    1f4e:	ba 95       	dec	r27
    1f50:	c9 f7       	brne	.-14     	; 0x1f44 <__fixunssfsi+0x14>
    1f52:	14 c0       	rjmp	.+40     	; 0x1f7c <__fixunssfsi+0x4c>
    1f54:	b1 30       	cpi	r27, 0x01	; 1
    1f56:	91 f0       	breq	.+36     	; 0x1f7c <__fixunssfsi+0x4c>
    1f58:	0e 94 4e 10 	call	0x209c	; 0x209c <__fp_zero>
    1f5c:	b1 e0       	ldi	r27, 0x01	; 1
    1f5e:	08 95       	ret
    1f60:	0c 94 4e 10 	jmp	0x209c	; 0x209c <__fp_zero>
    1f64:	67 2f       	mov	r22, r23
    1f66:	78 2f       	mov	r23, r24
    1f68:	88 27       	eor	r24, r24
    1f6a:	b8 5f       	subi	r27, 0xF8	; 248
    1f6c:	39 f0       	breq	.+14     	; 0x1f7c <__fixunssfsi+0x4c>
    1f6e:	b9 3f       	cpi	r27, 0xF9	; 249
    1f70:	cc f3       	brlt	.-14     	; 0x1f64 <__fixunssfsi+0x34>
    1f72:	86 95       	lsr	r24
    1f74:	77 95       	ror	r23
    1f76:	67 95       	ror	r22
    1f78:	b3 95       	inc	r27
    1f7a:	d9 f7       	brne	.-10     	; 0x1f72 <__fixunssfsi+0x42>
    1f7c:	3e f4       	brtc	.+14     	; 0x1f8c <__fixunssfsi+0x5c>
    1f7e:	90 95       	com	r25
    1f80:	80 95       	com	r24
    1f82:	70 95       	com	r23
    1f84:	61 95       	neg	r22
    1f86:	7f 4f       	sbci	r23, 0xFF	; 255
    1f88:	8f 4f       	sbci	r24, 0xFF	; 255
    1f8a:	9f 4f       	sbci	r25, 0xFF	; 255
    1f8c:	08 95       	ret

00001f8e <__floatunsisf>:
    1f8e:	e8 94       	clt
    1f90:	09 c0       	rjmp	.+18     	; 0x1fa4 <__floatsisf+0x12>

00001f92 <__floatsisf>:
    1f92:	97 fb       	bst	r25, 7
    1f94:	3e f4       	brtc	.+14     	; 0x1fa4 <__floatsisf+0x12>
    1f96:	90 95       	com	r25
    1f98:	80 95       	com	r24
    1f9a:	70 95       	com	r23
    1f9c:	61 95       	neg	r22
    1f9e:	7f 4f       	sbci	r23, 0xFF	; 255
    1fa0:	8f 4f       	sbci	r24, 0xFF	; 255
    1fa2:	9f 4f       	sbci	r25, 0xFF	; 255
    1fa4:	99 23       	and	r25, r25
    1fa6:	a9 f0       	breq	.+42     	; 0x1fd2 <__floatsisf+0x40>
    1fa8:	f9 2f       	mov	r31, r25
    1faa:	96 e9       	ldi	r25, 0x96	; 150
    1fac:	bb 27       	eor	r27, r27
    1fae:	93 95       	inc	r25
    1fb0:	f6 95       	lsr	r31
    1fb2:	87 95       	ror	r24
    1fb4:	77 95       	ror	r23
    1fb6:	67 95       	ror	r22
    1fb8:	b7 95       	ror	r27
    1fba:	f1 11       	cpse	r31, r1
    1fbc:	f8 cf       	rjmp	.-16     	; 0x1fae <__floatsisf+0x1c>
    1fbe:	fa f4       	brpl	.+62     	; 0x1ffe <__floatsisf+0x6c>
    1fc0:	bb 0f       	add	r27, r27
    1fc2:	11 f4       	brne	.+4      	; 0x1fc8 <__floatsisf+0x36>
    1fc4:	60 ff       	sbrs	r22, 0
    1fc6:	1b c0       	rjmp	.+54     	; 0x1ffe <__floatsisf+0x6c>
    1fc8:	6f 5f       	subi	r22, 0xFF	; 255
    1fca:	7f 4f       	sbci	r23, 0xFF	; 255
    1fcc:	8f 4f       	sbci	r24, 0xFF	; 255
    1fce:	9f 4f       	sbci	r25, 0xFF	; 255
    1fd0:	16 c0       	rjmp	.+44     	; 0x1ffe <__floatsisf+0x6c>
    1fd2:	88 23       	and	r24, r24
    1fd4:	11 f0       	breq	.+4      	; 0x1fda <__floatsisf+0x48>
    1fd6:	96 e9       	ldi	r25, 0x96	; 150
    1fd8:	11 c0       	rjmp	.+34     	; 0x1ffc <__floatsisf+0x6a>
    1fda:	77 23       	and	r23, r23
    1fdc:	21 f0       	breq	.+8      	; 0x1fe6 <__floatsisf+0x54>
    1fde:	9e e8       	ldi	r25, 0x8E	; 142
    1fe0:	87 2f       	mov	r24, r23
    1fe2:	76 2f       	mov	r23, r22
    1fe4:	05 c0       	rjmp	.+10     	; 0x1ff0 <__floatsisf+0x5e>
    1fe6:	66 23       	and	r22, r22
    1fe8:	71 f0       	breq	.+28     	; 0x2006 <__floatsisf+0x74>
    1fea:	96 e8       	ldi	r25, 0x86	; 134
    1fec:	86 2f       	mov	r24, r22
    1fee:	70 e0       	ldi	r23, 0x00	; 0
    1ff0:	60 e0       	ldi	r22, 0x00	; 0
    1ff2:	2a f0       	brmi	.+10     	; 0x1ffe <__floatsisf+0x6c>
    1ff4:	9a 95       	dec	r25
    1ff6:	66 0f       	add	r22, r22
    1ff8:	77 1f       	adc	r23, r23
    1ffa:	88 1f       	adc	r24, r24
    1ffc:	da f7       	brpl	.-10     	; 0x1ff4 <__floatsisf+0x62>
    1ffe:	88 0f       	add	r24, r24
    2000:	96 95       	lsr	r25
    2002:	87 95       	ror	r24
    2004:	97 f9       	bld	r25, 7
    2006:	08 95       	ret

00002008 <__fp_inf>:
    2008:	97 f9       	bld	r25, 7
    200a:	9f 67       	ori	r25, 0x7F	; 127
    200c:	80 e8       	ldi	r24, 0x80	; 128
    200e:	70 e0       	ldi	r23, 0x00	; 0
    2010:	60 e0       	ldi	r22, 0x00	; 0
    2012:	08 95       	ret

00002014 <__fp_nan>:
    2014:	9f ef       	ldi	r25, 0xFF	; 255
    2016:	80 ec       	ldi	r24, 0xC0	; 192
    2018:	08 95       	ret

0000201a <__fp_pscA>:
    201a:	00 24       	eor	r0, r0
    201c:	0a 94       	dec	r0
    201e:	16 16       	cp	r1, r22
    2020:	17 06       	cpc	r1, r23
    2022:	18 06       	cpc	r1, r24
    2024:	09 06       	cpc	r0, r25
    2026:	08 95       	ret

00002028 <__fp_pscB>:
    2028:	00 24       	eor	r0, r0
    202a:	0a 94       	dec	r0
    202c:	12 16       	cp	r1, r18
    202e:	13 06       	cpc	r1, r19
    2030:	14 06       	cpc	r1, r20
    2032:	05 06       	cpc	r0, r21
    2034:	08 95       	ret

00002036 <__fp_round>:
    2036:	09 2e       	mov	r0, r25
    2038:	03 94       	inc	r0
    203a:	00 0c       	add	r0, r0
    203c:	11 f4       	brne	.+4      	; 0x2042 <__fp_round+0xc>
    203e:	88 23       	and	r24, r24
    2040:	52 f0       	brmi	.+20     	; 0x2056 <__fp_round+0x20>
    2042:	bb 0f       	add	r27, r27
    2044:	40 f4       	brcc	.+16     	; 0x2056 <__fp_round+0x20>
    2046:	bf 2b       	or	r27, r31
    2048:	11 f4       	brne	.+4      	; 0x204e <__fp_round+0x18>
    204a:	60 ff       	sbrs	r22, 0
    204c:	04 c0       	rjmp	.+8      	; 0x2056 <__fp_round+0x20>
    204e:	6f 5f       	subi	r22, 0xFF	; 255
    2050:	7f 4f       	sbci	r23, 0xFF	; 255
    2052:	8f 4f       	sbci	r24, 0xFF	; 255
    2054:	9f 4f       	sbci	r25, 0xFF	; 255
    2056:	08 95       	ret

00002058 <__fp_split3>:
    2058:	57 fd       	sbrc	r21, 7
    205a:	90 58       	subi	r25, 0x80	; 128
    205c:	44 0f       	add	r20, r20
    205e:	55 1f       	adc	r21, r21
    2060:	59 f0       	breq	.+22     	; 0x2078 <__fp_splitA+0x10>
    2062:	5f 3f       	cpi	r21, 0xFF	; 255
    2064:	71 f0       	breq	.+28     	; 0x2082 <__fp_splitA+0x1a>
    2066:	47 95       	ror	r20

00002068 <__fp_splitA>:
    2068:	88 0f       	add	r24, r24
    206a:	97 fb       	bst	r25, 7
    206c:	99 1f       	adc	r25, r25
    206e:	61 f0       	breq	.+24     	; 0x2088 <__fp_splitA+0x20>
    2070:	9f 3f       	cpi	r25, 0xFF	; 255
    2072:	79 f0       	breq	.+30     	; 0x2092 <__fp_splitA+0x2a>
    2074:	87 95       	ror	r24
    2076:	08 95       	ret
    2078:	12 16       	cp	r1, r18
    207a:	13 06       	cpc	r1, r19
    207c:	14 06       	cpc	r1, r20
    207e:	55 1f       	adc	r21, r21
    2080:	f2 cf       	rjmp	.-28     	; 0x2066 <__fp_split3+0xe>
    2082:	46 95       	lsr	r20
    2084:	f1 df       	rcall	.-30     	; 0x2068 <__fp_splitA>
    2086:	08 c0       	rjmp	.+16     	; 0x2098 <__fp_splitA+0x30>
    2088:	16 16       	cp	r1, r22
    208a:	17 06       	cpc	r1, r23
    208c:	18 06       	cpc	r1, r24
    208e:	99 1f       	adc	r25, r25
    2090:	f1 cf       	rjmp	.-30     	; 0x2074 <__fp_splitA+0xc>
    2092:	86 95       	lsr	r24
    2094:	71 05       	cpc	r23, r1
    2096:	61 05       	cpc	r22, r1
    2098:	08 94       	sec
    209a:	08 95       	ret

0000209c <__fp_zero>:
    209c:	e8 94       	clt

0000209e <__fp_szero>:
    209e:	bb 27       	eor	r27, r27
    20a0:	66 27       	eor	r22, r22
    20a2:	77 27       	eor	r23, r23
    20a4:	cb 01       	movw	r24, r22
    20a6:	97 f9       	bld	r25, 7
    20a8:	08 95       	ret

000020aa <__mulsf3>:
    20aa:	0e 94 68 10 	call	0x20d0	; 0x20d0 <__mulsf3x>
    20ae:	0c 94 1b 10 	jmp	0x2036	; 0x2036 <__fp_round>
    20b2:	0e 94 0d 10 	call	0x201a	; 0x201a <__fp_pscA>
    20b6:	38 f0       	brcs	.+14     	; 0x20c6 <__mulsf3+0x1c>
    20b8:	0e 94 14 10 	call	0x2028	; 0x2028 <__fp_pscB>
    20bc:	20 f0       	brcs	.+8      	; 0x20c6 <__mulsf3+0x1c>
    20be:	95 23       	and	r25, r21
    20c0:	11 f0       	breq	.+4      	; 0x20c6 <__mulsf3+0x1c>
    20c2:	0c 94 04 10 	jmp	0x2008	; 0x2008 <__fp_inf>
    20c6:	0c 94 0a 10 	jmp	0x2014	; 0x2014 <__fp_nan>
    20ca:	11 24       	eor	r1, r1
    20cc:	0c 94 4f 10 	jmp	0x209e	; 0x209e <__fp_szero>

000020d0 <__mulsf3x>:
    20d0:	0e 94 2c 10 	call	0x2058	; 0x2058 <__fp_split3>
    20d4:	70 f3       	brcs	.-36     	; 0x20b2 <__mulsf3+0x8>

000020d6 <__mulsf3_pse>:
    20d6:	95 9f       	mul	r25, r21
    20d8:	c1 f3       	breq	.-16     	; 0x20ca <__mulsf3+0x20>
    20da:	95 0f       	add	r25, r21
    20dc:	50 e0       	ldi	r21, 0x00	; 0
    20de:	55 1f       	adc	r21, r21
    20e0:	62 9f       	mul	r22, r18
    20e2:	f0 01       	movw	r30, r0
    20e4:	72 9f       	mul	r23, r18
    20e6:	bb 27       	eor	r27, r27
    20e8:	f0 0d       	add	r31, r0
    20ea:	b1 1d       	adc	r27, r1
    20ec:	63 9f       	mul	r22, r19
    20ee:	aa 27       	eor	r26, r26
    20f0:	f0 0d       	add	r31, r0
    20f2:	b1 1d       	adc	r27, r1
    20f4:	aa 1f       	adc	r26, r26
    20f6:	64 9f       	mul	r22, r20
    20f8:	66 27       	eor	r22, r22
    20fa:	b0 0d       	add	r27, r0
    20fc:	a1 1d       	adc	r26, r1
    20fe:	66 1f       	adc	r22, r22
    2100:	82 9f       	mul	r24, r18
    2102:	22 27       	eor	r18, r18
    2104:	b0 0d       	add	r27, r0
    2106:	a1 1d       	adc	r26, r1
    2108:	62 1f       	adc	r22, r18
    210a:	73 9f       	mul	r23, r19
    210c:	b0 0d       	add	r27, r0
    210e:	a1 1d       	adc	r26, r1
    2110:	62 1f       	adc	r22, r18
    2112:	83 9f       	mul	r24, r19
    2114:	a0 0d       	add	r26, r0
    2116:	61 1d       	adc	r22, r1
    2118:	22 1f       	adc	r18, r18
    211a:	74 9f       	mul	r23, r20
    211c:	33 27       	eor	r19, r19
    211e:	a0 0d       	add	r26, r0
    2120:	61 1d       	adc	r22, r1
    2122:	23 1f       	adc	r18, r19
    2124:	84 9f       	mul	r24, r20
    2126:	60 0d       	add	r22, r0
    2128:	21 1d       	adc	r18, r1
    212a:	82 2f       	mov	r24, r18
    212c:	76 2f       	mov	r23, r22
    212e:	6a 2f       	mov	r22, r26
    2130:	11 24       	eor	r1, r1
    2132:	9f 57       	subi	r25, 0x7F	; 127
    2134:	50 40       	sbci	r21, 0x00	; 0
    2136:	9a f0       	brmi	.+38     	; 0x215e <__mulsf3_pse+0x88>
    2138:	f1 f0       	breq	.+60     	; 0x2176 <__mulsf3_pse+0xa0>
    213a:	88 23       	and	r24, r24
    213c:	4a f0       	brmi	.+18     	; 0x2150 <__mulsf3_pse+0x7a>
    213e:	ee 0f       	add	r30, r30
    2140:	ff 1f       	adc	r31, r31
    2142:	bb 1f       	adc	r27, r27
    2144:	66 1f       	adc	r22, r22
    2146:	77 1f       	adc	r23, r23
    2148:	88 1f       	adc	r24, r24
    214a:	91 50       	subi	r25, 0x01	; 1
    214c:	50 40       	sbci	r21, 0x00	; 0
    214e:	a9 f7       	brne	.-22     	; 0x213a <__mulsf3_pse+0x64>
    2150:	9e 3f       	cpi	r25, 0xFE	; 254
    2152:	51 05       	cpc	r21, r1
    2154:	80 f0       	brcs	.+32     	; 0x2176 <__mulsf3_pse+0xa0>
    2156:	0c 94 04 10 	jmp	0x2008	; 0x2008 <__fp_inf>
    215a:	0c 94 4f 10 	jmp	0x209e	; 0x209e <__fp_szero>
    215e:	5f 3f       	cpi	r21, 0xFF	; 255
    2160:	e4 f3       	brlt	.-8      	; 0x215a <__mulsf3_pse+0x84>
    2162:	98 3e       	cpi	r25, 0xE8	; 232
    2164:	d4 f3       	brlt	.-12     	; 0x215a <__mulsf3_pse+0x84>
    2166:	86 95       	lsr	r24
    2168:	77 95       	ror	r23
    216a:	67 95       	ror	r22
    216c:	b7 95       	ror	r27
    216e:	f7 95       	ror	r31
    2170:	e7 95       	ror	r30
    2172:	9f 5f       	subi	r25, 0xFF	; 255
    2174:	c1 f7       	brne	.-16     	; 0x2166 <__mulsf3_pse+0x90>
    2176:	fe 2b       	or	r31, r30
    2178:	88 0f       	add	r24, r24
    217a:	91 1d       	adc	r25, r1
    217c:	96 95       	lsr	r25
    217e:	87 95       	ror	r24
    2180:	97 f9       	bld	r25, 7
    2182:	08 95       	ret

00002184 <__tablejump2__>:
    2184:	ee 0f       	add	r30, r30
    2186:	ff 1f       	adc	r31, r31
    2188:	05 90       	lpm	r0, Z+
    218a:	f4 91       	lpm	r31, Z
    218c:	e0 2d       	mov	r30, r0
    218e:	09 94       	ijmp

00002190 <strcmp>:
    2190:	fb 01       	movw	r30, r22
    2192:	dc 01       	movw	r26, r24
    2194:	8d 91       	ld	r24, X+
    2196:	01 90       	ld	r0, Z+
    2198:	80 19       	sub	r24, r0
    219a:	01 10       	cpse	r0, r1
    219c:	d9 f3       	breq	.-10     	; 0x2194 <strcmp+0x4>
    219e:	99 0b       	sbc	r25, r25
    21a0:	08 95       	ret

000021a2 <strcpy>:
    21a2:	fb 01       	movw	r30, r22
    21a4:	dc 01       	movw	r26, r24
    21a6:	01 90       	ld	r0, Z+
    21a8:	0d 92       	st	X+, r0
    21aa:	00 20       	and	r0, r0
    21ac:	e1 f7       	brne	.-8      	; 0x21a6 <strcpy+0x4>
    21ae:	08 95       	ret

000021b0 <sprintf>:
    21b0:	ae e0       	ldi	r26, 0x0E	; 14
    21b2:	b0 e0       	ldi	r27, 0x00	; 0
    21b4:	ee ed       	ldi	r30, 0xDE	; 222
    21b6:	f0 e1       	ldi	r31, 0x10	; 16
    21b8:	0c 94 99 13 	jmp	0x2732	; 0x2732 <__prologue_saves__+0x1c>
    21bc:	0d 89       	ldd	r16, Y+21	; 0x15
    21be:	1e 89       	ldd	r17, Y+22	; 0x16
    21c0:	86 e0       	ldi	r24, 0x06	; 6
    21c2:	8c 83       	std	Y+4, r24	; 0x04
    21c4:	1a 83       	std	Y+2, r17	; 0x02
    21c6:	09 83       	std	Y+1, r16	; 0x01
    21c8:	8f ef       	ldi	r24, 0xFF	; 255
    21ca:	9f e7       	ldi	r25, 0x7F	; 127
    21cc:	9e 83       	std	Y+6, r25	; 0x06
    21ce:	8d 83       	std	Y+5, r24	; 0x05
    21d0:	ae 01       	movw	r20, r28
    21d2:	47 5e       	subi	r20, 0xE7	; 231
    21d4:	5f 4f       	sbci	r21, 0xFF	; 255
    21d6:	6f 89       	ldd	r22, Y+23	; 0x17
    21d8:	78 8d       	ldd	r23, Y+24	; 0x18
    21da:	ce 01       	movw	r24, r28
    21dc:	01 96       	adiw	r24, 0x01	; 1
    21de:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <vfprintf>
    21e2:	ef 81       	ldd	r30, Y+7	; 0x07
    21e4:	f8 85       	ldd	r31, Y+8	; 0x08
    21e6:	e0 0f       	add	r30, r16
    21e8:	f1 1f       	adc	r31, r17
    21ea:	10 82       	st	Z, r1
    21ec:	2e 96       	adiw	r28, 0x0e	; 14
    21ee:	e4 e0       	ldi	r30, 0x04	; 4
    21f0:	0c 94 b5 13 	jmp	0x276a	; 0x276a <__epilogue_restores__+0x1c>

000021f4 <vfprintf>:
    21f4:	ab e0       	ldi	r26, 0x0B	; 11
    21f6:	b0 e0       	ldi	r27, 0x00	; 0
    21f8:	e0 e0       	ldi	r30, 0x00	; 0
    21fa:	f1 e1       	ldi	r31, 0x11	; 17
    21fc:	0c 94 8b 13 	jmp	0x2716	; 0x2716 <__prologue_saves__>
    2200:	6c 01       	movw	r12, r24
    2202:	7b 01       	movw	r14, r22
    2204:	8a 01       	movw	r16, r20
    2206:	fc 01       	movw	r30, r24
    2208:	17 82       	std	Z+7, r1	; 0x07
    220a:	16 82       	std	Z+6, r1	; 0x06
    220c:	83 81       	ldd	r24, Z+3	; 0x03
    220e:	81 ff       	sbrs	r24, 1
    2210:	cc c1       	rjmp	.+920    	; 0x25aa <vfprintf+0x3b6>
    2212:	ce 01       	movw	r24, r28
    2214:	01 96       	adiw	r24, 0x01	; 1
    2216:	3c 01       	movw	r6, r24
    2218:	f6 01       	movw	r30, r12
    221a:	93 81       	ldd	r25, Z+3	; 0x03
    221c:	f7 01       	movw	r30, r14
    221e:	93 fd       	sbrc	r25, 3
    2220:	85 91       	lpm	r24, Z+
    2222:	93 ff       	sbrs	r25, 3
    2224:	81 91       	ld	r24, Z+
    2226:	7f 01       	movw	r14, r30
    2228:	88 23       	and	r24, r24
    222a:	09 f4       	brne	.+2      	; 0x222e <vfprintf+0x3a>
    222c:	ba c1       	rjmp	.+884    	; 0x25a2 <vfprintf+0x3ae>
    222e:	85 32       	cpi	r24, 0x25	; 37
    2230:	39 f4       	brne	.+14     	; 0x2240 <vfprintf+0x4c>
    2232:	93 fd       	sbrc	r25, 3
    2234:	85 91       	lpm	r24, Z+
    2236:	93 ff       	sbrs	r25, 3
    2238:	81 91       	ld	r24, Z+
    223a:	7f 01       	movw	r14, r30
    223c:	85 32       	cpi	r24, 0x25	; 37
    223e:	29 f4       	brne	.+10     	; 0x224a <vfprintf+0x56>
    2240:	b6 01       	movw	r22, r12
    2242:	90 e0       	ldi	r25, 0x00	; 0
    2244:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <fputc>
    2248:	e7 cf       	rjmp	.-50     	; 0x2218 <vfprintf+0x24>
    224a:	91 2c       	mov	r9, r1
    224c:	21 2c       	mov	r2, r1
    224e:	31 2c       	mov	r3, r1
    2250:	ff e1       	ldi	r31, 0x1F	; 31
    2252:	f3 15       	cp	r31, r3
    2254:	d8 f0       	brcs	.+54     	; 0x228c <vfprintf+0x98>
    2256:	8b 32       	cpi	r24, 0x2B	; 43
    2258:	79 f0       	breq	.+30     	; 0x2278 <vfprintf+0x84>
    225a:	38 f4       	brcc	.+14     	; 0x226a <vfprintf+0x76>
    225c:	80 32       	cpi	r24, 0x20	; 32
    225e:	79 f0       	breq	.+30     	; 0x227e <vfprintf+0x8a>
    2260:	83 32       	cpi	r24, 0x23	; 35
    2262:	a1 f4       	brne	.+40     	; 0x228c <vfprintf+0x98>
    2264:	23 2d       	mov	r18, r3
    2266:	20 61       	ori	r18, 0x10	; 16
    2268:	1d c0       	rjmp	.+58     	; 0x22a4 <vfprintf+0xb0>
    226a:	8d 32       	cpi	r24, 0x2D	; 45
    226c:	61 f0       	breq	.+24     	; 0x2286 <vfprintf+0x92>
    226e:	80 33       	cpi	r24, 0x30	; 48
    2270:	69 f4       	brne	.+26     	; 0x228c <vfprintf+0x98>
    2272:	23 2d       	mov	r18, r3
    2274:	21 60       	ori	r18, 0x01	; 1
    2276:	16 c0       	rjmp	.+44     	; 0x22a4 <vfprintf+0xb0>
    2278:	83 2d       	mov	r24, r3
    227a:	82 60       	ori	r24, 0x02	; 2
    227c:	38 2e       	mov	r3, r24
    227e:	e3 2d       	mov	r30, r3
    2280:	e4 60       	ori	r30, 0x04	; 4
    2282:	3e 2e       	mov	r3, r30
    2284:	2a c0       	rjmp	.+84     	; 0x22da <vfprintf+0xe6>
    2286:	f3 2d       	mov	r31, r3
    2288:	f8 60       	ori	r31, 0x08	; 8
    228a:	1d c0       	rjmp	.+58     	; 0x22c6 <vfprintf+0xd2>
    228c:	37 fc       	sbrc	r3, 7
    228e:	2d c0       	rjmp	.+90     	; 0x22ea <vfprintf+0xf6>
    2290:	20 ed       	ldi	r18, 0xD0	; 208
    2292:	28 0f       	add	r18, r24
    2294:	2a 30       	cpi	r18, 0x0A	; 10
    2296:	40 f0       	brcs	.+16     	; 0x22a8 <vfprintf+0xb4>
    2298:	8e 32       	cpi	r24, 0x2E	; 46
    229a:	b9 f4       	brne	.+46     	; 0x22ca <vfprintf+0xd6>
    229c:	36 fc       	sbrc	r3, 6
    229e:	81 c1       	rjmp	.+770    	; 0x25a2 <vfprintf+0x3ae>
    22a0:	23 2d       	mov	r18, r3
    22a2:	20 64       	ori	r18, 0x40	; 64
    22a4:	32 2e       	mov	r3, r18
    22a6:	19 c0       	rjmp	.+50     	; 0x22da <vfprintf+0xe6>
    22a8:	36 fe       	sbrs	r3, 6
    22aa:	06 c0       	rjmp	.+12     	; 0x22b8 <vfprintf+0xc4>
    22ac:	8a e0       	ldi	r24, 0x0A	; 10
    22ae:	98 9e       	mul	r9, r24
    22b0:	20 0d       	add	r18, r0
    22b2:	11 24       	eor	r1, r1
    22b4:	92 2e       	mov	r9, r18
    22b6:	11 c0       	rjmp	.+34     	; 0x22da <vfprintf+0xe6>
    22b8:	ea e0       	ldi	r30, 0x0A	; 10
    22ba:	2e 9e       	mul	r2, r30
    22bc:	20 0d       	add	r18, r0
    22be:	11 24       	eor	r1, r1
    22c0:	22 2e       	mov	r2, r18
    22c2:	f3 2d       	mov	r31, r3
    22c4:	f0 62       	ori	r31, 0x20	; 32
    22c6:	3f 2e       	mov	r3, r31
    22c8:	08 c0       	rjmp	.+16     	; 0x22da <vfprintf+0xe6>
    22ca:	8c 36       	cpi	r24, 0x6C	; 108
    22cc:	21 f4       	brne	.+8      	; 0x22d6 <vfprintf+0xe2>
    22ce:	83 2d       	mov	r24, r3
    22d0:	80 68       	ori	r24, 0x80	; 128
    22d2:	38 2e       	mov	r3, r24
    22d4:	02 c0       	rjmp	.+4      	; 0x22da <vfprintf+0xe6>
    22d6:	88 36       	cpi	r24, 0x68	; 104
    22d8:	41 f4       	brne	.+16     	; 0x22ea <vfprintf+0xf6>
    22da:	f7 01       	movw	r30, r14
    22dc:	93 fd       	sbrc	r25, 3
    22de:	85 91       	lpm	r24, Z+
    22e0:	93 ff       	sbrs	r25, 3
    22e2:	81 91       	ld	r24, Z+
    22e4:	7f 01       	movw	r14, r30
    22e6:	81 11       	cpse	r24, r1
    22e8:	b3 cf       	rjmp	.-154    	; 0x2250 <vfprintf+0x5c>
    22ea:	98 2f       	mov	r25, r24
    22ec:	9f 7d       	andi	r25, 0xDF	; 223
    22ee:	95 54       	subi	r25, 0x45	; 69
    22f0:	93 30       	cpi	r25, 0x03	; 3
    22f2:	28 f4       	brcc	.+10     	; 0x22fe <vfprintf+0x10a>
    22f4:	0c 5f       	subi	r16, 0xFC	; 252
    22f6:	1f 4f       	sbci	r17, 0xFF	; 255
    22f8:	9f e3       	ldi	r25, 0x3F	; 63
    22fa:	99 83       	std	Y+1, r25	; 0x01
    22fc:	0d c0       	rjmp	.+26     	; 0x2318 <vfprintf+0x124>
    22fe:	83 36       	cpi	r24, 0x63	; 99
    2300:	31 f0       	breq	.+12     	; 0x230e <vfprintf+0x11a>
    2302:	83 37       	cpi	r24, 0x73	; 115
    2304:	71 f0       	breq	.+28     	; 0x2322 <vfprintf+0x12e>
    2306:	83 35       	cpi	r24, 0x53	; 83
    2308:	09 f0       	breq	.+2      	; 0x230c <vfprintf+0x118>
    230a:	59 c0       	rjmp	.+178    	; 0x23be <vfprintf+0x1ca>
    230c:	21 c0       	rjmp	.+66     	; 0x2350 <vfprintf+0x15c>
    230e:	f8 01       	movw	r30, r16
    2310:	80 81       	ld	r24, Z
    2312:	89 83       	std	Y+1, r24	; 0x01
    2314:	0e 5f       	subi	r16, 0xFE	; 254
    2316:	1f 4f       	sbci	r17, 0xFF	; 255
    2318:	88 24       	eor	r8, r8
    231a:	83 94       	inc	r8
    231c:	91 2c       	mov	r9, r1
    231e:	53 01       	movw	r10, r6
    2320:	13 c0       	rjmp	.+38     	; 0x2348 <vfprintf+0x154>
    2322:	28 01       	movw	r4, r16
    2324:	f2 e0       	ldi	r31, 0x02	; 2
    2326:	4f 0e       	add	r4, r31
    2328:	51 1c       	adc	r5, r1
    232a:	f8 01       	movw	r30, r16
    232c:	a0 80       	ld	r10, Z
    232e:	b1 80       	ldd	r11, Z+1	; 0x01
    2330:	36 fe       	sbrs	r3, 6
    2332:	03 c0       	rjmp	.+6      	; 0x233a <vfprintf+0x146>
    2334:	69 2d       	mov	r22, r9
    2336:	70 e0       	ldi	r23, 0x00	; 0
    2338:	02 c0       	rjmp	.+4      	; 0x233e <vfprintf+0x14a>
    233a:	6f ef       	ldi	r22, 0xFF	; 255
    233c:	7f ef       	ldi	r23, 0xFF	; 255
    233e:	c5 01       	movw	r24, r10
    2340:	0e 94 e6 12 	call	0x25cc	; 0x25cc <strnlen>
    2344:	4c 01       	movw	r8, r24
    2346:	82 01       	movw	r16, r4
    2348:	f3 2d       	mov	r31, r3
    234a:	ff 77       	andi	r31, 0x7F	; 127
    234c:	3f 2e       	mov	r3, r31
    234e:	16 c0       	rjmp	.+44     	; 0x237c <vfprintf+0x188>
    2350:	28 01       	movw	r4, r16
    2352:	22 e0       	ldi	r18, 0x02	; 2
    2354:	42 0e       	add	r4, r18
    2356:	51 1c       	adc	r5, r1
    2358:	f8 01       	movw	r30, r16
    235a:	a0 80       	ld	r10, Z
    235c:	b1 80       	ldd	r11, Z+1	; 0x01
    235e:	36 fe       	sbrs	r3, 6
    2360:	03 c0       	rjmp	.+6      	; 0x2368 <vfprintf+0x174>
    2362:	69 2d       	mov	r22, r9
    2364:	70 e0       	ldi	r23, 0x00	; 0
    2366:	02 c0       	rjmp	.+4      	; 0x236c <vfprintf+0x178>
    2368:	6f ef       	ldi	r22, 0xFF	; 255
    236a:	7f ef       	ldi	r23, 0xFF	; 255
    236c:	c5 01       	movw	r24, r10
    236e:	0e 94 db 12 	call	0x25b6	; 0x25b6 <strnlen_P>
    2372:	4c 01       	movw	r8, r24
    2374:	f3 2d       	mov	r31, r3
    2376:	f0 68       	ori	r31, 0x80	; 128
    2378:	3f 2e       	mov	r3, r31
    237a:	82 01       	movw	r16, r4
    237c:	33 fc       	sbrc	r3, 3
    237e:	1b c0       	rjmp	.+54     	; 0x23b6 <vfprintf+0x1c2>
    2380:	82 2d       	mov	r24, r2
    2382:	90 e0       	ldi	r25, 0x00	; 0
    2384:	88 16       	cp	r8, r24
    2386:	99 06       	cpc	r9, r25
    2388:	b0 f4       	brcc	.+44     	; 0x23b6 <vfprintf+0x1c2>
    238a:	b6 01       	movw	r22, r12
    238c:	80 e2       	ldi	r24, 0x20	; 32
    238e:	90 e0       	ldi	r25, 0x00	; 0
    2390:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <fputc>
    2394:	2a 94       	dec	r2
    2396:	f4 cf       	rjmp	.-24     	; 0x2380 <vfprintf+0x18c>
    2398:	f5 01       	movw	r30, r10
    239a:	37 fc       	sbrc	r3, 7
    239c:	85 91       	lpm	r24, Z+
    239e:	37 fe       	sbrs	r3, 7
    23a0:	81 91       	ld	r24, Z+
    23a2:	5f 01       	movw	r10, r30
    23a4:	b6 01       	movw	r22, r12
    23a6:	90 e0       	ldi	r25, 0x00	; 0
    23a8:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <fputc>
    23ac:	21 10       	cpse	r2, r1
    23ae:	2a 94       	dec	r2
    23b0:	21 e0       	ldi	r18, 0x01	; 1
    23b2:	82 1a       	sub	r8, r18
    23b4:	91 08       	sbc	r9, r1
    23b6:	81 14       	cp	r8, r1
    23b8:	91 04       	cpc	r9, r1
    23ba:	71 f7       	brne	.-36     	; 0x2398 <vfprintf+0x1a4>
    23bc:	e8 c0       	rjmp	.+464    	; 0x258e <vfprintf+0x39a>
    23be:	84 36       	cpi	r24, 0x64	; 100
    23c0:	11 f0       	breq	.+4      	; 0x23c6 <vfprintf+0x1d2>
    23c2:	89 36       	cpi	r24, 0x69	; 105
    23c4:	41 f5       	brne	.+80     	; 0x2416 <vfprintf+0x222>
    23c6:	f8 01       	movw	r30, r16
    23c8:	37 fe       	sbrs	r3, 7
    23ca:	07 c0       	rjmp	.+14     	; 0x23da <vfprintf+0x1e6>
    23cc:	60 81       	ld	r22, Z
    23ce:	71 81       	ldd	r23, Z+1	; 0x01
    23d0:	82 81       	ldd	r24, Z+2	; 0x02
    23d2:	93 81       	ldd	r25, Z+3	; 0x03
    23d4:	0c 5f       	subi	r16, 0xFC	; 252
    23d6:	1f 4f       	sbci	r17, 0xFF	; 255
    23d8:	08 c0       	rjmp	.+16     	; 0x23ea <vfprintf+0x1f6>
    23da:	60 81       	ld	r22, Z
    23dc:	71 81       	ldd	r23, Z+1	; 0x01
    23de:	07 2e       	mov	r0, r23
    23e0:	00 0c       	add	r0, r0
    23e2:	88 0b       	sbc	r24, r24
    23e4:	99 0b       	sbc	r25, r25
    23e6:	0e 5f       	subi	r16, 0xFE	; 254
    23e8:	1f 4f       	sbci	r17, 0xFF	; 255
    23ea:	f3 2d       	mov	r31, r3
    23ec:	ff 76       	andi	r31, 0x6F	; 111
    23ee:	3f 2e       	mov	r3, r31
    23f0:	97 ff       	sbrs	r25, 7
    23f2:	09 c0       	rjmp	.+18     	; 0x2406 <vfprintf+0x212>
    23f4:	90 95       	com	r25
    23f6:	80 95       	com	r24
    23f8:	70 95       	com	r23
    23fa:	61 95       	neg	r22
    23fc:	7f 4f       	sbci	r23, 0xFF	; 255
    23fe:	8f 4f       	sbci	r24, 0xFF	; 255
    2400:	9f 4f       	sbci	r25, 0xFF	; 255
    2402:	f0 68       	ori	r31, 0x80	; 128
    2404:	3f 2e       	mov	r3, r31
    2406:	2a e0       	ldi	r18, 0x0A	; 10
    2408:	30 e0       	ldi	r19, 0x00	; 0
    240a:	a3 01       	movw	r20, r6
    240c:	0e 94 2d 13 	call	0x265a	; 0x265a <__ultoa_invert>
    2410:	88 2e       	mov	r8, r24
    2412:	86 18       	sub	r8, r6
    2414:	45 c0       	rjmp	.+138    	; 0x24a0 <vfprintf+0x2ac>
    2416:	85 37       	cpi	r24, 0x75	; 117
    2418:	31 f4       	brne	.+12     	; 0x2426 <vfprintf+0x232>
    241a:	23 2d       	mov	r18, r3
    241c:	2f 7e       	andi	r18, 0xEF	; 239
    241e:	b2 2e       	mov	r11, r18
    2420:	2a e0       	ldi	r18, 0x0A	; 10
    2422:	30 e0       	ldi	r19, 0x00	; 0
    2424:	25 c0       	rjmp	.+74     	; 0x2470 <vfprintf+0x27c>
    2426:	93 2d       	mov	r25, r3
    2428:	99 7f       	andi	r25, 0xF9	; 249
    242a:	b9 2e       	mov	r11, r25
    242c:	8f 36       	cpi	r24, 0x6F	; 111
    242e:	c1 f0       	breq	.+48     	; 0x2460 <vfprintf+0x26c>
    2430:	18 f4       	brcc	.+6      	; 0x2438 <vfprintf+0x244>
    2432:	88 35       	cpi	r24, 0x58	; 88
    2434:	79 f0       	breq	.+30     	; 0x2454 <vfprintf+0x260>
    2436:	b5 c0       	rjmp	.+362    	; 0x25a2 <vfprintf+0x3ae>
    2438:	80 37       	cpi	r24, 0x70	; 112
    243a:	19 f0       	breq	.+6      	; 0x2442 <vfprintf+0x24e>
    243c:	88 37       	cpi	r24, 0x78	; 120
    243e:	21 f0       	breq	.+8      	; 0x2448 <vfprintf+0x254>
    2440:	b0 c0       	rjmp	.+352    	; 0x25a2 <vfprintf+0x3ae>
    2442:	e9 2f       	mov	r30, r25
    2444:	e0 61       	ori	r30, 0x10	; 16
    2446:	be 2e       	mov	r11, r30
    2448:	b4 fe       	sbrs	r11, 4
    244a:	0d c0       	rjmp	.+26     	; 0x2466 <vfprintf+0x272>
    244c:	fb 2d       	mov	r31, r11
    244e:	f4 60       	ori	r31, 0x04	; 4
    2450:	bf 2e       	mov	r11, r31
    2452:	09 c0       	rjmp	.+18     	; 0x2466 <vfprintf+0x272>
    2454:	34 fe       	sbrs	r3, 4
    2456:	0a c0       	rjmp	.+20     	; 0x246c <vfprintf+0x278>
    2458:	29 2f       	mov	r18, r25
    245a:	26 60       	ori	r18, 0x06	; 6
    245c:	b2 2e       	mov	r11, r18
    245e:	06 c0       	rjmp	.+12     	; 0x246c <vfprintf+0x278>
    2460:	28 e0       	ldi	r18, 0x08	; 8
    2462:	30 e0       	ldi	r19, 0x00	; 0
    2464:	05 c0       	rjmp	.+10     	; 0x2470 <vfprintf+0x27c>
    2466:	20 e1       	ldi	r18, 0x10	; 16
    2468:	30 e0       	ldi	r19, 0x00	; 0
    246a:	02 c0       	rjmp	.+4      	; 0x2470 <vfprintf+0x27c>
    246c:	20 e1       	ldi	r18, 0x10	; 16
    246e:	32 e0       	ldi	r19, 0x02	; 2
    2470:	f8 01       	movw	r30, r16
    2472:	b7 fe       	sbrs	r11, 7
    2474:	07 c0       	rjmp	.+14     	; 0x2484 <vfprintf+0x290>
    2476:	60 81       	ld	r22, Z
    2478:	71 81       	ldd	r23, Z+1	; 0x01
    247a:	82 81       	ldd	r24, Z+2	; 0x02
    247c:	93 81       	ldd	r25, Z+3	; 0x03
    247e:	0c 5f       	subi	r16, 0xFC	; 252
    2480:	1f 4f       	sbci	r17, 0xFF	; 255
    2482:	06 c0       	rjmp	.+12     	; 0x2490 <vfprintf+0x29c>
    2484:	60 81       	ld	r22, Z
    2486:	71 81       	ldd	r23, Z+1	; 0x01
    2488:	80 e0       	ldi	r24, 0x00	; 0
    248a:	90 e0       	ldi	r25, 0x00	; 0
    248c:	0e 5f       	subi	r16, 0xFE	; 254
    248e:	1f 4f       	sbci	r17, 0xFF	; 255
    2490:	a3 01       	movw	r20, r6
    2492:	0e 94 2d 13 	call	0x265a	; 0x265a <__ultoa_invert>
    2496:	88 2e       	mov	r8, r24
    2498:	86 18       	sub	r8, r6
    249a:	fb 2d       	mov	r31, r11
    249c:	ff 77       	andi	r31, 0x7F	; 127
    249e:	3f 2e       	mov	r3, r31
    24a0:	36 fe       	sbrs	r3, 6
    24a2:	0d c0       	rjmp	.+26     	; 0x24be <vfprintf+0x2ca>
    24a4:	23 2d       	mov	r18, r3
    24a6:	2e 7f       	andi	r18, 0xFE	; 254
    24a8:	a2 2e       	mov	r10, r18
    24aa:	89 14       	cp	r8, r9
    24ac:	58 f4       	brcc	.+22     	; 0x24c4 <vfprintf+0x2d0>
    24ae:	34 fe       	sbrs	r3, 4
    24b0:	0b c0       	rjmp	.+22     	; 0x24c8 <vfprintf+0x2d4>
    24b2:	32 fc       	sbrc	r3, 2
    24b4:	09 c0       	rjmp	.+18     	; 0x24c8 <vfprintf+0x2d4>
    24b6:	83 2d       	mov	r24, r3
    24b8:	8e 7e       	andi	r24, 0xEE	; 238
    24ba:	a8 2e       	mov	r10, r24
    24bc:	05 c0       	rjmp	.+10     	; 0x24c8 <vfprintf+0x2d4>
    24be:	b8 2c       	mov	r11, r8
    24c0:	a3 2c       	mov	r10, r3
    24c2:	03 c0       	rjmp	.+6      	; 0x24ca <vfprintf+0x2d6>
    24c4:	b8 2c       	mov	r11, r8
    24c6:	01 c0       	rjmp	.+2      	; 0x24ca <vfprintf+0x2d6>
    24c8:	b9 2c       	mov	r11, r9
    24ca:	a4 fe       	sbrs	r10, 4
    24cc:	0f c0       	rjmp	.+30     	; 0x24ec <vfprintf+0x2f8>
    24ce:	fe 01       	movw	r30, r28
    24d0:	e8 0d       	add	r30, r8
    24d2:	f1 1d       	adc	r31, r1
    24d4:	80 81       	ld	r24, Z
    24d6:	80 33       	cpi	r24, 0x30	; 48
    24d8:	21 f4       	brne	.+8      	; 0x24e2 <vfprintf+0x2ee>
    24da:	9a 2d       	mov	r25, r10
    24dc:	99 7e       	andi	r25, 0xE9	; 233
    24de:	a9 2e       	mov	r10, r25
    24e0:	09 c0       	rjmp	.+18     	; 0x24f4 <vfprintf+0x300>
    24e2:	a2 fe       	sbrs	r10, 2
    24e4:	06 c0       	rjmp	.+12     	; 0x24f2 <vfprintf+0x2fe>
    24e6:	b3 94       	inc	r11
    24e8:	b3 94       	inc	r11
    24ea:	04 c0       	rjmp	.+8      	; 0x24f4 <vfprintf+0x300>
    24ec:	8a 2d       	mov	r24, r10
    24ee:	86 78       	andi	r24, 0x86	; 134
    24f0:	09 f0       	breq	.+2      	; 0x24f4 <vfprintf+0x300>
    24f2:	b3 94       	inc	r11
    24f4:	a3 fc       	sbrc	r10, 3
    24f6:	11 c0       	rjmp	.+34     	; 0x251a <vfprintf+0x326>
    24f8:	a0 fe       	sbrs	r10, 0
    24fa:	06 c0       	rjmp	.+12     	; 0x2508 <vfprintf+0x314>
    24fc:	b2 14       	cp	r11, r2
    24fe:	88 f4       	brcc	.+34     	; 0x2522 <vfprintf+0x32e>
    2500:	28 0c       	add	r2, r8
    2502:	92 2c       	mov	r9, r2
    2504:	9b 18       	sub	r9, r11
    2506:	0e c0       	rjmp	.+28     	; 0x2524 <vfprintf+0x330>
    2508:	b2 14       	cp	r11, r2
    250a:	60 f4       	brcc	.+24     	; 0x2524 <vfprintf+0x330>
    250c:	b6 01       	movw	r22, r12
    250e:	80 e2       	ldi	r24, 0x20	; 32
    2510:	90 e0       	ldi	r25, 0x00	; 0
    2512:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <fputc>
    2516:	b3 94       	inc	r11
    2518:	f7 cf       	rjmp	.-18     	; 0x2508 <vfprintf+0x314>
    251a:	b2 14       	cp	r11, r2
    251c:	18 f4       	brcc	.+6      	; 0x2524 <vfprintf+0x330>
    251e:	2b 18       	sub	r2, r11
    2520:	02 c0       	rjmp	.+4      	; 0x2526 <vfprintf+0x332>
    2522:	98 2c       	mov	r9, r8
    2524:	21 2c       	mov	r2, r1
    2526:	a4 fe       	sbrs	r10, 4
    2528:	10 c0       	rjmp	.+32     	; 0x254a <vfprintf+0x356>
    252a:	b6 01       	movw	r22, r12
    252c:	80 e3       	ldi	r24, 0x30	; 48
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <fputc>
    2534:	a2 fe       	sbrs	r10, 2
    2536:	17 c0       	rjmp	.+46     	; 0x2566 <vfprintf+0x372>
    2538:	a1 fc       	sbrc	r10, 1
    253a:	03 c0       	rjmp	.+6      	; 0x2542 <vfprintf+0x34e>
    253c:	88 e7       	ldi	r24, 0x78	; 120
    253e:	90 e0       	ldi	r25, 0x00	; 0
    2540:	02 c0       	rjmp	.+4      	; 0x2546 <vfprintf+0x352>
    2542:	88 e5       	ldi	r24, 0x58	; 88
    2544:	90 e0       	ldi	r25, 0x00	; 0
    2546:	b6 01       	movw	r22, r12
    2548:	0c c0       	rjmp	.+24     	; 0x2562 <vfprintf+0x36e>
    254a:	8a 2d       	mov	r24, r10
    254c:	86 78       	andi	r24, 0x86	; 134
    254e:	59 f0       	breq	.+22     	; 0x2566 <vfprintf+0x372>
    2550:	a1 fe       	sbrs	r10, 1
    2552:	02 c0       	rjmp	.+4      	; 0x2558 <vfprintf+0x364>
    2554:	8b e2       	ldi	r24, 0x2B	; 43
    2556:	01 c0       	rjmp	.+2      	; 0x255a <vfprintf+0x366>
    2558:	80 e2       	ldi	r24, 0x20	; 32
    255a:	a7 fc       	sbrc	r10, 7
    255c:	8d e2       	ldi	r24, 0x2D	; 45
    255e:	b6 01       	movw	r22, r12
    2560:	90 e0       	ldi	r25, 0x00	; 0
    2562:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <fputc>
    2566:	89 14       	cp	r8, r9
    2568:	38 f4       	brcc	.+14     	; 0x2578 <vfprintf+0x384>
    256a:	b6 01       	movw	r22, r12
    256c:	80 e3       	ldi	r24, 0x30	; 48
    256e:	90 e0       	ldi	r25, 0x00	; 0
    2570:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <fputc>
    2574:	9a 94       	dec	r9
    2576:	f7 cf       	rjmp	.-18     	; 0x2566 <vfprintf+0x372>
    2578:	8a 94       	dec	r8
    257a:	f3 01       	movw	r30, r6
    257c:	e8 0d       	add	r30, r8
    257e:	f1 1d       	adc	r31, r1
    2580:	80 81       	ld	r24, Z
    2582:	b6 01       	movw	r22, r12
    2584:	90 e0       	ldi	r25, 0x00	; 0
    2586:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <fputc>
    258a:	81 10       	cpse	r8, r1
    258c:	f5 cf       	rjmp	.-22     	; 0x2578 <vfprintf+0x384>
    258e:	22 20       	and	r2, r2
    2590:	09 f4       	brne	.+2      	; 0x2594 <vfprintf+0x3a0>
    2592:	42 ce       	rjmp	.-892    	; 0x2218 <vfprintf+0x24>
    2594:	b6 01       	movw	r22, r12
    2596:	80 e2       	ldi	r24, 0x20	; 32
    2598:	90 e0       	ldi	r25, 0x00	; 0
    259a:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <fputc>
    259e:	2a 94       	dec	r2
    25a0:	f6 cf       	rjmp	.-20     	; 0x258e <vfprintf+0x39a>
    25a2:	f6 01       	movw	r30, r12
    25a4:	86 81       	ldd	r24, Z+6	; 0x06
    25a6:	97 81       	ldd	r25, Z+7	; 0x07
    25a8:	02 c0       	rjmp	.+4      	; 0x25ae <vfprintf+0x3ba>
    25aa:	8f ef       	ldi	r24, 0xFF	; 255
    25ac:	9f ef       	ldi	r25, 0xFF	; 255
    25ae:	2b 96       	adiw	r28, 0x0b	; 11
    25b0:	e2 e1       	ldi	r30, 0x12	; 18
    25b2:	0c 94 a7 13 	jmp	0x274e	; 0x274e <__epilogue_restores__>

000025b6 <strnlen_P>:
    25b6:	fc 01       	movw	r30, r24
    25b8:	05 90       	lpm	r0, Z+
    25ba:	61 50       	subi	r22, 0x01	; 1
    25bc:	70 40       	sbci	r23, 0x00	; 0
    25be:	01 10       	cpse	r0, r1
    25c0:	d8 f7       	brcc	.-10     	; 0x25b8 <strnlen_P+0x2>
    25c2:	80 95       	com	r24
    25c4:	90 95       	com	r25
    25c6:	8e 0f       	add	r24, r30
    25c8:	9f 1f       	adc	r25, r31
    25ca:	08 95       	ret

000025cc <strnlen>:
    25cc:	fc 01       	movw	r30, r24
    25ce:	61 50       	subi	r22, 0x01	; 1
    25d0:	70 40       	sbci	r23, 0x00	; 0
    25d2:	01 90       	ld	r0, Z+
    25d4:	01 10       	cpse	r0, r1
    25d6:	d8 f7       	brcc	.-10     	; 0x25ce <strnlen+0x2>
    25d8:	80 95       	com	r24
    25da:	90 95       	com	r25
    25dc:	8e 0f       	add	r24, r30
    25de:	9f 1f       	adc	r25, r31
    25e0:	08 95       	ret

000025e2 <fputc>:
    25e2:	0f 93       	push	r16
    25e4:	1f 93       	push	r17
    25e6:	cf 93       	push	r28
    25e8:	df 93       	push	r29
    25ea:	fb 01       	movw	r30, r22
    25ec:	23 81       	ldd	r18, Z+3	; 0x03
    25ee:	21 fd       	sbrc	r18, 1
    25f0:	03 c0       	rjmp	.+6      	; 0x25f8 <fputc+0x16>
    25f2:	8f ef       	ldi	r24, 0xFF	; 255
    25f4:	9f ef       	ldi	r25, 0xFF	; 255
    25f6:	2c c0       	rjmp	.+88     	; 0x2650 <fputc+0x6e>
    25f8:	22 ff       	sbrs	r18, 2
    25fa:	16 c0       	rjmp	.+44     	; 0x2628 <fputc+0x46>
    25fc:	46 81       	ldd	r20, Z+6	; 0x06
    25fe:	57 81       	ldd	r21, Z+7	; 0x07
    2600:	24 81       	ldd	r18, Z+4	; 0x04
    2602:	35 81       	ldd	r19, Z+5	; 0x05
    2604:	42 17       	cp	r20, r18
    2606:	53 07       	cpc	r21, r19
    2608:	44 f4       	brge	.+16     	; 0x261a <fputc+0x38>
    260a:	a0 81       	ld	r26, Z
    260c:	b1 81       	ldd	r27, Z+1	; 0x01
    260e:	9d 01       	movw	r18, r26
    2610:	2f 5f       	subi	r18, 0xFF	; 255
    2612:	3f 4f       	sbci	r19, 0xFF	; 255
    2614:	31 83       	std	Z+1, r19	; 0x01
    2616:	20 83       	st	Z, r18
    2618:	8c 93       	st	X, r24
    261a:	26 81       	ldd	r18, Z+6	; 0x06
    261c:	37 81       	ldd	r19, Z+7	; 0x07
    261e:	2f 5f       	subi	r18, 0xFF	; 255
    2620:	3f 4f       	sbci	r19, 0xFF	; 255
    2622:	37 83       	std	Z+7, r19	; 0x07
    2624:	26 83       	std	Z+6, r18	; 0x06
    2626:	14 c0       	rjmp	.+40     	; 0x2650 <fputc+0x6e>
    2628:	8b 01       	movw	r16, r22
    262a:	ec 01       	movw	r28, r24
    262c:	fb 01       	movw	r30, r22
    262e:	00 84       	ldd	r0, Z+8	; 0x08
    2630:	f1 85       	ldd	r31, Z+9	; 0x09
    2632:	e0 2d       	mov	r30, r0
    2634:	09 95       	icall
    2636:	89 2b       	or	r24, r25
    2638:	e1 f6       	brne	.-72     	; 0x25f2 <fputc+0x10>
    263a:	d8 01       	movw	r26, r16
    263c:	16 96       	adiw	r26, 0x06	; 6
    263e:	8d 91       	ld	r24, X+
    2640:	9c 91       	ld	r25, X
    2642:	17 97       	sbiw	r26, 0x07	; 7
    2644:	01 96       	adiw	r24, 0x01	; 1
    2646:	17 96       	adiw	r26, 0x07	; 7
    2648:	9c 93       	st	X, r25
    264a:	8e 93       	st	-X, r24
    264c:	16 97       	sbiw	r26, 0x06	; 6
    264e:	ce 01       	movw	r24, r28
    2650:	df 91       	pop	r29
    2652:	cf 91       	pop	r28
    2654:	1f 91       	pop	r17
    2656:	0f 91       	pop	r16
    2658:	08 95       	ret

0000265a <__ultoa_invert>:
    265a:	fa 01       	movw	r30, r20
    265c:	aa 27       	eor	r26, r26
    265e:	28 30       	cpi	r18, 0x08	; 8
    2660:	51 f1       	breq	.+84     	; 0x26b6 <__ultoa_invert+0x5c>
    2662:	20 31       	cpi	r18, 0x10	; 16
    2664:	81 f1       	breq	.+96     	; 0x26c6 <__ultoa_invert+0x6c>
    2666:	e8 94       	clt
    2668:	6f 93       	push	r22
    266a:	6e 7f       	andi	r22, 0xFE	; 254
    266c:	6e 5f       	subi	r22, 0xFE	; 254
    266e:	7f 4f       	sbci	r23, 0xFF	; 255
    2670:	8f 4f       	sbci	r24, 0xFF	; 255
    2672:	9f 4f       	sbci	r25, 0xFF	; 255
    2674:	af 4f       	sbci	r26, 0xFF	; 255
    2676:	b1 e0       	ldi	r27, 0x01	; 1
    2678:	3e d0       	rcall	.+124    	; 0x26f6 <__ultoa_invert+0x9c>
    267a:	b4 e0       	ldi	r27, 0x04	; 4
    267c:	3c d0       	rcall	.+120    	; 0x26f6 <__ultoa_invert+0x9c>
    267e:	67 0f       	add	r22, r23
    2680:	78 1f       	adc	r23, r24
    2682:	89 1f       	adc	r24, r25
    2684:	9a 1f       	adc	r25, r26
    2686:	a1 1d       	adc	r26, r1
    2688:	68 0f       	add	r22, r24
    268a:	79 1f       	adc	r23, r25
    268c:	8a 1f       	adc	r24, r26
    268e:	91 1d       	adc	r25, r1
    2690:	a1 1d       	adc	r26, r1
    2692:	6a 0f       	add	r22, r26
    2694:	71 1d       	adc	r23, r1
    2696:	81 1d       	adc	r24, r1
    2698:	91 1d       	adc	r25, r1
    269a:	a1 1d       	adc	r26, r1
    269c:	20 d0       	rcall	.+64     	; 0x26de <__ultoa_invert+0x84>
    269e:	09 f4       	brne	.+2      	; 0x26a2 <__ultoa_invert+0x48>
    26a0:	68 94       	set
    26a2:	3f 91       	pop	r19
    26a4:	2a e0       	ldi	r18, 0x0A	; 10
    26a6:	26 9f       	mul	r18, r22
    26a8:	11 24       	eor	r1, r1
    26aa:	30 19       	sub	r19, r0
    26ac:	30 5d       	subi	r19, 0xD0	; 208
    26ae:	31 93       	st	Z+, r19
    26b0:	de f6       	brtc	.-74     	; 0x2668 <__ultoa_invert+0xe>
    26b2:	cf 01       	movw	r24, r30
    26b4:	08 95       	ret
    26b6:	46 2f       	mov	r20, r22
    26b8:	47 70       	andi	r20, 0x07	; 7
    26ba:	40 5d       	subi	r20, 0xD0	; 208
    26bc:	41 93       	st	Z+, r20
    26be:	b3 e0       	ldi	r27, 0x03	; 3
    26c0:	0f d0       	rcall	.+30     	; 0x26e0 <__ultoa_invert+0x86>
    26c2:	c9 f7       	brne	.-14     	; 0x26b6 <__ultoa_invert+0x5c>
    26c4:	f6 cf       	rjmp	.-20     	; 0x26b2 <__ultoa_invert+0x58>
    26c6:	46 2f       	mov	r20, r22
    26c8:	4f 70       	andi	r20, 0x0F	; 15
    26ca:	40 5d       	subi	r20, 0xD0	; 208
    26cc:	4a 33       	cpi	r20, 0x3A	; 58
    26ce:	18 f0       	brcs	.+6      	; 0x26d6 <__ultoa_invert+0x7c>
    26d0:	49 5d       	subi	r20, 0xD9	; 217
    26d2:	31 fd       	sbrc	r19, 1
    26d4:	40 52       	subi	r20, 0x20	; 32
    26d6:	41 93       	st	Z+, r20
    26d8:	02 d0       	rcall	.+4      	; 0x26de <__ultoa_invert+0x84>
    26da:	a9 f7       	brne	.-22     	; 0x26c6 <__ultoa_invert+0x6c>
    26dc:	ea cf       	rjmp	.-44     	; 0x26b2 <__ultoa_invert+0x58>
    26de:	b4 e0       	ldi	r27, 0x04	; 4
    26e0:	a6 95       	lsr	r26
    26e2:	97 95       	ror	r25
    26e4:	87 95       	ror	r24
    26e6:	77 95       	ror	r23
    26e8:	67 95       	ror	r22
    26ea:	ba 95       	dec	r27
    26ec:	c9 f7       	brne	.-14     	; 0x26e0 <__ultoa_invert+0x86>
    26ee:	00 97       	sbiw	r24, 0x00	; 0
    26f0:	61 05       	cpc	r22, r1
    26f2:	71 05       	cpc	r23, r1
    26f4:	08 95       	ret
    26f6:	9b 01       	movw	r18, r22
    26f8:	ac 01       	movw	r20, r24
    26fa:	0a 2e       	mov	r0, r26
    26fc:	06 94       	lsr	r0
    26fe:	57 95       	ror	r21
    2700:	47 95       	ror	r20
    2702:	37 95       	ror	r19
    2704:	27 95       	ror	r18
    2706:	ba 95       	dec	r27
    2708:	c9 f7       	brne	.-14     	; 0x26fc <__ultoa_invert+0xa2>
    270a:	62 0f       	add	r22, r18
    270c:	73 1f       	adc	r23, r19
    270e:	84 1f       	adc	r24, r20
    2710:	95 1f       	adc	r25, r21
    2712:	a0 1d       	adc	r26, r0
    2714:	08 95       	ret

00002716 <__prologue_saves__>:
    2716:	2f 92       	push	r2
    2718:	3f 92       	push	r3
    271a:	4f 92       	push	r4
    271c:	5f 92       	push	r5
    271e:	6f 92       	push	r6
    2720:	7f 92       	push	r7
    2722:	8f 92       	push	r8
    2724:	9f 92       	push	r9
    2726:	af 92       	push	r10
    2728:	bf 92       	push	r11
    272a:	cf 92       	push	r12
    272c:	df 92       	push	r13
    272e:	ef 92       	push	r14
    2730:	ff 92       	push	r15
    2732:	0f 93       	push	r16
    2734:	1f 93       	push	r17
    2736:	cf 93       	push	r28
    2738:	df 93       	push	r29
    273a:	cd b7       	in	r28, 0x3d	; 61
    273c:	de b7       	in	r29, 0x3e	; 62
    273e:	ca 1b       	sub	r28, r26
    2740:	db 0b       	sbc	r29, r27
    2742:	0f b6       	in	r0, 0x3f	; 63
    2744:	f8 94       	cli
    2746:	de bf       	out	0x3e, r29	; 62
    2748:	0f be       	out	0x3f, r0	; 63
    274a:	cd bf       	out	0x3d, r28	; 61
    274c:	09 94       	ijmp

0000274e <__epilogue_restores__>:
    274e:	2a 88       	ldd	r2, Y+18	; 0x12
    2750:	39 88       	ldd	r3, Y+17	; 0x11
    2752:	48 88       	ldd	r4, Y+16	; 0x10
    2754:	5f 84       	ldd	r5, Y+15	; 0x0f
    2756:	6e 84       	ldd	r6, Y+14	; 0x0e
    2758:	7d 84       	ldd	r7, Y+13	; 0x0d
    275a:	8c 84       	ldd	r8, Y+12	; 0x0c
    275c:	9b 84       	ldd	r9, Y+11	; 0x0b
    275e:	aa 84       	ldd	r10, Y+10	; 0x0a
    2760:	b9 84       	ldd	r11, Y+9	; 0x09
    2762:	c8 84       	ldd	r12, Y+8	; 0x08
    2764:	df 80       	ldd	r13, Y+7	; 0x07
    2766:	ee 80       	ldd	r14, Y+6	; 0x06
    2768:	fd 80       	ldd	r15, Y+5	; 0x05
    276a:	0c 81       	ldd	r16, Y+4	; 0x04
    276c:	1b 81       	ldd	r17, Y+3	; 0x03
    276e:	aa 81       	ldd	r26, Y+2	; 0x02
    2770:	b9 81       	ldd	r27, Y+1	; 0x01
    2772:	ce 0f       	add	r28, r30
    2774:	d1 1d       	adc	r29, r1
    2776:	0f b6       	in	r0, 0x3f	; 63
    2778:	f8 94       	cli
    277a:	de bf       	out	0x3e, r29	; 62
    277c:	0f be       	out	0x3f, r0	; 63
    277e:	cd bf       	out	0x3d, r28	; 61
    2780:	ed 01       	movw	r28, r26
    2782:	08 95       	ret

00002784 <_exit>:
    2784:	f8 94       	cli

00002786 <__stop_program>:
    2786:	ff cf       	rjmp	.-2      	; 0x2786 <__stop_program>
