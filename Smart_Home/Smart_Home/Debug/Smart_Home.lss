
Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003780  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000746  00800060  00003780  00003814  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000b6  008007a6  008007a6  00003f5a  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003f5a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00003fb8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000640  00000000  00000000  00003ff4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000691f  00000000  00000000  00004634  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001aa7  00000000  00000000  0000af53  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000043ed  00000000  00000000  0000c9fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000eec  00000000  00000000  00010de8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000015a2  00000000  00000000  00011cd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003942  00000000  00000000  00013276  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004e0  00000000  00000000  00016bb8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8c 00 	jmp	0x118	; 0x118 <__ctors_end>
       4:	0c 94 ec 13 	jmp	0x27d8	; 0x27d8 <__vector_1>
       8:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
       c:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      10:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      14:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      18:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      1c:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      20:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      24:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      28:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      2c:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      30:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      34:	0c 94 67 13 	jmp	0x26ce	; 0x26ce <__vector_13>
      38:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      3c:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      40:	0c 94 26 14 	jmp	0x284c	; 0x284c <__vector_16>
      44:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      48:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      4c:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      50:	0c 94 a9 00 	jmp	0x152	; 0x152 <__bad_interrupt>
      54:	b3 04       	cpc	r11, r3
      56:	b7 04       	cpc	r11, r7
      58:	bb 04       	cpc	r11, r11
      5a:	bf 04       	cpc	r11, r15
      5c:	c3 04       	cpc	r12, r3
      5e:	c7 04       	cpc	r12, r7
      60:	cb 04       	cpc	r12, r11
      62:	d5 06       	cpc	r13, r21
      64:	e9 06       	cpc	r14, r25
      66:	e9 06       	cpc	r14, r25
      68:	e9 06       	cpc	r14, r25
      6a:	e9 06       	cpc	r14, r25
      6c:	e9 06       	cpc	r14, r25
      6e:	e9 06       	cpc	r14, r25
      70:	e9 06       	cpc	r14, r25
      72:	eb 06       	cpc	r14, r27
      74:	e9 06       	cpc	r14, r25
      76:	e9 06       	cpc	r14, r25
      78:	e9 06       	cpc	r14, r25
      7a:	e9 06       	cpc	r14, r25
      7c:	e9 06       	cpc	r14, r25
      7e:	e9 06       	cpc	r14, r25
      80:	e9 06       	cpc	r14, r25
      82:	d7 06       	cpc	r13, r23
      84:	e9 06       	cpc	r14, r25
      86:	e9 06       	cpc	r14, r25
      88:	e9 06       	cpc	r14, r25
      8a:	e9 06       	cpc	r14, r25
      8c:	e9 06       	cpc	r14, r25
      8e:	e9 06       	cpc	r14, r25
      90:	e9 06       	cpc	r14, r25
      92:	d9 06       	cpc	r13, r25
      94:	e9 06       	cpc	r14, r25
      96:	e9 06       	cpc	r14, r25
      98:	e9 06       	cpc	r14, r25
      9a:	e9 06       	cpc	r14, r25
      9c:	e9 06       	cpc	r14, r25
      9e:	e9 06       	cpc	r14, r25
      a0:	e9 06       	cpc	r14, r25
      a2:	db 06       	cpc	r13, r27
      a4:	e9 06       	cpc	r14, r25
      a6:	e9 06       	cpc	r14, r25
      a8:	e9 06       	cpc	r14, r25
      aa:	e9 06       	cpc	r14, r25
      ac:	e9 06       	cpc	r14, r25
      ae:	e9 06       	cpc	r14, r25
      b0:	e9 06       	cpc	r14, r25
      b2:	dd 06       	cpc	r13, r29
      b4:	e9 06       	cpc	r14, r25
      b6:	e9 06       	cpc	r14, r25
      b8:	e9 06       	cpc	r14, r25
      ba:	e9 06       	cpc	r14, r25
      bc:	e9 06       	cpc	r14, r25
      be:	e9 06       	cpc	r14, r25
      c0:	e9 06       	cpc	r14, r25
      c2:	df 06       	cpc	r13, r31
      c4:	e9 06       	cpc	r14, r25
      c6:	e9 06       	cpc	r14, r25
      c8:	e9 06       	cpc	r14, r25
      ca:	e9 06       	cpc	r14, r25
      cc:	e9 06       	cpc	r14, r25
      ce:	e9 06       	cpc	r14, r25
      d0:	e9 06       	cpc	r14, r25
      d2:	e1 06       	cpc	r14, r17
      d4:	e9 06       	cpc	r14, r25
      d6:	e9 06       	cpc	r14, r25
      d8:	e9 06       	cpc	r14, r25
      da:	e9 06       	cpc	r14, r25
      dc:	e9 06       	cpc	r14, r25
      de:	e9 06       	cpc	r14, r25
      e0:	e9 06       	cpc	r14, r25
      e2:	e3 06       	cpc	r14, r19
      e4:	e9 06       	cpc	r14, r25
      e6:	e9 06       	cpc	r14, r25
      e8:	e9 06       	cpc	r14, r25
      ea:	e9 06       	cpc	r14, r25
      ec:	e9 06       	cpc	r14, r25
      ee:	e9 06       	cpc	r14, r25
      f0:	e9 06       	cpc	r14, r25
      f2:	e5 06       	cpc	r14, r21
      f4:	e9 06       	cpc	r14, r25
      f6:	e9 06       	cpc	r14, r25
      f8:	e9 06       	cpc	r14, r25
      fa:	e9 06       	cpc	r14, r25
      fc:	e9 06       	cpc	r14, r25
      fe:	e9 06       	cpc	r14, r25
     100:	e9 06       	cpc	r14, r25
     102:	e7 06       	cpc	r14, r23
     104:	29 0c       	add	r2, r9
     106:	30 0c       	add	r3, r0
     108:	37 0c       	add	r3, r7
     10a:	3e 0c       	add	r3, r14
     10c:	45 0c       	add	r4, r5
     10e:	4c 0c       	add	r4, r12
     110:	53 0c       	add	r5, r3
     112:	5a 0c       	add	r5, r10
     114:	61 0c       	add	r6, r1
     116:	68 0c       	add	r6, r8

00000118 <__ctors_end>:
     118:	11 24       	eor	r1, r1
     11a:	1f be       	out	0x3f, r1	; 63
     11c:	cf e5       	ldi	r28, 0x5F	; 95
     11e:	d8 e0       	ldi	r29, 0x08	; 8
     120:	de bf       	out	0x3e, r29	; 62
     122:	cd bf       	out	0x3d, r28	; 61

00000124 <__do_copy_data>:
     124:	17 e0       	ldi	r17, 0x07	; 7
     126:	a0 e6       	ldi	r26, 0x60	; 96
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	e0 e8       	ldi	r30, 0x80	; 128
     12c:	f7 e3       	ldi	r31, 0x37	; 55
     12e:	02 c0       	rjmp	.+4      	; 0x134 <__do_copy_data+0x10>
     130:	05 90       	lpm	r0, Z+
     132:	0d 92       	st	X+, r0
     134:	a6 3a       	cpi	r26, 0xA6	; 166
     136:	b1 07       	cpc	r27, r17
     138:	d9 f7       	brne	.-10     	; 0x130 <__do_copy_data+0xc>

0000013a <__do_clear_bss>:
     13a:	28 e0       	ldi	r18, 0x08	; 8
     13c:	a6 ea       	ldi	r26, 0xA6	; 166
     13e:	b7 e0       	ldi	r27, 0x07	; 7
     140:	01 c0       	rjmp	.+2      	; 0x144 <.do_clear_bss_start>

00000142 <.do_clear_bss_loop>:
     142:	1d 92       	st	X+, r1

00000144 <.do_clear_bss_start>:
     144:	ac 35       	cpi	r26, 0x5C	; 92
     146:	b2 07       	cpc	r27, r18
     148:	e1 f7       	brne	.-8      	; 0x142 <.do_clear_bss_loop>
     14a:	0e 94 85 04 	call	0x90a	; 0x90a <main>
     14e:	0c 94 be 1b 	jmp	0x377c	; 0x377c <_exit>

00000152 <__bad_interrupt>:
     152:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000156 <App_init>:

#include "app.h"

 // Does all the initializations required in the app
void App_init(void) {
  Remote_init(9600);
     156:	60 e8       	ldi	r22, 0x80	; 128
     158:	75 e2       	ldi	r23, 0x25	; 37
     15a:	80 e0       	ldi	r24, 0x00	; 0
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	0e 94 1e 10 	call	0x203c	; 0x203c <Remote_init>
  Local_access_init();
     162:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <Local_access_init>
  Lamps_init();
     166:	0e 94 41 0b 	call	0x1682	; 0x1682 <Lamps_init>
  Door_init();
     16a:	0e 94 33 0b 	call	0x1666	; 0x1666 <Door_init>
  AC_auto_control_service_start();
     16e:	0e 94 10 14 	call	0x2820	; 0x2820 <AC_auto_control_service_start>
  Buzzer_init(BUZZER_PORT, BUZZER_PIN);
     172:	63 e0       	ldi	r22, 0x03	; 3
     174:	84 e4       	ldi	r24, 0x44	; 68
     176:	0e 94 cf 00 	call	0x19e	; 0x19e <Buzzer_init>
  sei();
     17a:	78 94       	sei

  // Uncomment and use only one time to initialize the DB
  // User_DB_format();

  run_system = true;
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	80 93 a9 07 	sts	0x07A9, r24	; 0x8007a9 <run_system>
     182:	08 95       	ret

00000184 <App_start>:
  }

// Contains all functionalities and top level logic of the app
void App_start(void) {
  while (run_system) {
     184:	02 c0       	rjmp	.+4      	; 0x18a <App_start+0x6>
    Local_control_input_handler();
     186:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <Local_control_input_handler>
  run_system = true;
  }

// Contains all functionalities and top level logic of the app
void App_start(void) {
  while (run_system) {
     18a:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <run_system>
     18e:	81 11       	cpse	r24, r1
     190:	fa cf       	rjmp	.-12     	; 0x186 <App_start+0x2>
    Local_control_input_handler();
    }
  cli();
     192:	f8 94       	cli
  // If the invalid attempts are exhausted, the program will halt.
  // The program can halt by returning  and letting it reach the end of main. Or by just entering another infinite loop.
    // Set the alarm
  Buzzer_on(BUZZER_PORT, BUZZER_PIN);
     194:	63 e0       	ldi	r22, 0x03	; 3
     196:	84 e4       	ldi	r24, 0x44	; 68
     198:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <Buzzer_on>
     19c:	ff cf       	rjmp	.-2      	; 0x19c <App_start+0x18>

0000019e <Buzzer_init>:
 */

#include "buzzer.h"

 // Initialize the buzzer
EN_BuzzerError_t Buzzer_init(u8 buzzerPort, u8 buzzerPin) {
     19e:	98 2f       	mov	r25, r24
     1a0:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(buzzerPin, buzzerPort, OUT) == DIO_OK) {
     1a2:	41 e0       	ldi	r20, 0x01	; 1
     1a4:	69 2f       	mov	r22, r25
     1a6:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
     1aa:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that the buzzer initialization failed
  return BUZZER_ERROR_INIT;
     1ac:	81 e0       	ldi	r24, 0x01	; 1
  }
     1ae:	08 95       	ret

000001b0 <Buzzer_on>:

// Turn on the buzzer
EN_BuzzerError_t Buzzer_on(u8 buzzerPort, u8 buzzerPin) {
     1b0:	98 2f       	mov	r25, r24
     1b2:	86 2f       	mov	r24, r22
  if (DIO_write(buzzerPin, buzzerPort, HIGH) == DIO_OK) {
     1b4:	41 e0       	ldi	r20, 0x01	; 1
     1b6:	69 2f       	mov	r22, r25
     1b8:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
     1bc:	81 11       	cpse	r24, r1
    return BUZZER_OK;
    }
  // Return error code to indicate that attempting to turn on the buzzer has failed
  return BUZZER_ERROR_ON;
     1be:	82 e0       	ldi	r24, 0x02	; 2
  }
     1c0:	08 95       	ret

000001c2 <EEPROM_init>:
 */

#include "eeprom.h"

void EEPROM_init() {
  I2C_init();
     1c2:	0e 94 ed 06 	call	0xdda	; 0xdda <I2C_init>
     1c6:	08 95       	ret

000001c8 <EEPROM_read_byte>:
  }

void EEPROM_read_byte(u8 page, u8 address, s8* data) {
     1c8:	0f 93       	push	r16
     1ca:	1f 93       	push	r17
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	c8 2f       	mov	r28, r24
     1d2:	d6 2f       	mov	r29, r22
     1d4:	8a 01       	movw	r16, r20
  I2C_start();
     1d6:	0e 94 f1 06 	call	0xde2	; 0xde2 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     1da:	cc 0f       	add	r28, r28
     1dc:	80 ea       	ldi	r24, 0xA0	; 160
     1de:	8c 0f       	add	r24, r28
     1e0:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  I2C_write(address);
     1e4:	8d 2f       	mov	r24, r29
     1e6:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  I2C_start();
     1ea:	0e 94 f1 06 	call	0xde2	; 0xde2 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     1ee:	81 ea       	ldi	r24, 0xA1	; 161
     1f0:	8c 0f       	add	r24, r28
     1f2:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  // read_Ack will halt the reading here, because it will send the next byte, which will not be received and wait for ack, which will not be sent. 
  // Nack must be sent after the arrival of the last requested byte. It's used basically to indicate that no further data transmission is required and then the stop condition is sent
  I2C_read_Nack(data);
     1f6:	c8 01       	movw	r24, r16
     1f8:	0e 94 0d 07 	call	0xe1a	; 0xe1a <I2C_read_Nack>
  I2C_stop();
     1fc:	0e 94 18 07 	call	0xe30	; 0xe30 <I2C_stop>
  }
     200:	df 91       	pop	r29
     202:	cf 91       	pop	r28
     204:	1f 91       	pop	r17
     206:	0f 91       	pop	r16
     208:	08 95       	ret

0000020a <EEPROM_read_block>:

void EEPROM_read_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     20a:	ef 92       	push	r14
     20c:	ff 92       	push	r15
     20e:	0f 93       	push	r16
     210:	1f 93       	push	r17
     212:	cf 93       	push	r28
     214:	df 93       	push	r29
     216:	c8 2f       	mov	r28, r24
     218:	d6 2f       	mov	r29, r22
     21a:	7a 01       	movw	r14, r20
     21c:	89 01       	movw	r16, r18
  u16 i;
  for (i = 0;i < bytes_number;i++) {
    EEPROM_read_byte(page, address + i, &data[i]);
    }
#elif READ_BLOCK_METHOD == MULTIBYTE
  I2C_start();
     21e:	0e 94 f1 06 	call	0xde2	; 0xde2 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     222:	cc 0f       	add	r28, r28
     224:	80 ea       	ldi	r24, 0xA0	; 160
     226:	8c 0f       	add	r24, r28
     228:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  I2C_write(address);
     22c:	8d 2f       	mov	r24, r29
     22e:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  I2C_start();
     232:	0e 94 f1 06 	call	0xde2	; 0xde2 <I2C_start>
  I2C_write(0xA0 + (page << 1) + 1);
     236:	81 ea       	ldi	r24, 0xA1	; 161
     238:	8c 0f       	add	r24, r28
     23a:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     23e:	c0 e0       	ldi	r28, 0x00	; 0
     240:	d0 e0       	ldi	r29, 0x00	; 0
     242:	06 c0       	rjmp	.+12     	; 0x250 <EEPROM_read_block+0x46>
    I2C_read_Ack(&data[i]);
     244:	c8 01       	movw	r24, r16
     246:	8c 0f       	add	r24, r28
     248:	9d 1f       	adc	r25, r29
     24a:	0e 94 02 07 	call	0xe04	; 0xe04 <I2C_read_Ack>
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  I2C_start();
  I2C_write(0xA0 + (page << 1) + 1);
  u16 i;
  for (i = 0;i < bytes_number - 1;i++) {
     24e:	21 96       	adiw	r28, 0x01	; 1
     250:	c7 01       	movw	r24, r14
     252:	01 97       	sbiw	r24, 0x01	; 1
     254:	c8 17       	cp	r28, r24
     256:	d9 07       	cpc	r29, r25
     258:	a8 f3       	brcs	.-22     	; 0x244 <EEPROM_read_block+0x3a>
    I2C_read_Ack(&data[i]);
    }
  I2C_read_Nack(&data[i]);
     25a:	c8 01       	movw	r24, r16
     25c:	8c 0f       	add	r24, r28
     25e:	9d 1f       	adc	r25, r29
     260:	0e 94 0d 07 	call	0xe1a	; 0xe1a <I2C_read_Nack>
  I2C_stop();
     264:	0e 94 18 07 	call	0xe30	; 0xe30 <I2C_stop>
#endif
  }
     268:	df 91       	pop	r29
     26a:	cf 91       	pop	r28
     26c:	1f 91       	pop	r17
     26e:	0f 91       	pop	r16
     270:	ff 90       	pop	r15
     272:	ef 90       	pop	r14
     274:	08 95       	ret

00000276 <EEPROM_write_byte>:

void EEPROM_write_byte(u8 page, u8 address, s8 data) {
     276:	1f 93       	push	r17
     278:	cf 93       	push	r28
     27a:	df 93       	push	r29
     27c:	c8 2f       	mov	r28, r24
     27e:	16 2f       	mov	r17, r22
     280:	d4 2f       	mov	r29, r20
  I2C_start();
     282:	0e 94 f1 06 	call	0xde2	; 0xde2 <I2C_start>
  // I2C_write(0b10100000 + (page << 1));
  I2C_write(0xA0 + (page << 1)); // EEPROM address first part + page number
     286:	8c 2f       	mov	r24, r28
     288:	88 0f       	add	r24, r24
     28a:	80 56       	subi	r24, 0x60	; 96
     28c:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  I2C_write(address);
     290:	81 2f       	mov	r24, r17
     292:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  I2C_write(data);
     296:	8d 2f       	mov	r24, r29
     298:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  I2C_stop();
     29c:	0e 94 18 07 	call	0xe30	; 0xe30 <I2C_stop>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     2a0:	8f e3       	ldi	r24, 0x3F	; 63
     2a2:	9c e9       	ldi	r25, 0x9C	; 156
     2a4:	01 97       	sbiw	r24, 0x01	; 1
     2a6:	f1 f7       	brne	.-4      	; 0x2a4 <EEPROM_write_byte+0x2e>
     2a8:	00 c0       	rjmp	.+0      	; 0x2aa <EEPROM_write_byte+0x34>
     2aa:	00 00       	nop

#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
  }
     2ac:	df 91       	pop	r29
     2ae:	cf 91       	pop	r28
     2b0:	1f 91       	pop	r17
     2b2:	08 95       	ret

000002b4 <EEPROM_write_block>:

// bytes_number must be within page size (256 bytes)
void EEPROM_write_block(u8 page, u8 address, u16 bytes_number, s8* data) {
     2b4:	6f 92       	push	r6
     2b6:	7f 92       	push	r7
     2b8:	8f 92       	push	r8
     2ba:	9f 92       	push	r9
     2bc:	af 92       	push	r10
     2be:	bf 92       	push	r11
     2c0:	cf 92       	push	r12
     2c2:	df 92       	push	r13
     2c4:	ef 92       	push	r14
     2c6:	ff 92       	push	r15
     2c8:	0f 93       	push	r16
     2ca:	1f 93       	push	r17
     2cc:	cf 93       	push	r28
     2ce:	df 93       	push	r29
     2d0:	78 2e       	mov	r7, r24
     2d2:	66 2e       	mov	r6, r22
     2d4:	6a 01       	movw	r12, r20
     2d6:	89 01       	movw	r16, r18
  //! If data is required to be written in the first 16 bytes starting from byte 10 for example, the data will be stored starting from bytes 10, 
  //! and if the data exceeds the row limit ** IT WILL ROLL OVER AND OVERWRITE THE ROW **. Therefore, in a single multibyte write cycle, we can't write more than 16 bytes at maximum if starting from the first byte in the row
  //! or the remaining bytes till the end of the row from the starting position. The remaining bytes must be written in another write cycle to avoind the roll over problem.

  u16 dataIndex, blockNumber, i;
  u16 first_block_size = 16 - (address % 16);
     2d8:	86 2f       	mov	r24, r22
     2da:	8f 70       	andi	r24, 0x0F	; 15
     2dc:	20 e1       	ldi	r18, 0x10	; 16
     2de:	30 e0       	ldi	r19, 0x00	; 0
     2e0:	79 01       	movw	r14, r18
     2e2:	e8 1a       	sub	r14, r24
     2e4:	f1 08       	sbc	r15, r1
  if (16 - (address % 16) > bytes_number) first_block_size = bytes_number;
     2e6:	4e 15       	cp	r20, r14
     2e8:	5f 05       	cpc	r21, r15
     2ea:	08 f4       	brcc	.+2      	; 0x2ee <EEPROM_write_block+0x3a>
     2ec:	7a 01       	movw	r14, r20

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
     2ee:	0e 94 f1 06 	call	0xde2	; 0xde2 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     2f2:	87 2d       	mov	r24, r7
     2f4:	88 0f       	add	r24, r24
     2f6:	0f 2e       	mov	r0, r31
     2f8:	f0 ea       	ldi	r31, 0xA0	; 160
     2fa:	7f 2e       	mov	r7, r31
     2fc:	f0 2d       	mov	r31, r0
     2fe:	78 0e       	add	r7, r24
     300:	87 2d       	mov	r24, r7
     302:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  I2C_write(address);
     306:	86 2d       	mov	r24, r6
     308:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     30c:	c0 e0       	ldi	r28, 0x00	; 0
     30e:	d0 e0       	ldi	r29, 0x00	; 0
     310:	07 c0       	rjmp	.+14     	; 0x320 <EEPROM_write_block+0x6c>
    I2C_write(data[dataIndex]);
     312:	f8 01       	movw	r30, r16
     314:	ec 0f       	add	r30, r28
     316:	fd 1f       	adc	r31, r29
     318:	80 81       	ld	r24, Z
     31a:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>

  // Write the first part of the data in the remaining space in the starting row
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address);
  for (dataIndex = 0;dataIndex < first_block_size;dataIndex++) {
     31e:	21 96       	adiw	r28, 0x01	; 1
     320:	ce 15       	cp	r28, r14
     322:	df 05       	cpc	r29, r15
     324:	b0 f3       	brcs	.-20     	; 0x312 <EEPROM_write_block+0x5e>
    I2C_write(data[dataIndex]);
    }
  I2C_stop();
     326:	0e 94 18 07 	call	0xe30	; 0xe30 <I2C_stop>
     32a:	8f e3       	ldi	r24, 0x3F	; 63
     32c:	9c e9       	ldi	r25, 0x9C	; 156
     32e:	01 97       	sbiw	r24, 0x01	; 1
     330:	f1 f7       	brne	.-4      	; 0x32e <EEPROM_write_block+0x7a>
     332:	00 c0       	rjmp	.+0      	; 0x334 <EEPROM_write_block+0x80>
     334:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif

  // Return if the data fits in the row (data fits in a single row or the remaining part of it after the address)
  if (first_block_size == bytes_number) return;
     336:	ec 14       	cp	r14, r12
     338:	fd 04       	cpc	r15, r13
     33a:	09 f4       	brne	.+2      	; 0x33e <EEPROM_write_block+0x8a>
     33c:	61 c0       	rjmp	.+194    	; 0x400 <__EEPROM_REGION_LENGTH__>

  u16 last_block_size = (address + bytes_number) % 16;
     33e:	56 01       	movw	r10, r12
     340:	a6 0c       	add	r10, r6
     342:	b1 1c       	adc	r11, r1
     344:	9f e0       	ldi	r25, 0x0F	; 15
     346:	a9 22       	and	r10, r25
     348:	bb 24       	eor	r11, r11
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
     34a:	ce 18       	sub	r12, r14
     34c:	df 08       	sbc	r13, r15
     34e:	ca 18       	sub	r12, r10
     350:	db 08       	sbc	r13, r11
     352:	d6 94       	lsr	r13
     354:	c7 94       	ror	r12
     356:	d6 94       	lsr	r13
     358:	c7 94       	ror	r12
     35a:	d6 94       	lsr	r13
     35c:	c7 94       	ror	r12
     35e:	d6 94       	lsr	r13
     360:	c7 94       	ror	r12
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     362:	e1 2c       	mov	r14, r1
     364:	f1 2c       	mov	r15, r1
     366:	27 c0       	rjmp	.+78     	; 0x3b6 <EEPROM_write_block+0x102>
    I2C_start();
     368:	0e 94 f1 06 	call	0xde2	; 0xde2 <I2C_start>
    I2C_write(0xA0 + (page << 1));
     36c:	87 2d       	mov	r24, r7
     36e:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
    I2C_write(address + dataIndex);
     372:	8c 2f       	mov	r24, r28
     374:	86 0d       	add	r24, r6
     376:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
    for (i = 0;i < 16;i++) {
     37a:	81 2c       	mov	r8, r1
     37c:	91 2c       	mov	r9, r1
     37e:	0b c0       	rjmp	.+22     	; 0x396 <EEPROM_write_block+0xe2>
      I2C_write(data[dataIndex + i]);
     380:	fe 01       	movw	r30, r28
     382:	e8 0d       	add	r30, r8
     384:	f9 1d       	adc	r31, r9
     386:	e0 0f       	add	r30, r16
     388:	f1 1f       	adc	r31, r17
     38a:	80 81       	ld	r24, Z
     38c:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
    I2C_start();
    I2C_write(0xA0 + (page << 1));
    I2C_write(address + dataIndex);
    for (i = 0;i < 16;i++) {
     390:	8f ef       	ldi	r24, 0xFF	; 255
     392:	88 1a       	sub	r8, r24
     394:	98 0a       	sbc	r9, r24
     396:	90 e1       	ldi	r25, 0x10	; 16
     398:	89 16       	cp	r8, r25
     39a:	91 04       	cpc	r9, r1
     39c:	88 f3       	brcs	.-30     	; 0x380 <EEPROM_write_block+0xcc>
      I2C_write(data[dataIndex + i]);
      }
    dataIndex += 16;
     39e:	60 96       	adiw	r28, 0x10	; 16
    I2C_stop();
     3a0:	0e 94 18 07 	call	0xe30	; 0xe30 <I2C_stop>
     3a4:	8f e3       	ldi	r24, 0x3F	; 63
     3a6:	9c e9       	ldi	r25, 0x9C	; 156
     3a8:	01 97       	sbiw	r24, 0x01	; 1
     3aa:	f1 f7       	brne	.-4      	; 0x3a8 <EEPROM_write_block+0xf4>
     3ac:	00 c0       	rjmp	.+0      	; 0x3ae <EEPROM_write_block+0xfa>
     3ae:	00 00       	nop
  if (first_block_size == bytes_number) return;

  u16 last_block_size = (address + bytes_number) % 16;
  u16 blocks_number = (bytes_number - first_block_size - last_block_size) / 16;
  // Write the remaining whole rows if any
  for (blockNumber = 0;blockNumber < blocks_number;blockNumber++) {
     3b0:	9f ef       	ldi	r25, 0xFF	; 255
     3b2:	e9 1a       	sub	r14, r25
     3b4:	f9 0a       	sbc	r15, r25
     3b6:	ec 14       	cp	r14, r12
     3b8:	fd 04       	cpc	r15, r13
     3ba:	b0 f2       	brcs	.-84     	; 0x368 <EEPROM_write_block+0xb4>
    _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
    }

  // Write the last part of the data
  I2C_start();
     3bc:	0e 94 f1 06 	call	0xde2	; 0xde2 <I2C_start>
  I2C_write(0xA0 + (page << 1));
     3c0:	87 2d       	mov	r24, r7
     3c2:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  I2C_write(address + dataIndex);
     3c6:	8c 2f       	mov	r24, r28
     3c8:	86 0d       	add	r24, r6
     3ca:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>
  for (i = 0;i < last_block_size;i++) {
     3ce:	e1 2c       	mov	r14, r1
     3d0:	f1 2c       	mov	r15, r1
     3d2:	0b c0       	rjmp	.+22     	; 0x3ea <EEPROM_write_block+0x136>
    I2C_write(data[dataIndex + i]);
     3d4:	fe 01       	movw	r30, r28
     3d6:	ee 0d       	add	r30, r14
     3d8:	ff 1d       	adc	r31, r15
     3da:	e0 0f       	add	r30, r16
     3dc:	f1 1f       	adc	r31, r17
     3de:	80 81       	ld	r24, Z
     3e0:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <I2C_write>

  // Write the last part of the data
  I2C_start();
  I2C_write(0xA0 + (page << 1));
  I2C_write(address + dataIndex);
  for (i = 0;i < last_block_size;i++) {
     3e4:	8f ef       	ldi	r24, 0xFF	; 255
     3e6:	e8 1a       	sub	r14, r24
     3e8:	f8 0a       	sbc	r15, r24
     3ea:	ea 14       	cp	r14, r10
     3ec:	fb 04       	cpc	r15, r11
     3ee:	90 f3       	brcs	.-28     	; 0x3d4 <EEPROM_write_block+0x120>
    I2C_write(data[dataIndex + i]);
    }
  I2C_stop();
     3f0:	0e 94 18 07 	call	0xe30	; 0xe30 <I2C_stop>
     3f4:	8f e3       	ldi	r24, 0x3F	; 63
     3f6:	9c e9       	ldi	r25, 0x9C	; 156
     3f8:	01 97       	sbiw	r24, 0x01	; 1
     3fa:	f1 f7       	brne	.-4      	; 0x3f8 <EEPROM_write_block+0x144>
     3fc:	00 c0       	rjmp	.+0      	; 0x3fe <EEPROM_write_block+0x14a>
     3fe:	00 00       	nop
#if EEPROM_WRITE_DELAY_MS
  _delay_ms(EEPROM_WRITE_DELAY_MS);
#endif
#endif
     400:	df 91       	pop	r29
     402:	cf 91       	pop	r28
     404:	1f 91       	pop	r17
     406:	0f 91       	pop	r16
     408:	ff 90       	pop	r15
     40a:	ef 90       	pop	r14
     40c:	df 90       	pop	r13
     40e:	cf 90       	pop	r12
     410:	bf 90       	pop	r11
     412:	af 90       	pop	r10
     414:	9f 90       	pop	r9
     416:	8f 90       	pop	r8
     418:	7f 90       	pop	r7
     41a:	6f 90       	pop	r6
     41c:	08 95       	ret

0000041e <BT_init>:
 *  Author: Hesham Hany
 */

#include "hc_05.h"

void BT_init(u32 baudRate) {
     41e:	cf 92       	push	r12
     420:	df 92       	push	r13
     422:	ef 92       	push	r14
     424:	ff 92       	push	r15
     426:	6b 01       	movw	r12, r22
     428:	7c 01       	movw	r14, r24
  DIO_init(HC_05_STATUS_PIN, HC_05_STATUS_PORT, IN);
     42a:	40 e0       	ldi	r20, 0x00	; 0
     42c:	64 e4       	ldi	r22, 0x44	; 68
     42e:	82 e0       	ldi	r24, 0x02	; 2
     430:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  UART_init(baudRate);
     434:	c7 01       	movw	r24, r14
     436:	b6 01       	movw	r22, r12
     438:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <UART_init>
  }
     43c:	ff 90       	pop	r15
     43e:	ef 90       	pop	r14
     440:	df 90       	pop	r13
     442:	cf 90       	pop	r12
     444:	08 95       	ret

00000446 <BT_sendChar>:

void BT_sendChar(s8 data) {
  UART_sendChar(data);
     446:	0e 94 0c 0b 	call	0x1618	; 0x1618 <UART_sendChar>
     44a:	08 95       	ret

0000044c <BT_sendString>:
  }

void BT_sendString(s8* str) {
  UART_sendString(str);
     44c:	0e 94 12 0b 	call	0x1624	; 0x1624 <UART_sendString>
     450:	08 95       	ret

00000452 <Keypad_init>:

#include "keypad.h"

EN_KeypadStatusCode_t Keypad_init(void) {
  // Set rows as outputs
  DIO_init(KEYPAD_R0_PIN, KEYPAD_PORT, OUT);
     452:	41 e0       	ldi	r20, 0x01	; 1
     454:	62 e4       	ldi	r22, 0x42	; 66
     456:	80 e0       	ldi	r24, 0x00	; 0
     458:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  DIO_init(KEYPAD_R1_PIN, KEYPAD_PORT, OUT);
     45c:	41 e0       	ldi	r20, 0x01	; 1
     45e:	62 e4       	ldi	r22, 0x42	; 66
     460:	81 e0       	ldi	r24, 0x01	; 1
     462:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  DIO_init(KEYPAD_R2_PIN, KEYPAD_PORT, OUT);
     466:	41 e0       	ldi	r20, 0x01	; 1
     468:	62 e4       	ldi	r22, 0x42	; 66
     46a:	82 e0       	ldi	r24, 0x02	; 2
     46c:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  DIO_init(KEYPAD_R3_PIN, KEYPAD_PORT, OUT);
     470:	41 e0       	ldi	r20, 0x01	; 1
     472:	62 e4       	ldi	r22, 0x42	; 66
     474:	83 e0       	ldi	r24, 0x03	; 3
     476:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  // Set all high
  DIO_write(KEYPAD_R0_PIN, KEYPAD_PORT, HIGH);
     47a:	41 e0       	ldi	r20, 0x01	; 1
     47c:	62 e4       	ldi	r22, 0x42	; 66
     47e:	80 e0       	ldi	r24, 0x00	; 0
     480:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  DIO_write(KEYPAD_R1_PIN, KEYPAD_PORT, HIGH);
     484:	41 e0       	ldi	r20, 0x01	; 1
     486:	62 e4       	ldi	r22, 0x42	; 66
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  DIO_write(KEYPAD_R2_PIN, KEYPAD_PORT, HIGH);
     48e:	41 e0       	ldi	r20, 0x01	; 1
     490:	62 e4       	ldi	r22, 0x42	; 66
     492:	82 e0       	ldi	r24, 0x02	; 2
     494:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  DIO_write(KEYPAD_R3_PIN, KEYPAD_PORT, HIGH);
     498:	41 e0       	ldi	r20, 0x01	; 1
     49a:	62 e4       	ldi	r22, 0x42	; 66
     49c:	83 e0       	ldi	r24, 0x03	; 3
     49e:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  // Set columns as inputs
  DIO_init(KEYPAD_C0_PIN, KEYPAD_PORT, IN);
     4a2:	40 e0       	ldi	r20, 0x00	; 0
     4a4:	62 e4       	ldi	r22, 0x42	; 66
     4a6:	84 e0       	ldi	r24, 0x04	; 4
     4a8:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  DIO_init(KEYPAD_C1_PIN, KEYPAD_PORT, IN);
     4ac:	40 e0       	ldi	r20, 0x00	; 0
     4ae:	62 e4       	ldi	r22, 0x42	; 66
     4b0:	85 e0       	ldi	r24, 0x05	; 5
     4b2:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  DIO_init(KEYPAD_C2_PIN, KEYPAD_PORT, IN);
     4b6:	40 e0       	ldi	r20, 0x00	; 0
     4b8:	62 e4       	ldi	r22, 0x42	; 66
     4ba:	86 e0       	ldi	r24, 0x06	; 6
     4bc:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  DIO_init(KEYPAD_C3_PIN, KEYPAD_PORT, IN);
     4c0:	40 e0       	ldi	r20, 0x00	; 0
     4c2:	62 e4       	ldi	r22, 0x42	; 66
     4c4:	87 e0       	ldi	r24, 0x07	; 7
     4c6:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  // Activate the pull up resistors
  DIO_write(KEYPAD_C0_PIN, KEYPAD_PORT, HIGH);
     4ca:	41 e0       	ldi	r20, 0x01	; 1
     4cc:	62 e4       	ldi	r22, 0x42	; 66
     4ce:	84 e0       	ldi	r24, 0x04	; 4
     4d0:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  DIO_write(KEYPAD_C1_PIN, KEYPAD_PORT, HIGH);
     4d4:	41 e0       	ldi	r20, 0x01	; 1
     4d6:	62 e4       	ldi	r22, 0x42	; 66
     4d8:	85 e0       	ldi	r24, 0x05	; 5
     4da:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  DIO_write(KEYPAD_C2_PIN, KEYPAD_PORT, HIGH);
     4de:	41 e0       	ldi	r20, 0x01	; 1
     4e0:	62 e4       	ldi	r22, 0x42	; 66
     4e2:	86 e0       	ldi	r24, 0x06	; 6
     4e4:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  DIO_write(KEYPAD_C3_PIN, KEYPAD_PORT, HIGH);
     4e8:	41 e0       	ldi	r20, 0x01	; 1
     4ea:	62 e4       	ldi	r22, 0x42	; 66
     4ec:	87 e0       	ldi	r24, 0x07	; 7
     4ee:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>

  return KEYPAD_INIT_OK;
  }
     4f2:	80 e0       	ldi	r24, 0x00	; 0
     4f4:	08 95       	ret

000004f6 <toggle_row>:

void toggle_row(u8 row) {
  switch (row) {
     4f6:	81 30       	cpi	r24, 0x01	; 1
     4f8:	59 f0       	breq	.+22     	; 0x510 <toggle_row+0x1a>
     4fa:	28 f0       	brcs	.+10     	; 0x506 <toggle_row+0x10>
     4fc:	82 30       	cpi	r24, 0x02	; 2
     4fe:	69 f0       	breq	.+26     	; 0x51a <toggle_row+0x24>
     500:	83 30       	cpi	r24, 0x03	; 3
     502:	81 f0       	breq	.+32     	; 0x524 <toggle_row+0x2e>
     504:	08 95       	ret
      case 0:
        DIO_toggle(KEYPAD_R0_PIN, KEYPAD_PORT);
     506:	62 e4       	ldi	r22, 0x42	; 66
     508:	80 e0       	ldi	r24, 0x00	; 0
     50a:	0e 94 76 06 	call	0xcec	; 0xcec <DIO_toggle>
        break;
     50e:	08 95       	ret
      case 1:
        DIO_toggle(KEYPAD_R1_PIN, KEYPAD_PORT);
     510:	62 e4       	ldi	r22, 0x42	; 66
     512:	81 e0       	ldi	r24, 0x01	; 1
     514:	0e 94 76 06 	call	0xcec	; 0xcec <DIO_toggle>
        break;
     518:	08 95       	ret
      case 2:
        DIO_toggle(KEYPAD_R2_PIN, KEYPAD_PORT);
     51a:	62 e4       	ldi	r22, 0x42	; 66
     51c:	82 e0       	ldi	r24, 0x02	; 2
     51e:	0e 94 76 06 	call	0xcec	; 0xcec <DIO_toggle>
        break;
     522:	08 95       	ret
      case 3:
        DIO_toggle(KEYPAD_R3_PIN, KEYPAD_PORT);
     524:	62 e4       	ldi	r22, 0x42	; 66
     526:	83 e0       	ldi	r24, 0x03	; 3
     528:	0e 94 76 06 	call	0xcec	; 0xcec <DIO_toggle>
     52c:	08 95       	ret

0000052e <check_col>:
        break;
    }
  }

void check_col(u8 col, u8* res) {
  switch (col) {
     52e:	81 30       	cpi	r24, 0x01	; 1
     530:	61 f0       	breq	.+24     	; 0x54a <check_col+0x1c>
     532:	28 f0       	brcs	.+10     	; 0x53e <check_col+0x10>
     534:	82 30       	cpi	r24, 0x02	; 2
     536:	79 f0       	breq	.+30     	; 0x556 <check_col+0x28>
     538:	83 30       	cpi	r24, 0x03	; 3
     53a:	99 f0       	breq	.+38     	; 0x562 <check_col+0x34>
     53c:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_C0_PIN, KEYPAD_PORT, res);
     53e:	ab 01       	movw	r20, r22
     540:	62 e4       	ldi	r22, 0x42	; 66
     542:	84 e0       	ldi	r24, 0x04	; 4
     544:	0e 94 20 06 	call	0xc40	; 0xc40 <DIO_Read>
        break;
     548:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_C1_PIN, KEYPAD_PORT, res);
     54a:	ab 01       	movw	r20, r22
     54c:	62 e4       	ldi	r22, 0x42	; 66
     54e:	85 e0       	ldi	r24, 0x05	; 5
     550:	0e 94 20 06 	call	0xc40	; 0xc40 <DIO_Read>
        break;
     554:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_C2_PIN, KEYPAD_PORT, res);
     556:	ab 01       	movw	r20, r22
     558:	62 e4       	ldi	r22, 0x42	; 66
     55a:	86 e0       	ldi	r24, 0x06	; 6
     55c:	0e 94 20 06 	call	0xc40	; 0xc40 <DIO_Read>
        break;
     560:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_C3_PIN, KEYPAD_PORT, res);
     562:	ab 01       	movw	r20, r22
     564:	62 e4       	ldi	r22, 0x42	; 66
     566:	87 e0       	ldi	r24, 0x07	; 7
     568:	0e 94 20 06 	call	0xc40	; 0xc40 <DIO_Read>
     56c:	08 95       	ret

0000056e <check_row>:
        break;
    }
  }

void check_row(u8 row, u8* res) {
  switch (row) {
     56e:	81 30       	cpi	r24, 0x01	; 1
     570:	61 f0       	breq	.+24     	; 0x58a <check_row+0x1c>
     572:	28 f0       	brcs	.+10     	; 0x57e <check_row+0x10>
     574:	82 30       	cpi	r24, 0x02	; 2
     576:	79 f0       	breq	.+30     	; 0x596 <check_row+0x28>
     578:	83 30       	cpi	r24, 0x03	; 3
     57a:	99 f0       	breq	.+38     	; 0x5a2 <check_row+0x34>
     57c:	08 95       	ret
      case 0:
        DIO_Read(KEYPAD_R0_PIN, KEYPAD_PORT, res);
     57e:	ab 01       	movw	r20, r22
     580:	62 e4       	ldi	r22, 0x42	; 66
     582:	80 e0       	ldi	r24, 0x00	; 0
     584:	0e 94 20 06 	call	0xc40	; 0xc40 <DIO_Read>
        break;
     588:	08 95       	ret
      case 1:
        DIO_Read(KEYPAD_R1_PIN, KEYPAD_PORT, res);
     58a:	ab 01       	movw	r20, r22
     58c:	62 e4       	ldi	r22, 0x42	; 66
     58e:	81 e0       	ldi	r24, 0x01	; 1
     590:	0e 94 20 06 	call	0xc40	; 0xc40 <DIO_Read>
        break;
     594:	08 95       	ret
      case 2:
        DIO_Read(KEYPAD_R2_PIN, KEYPAD_PORT, res);
     596:	ab 01       	movw	r20, r22
     598:	62 e4       	ldi	r22, 0x42	; 66
     59a:	82 e0       	ldi	r24, 0x02	; 2
     59c:	0e 94 20 06 	call	0xc40	; 0xc40 <DIO_Read>
        break;
     5a0:	08 95       	ret
      case 3:
        DIO_Read(KEYPAD_R3_PIN, KEYPAD_PORT, res);
     5a2:	ab 01       	movw	r20, r22
     5a4:	62 e4       	ldi	r22, 0x42	; 66
     5a6:	83 e0       	ldi	r24, 0x03	; 3
     5a8:	0e 94 20 06 	call	0xc40	; 0xc40 <DIO_Read>
     5ac:	08 95       	ret

000005ae <Keypad_getPressedKey>:
        break;
    }
  }

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
     5ae:	ef 92       	push	r14
     5b0:	ff 92       	push	r15
     5b2:	0f 93       	push	r16
     5b4:	1f 93       	push	r17
     5b6:	cf 93       	push	r28
     5b8:	df 93       	push	r29
     5ba:	cd b7       	in	r28, 0x3d	; 61
     5bc:	de b7       	in	r29, 0x3e	; 62
     5be:	62 97       	sbiw	r28, 0x12	; 18
     5c0:	0f b6       	in	r0, 0x3f	; 63
     5c2:	f8 94       	cli
     5c4:	de bf       	out	0x3e, r29	; 62
     5c6:	0f be       	out	0x3f, r0	; 63
     5c8:	cd bf       	out	0x3d, r28	; 61
     5ca:	7c 01       	movw	r14, r24
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
     5cc:	80 e1       	ldi	r24, 0x10	; 16
     5ce:	e0 e6       	ldi	r30, 0x60	; 96
     5d0:	f0 e0       	ldi	r31, 0x00	; 0
     5d2:	de 01       	movw	r26, r28
     5d4:	11 96       	adiw	r26, 0x01	; 1
     5d6:	01 90       	ld	r0, Z+
     5d8:	0d 92       	st	X+, r0
     5da:	8a 95       	dec	r24
     5dc:	e1 f7       	brne	.-8      	; 0x5d6 <Keypad_getPressedKey+0x28>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     5de:	00 e0       	ldi	r16, 0x00	; 0
     5e0:	1c c0       	rjmp	.+56     	; 0x61a <Keypad_getPressedKey+0x6c>
    check_row(row, &row_state);
     5e2:	be 01       	movw	r22, r28
     5e4:	6e 5e       	subi	r22, 0xEE	; 238
     5e6:	7f 4f       	sbci	r23, 0xFF	; 255
     5e8:	80 2f       	mov	r24, r16
     5ea:	0e 94 b7 02 	call	0x56e	; 0x56e <check_row>
    if (row_state == LOW) {
     5ee:	8a 89       	ldd	r24, Y+18	; 0x12
     5f0:	88 23       	and	r24, r24
     5f2:	61 f0       	breq	.+24     	; 0x60c <Keypad_getPressedKey+0x5e>
     5f4:	11 c0       	rjmp	.+34     	; 0x618 <Keypad_getPressedKey+0x6a>
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
     5f6:	be 01       	movw	r22, r28
     5f8:	6f 5e       	subi	r22, 0xEF	; 239
     5fa:	7f 4f       	sbci	r23, 0xFF	; 255
     5fc:	81 2f       	mov	r24, r17
     5fe:	0e 94 97 02 	call	0x52e	; 0x52e <check_col>
        if (col_state == LOW) {
     602:	89 89       	ldd	r24, Y+17	; 0x11
     604:	88 23       	and	r24, r24
     606:	c9 f1       	breq	.+114    	; 0x67a <Keypad_getPressedKey+0xcc>
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
     608:	1f 5f       	subi	r17, 0xFF	; 255
     60a:	01 c0       	rjmp	.+2      	; 0x60e <Keypad_getPressedKey+0x60>
     60c:	10 e0       	ldi	r17, 0x00	; 0
     60e:	14 30       	cpi	r17, 0x04	; 4
     610:	90 f3       	brcs	.-28     	; 0x5f6 <Keypad_getPressedKey+0x48>
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
          }
        }
      toggle_row(row);
     612:	80 2f       	mov	r24, r16
     614:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <toggle_row>

EN_KeypadStatusCode_t Keypad_getPressedKey(u8* key) {
  u8 keys[KEYPAD_ROW_NUM][KEYPAD_COL_NUM] = KEYPAD_BUTTON_VALUES;
  u8 row, col, col_state, row_state;
  // Check if the key has been depressed. If not return no presses.
  for (row = 0;row < KEYPAD_ROW_NUM; row++) {
     618:	0f 5f       	subi	r16, 0xFF	; 255
     61a:	04 30       	cpi	r16, 0x04	; 4
     61c:	10 f3       	brcs	.-60     	; 0x5e2 <Keypad_getPressedKey+0x34>
     61e:	00 e0       	ldi	r16, 0x00	; 0
     620:	28 c0       	rjmp	.+80     	; 0x672 <Keypad_getPressedKey+0xc4>
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
     622:	80 2f       	mov	r24, r16
     624:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <toggle_row>
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     628:	10 e0       	ldi	r17, 0x00	; 0
     62a:	1d c0       	rjmp	.+58     	; 0x666 <Keypad_getPressedKey+0xb8>
      check_col(col, &col_state);
     62c:	be 01       	movw	r22, r28
     62e:	6f 5e       	subi	r22, 0xEF	; 239
     630:	7f 4f       	sbci	r23, 0xFF	; 255
     632:	81 2f       	mov	r24, r17
     634:	0e 94 97 02 	call	0x52e	; 0x52e <check_col>
      if (col_state == LOW) {
     638:	89 89       	ldd	r24, Y+17	; 0x11
     63a:	81 11       	cpse	r24, r1
     63c:	13 c0       	rjmp	.+38     	; 0x664 <Keypad_getPressedKey+0xb6>
        // while (col_state == LOW) {  // Wait until the key is released (busy waiting - halts the system)
        //   check_col(col, &col_state);
        //   }
        *key = keys[row][col];
     63e:	e0 2f       	mov	r30, r16
     640:	f0 e0       	ldi	r31, 0x00	; 0
     642:	ee 0f       	add	r30, r30
     644:	ff 1f       	adc	r31, r31
     646:	ee 0f       	add	r30, r30
     648:	ff 1f       	adc	r31, r31
     64a:	81 e0       	ldi	r24, 0x01	; 1
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	8c 0f       	add	r24, r28
     650:	9d 1f       	adc	r25, r29
     652:	e8 0f       	add	r30, r24
     654:	f9 1f       	adc	r31, r25
     656:	e1 0f       	add	r30, r17
     658:	f1 1d       	adc	r31, r1
     65a:	80 81       	ld	r24, Z
     65c:	f7 01       	movw	r30, r14
     65e:	80 83       	st	Z, r24
        return KEY_PRESSED;
     660:	81 e0       	ldi	r24, 0x01	; 1
     662:	0c c0       	rjmp	.+24     	; 0x67c <Keypad_getPressedKey+0xce>
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
    toggle_row(row);
    for (col = 0; col < KEYPAD_COL_NUM; col++) {
     664:	1f 5f       	subi	r17, 0xFF	; 255
     666:	14 30       	cpi	r17, 0x04	; 4
     668:	08 f3       	brcs	.-62     	; 0x62c <Keypad_getPressedKey+0x7e>
        //   }
        *key = keys[row][col];
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
     66a:	80 2f       	mov	r24, r16
     66c:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <toggle_row>
          }
        }
      toggle_row(row);
      }
    }
  for (row = 0; row < KEYPAD_ROW_NUM; row++) {
     670:	0f 5f       	subi	r16, 0xFF	; 255
     672:	04 30       	cpi	r16, 0x04	; 4
     674:	b0 f2       	brcs	.-84     	; 0x622 <Keypad_getPressedKey+0x74>
        return KEY_PRESSED;
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     676:	82 e0       	ldi	r24, 0x02	; 2
     678:	01 c0       	rjmp	.+2      	; 0x67c <Keypad_getPressedKey+0xce>
    check_row(row, &row_state);
    if (row_state == LOW) {
      for (col = 0; col < KEYPAD_COL_NUM; col++) {
        check_col(col, &col_state);
        if (col_state == LOW) {
          return NO_KEY_PRESSED;
     67a:	82 e0       	ldi	r24, 0x02	; 2
        }
      }
    toggle_row(row);
    }
  return NO_KEY_PRESSED;
     67c:	62 96       	adiw	r28, 0x12	; 18
     67e:	0f b6       	in	r0, 0x3f	; 63
     680:	f8 94       	cli
     682:	de bf       	out	0x3e, r29	; 62
     684:	0f be       	out	0x3f, r0	; 63
     686:	cd bf       	out	0x3d, r28	; 61
     688:	df 91       	pop	r29
     68a:	cf 91       	pop	r28
     68c:	1f 91       	pop	r17
     68e:	0f 91       	pop	r16
     690:	ff 90       	pop	r15
     692:	ef 90       	pop	r14
     694:	08 95       	ret

00000696 <LCD_sendEnablePulse>:
#include "lcd.h"

 // TODO: implement the eight bit mode

void LCD_sendEnablePulse(void) {
  DIO_write(EN, LCD_CTRL_PORT, HIGH);
     696:	41 e0       	ldi	r20, 0x01	; 1
     698:	61 e4       	ldi	r22, 0x41	; 65
     69a:	86 e0       	ldi	r24, 0x06	; 6
     69c:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6a0:	8a e1       	ldi	r24, 0x1A	; 26
     6a2:	8a 95       	dec	r24
     6a4:	f1 f7       	brne	.-4      	; 0x6a2 <LCD_sendEnablePulse+0xc>
     6a6:	00 c0       	rjmp	.+0      	; 0x6a8 <LCD_sendEnablePulse+0x12>
  _delay_us(5);
  DIO_write(EN, LCD_CTRL_PORT, LOW);
     6a8:	40 e0       	ldi	r20, 0x00	; 0
     6aa:	61 e4       	ldi	r22, 0x41	; 65
     6ac:	86 e0       	ldi	r24, 0x06	; 6
     6ae:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
     6b2:	08 95       	ret

000006b4 <LCD_write_4bits>:
  }

void LCD_write_4bits(u8 data) {
     6b4:	cf 93       	push	r28
     6b6:	c8 2f       	mov	r28, r24
  DIO_write(LCD_DATA_PIN4, LCD_DATA_PORT, read_bit(data, 0));
     6b8:	48 2f       	mov	r20, r24
     6ba:	41 70       	andi	r20, 0x01	; 1
     6bc:	61 e4       	ldi	r22, 0x41	; 65
     6be:	80 e0       	ldi	r24, 0x00	; 0
     6c0:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  DIO_write(LCD_DATA_PIN5, LCD_DATA_PORT, read_bit(data, 1));
     6c4:	c1 fb       	bst	r28, 1
     6c6:	44 27       	eor	r20, r20
     6c8:	40 f9       	bld	r20, 0
     6ca:	61 e4       	ldi	r22, 0x41	; 65
     6cc:	81 e0       	ldi	r24, 0x01	; 1
     6ce:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  DIO_write(LCD_DATA_PIN6, LCD_DATA_PORT, read_bit(data, 2));
     6d2:	c2 fb       	bst	r28, 2
     6d4:	44 27       	eor	r20, r20
     6d6:	40 f9       	bld	r20, 0
     6d8:	61 e4       	ldi	r22, 0x41	; 65
     6da:	82 e0       	ldi	r24, 0x02	; 2
     6dc:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  DIO_write(LCD_DATA_PIN7, LCD_DATA_PORT, read_bit(data, 3));
     6e0:	c3 fb       	bst	r28, 3
     6e2:	44 27       	eor	r20, r20
     6e4:	40 f9       	bld	r20, 0
     6e6:	61 e4       	ldi	r22, 0x41	; 65
     6e8:	83 e0       	ldi	r24, 0x03	; 3
     6ea:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  }
     6ee:	cf 91       	pop	r28
     6f0:	08 95       	ret

000006f2 <LCD_sendData>:

void LCD_sendData(u8 data) {
     6f2:	cf 93       	push	r28
     6f4:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(data >> 4);
     6f6:	82 95       	swap	r24
     6f8:	8f 70       	andi	r24, 0x0F	; 15
     6fa:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, HIGH); // To indicate that this data
     6fe:	41 e0       	ldi	r20, 0x01	; 1
     700:	61 e4       	ldi	r22, 0x41	; 65
     702:	84 e0       	ldi	r24, 0x04	; 4
     704:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>

  LCD_sendEnablePulse();
     708:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the data to be sent

  LCD_write_4bits(data);
     70c:	8c 2f       	mov	r24, r28
     70e:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <LCD_write_4bits>

  LCD_sendEnablePulse();
     712:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_sendEnablePulse>
     716:	85 e0       	ldi	r24, 0x05	; 5
     718:	8a 95       	dec	r24
     71a:	f1 f7       	brne	.-4      	; 0x718 <LCD_sendData+0x26>
     71c:	00 00       	nop

  _delay_us(1); // wait for the data to be processed
#else

#endif
  }
     71e:	cf 91       	pop	r28
     720:	08 95       	ret

00000722 <LCD_sendCommand>:

void LCD_sendCommand(u8 cmd) {
     722:	cf 93       	push	r28
     724:	c8 2f       	mov	r28, r24
#if LCD_MODE == FOUR_BIT_MODE
  LCD_write_4bits(cmd >> 4);
     726:	82 95       	swap	r24
     728:	8f 70       	andi	r24, 0x0F	; 15
     72a:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <LCD_write_4bits>

  DIO_write(RS, LCD_CTRL_PORT, LOW); // To indicate that this a command
     72e:	40 e0       	ldi	r20, 0x00	; 0
     730:	61 e4       	ldi	r22, 0x41	; 65
     732:	84 e0       	ldi	r24, 0x04	; 4
     734:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>

  LCD_sendEnablePulse();
     738:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_sendEnablePulse>

  // _delay_us(200); // optional wait for the command to be sent

  LCD_write_4bits(cmd);
     73c:	8c 2f       	mov	r24, r28
     73e:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <LCD_write_4bits>

  LCD_sendEnablePulse();
     742:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_sendEnablePulse>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     746:	8f ed       	ldi	r24, 0xDF	; 223
     748:	9e e2       	ldi	r25, 0x2E	; 46
     74a:	01 97       	sbiw	r24, 0x01	; 1
     74c:	f1 f7       	brne	.-4      	; 0x74a <LCD_sendCommand+0x28>
     74e:	00 c0       	rjmp	.+0      	; 0x750 <LCD_sendCommand+0x2e>
     750:	00 00       	nop

  _delay_ms(3); // wait for the command to be executed
#else

#endif
  }
     752:	cf 91       	pop	r28
     754:	08 95       	ret

00000756 <LCD_clear_screen>:

void LCD_clear_screen() {
  LCD_sendCommand(0x01);
     756:	81 e0       	ldi	r24, 0x01	; 1
     758:	0e 94 91 03 	call	0x722	; 0x722 <LCD_sendCommand>
     75c:	08 95       	ret

0000075e <LCD_init>:
     75e:	2f ef       	ldi	r18, 0xFF	; 255
     760:	89 ef       	ldi	r24, 0xF9	; 249
     762:	90 e0       	ldi	r25, 0x00	; 0
     764:	21 50       	subi	r18, 0x01	; 1
     766:	80 40       	sbci	r24, 0x00	; 0
     768:	90 40       	sbci	r25, 0x00	; 0
     76a:	e1 f7       	brne	.-8      	; 0x764 <LCD_init+0x6>
     76c:	00 c0       	rjmp	.+0      	; 0x76e <LCD_init+0x10>
     76e:	00 00       	nop

void LCD_init(void) {
  _delay_ms(20); // wait for the LCD to start up.

#if LCD_MODE == FOUR_BIT_MODE
  DIO_init(LCD_DATA_PIN4, LCD_DATA_PORT, OUT);
     770:	41 e0       	ldi	r20, 0x01	; 1
     772:	61 e4       	ldi	r22, 0x41	; 65
     774:	80 e0       	ldi	r24, 0x00	; 0
     776:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  DIO_init(LCD_DATA_PIN5, LCD_DATA_PORT, OUT);
     77a:	41 e0       	ldi	r20, 0x01	; 1
     77c:	61 e4       	ldi	r22, 0x41	; 65
     77e:	81 e0       	ldi	r24, 0x01	; 1
     780:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  DIO_init(LCD_DATA_PIN6, LCD_DATA_PORT, OUT);
     784:	41 e0       	ldi	r20, 0x01	; 1
     786:	61 e4       	ldi	r22, 0x41	; 65
     788:	82 e0       	ldi	r24, 0x02	; 2
     78a:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  DIO_init(LCD_DATA_PIN7, LCD_DATA_PORT, OUT);
     78e:	41 e0       	ldi	r20, 0x01	; 1
     790:	61 e4       	ldi	r22, 0x41	; 65
     792:	83 e0       	ldi	r24, 0x03	; 3
     794:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>

  DIO_init(RS, LCD_CTRL_PORT, OUT);
     798:	41 e0       	ldi	r20, 0x01	; 1
     79a:	61 e4       	ldi	r22, 0x41	; 65
     79c:	84 e0       	ldi	r24, 0x04	; 4
     79e:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  DIO_init(RW, LCD_CTRL_PORT, OUT);
     7a2:	41 e0       	ldi	r20, 0x01	; 1
     7a4:	61 e4       	ldi	r22, 0x41	; 65
     7a6:	85 e0       	ldi	r24, 0x05	; 5
     7a8:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  DIO_init(EN, LCD_CTRL_PORT, OUT);
     7ac:	41 e0       	ldi	r20, 0x01	; 1
     7ae:	61 e4       	ldi	r22, 0x41	; 65
     7b0:	86 e0       	ldi	r24, 0x06	; 6
     7b2:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>

  DIO_write(RW, LCD_CTRL_PORT, LOW);
     7b6:	40 e0       	ldi	r20, 0x00	; 0
     7b8:	61 e4       	ldi	r22, 0x41	; 65
     7ba:	85 e0       	ldi	r24, 0x05	; 5
     7bc:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>

  LCD_sendCommand(0x02);  // return home 
     7c0:	82 e0       	ldi	r24, 0x02	; 2
     7c2:	0e 94 91 03 	call	0x722	; 0x722 <LCD_sendCommand>
  LCD_sendCommand(0x28);  // 2 line  and 4 bit mode
     7c6:	88 e2       	ldi	r24, 0x28	; 40
     7c8:	0e 94 91 03 	call	0x722	; 0x722 <LCD_sendCommand>
  LCD_sendCommand(0x0C);  // display on 
     7cc:	8c e0       	ldi	r24, 0x0C	; 12
     7ce:	0e 94 91 03 	call	0x722	; 0x722 <LCD_sendCommand>
  LCD_sendCommand(0x06);  // auto increment 
     7d2:	86 e0       	ldi	r24, 0x06	; 6
     7d4:	0e 94 91 03 	call	0x722	; 0x722 <LCD_sendCommand>
  LCD_clear_screen();
     7d8:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
     7dc:	08 95       	ret

000007de <LCD_write_string>:
#else

#endif
  }

void LCD_write_string(s8* str) {
     7de:	cf 92       	push	r12
     7e0:	df 92       	push	r13
     7e2:	ef 92       	push	r14
     7e4:	ff 92       	push	r15
     7e6:	cf 93       	push	r28
     7e8:	df 93       	push	r29
     7ea:	ec 01       	movw	r28, r24
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     7ec:	c1 2c       	mov	r12, r1
     7ee:	d1 2c       	mov	r13, r1
     7f0:	76 01       	movw	r14, r12
     7f2:	07 c0       	rjmp	.+14     	; 0x802 <__DATA_REGION_LENGTH__+0x2>
    LCD_sendData(str[i]);
     7f4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <LCD_sendData>
#endif
  }

void LCD_write_string(s8* str) {
  u32 i;
  for (i = 0;str[i] != 0;i++) {
     7f8:	8f ef       	ldi	r24, 0xFF	; 255
     7fa:	c8 1a       	sub	r12, r24
     7fc:	d8 0a       	sbc	r13, r24
     7fe:	e8 0a       	sbc	r14, r24
     800:	f8 0a       	sbc	r15, r24
     802:	fe 01       	movw	r30, r28
     804:	ec 0d       	add	r30, r12
     806:	fd 1d       	adc	r31, r13
     808:	80 81       	ld	r24, Z
     80a:	81 11       	cpse	r24, r1
     80c:	f3 cf       	rjmp	.-26     	; 0x7f4 <LCD_write_string+0x16>
    LCD_sendData(str[i]);
    }
  }
     80e:	df 91       	pop	r29
     810:	cf 91       	pop	r28
     812:	ff 90       	pop	r15
     814:	ef 90       	pop	r14
     816:	df 90       	pop	r13
     818:	cf 90       	pop	r12
     81a:	08 95       	ret

0000081c <LCD_move_cursor_xy>:

void LCD_move_cursor_xy(u8 x, u8 y) {
  switch (y) {
     81c:	66 23       	and	r22, r22
     81e:	19 f0       	breq	.+6      	; 0x826 <LCD_move_cursor_xy+0xa>
     820:	61 30       	cpi	r22, 0x01	; 1
     822:	29 f0       	breq	.+10     	; 0x82e <LCD_move_cursor_xy+0x12>
     824:	08 95       	ret
      case 0:
        LCD_sendCommand(0x80 + x);
     826:	80 58       	subi	r24, 0x80	; 128
     828:	0e 94 91 03 	call	0x722	; 0x722 <LCD_sendCommand>
        break;
     82c:	08 95       	ret
      case 1:
        LCD_sendCommand(0xC0 + x);
     82e:	80 54       	subi	r24, 0x40	; 64
     830:	0e 94 91 03 	call	0x722	; 0x722 <LCD_sendCommand>
     834:	08 95       	ret

00000836 <LCD_write_string_xy>:
        break;
    }
  }

void LCD_write_string_xy(u8 x, u8 y, s8* str) {
     836:	cf 93       	push	r28
     838:	df 93       	push	r29
     83a:	ea 01       	movw	r28, r20
  LCD_move_cursor_xy(x, y);
     83c:	0e 94 0e 04 	call	0x81c	; 0x81c <LCD_move_cursor_xy>
  LCD_write_string(str);
     840:	ce 01       	movw	r24, r28
     842:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_write_string>
  // TODO: Input validation
     846:	df 91       	pop	r29
     848:	cf 91       	pop	r28
     84a:	08 95       	ret

0000084c <LED_init>:
 */

#include "led.h"

 // Initialize the LED
EN_ledError_t LED_init(u8 ledPort, u8 ledPin) {
     84c:	98 2f       	mov	r25, r24
     84e:	86 2f       	mov	r24, r22
  // Check if the dio was initialized correctly
  if (DIO_init(ledPin, ledPort, OUT) == DIO_OK) {
     850:	41 e0       	ldi	r20, 0x01	; 1
     852:	69 2f       	mov	r22, r25
     854:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
     858:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that the led initialization failed
  return LED_ERROR_INIT;
     85a:	81 e0       	ldi	r24, 0x01	; 1
  }
     85c:	08 95       	ret

0000085e <LED_on>:

// Turn on the LED
EN_ledError_t LED_on(u8 ledPort, u8 ledPin) {
     85e:	98 2f       	mov	r25, r24
     860:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, HIGH) == DIO_OK) {
     862:	41 e0       	ldi	r20, 0x01	; 1
     864:	69 2f       	mov	r22, r25
     866:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
     86a:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn on the led has failed
  return LED_ERROR_ON;
     86c:	82 e0       	ldi	r24, 0x02	; 2
  }
     86e:	08 95       	ret

00000870 <LED_off>:

// Turn off the LED
EN_ledError_t LED_off(u8 ledPort, u8 ledPin) {
     870:	98 2f       	mov	r25, r24
     872:	86 2f       	mov	r24, r22
  if (DIO_write(ledPin, ledPort, LOW) == DIO_OK) {
     874:	40 e0       	ldi	r20, 0x00	; 0
     876:	69 2f       	mov	r22, r25
     878:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
     87c:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to turn off the led has failed
  return LED_ERROR_OFF;
     87e:	83 e0       	ldi	r24, 0x03	; 3
  }
     880:	08 95       	ret

00000882 <LED_toggle>:

// Toggle the LED
EN_ledError_t LED_toggle(u8 ledPort, u8 ledPin) {
     882:	98 2f       	mov	r25, r24
     884:	86 2f       	mov	r24, r22
  if (DIO_toggle(ledPin, ledPort) == DIO_OK) {
     886:	69 2f       	mov	r22, r25
     888:	0e 94 76 06 	call	0xcec	; 0xcec <DIO_toggle>
     88c:	81 11       	cpse	r24, r1
    return LED_OK;
    }
  // Return error code to indicate that attempting to toggle the led has failed
  return LED_ERROR_TOGGLE;
     88e:	84 e0       	ldi	r24, 0x04	; 4
     890:	08 95       	ret

00000892 <LM35_init_INT>:
  ADC_init();
  ADC_select_channel(pinNumber);
  }

// Initialize LM35 with the ADC in auto trigger mode
void LM35_init_INT(u8 pinNumber, u8 trigger) {
     892:	cf 93       	push	r28
     894:	df 93       	push	r29
     896:	c8 2f       	mov	r28, r24
     898:	d6 2f       	mov	r29, r22
  DIO_init(pinNumber, PORT_A, IN);
     89a:	40 e0       	ldi	r20, 0x00	; 0
     89c:	61 e4       	ldi	r22, 0x41	; 65
     89e:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  ADC_init_auto_trigger(trigger);
     8a2:	8d 2f       	mov	r24, r29
     8a4:	0e 94 96 04 	call	0x92c	; 0x92c <ADC_init_auto_trigger>
  ADC_select_channel(pinNumber);
     8a8:	8c 2f       	mov	r24, r28
     8aa:	0e 94 8c 04 	call	0x918	; 0x918 <ADC_select_channel>
     8ae:	df 91       	pop	r29
     8b0:	cf 91       	pop	r28
     8b2:	08 95       	ret

000008b4 <Servo_init>:

#include "servo.h"

 // Initialized the servo
void Servo_init() {
  DIO_init(SERVO_PIN, SERVO_PORT, OUT);
     8b4:	41 e0       	ldi	r20, 0x01	; 1
     8b6:	64 e4       	ldi	r22, 0x44	; 68
     8b8:	85 e0       	ldi	r24, 0x05	; 5
     8ba:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
  PWM_init(SERVO_PWM_PIN, (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS), PWM_PHASE_CORRECT);
     8be:	22 e0       	ldi	r18, 0x02	; 2
     8c0:	4d ec       	ldi	r20, 0xCD	; 205
     8c2:	5c ec       	ldi	r21, 0xCC	; 204
     8c4:	6c ec       	ldi	r22, 0xCC	; 204
     8c6:	7c e3       	ldi	r23, 0x3C	; 60
     8c8:	81 e0       	ldi	r24, 0x01	; 1
     8ca:	0e 94 84 09 	call	0x1308	; 0x1308 <PWM_init>
  Timer_start(TIMER_1, 8);
     8ce:	68 e0       	ldi	r22, 0x08	; 8
     8d0:	70 e0       	ldi	r23, 0x00	; 0
     8d2:	81 e0       	ldi	r24, 0x01	; 1
     8d4:	0e 94 14 09 	call	0x1228	; 0x1228 <Timer_start>
     8d8:	08 95       	ret

000008da <Servo_move_to_angle>:
  }

// Moves the servo to a specific angle (relative to the 0 angle position, not the previous one).
void Servo_move_to_angle(u8 angle) {
  PWM_set_DC(SERVO_PWM_PIN, ((double)angle / ((SERVO_MAX_ANGLE - SERVO_MIN_ANGLE) * (SERVO_PULSE_PERIODIC_TIME_mS / (SERVO_MAX_HIGH_PULSE_DURATION_mS - SERVO_MIN_HIGH_PULSE_DURATION_mS)))) + (SERVO_MIN_HIGH_PULSE_DURATION_mS / SERVO_PULSE_PERIODIC_TIME_mS));
     8da:	68 2f       	mov	r22, r24
     8dc:	70 e0       	ldi	r23, 0x00	; 0
     8de:	80 e0       	ldi	r24, 0x00	; 0
     8e0:	90 e0       	ldi	r25, 0x00	; 0
     8e2:	0e 94 c3 17 	call	0x2f86	; 0x2f86 <__floatunsisf>
     8e6:	20 e0       	ldi	r18, 0x00	; 0
     8e8:	30 e0       	ldi	r19, 0x00	; 0
     8ea:	41 ee       	ldi	r20, 0xE1	; 225
     8ec:	54 e4       	ldi	r21, 0x44	; 68
     8ee:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__divsf3>
     8f2:	2d ec       	ldi	r18, 0xCD	; 205
     8f4:	3c ec       	ldi	r19, 0xCC	; 204
     8f6:	4c ec       	ldi	r20, 0xCC	; 204
     8f8:	5c e3       	ldi	r21, 0x3C	; 60
     8fa:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <__addsf3>
     8fe:	ab 01       	movw	r20, r22
     900:	bc 01       	movw	r22, r24
     902:	81 e0       	ldi	r24, 0x01	; 1
     904:	0e 94 2b 0a 	call	0x1456	; 0x1456 <PWM_set_DC>
     908:	08 95       	ret

0000090a <main>:
#include "Application/app.h"
// #include "Services/Local_access/local.h"

int main(void) {
	
	App_init();
     90a:	0e 94 ab 00 	call	0x156	; 0x156 <App_init>
	
	App_start();
     90e:	0e 94 c2 00 	call	0x184	; 0x184 <App_start>
	
	}
     912:	80 e0       	ldi	r24, 0x00	; 0
     914:	90 e0       	ldi	r25, 0x00	; 0
     916:	08 95       	ret

00000918 <ADC_select_channel>:
  //   adjusted and no more than 8 - bit precision is required, it is sufficient to read ADCH.Otherwise, ADCL must be read
  //   first, then ADCH.
  * result = (u16)ADCL + ((u16)ADCH << 8); //? This will work
  //! *result = ((u16)ADCH << 8) + (u16)ADCL; // This won't work
  return ADC_OK;
  }
     918:	88 30       	cpi	r24, 0x08	; 8
     91a:	30 f4       	brcc	.+12     	; 0x928 <ADC_select_channel+0x10>
     91c:	97 b1       	in	r25, 0x07	; 7
     91e:	90 7e       	andi	r25, 0xE0	; 224
     920:	89 2b       	or	r24, r25
     922:	87 b9       	out	0x07, r24	; 7
     924:	80 e0       	ldi	r24, 0x00	; 0
     926:	08 95       	ret
     928:	81 e0       	ldi	r24, 0x01	; 1
     92a:	08 95       	ret

0000092c <ADC_init_auto_trigger>:

// Initialize the ADC in auto trigger mode
EN_ADCError_t ADC_init_auto_trigger(u8 trigger) {
     92c:	e8 2f       	mov	r30, r24
  // since the defualt for pins is to be low (0) we don't need to change anything here(since it's 0).
  // I don't need to write anything too. Because the VREF won't be changed during the run time. The only case I will need to clear a bit is if it was set by the MCU or me.
#elif (ADC_VREF == AVCC)
  set_bit(ADMUX, REFS0);
#elif (ADC_VREF == INTERNAL_VREF)
  set_bit(ADMUX, REFS0);
     92e:	87 b1       	in	r24, 0x07	; 7
     930:	80 64       	ori	r24, 0x40	; 64
     932:	87 b9       	out	0x07, r24	; 7
  set_bit(ADMUX, REFS1);
     934:	87 b1       	in	r24, 0x07	; 7
     936:	80 68       	ori	r24, 0x80	; 128
     938:	87 b9       	out	0x07, r24	; 7
#endif
  // Setting the prescalar to 128 so the operation frequency of the adc be within
  // the applicable range (50KHz-200KHz). The oscillator frequency is 16000000, Therefore the only applicable prescalar is 128.
  set_bit(ADCSRA, ADPS0);
     93a:	86 b1       	in	r24, 0x06	; 6
     93c:	81 60       	ori	r24, 0x01	; 1
     93e:	86 b9       	out	0x06, r24	; 6
  set_bit(ADCSRA, ADPS1);
     940:	86 b1       	in	r24, 0x06	; 6
     942:	82 60       	ori	r24, 0x02	; 2
     944:	86 b9       	out	0x06, r24	; 6
  set_bit(ADCSRA, ADPS2);
     946:	86 b1       	in	r24, 0x06	; 6
     948:	84 60       	ori	r24, 0x04	; 4
     94a:	86 b9       	out	0x06, r24	; 6
  // Enable the auto trigger mode
  set_bit(ADCSRA, ADATE);
     94c:	86 b1       	in	r24, 0x06	; 6
     94e:	80 62       	ori	r24, 0x20	; 32
     950:	86 b9       	out	0x06, r24	; 6
  // Select the auto trigger source
  //! Cause of a bug: setting ADTS bits one by one. when setting them one by one, only the last bit is set and the rest are cleared. 
  //! The bits must be set in one write operation.
  //^ Generally, in this project, setting bits in a register one by one has caused multiple issues, also sometimes the order matters. other times a register must be read before another.
  //? Setting one bit is okay. But multiple bits need to be set in one write operation.
  switch (trigger) {
     952:	8e 2f       	mov	r24, r30
     954:	90 e0       	ldi	r25, 0x00	; 0
     956:	87 30       	cpi	r24, 0x07	; 7
     958:	91 05       	cpc	r25, r1
     95a:	00 f5       	brcc	.+64     	; 0x99c <ADC_init_auto_trigger+0x70>
     95c:	fc 01       	movw	r30, r24
     95e:	e6 5d       	subi	r30, 0xD6	; 214
     960:	ff 4f       	sbci	r31, 0xFF	; 255
     962:	0c 94 be 18 	jmp	0x317c	; 0x317c <__tablejump2__>
      case FREE_RUNNING_MODE_TRIGGER:
        // All bits are clear by default
        // Start free running mode first conversion
        set_bit(ADCSRA, ADSC);
     966:	86 b1       	in	r24, 0x06	; 6
     968:	80 64       	ori	r24, 0x40	; 64
     96a:	86 b9       	out	0x06, r24	; 6
        break;
     96c:	17 c0       	rjmp	.+46     	; 0x99c <ADC_init_auto_trigger+0x70>
      case ANALOG_COMPARATOR_TRIGGER:
        set_bit(SFIOR, ADTS0);
     96e:	80 b7       	in	r24, 0x30	; 48
     970:	80 62       	ori	r24, 0x20	; 32
     972:	80 bf       	out	0x30, r24	; 48
        break;
     974:	13 c0       	rjmp	.+38     	; 0x99c <ADC_init_auto_trigger+0x70>
      case INT0_TRIGGER:
        set_bit(SFIOR, ADTS1);
     976:	80 b7       	in	r24, 0x30	; 48
     978:	80 64       	ori	r24, 0x40	; 64
     97a:	80 bf       	out	0x30, r24	; 48
        break;
     97c:	0f c0       	rjmp	.+30     	; 0x99c <ADC_init_auto_trigger+0x70>
      case TIMER_0_COMPARE_MATCH_TRIGGER:
        SFIOR |= (1 << ADTS0) | (1 << ADTS1);
     97e:	80 b7       	in	r24, 0x30	; 48
     980:	80 66       	ori	r24, 0x60	; 96
     982:	80 bf       	out	0x30, r24	; 48
        break;
     984:	0b c0       	rjmp	.+22     	; 0x99c <ADC_init_auto_trigger+0x70>
      case TIMER_0_OVF_TRIGGER:
        set_bit(SFIOR, ADTS2);
     986:	80 b7       	in	r24, 0x30	; 48
     988:	80 68       	ori	r24, 0x80	; 128
     98a:	80 bf       	out	0x30, r24	; 48
        break;
     98c:	07 c0       	rjmp	.+14     	; 0x99c <ADC_init_auto_trigger+0x70>
      case TIMER_1_COMPARE_MATCH_B_TRIGGER:
        SFIOR |= (1 << ADTS0) | (1 << ADTS2);
     98e:	80 b7       	in	r24, 0x30	; 48
     990:	80 6a       	ori	r24, 0xA0	; 160
     992:	80 bf       	out	0x30, r24	; 48
        break;
     994:	03 c0       	rjmp	.+6      	; 0x99c <ADC_init_auto_trigger+0x70>
      case TIMER_1_OVF_TRIGGER:
        SFIOR |= (1 << ADTS1) | (1 << ADTS2);
     996:	80 b7       	in	r24, 0x30	; 48
     998:	80 6c       	ori	r24, 0xC0	; 192
     99a:	80 bf       	out	0x30, r24	; 48
        break;
    }
  // Enable the ADC
  set_bit(ADCSRA, ADEN);
     99c:	86 b1       	in	r24, 0x06	; 6
     99e:	80 68       	ori	r24, 0x80	; 128
     9a0:	86 b9       	out	0x06, r24	; 6
  return ADC_OK;
     9a2:	80 e0       	ldi	r24, 0x00	; 0
     9a4:	08 95       	ret

000009a6 <isValidPinNumber>:
 */

#include "dio.h"

bool isValidPinNumber(u8 pinNumber) {
	if (pinNumber < 8) {
     9a6:	88 30       	cpi	r24, 0x08	; 8
     9a8:	10 f4       	brcc	.+4      	; 0x9ae <isValidPinNumber+0x8>
		return true;
     9aa:	81 e0       	ldi	r24, 0x01	; 1
     9ac:	08 95       	ret
		}
	return false;
     9ae:	80 e0       	ldi	r24, 0x00	; 0
	}
     9b0:	08 95       	ret

000009b2 <isValidPortNumber>:

bool isValidPortNumber(u8 portNumber) {
	if (portNumber == PORT_A || portNumber == PORT_B || portNumber == PORT_C || portNumber == PORT_D) {
     9b2:	81 54       	subi	r24, 0x41	; 65
     9b4:	84 30       	cpi	r24, 0x04	; 4
     9b6:	10 f4       	brcc	.+4      	; 0x9bc <isValidPortNumber+0xa>
		return true;
     9b8:	81 e0       	ldi	r24, 0x01	; 1
     9ba:	08 95       	ret
		}
	return false;
     9bc:	80 e0       	ldi	r24, 0x00	; 0
	}
     9be:	08 95       	ret

000009c0 <isValidDirection>:

bool isValidDirection(u8 direction) {
	if (direction == IN || direction == OUT) {
     9c0:	82 30       	cpi	r24, 0x02	; 2
     9c2:	10 f4       	brcc	.+4      	; 0x9c8 <isValidDirection+0x8>
		return true;
     9c4:	81 e0       	ldi	r24, 0x01	; 1
     9c6:	08 95       	ret
		}
	return false;
     9c8:	80 e0       	ldi	r24, 0x00	; 0
	}
     9ca:	08 95       	ret

000009cc <isValidState>:

bool isValidState(u8 state) {
	if (state == HIGH || state == LOW) {
     9cc:	82 30       	cpi	r24, 0x02	; 2
     9ce:	10 f4       	brcc	.+4      	; 0x9d4 <isValidState+0x8>
		return true;
     9d0:	81 e0       	ldi	r24, 0x01	; 1
     9d2:	08 95       	ret
		}
	return false;
     9d4:	80 e0       	ldi	r24, 0x00	; 0
	}
     9d6:	08 95       	ret

000009d8 <DIO_init>:

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
     9d8:	1f 93       	push	r17
     9da:	cf 93       	push	r28
     9dc:	df 93       	push	r29
     9de:	c8 2f       	mov	r28, r24
     9e0:	d6 2f       	mov	r29, r22
     9e2:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     9e4:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <isValidPinNumber>
     9e8:	88 23       	and	r24, r24
     9ea:	09 f4       	brne	.+2      	; 0x9ee <DIO_init+0x16>
     9ec:	84 c0       	rjmp	.+264    	; 0xaf6 <DIO_init+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     9ee:	8d 2f       	mov	r24, r29
     9f0:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <isValidPortNumber>
     9f4:	88 23       	and	r24, r24
     9f6:	09 f4       	brne	.+2      	; 0x9fa <DIO_init+0x22>
     9f8:	80 c0       	rjmp	.+256    	; 0xafa <DIO_init+0x122>
		return WRONG_PORT;
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
     9fa:	81 2f       	mov	r24, r17
     9fc:	0e 94 e0 04 	call	0x9c0	; 0x9c0 <isValidDirection>
     a00:	88 23       	and	r24, r24
     a02:	09 f4       	brne	.+2      	; 0xa06 <DIO_init+0x2e>
     a04:	7c c0       	rjmp	.+248    	; 0xafe <DIO_init+0x126>
		return WRONG_DIRECTION;
		}
	switch (portNumber) {
     a06:	d2 34       	cpi	r29, 0x42	; 66
     a08:	29 f1       	breq	.+74     	; 0xa54 <DIO_init+0x7c>
     a0a:	18 f4       	brcc	.+6      	; 0xa12 <DIO_init+0x3a>
     a0c:	d1 34       	cpi	r29, 0x41	; 65
     a0e:	39 f0       	breq	.+14     	; 0xa1e <DIO_init+0x46>
     a10:	78 c0       	rjmp	.+240    	; 0xb02 <DIO_init+0x12a>
     a12:	d3 34       	cpi	r29, 0x43	; 67
     a14:	d1 f1       	breq	.+116    	; 0xa8a <DIO_init+0xb2>
     a16:	d4 34       	cpi	r29, 0x44	; 68
     a18:	09 f4       	brne	.+2      	; 0xa1c <DIO_init+0x44>
     a1a:	52 c0       	rjmp	.+164    	; 0xac0 <DIO_init+0xe8>
     a1c:	72 c0       	rjmp	.+228    	; 0xb02 <DIO_init+0x12a>
			case PORT_A:
				if (direction == OUT) {
     a1e:	11 30       	cpi	r17, 0x01	; 1
     a20:	61 f4       	brne	.+24     	; 0xa3a <DIO_init+0x62>
					set_bit(DDRA, pinNumber);
     a22:	2a b3       	in	r18, 0x1a	; 26
     a24:	81 e0       	ldi	r24, 0x01	; 1
     a26:	90 e0       	ldi	r25, 0x00	; 0
     a28:	02 c0       	rjmp	.+4      	; 0xa2e <DIO_init+0x56>
     a2a:	88 0f       	add	r24, r24
     a2c:	99 1f       	adc	r25, r25
     a2e:	ca 95       	dec	r28
     a30:	e2 f7       	brpl	.-8      	; 0xa2a <DIO_init+0x52>
     a32:	82 2b       	or	r24, r18
     a34:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a36:	80 e0       	ldi	r24, 0x00	; 0
     a38:	65 c0       	rjmp	.+202    	; 0xb04 <DIO_init+0x12c>
			case PORT_A:
				if (direction == OUT) {
					set_bit(DDRA, pinNumber);
					}
				else {
					clear_bit(DDRA, pinNumber);
     a3a:	2a b3       	in	r18, 0x1a	; 26
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	02 c0       	rjmp	.+4      	; 0xa46 <DIO_init+0x6e>
     a42:	88 0f       	add	r24, r24
     a44:	99 1f       	adc	r25, r25
     a46:	ca 95       	dec	r28
     a48:	e2 f7       	brpl	.-8      	; 0xa42 <DIO_init+0x6a>
     a4a:	80 95       	com	r24
     a4c:	82 23       	and	r24, r18
     a4e:	8a bb       	out	0x1a, r24	; 26
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	58 c0       	rjmp	.+176    	; 0xb04 <DIO_init+0x12c>
				else {
					clear_bit(DDRA, pinNumber);
					}
				break;
			case PORT_B:
				if (direction == OUT) {
     a54:	11 30       	cpi	r17, 0x01	; 1
     a56:	61 f4       	brne	.+24     	; 0xa70 <DIO_init+0x98>
					set_bit(DDRB, pinNumber);
     a58:	27 b3       	in	r18, 0x17	; 23
     a5a:	81 e0       	ldi	r24, 0x01	; 1
     a5c:	90 e0       	ldi	r25, 0x00	; 0
     a5e:	02 c0       	rjmp	.+4      	; 0xa64 <DIO_init+0x8c>
     a60:	88 0f       	add	r24, r24
     a62:	99 1f       	adc	r25, r25
     a64:	ca 95       	dec	r28
     a66:	e2 f7       	brpl	.-8      	; 0xa60 <DIO_init+0x88>
     a68:	82 2b       	or	r24, r18
     a6a:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a6c:	80 e0       	ldi	r24, 0x00	; 0
     a6e:	4a c0       	rjmp	.+148    	; 0xb04 <DIO_init+0x12c>
			case PORT_B:
				if (direction == OUT) {
					set_bit(DDRB, pinNumber);
					}
				else {
					clear_bit(DDRB, pinNumber);
     a70:	27 b3       	in	r18, 0x17	; 23
     a72:	81 e0       	ldi	r24, 0x01	; 1
     a74:	90 e0       	ldi	r25, 0x00	; 0
     a76:	02 c0       	rjmp	.+4      	; 0xa7c <DIO_init+0xa4>
     a78:	88 0f       	add	r24, r24
     a7a:	99 1f       	adc	r25, r25
     a7c:	ca 95       	dec	r28
     a7e:	e2 f7       	brpl	.-8      	; 0xa78 <DIO_init+0xa0>
     a80:	80 95       	com	r24
     a82:	82 23       	and	r24, r18
     a84:	87 bb       	out	0x17, r24	; 23
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     a86:	80 e0       	ldi	r24, 0x00	; 0
     a88:	3d c0       	rjmp	.+122    	; 0xb04 <DIO_init+0x12c>
				else {
					clear_bit(DDRB, pinNumber);
					}
				break;
			case PORT_C:
				if (direction == OUT) {
     a8a:	11 30       	cpi	r17, 0x01	; 1
     a8c:	61 f4       	brne	.+24     	; 0xaa6 <DIO_init+0xce>
					set_bit(DDRC, pinNumber);
     a8e:	24 b3       	in	r18, 0x14	; 20
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	02 c0       	rjmp	.+4      	; 0xa9a <DIO_init+0xc2>
     a96:	88 0f       	add	r24, r24
     a98:	99 1f       	adc	r25, r25
     a9a:	ca 95       	dec	r28
     a9c:	e2 f7       	brpl	.-8      	; 0xa96 <DIO_init+0xbe>
     a9e:	82 2b       	or	r24, r18
     aa0:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     aa2:	80 e0       	ldi	r24, 0x00	; 0
     aa4:	2f c0       	rjmp	.+94     	; 0xb04 <DIO_init+0x12c>
			case PORT_C:
				if (direction == OUT) {
					set_bit(DDRC, pinNumber);
					}
				else {
					clear_bit(DDRC, pinNumber);
     aa6:	24 b3       	in	r18, 0x14	; 20
     aa8:	81 e0       	ldi	r24, 0x01	; 1
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	02 c0       	rjmp	.+4      	; 0xab2 <DIO_init+0xda>
     aae:	88 0f       	add	r24, r24
     ab0:	99 1f       	adc	r25, r25
     ab2:	ca 95       	dec	r28
     ab4:	e2 f7       	brpl	.-8      	; 0xaae <DIO_init+0xd6>
     ab6:	80 95       	com	r24
     ab8:	82 23       	and	r24, r18
     aba:	84 bb       	out	0x14, r24	; 20
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     abc:	80 e0       	ldi	r24, 0x00	; 0
     abe:	22 c0       	rjmp	.+68     	; 0xb04 <DIO_init+0x12c>
				else {
					clear_bit(DDRC, pinNumber);
					}
				break;
			case PORT_D:
				if (direction == OUT) {
     ac0:	11 30       	cpi	r17, 0x01	; 1
     ac2:	61 f4       	brne	.+24     	; 0xadc <DIO_init+0x104>
					set_bit(DDRD, pinNumber);
     ac4:	21 b3       	in	r18, 0x11	; 17
     ac6:	81 e0       	ldi	r24, 0x01	; 1
     ac8:	90 e0       	ldi	r25, 0x00	; 0
     aca:	02 c0       	rjmp	.+4      	; 0xad0 <DIO_init+0xf8>
     acc:	88 0f       	add	r24, r24
     ace:	99 1f       	adc	r25, r25
     ad0:	ca 95       	dec	r28
     ad2:	e2 f7       	brpl	.-8      	; 0xacc <DIO_init+0xf4>
     ad4:	82 2b       	or	r24, r18
     ad6:	81 bb       	out	0x11, r24	; 17
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     ad8:	80 e0       	ldi	r24, 0x00	; 0
     ada:	14 c0       	rjmp	.+40     	; 0xb04 <DIO_init+0x12c>
			case PORT_D:
				if (direction == OUT) {
					set_bit(DDRD, pinNumber);
					}
				else {
					clear_bit(DDRD, pinNumber);
     adc:	21 b3       	in	r18, 0x11	; 17
     ade:	81 e0       	ldi	r24, 0x01	; 1
     ae0:	90 e0       	ldi	r25, 0x00	; 0
     ae2:	02 c0       	rjmp	.+4      	; 0xae8 <DIO_init+0x110>
     ae4:	88 0f       	add	r24, r24
     ae6:	99 1f       	adc	r25, r25
     ae8:	ca 95       	dec	r28
     aea:	e2 f7       	brpl	.-8      	; 0xae4 <DIO_init+0x10c>
     aec:	80 95       	com	r24
     aee:	82 23       	and	r24, r18
     af0:	81 bb       	out	0x11, r24	; 17
					}
				break;
		}
	return DIO_OK;
     af2:	80 e0       	ldi	r24, 0x00	; 0
     af4:	07 c0       	rjmp	.+14     	; 0xb04 <DIO_init+0x12c>

// Initialize the pin direction
EN_dioError_t DIO_init(u8 pinNumber, u8 portNumber, u8 direction) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     af6:	81 e0       	ldi	r24, 0x01	; 1
     af8:	05 c0       	rjmp	.+10     	; 0xb04 <DIO_init+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     afa:	82 e0       	ldi	r24, 0x02	; 2
     afc:	03 c0       	rjmp	.+6      	; 0xb04 <DIO_init+0x12c>
		}
	// Validate the direction
	if (!isValidDirection(direction)) {
		return WRONG_DIRECTION;
     afe:	83 e0       	ldi	r24, 0x03	; 3
     b00:	01 c0       	rjmp	.+2      	; 0xb04 <DIO_init+0x12c>
				else {
					clear_bit(DDRD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     b02:	80 e0       	ldi	r24, 0x00	; 0
	}
     b04:	df 91       	pop	r29
     b06:	cf 91       	pop	r28
     b08:	1f 91       	pop	r17
     b0a:	08 95       	ret

00000b0c <DIO_write>:

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
     b0c:	1f 93       	push	r17
     b0e:	cf 93       	push	r28
     b10:	df 93       	push	r29
     b12:	c8 2f       	mov	r28, r24
     b14:	d6 2f       	mov	r29, r22
     b16:	14 2f       	mov	r17, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     b18:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <isValidPinNumber>
     b1c:	88 23       	and	r24, r24
     b1e:	09 f4       	brne	.+2      	; 0xb22 <DIO_write+0x16>
     b20:	84 c0       	rjmp	.+264    	; 0xc2a <DIO_write+0x11e>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     b22:	8d 2f       	mov	r24, r29
     b24:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <isValidPortNumber>
     b28:	88 23       	and	r24, r24
     b2a:	09 f4       	brne	.+2      	; 0xb2e <DIO_write+0x22>
     b2c:	80 c0       	rjmp	.+256    	; 0xc2e <DIO_write+0x122>
		return WRONG_PORT;
		}
	// Validate the pin state
	if (!isValidState(state)) {
     b2e:	81 2f       	mov	r24, r17
     b30:	0e 94 e6 04 	call	0x9cc	; 0x9cc <isValidState>
     b34:	88 23       	and	r24, r24
     b36:	09 f4       	brne	.+2      	; 0xb3a <DIO_write+0x2e>
     b38:	7c c0       	rjmp	.+248    	; 0xc32 <DIO_write+0x126>
		return WRONG_STATE;
		}
	switch (portNumber) {
     b3a:	d2 34       	cpi	r29, 0x42	; 66
     b3c:	29 f1       	breq	.+74     	; 0xb88 <DIO_write+0x7c>
     b3e:	18 f4       	brcc	.+6      	; 0xb46 <DIO_write+0x3a>
     b40:	d1 34       	cpi	r29, 0x41	; 65
     b42:	39 f0       	breq	.+14     	; 0xb52 <DIO_write+0x46>
     b44:	78 c0       	rjmp	.+240    	; 0xc36 <DIO_write+0x12a>
     b46:	d3 34       	cpi	r29, 0x43	; 67
     b48:	d1 f1       	breq	.+116    	; 0xbbe <DIO_write+0xb2>
     b4a:	d4 34       	cpi	r29, 0x44	; 68
     b4c:	09 f4       	brne	.+2      	; 0xb50 <DIO_write+0x44>
     b4e:	52 c0       	rjmp	.+164    	; 0xbf4 <DIO_write+0xe8>
     b50:	72 c0       	rjmp	.+228    	; 0xc36 <DIO_write+0x12a>
			case PORT_A:
				if (state == HIGH) {
     b52:	11 30       	cpi	r17, 0x01	; 1
     b54:	61 f4       	brne	.+24     	; 0xb6e <DIO_write+0x62>
					set_bit(PORTA, pinNumber);
     b56:	2b b3       	in	r18, 0x1b	; 27
     b58:	81 e0       	ldi	r24, 0x01	; 1
     b5a:	90 e0       	ldi	r25, 0x00	; 0
     b5c:	02 c0       	rjmp	.+4      	; 0xb62 <DIO_write+0x56>
     b5e:	88 0f       	add	r24, r24
     b60:	99 1f       	adc	r25, r25
     b62:	ca 95       	dec	r28
     b64:	e2 f7       	brpl	.-8      	; 0xb5e <DIO_write+0x52>
     b66:	82 2b       	or	r24, r18
     b68:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     b6a:	80 e0       	ldi	r24, 0x00	; 0
     b6c:	65 c0       	rjmp	.+202    	; 0xc38 <DIO_write+0x12c>
			case PORT_A:
				if (state == HIGH) {
					set_bit(PORTA, pinNumber);
					}
				else {
					clear_bit(PORTA, pinNumber);
     b6e:	2b b3       	in	r18, 0x1b	; 27
     b70:	81 e0       	ldi	r24, 0x01	; 1
     b72:	90 e0       	ldi	r25, 0x00	; 0
     b74:	02 c0       	rjmp	.+4      	; 0xb7a <DIO_write+0x6e>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	ca 95       	dec	r28
     b7c:	e2 f7       	brpl	.-8      	; 0xb76 <DIO_write+0x6a>
     b7e:	80 95       	com	r24
     b80:	82 23       	and	r24, r18
     b82:	8b bb       	out	0x1b, r24	; 27
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     b84:	80 e0       	ldi	r24, 0x00	; 0
     b86:	58 c0       	rjmp	.+176    	; 0xc38 <DIO_write+0x12c>
				else {
					clear_bit(PORTA, pinNumber);
					}
				break;
			case PORT_B:
				if (state == HIGH) {
     b88:	11 30       	cpi	r17, 0x01	; 1
     b8a:	61 f4       	brne	.+24     	; 0xba4 <DIO_write+0x98>
					set_bit(PORTB, pinNumber);
     b8c:	28 b3       	in	r18, 0x18	; 24
     b8e:	81 e0       	ldi	r24, 0x01	; 1
     b90:	90 e0       	ldi	r25, 0x00	; 0
     b92:	02 c0       	rjmp	.+4      	; 0xb98 <DIO_write+0x8c>
     b94:	88 0f       	add	r24, r24
     b96:	99 1f       	adc	r25, r25
     b98:	ca 95       	dec	r28
     b9a:	e2 f7       	brpl	.-8      	; 0xb94 <DIO_write+0x88>
     b9c:	82 2b       	or	r24, r18
     b9e:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     ba0:	80 e0       	ldi	r24, 0x00	; 0
     ba2:	4a c0       	rjmp	.+148    	; 0xc38 <DIO_write+0x12c>
			case PORT_B:
				if (state == HIGH) {
					set_bit(PORTB, pinNumber);
					}
				else {
					clear_bit(PORTB, pinNumber);
     ba4:	28 b3       	in	r18, 0x18	; 24
     ba6:	81 e0       	ldi	r24, 0x01	; 1
     ba8:	90 e0       	ldi	r25, 0x00	; 0
     baa:	02 c0       	rjmp	.+4      	; 0xbb0 <DIO_write+0xa4>
     bac:	88 0f       	add	r24, r24
     bae:	99 1f       	adc	r25, r25
     bb0:	ca 95       	dec	r28
     bb2:	e2 f7       	brpl	.-8      	; 0xbac <DIO_write+0xa0>
     bb4:	80 95       	com	r24
     bb6:	82 23       	and	r24, r18
     bb8:	88 bb       	out	0x18, r24	; 24
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     bba:	80 e0       	ldi	r24, 0x00	; 0
     bbc:	3d c0       	rjmp	.+122    	; 0xc38 <DIO_write+0x12c>
				else {
					clear_bit(PORTB, pinNumber);
					}
				break;
			case PORT_C:
				if (state == HIGH) {
     bbe:	11 30       	cpi	r17, 0x01	; 1
     bc0:	61 f4       	brne	.+24     	; 0xbda <DIO_write+0xce>
					set_bit(PORTC, pinNumber);
     bc2:	25 b3       	in	r18, 0x15	; 21
     bc4:	81 e0       	ldi	r24, 0x01	; 1
     bc6:	90 e0       	ldi	r25, 0x00	; 0
     bc8:	02 c0       	rjmp	.+4      	; 0xbce <DIO_write+0xc2>
     bca:	88 0f       	add	r24, r24
     bcc:	99 1f       	adc	r25, r25
     bce:	ca 95       	dec	r28
     bd0:	e2 f7       	brpl	.-8      	; 0xbca <DIO_write+0xbe>
     bd2:	82 2b       	or	r24, r18
     bd4:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     bd6:	80 e0       	ldi	r24, 0x00	; 0
     bd8:	2f c0       	rjmp	.+94     	; 0xc38 <DIO_write+0x12c>
			case PORT_C:
				if (state == HIGH) {
					set_bit(PORTC, pinNumber);
					}
				else {
					clear_bit(PORTC, pinNumber);
     bda:	25 b3       	in	r18, 0x15	; 21
     bdc:	81 e0       	ldi	r24, 0x01	; 1
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	02 c0       	rjmp	.+4      	; 0xbe6 <DIO_write+0xda>
     be2:	88 0f       	add	r24, r24
     be4:	99 1f       	adc	r25, r25
     be6:	ca 95       	dec	r28
     be8:	e2 f7       	brpl	.-8      	; 0xbe2 <DIO_write+0xd6>
     bea:	80 95       	com	r24
     bec:	82 23       	and	r24, r18
     bee:	85 bb       	out	0x15, r24	; 21
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     bf0:	80 e0       	ldi	r24, 0x00	; 0
     bf2:	22 c0       	rjmp	.+68     	; 0xc38 <DIO_write+0x12c>
				else {
					clear_bit(PORTC, pinNumber);
					}
				break;
			case PORT_D:
				if (state == HIGH) {
     bf4:	11 30       	cpi	r17, 0x01	; 1
     bf6:	61 f4       	brne	.+24     	; 0xc10 <DIO_write+0x104>
					set_bit(PORTD, pinNumber);
     bf8:	22 b3       	in	r18, 0x12	; 18
     bfa:	81 e0       	ldi	r24, 0x01	; 1
     bfc:	90 e0       	ldi	r25, 0x00	; 0
     bfe:	02 c0       	rjmp	.+4      	; 0xc04 <DIO_write+0xf8>
     c00:	88 0f       	add	r24, r24
     c02:	99 1f       	adc	r25, r25
     c04:	ca 95       	dec	r28
     c06:	e2 f7       	brpl	.-8      	; 0xc00 <DIO_write+0xf4>
     c08:	82 2b       	or	r24, r18
     c0a:	82 bb       	out	0x12, r24	; 18
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     c0c:	80 e0       	ldi	r24, 0x00	; 0
     c0e:	14 c0       	rjmp	.+40     	; 0xc38 <DIO_write+0x12c>
			case PORT_D:
				if (state == HIGH) {
					set_bit(PORTD, pinNumber);
					}
				else {
					clear_bit(PORTD, pinNumber);
     c10:	22 b3       	in	r18, 0x12	; 18
     c12:	81 e0       	ldi	r24, 0x01	; 1
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	02 c0       	rjmp	.+4      	; 0xc1c <DIO_write+0x110>
     c18:	88 0f       	add	r24, r24
     c1a:	99 1f       	adc	r25, r25
     c1c:	ca 95       	dec	r28
     c1e:	e2 f7       	brpl	.-8      	; 0xc18 <DIO_write+0x10c>
     c20:	80 95       	com	r24
     c22:	82 23       	and	r24, r18
     c24:	82 bb       	out	0x12, r24	; 18
					}
				break;
		}
	return DIO_OK;
     c26:	80 e0       	ldi	r24, 0x00	; 0
     c28:	07 c0       	rjmp	.+14     	; 0xc38 <DIO_write+0x12c>

// Write a value to a pin
EN_dioError_t DIO_write(u8 pinNumber, u8 portNumber, u8 state) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     c2a:	81 e0       	ldi	r24, 0x01	; 1
     c2c:	05 c0       	rjmp	.+10     	; 0xc38 <DIO_write+0x12c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     c2e:	82 e0       	ldi	r24, 0x02	; 2
     c30:	03 c0       	rjmp	.+6      	; 0xc38 <DIO_write+0x12c>
		}
	// Validate the pin state
	if (!isValidState(state)) {
		return WRONG_STATE;
     c32:	84 e0       	ldi	r24, 0x04	; 4
     c34:	01 c0       	rjmp	.+2      	; 0xc38 <DIO_write+0x12c>
				else {
					clear_bit(PORTD, pinNumber);
					}
				break;
		}
	return DIO_OK;
     c36:	80 e0       	ldi	r24, 0x00	; 0
	}
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	08 95       	ret

00000c40 <DIO_Read>:

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
     c40:	0f 93       	push	r16
     c42:	1f 93       	push	r17
     c44:	cf 93       	push	r28
     c46:	df 93       	push	r29
     c48:	d8 2f       	mov	r29, r24
     c4a:	c6 2f       	mov	r28, r22
     c4c:	8a 01       	movw	r16, r20
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     c4e:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <isValidPinNumber>
     c52:	88 23       	and	r24, r24
     c54:	09 f4       	brne	.+2      	; 0xc58 <DIO_Read+0x18>
     c56:	40 c0       	rjmp	.+128    	; 0xcd8 <DIO_Read+0x98>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     c58:	8c 2f       	mov	r24, r28
     c5a:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <isValidPortNumber>
     c5e:	88 23       	and	r24, r24
     c60:	e9 f1       	breq	.+122    	; 0xcdc <DIO_Read+0x9c>
		return WRONG_PORT;
		}
	switch (portNumber) {
     c62:	c2 34       	cpi	r28, 0x42	; 66
     c64:	a9 f0       	breq	.+42     	; 0xc90 <DIO_Read+0x50>
     c66:	18 f4       	brcc	.+6      	; 0xc6e <DIO_Read+0x2e>
     c68:	c1 34       	cpi	r28, 0x41	; 65
     c6a:	31 f0       	breq	.+12     	; 0xc78 <DIO_Read+0x38>
     c6c:	39 c0       	rjmp	.+114    	; 0xce0 <DIO_Read+0xa0>
     c6e:	c3 34       	cpi	r28, 0x43	; 67
     c70:	d9 f0       	breq	.+54     	; 0xca8 <DIO_Read+0x68>
     c72:	c4 34       	cpi	r28, 0x44	; 68
     c74:	29 f1       	breq	.+74     	; 0xcc0 <DIO_Read+0x80>
     c76:	34 c0       	rjmp	.+104    	; 0xce0 <DIO_Read+0xa0>
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
     c78:	89 b3       	in	r24, 0x19	; 25
     c7a:	90 e0       	ldi	r25, 0x00	; 0
     c7c:	02 c0       	rjmp	.+4      	; 0xc82 <DIO_Read+0x42>
     c7e:	95 95       	asr	r25
     c80:	87 95       	ror	r24
     c82:	da 95       	dec	r29
     c84:	e2 f7       	brpl	.-8      	; 0xc7e <DIO_Read+0x3e>
     c86:	81 70       	andi	r24, 0x01	; 1
     c88:	f8 01       	movw	r30, r16
     c8a:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     c8c:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
     c8e:	29 c0       	rjmp	.+82     	; 0xce2 <DIO_Read+0xa2>
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
     c90:	86 b3       	in	r24, 0x16	; 22
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	02 c0       	rjmp	.+4      	; 0xc9a <DIO_Read+0x5a>
     c96:	95 95       	asr	r25
     c98:	87 95       	ror	r24
     c9a:	da 95       	dec	r29
     c9c:	e2 f7       	brpl	.-8      	; 0xc96 <DIO_Read+0x56>
     c9e:	81 70       	andi	r24, 0x01	; 1
     ca0:	f8 01       	movw	r30, r16
     ca2:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     ca4:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				*value = read_bit(PINA, pinNumber);
				break;
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
     ca6:	1d c0       	rjmp	.+58     	; 0xce2 <DIO_Read+0xa2>
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
     ca8:	83 b3       	in	r24, 0x13	; 19
     caa:	90 e0       	ldi	r25, 0x00	; 0
     cac:	02 c0       	rjmp	.+4      	; 0xcb2 <DIO_Read+0x72>
     cae:	95 95       	asr	r25
     cb0:	87 95       	ror	r24
     cb2:	da 95       	dec	r29
     cb4:	e2 f7       	brpl	.-8      	; 0xcae <DIO_Read+0x6e>
     cb6:	81 70       	andi	r24, 0x01	; 1
     cb8:	f8 01       	movw	r30, r16
     cba:	80 83       	st	Z, r24
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     cbc:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				*value = read_bit(PINB, pinNumber);
				break;
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
     cbe:	11 c0       	rjmp	.+34     	; 0xce2 <DIO_Read+0xa2>
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
     cc0:	80 b3       	in	r24, 0x10	; 16
     cc2:	90 e0       	ldi	r25, 0x00	; 0
     cc4:	02 c0       	rjmp	.+4      	; 0xcca <DIO_Read+0x8a>
     cc6:	95 95       	asr	r25
     cc8:	87 95       	ror	r24
     cca:	da 95       	dec	r29
     ccc:	e2 f7       	brpl	.-8      	; 0xcc6 <DIO_Read+0x86>
     cce:	81 70       	andi	r24, 0x01	; 1
     cd0:	f8 01       	movw	r30, r16
     cd2:	80 83       	st	Z, r24
				break;
		}
	return DIO_OK;
     cd4:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				*value = read_bit(PINC, pinNumber);
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
     cd6:	05 c0       	rjmp	.+10     	; 0xce2 <DIO_Read+0xa2>

// Read a value from a pin
EN_dioError_t DIO_Read(u8 pinNumber, u8 portNumber, u8* value) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     cd8:	81 e0       	ldi	r24, 0x01	; 1
     cda:	03 c0       	rjmp	.+6      	; 0xce2 <DIO_Read+0xa2>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     cdc:	82 e0       	ldi	r24, 0x02	; 2
     cde:	01 c0       	rjmp	.+2      	; 0xce2 <DIO_Read+0xa2>
				break;
			case PORT_D:
				*value = read_bit(PIND, pinNumber);
				break;
		}
	return DIO_OK;
     ce0:	80 e0       	ldi	r24, 0x00	; 0
	}
     ce2:	df 91       	pop	r29
     ce4:	cf 91       	pop	r28
     ce6:	1f 91       	pop	r17
     ce8:	0f 91       	pop	r16
     cea:	08 95       	ret

00000cec <DIO_toggle>:

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
     cec:	cf 93       	push	r28
     cee:	df 93       	push	r29
     cf0:	d8 2f       	mov	r29, r24
     cf2:	c6 2f       	mov	r28, r22
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
     cf4:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <isValidPinNumber>
     cf8:	88 23       	and	r24, r24
     cfa:	09 f4       	brne	.+2      	; 0xcfe <DIO_toggle+0x12>
     cfc:	40 c0       	rjmp	.+128    	; 0xd7e <DIO_toggle+0x92>
		return WRONG_PIN;
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
     cfe:	8c 2f       	mov	r24, r28
     d00:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <isValidPortNumber>
     d04:	88 23       	and	r24, r24
     d06:	e9 f1       	breq	.+122    	; 0xd82 <DIO_toggle+0x96>
		return WRONG_PORT;
		}
	switch (portNumber) {
     d08:	c2 34       	cpi	r28, 0x42	; 66
     d0a:	a9 f0       	breq	.+42     	; 0xd36 <DIO_toggle+0x4a>
     d0c:	18 f4       	brcc	.+6      	; 0xd14 <DIO_toggle+0x28>
     d0e:	c1 34       	cpi	r28, 0x41	; 65
     d10:	31 f0       	breq	.+12     	; 0xd1e <DIO_toggle+0x32>
     d12:	39 c0       	rjmp	.+114    	; 0xd86 <DIO_toggle+0x9a>
     d14:	c3 34       	cpi	r28, 0x43	; 67
     d16:	d9 f0       	breq	.+54     	; 0xd4e <DIO_toggle+0x62>
     d18:	c4 34       	cpi	r28, 0x44	; 68
     d1a:	29 f1       	breq	.+74     	; 0xd66 <DIO_toggle+0x7a>
     d1c:	34 c0       	rjmp	.+104    	; 0xd86 <DIO_toggle+0x9a>
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
     d1e:	2b b3       	in	r18, 0x1b	; 27
     d20:	81 e0       	ldi	r24, 0x01	; 1
     d22:	90 e0       	ldi	r25, 0x00	; 0
     d24:	02 c0       	rjmp	.+4      	; 0xd2a <DIO_toggle+0x3e>
     d26:	88 0f       	add	r24, r24
     d28:	99 1f       	adc	r25, r25
     d2a:	da 95       	dec	r29
     d2c:	e2 f7       	brpl	.-8      	; 0xd26 <DIO_toggle+0x3a>
     d2e:	82 27       	eor	r24, r18
     d30:	8b bb       	out	0x1b, r24	; 27
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     d32:	80 e0       	ldi	r24, 0x00	; 0
		return WRONG_PORT;
		}
	switch (portNumber) {
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
     d34:	29 c0       	rjmp	.+82     	; 0xd88 <DIO_toggle+0x9c>
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
     d36:	28 b3       	in	r18, 0x18	; 24
     d38:	81 e0       	ldi	r24, 0x01	; 1
     d3a:	90 e0       	ldi	r25, 0x00	; 0
     d3c:	02 c0       	rjmp	.+4      	; 0xd42 <DIO_toggle+0x56>
     d3e:	88 0f       	add	r24, r24
     d40:	99 1f       	adc	r25, r25
     d42:	da 95       	dec	r29
     d44:	e2 f7       	brpl	.-8      	; 0xd3e <DIO_toggle+0x52>
     d46:	82 27       	eor	r24, r18
     d48:	88 bb       	out	0x18, r24	; 24
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     d4a:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_A:
				toggle_bit(PORTA, pinNumber);
				break;
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
     d4c:	1d c0       	rjmp	.+58     	; 0xd88 <DIO_toggle+0x9c>
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
     d4e:	25 b3       	in	r18, 0x15	; 21
     d50:	81 e0       	ldi	r24, 0x01	; 1
     d52:	90 e0       	ldi	r25, 0x00	; 0
     d54:	02 c0       	rjmp	.+4      	; 0xd5a <DIO_toggle+0x6e>
     d56:	88 0f       	add	r24, r24
     d58:	99 1f       	adc	r25, r25
     d5a:	da 95       	dec	r29
     d5c:	e2 f7       	brpl	.-8      	; 0xd56 <DIO_toggle+0x6a>
     d5e:	82 27       	eor	r24, r18
     d60:	85 bb       	out	0x15, r24	; 21
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     d62:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_B:
				toggle_bit(PORTB, pinNumber);
				break;
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
     d64:	11 c0       	rjmp	.+34     	; 0xd88 <DIO_toggle+0x9c>
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
     d66:	22 b3       	in	r18, 0x12	; 18
     d68:	81 e0       	ldi	r24, 0x01	; 1
     d6a:	90 e0       	ldi	r25, 0x00	; 0
     d6c:	02 c0       	rjmp	.+4      	; 0xd72 <DIO_toggle+0x86>
     d6e:	88 0f       	add	r24, r24
     d70:	99 1f       	adc	r25, r25
     d72:	da 95       	dec	r29
     d74:	e2 f7       	brpl	.-8      	; 0xd6e <DIO_toggle+0x82>
     d76:	82 27       	eor	r24, r18
     d78:	82 bb       	out	0x12, r24	; 18
				break;
		}
	return DIO_OK;
     d7a:	80 e0       	ldi	r24, 0x00	; 0
			case PORT_C:
				toggle_bit(PORTC, pinNumber);
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
     d7c:	05 c0       	rjmp	.+10     	; 0xd88 <DIO_toggle+0x9c>

// Toggle a pin
EN_dioError_t DIO_toggle(u8 pinNumber, u8 portNumber) {
	// Validate the pin number
	if (!isValidPinNumber(pinNumber)) {
		return WRONG_PIN;
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	03 c0       	rjmp	.+6      	; 0xd88 <DIO_toggle+0x9c>
		}
	// Validate the port number
	if (!isValidPortNumber(portNumber)) {
		return WRONG_PORT;
     d82:	82 e0       	ldi	r24, 0x02	; 2
     d84:	01 c0       	rjmp	.+2      	; 0xd88 <DIO_toggle+0x9c>
				break;
			case PORT_D:
				toggle_bit(PORTD, pinNumber);
				break;
		}
	return DIO_OK;
     d86:	80 e0       	ldi	r24, 0x00	; 0
     d88:	df 91       	pop	r29
     d8a:	cf 91       	pop	r28
     d8c:	08 95       	ret

00000d8e <getCurrentStatus>:

EN_I2CMasterStatusCode_t I2C_repeatedStart() {   // Same as start, just a different name
  TWCR = (1 << TWSTA) | (1 << TWEN) | (1 << TWINT);
  while (read_bit(TWCR, TWINT) == 0);
  return getCurrentStatus();
  }
     d8e:	81 b1       	in	r24, 0x01	; 1
     d90:	e8 2f       	mov	r30, r24
     d92:	e8 7f       	andi	r30, 0xF8	; 248
     d94:	8e 2f       	mov	r24, r30
     d96:	90 e0       	ldi	r25, 0x00	; 0
     d98:	fc 01       	movw	r30, r24
     d9a:	38 97       	sbiw	r30, 0x08	; 8
     d9c:	e1 35       	cpi	r30, 0x51	; 81
     d9e:	f1 05       	cpc	r31, r1
     da0:	c0 f4       	brcc	.+48     	; 0xdd2 <getCurrentStatus+0x44>
     da2:	ef 5c       	subi	r30, 0xCF	; 207
     da4:	ff 4f       	sbci	r31, 0xFF	; 255
     da6:	0c 94 be 18 	jmp	0x317c	; 0x317c <__tablejump2__>
     daa:	80 e0       	ldi	r24, 0x00	; 0
     dac:	08 95       	ret
     dae:	82 e0       	ldi	r24, 0x02	; 2
     db0:	08 95       	ret
     db2:	83 e0       	ldi	r24, 0x03	; 3
     db4:	08 95       	ret
     db6:	84 e0       	ldi	r24, 0x04	; 4
     db8:	08 95       	ret
     dba:	85 e0       	ldi	r24, 0x05	; 5
     dbc:	08 95       	ret
     dbe:	86 e0       	ldi	r24, 0x06	; 6
     dc0:	08 95       	ret
     dc2:	87 e0       	ldi	r24, 0x07	; 7
     dc4:	08 95       	ret
     dc6:	88 e0       	ldi	r24, 0x08	; 8
     dc8:	08 95       	ret
     dca:	89 e0       	ldi	r24, 0x09	; 9
     dcc:	08 95       	ret
     dce:	8a e0       	ldi	r24, 0x0A	; 10
     dd0:	08 95       	ret
     dd2:	8b e0       	ldi	r24, 0x0B	; 11
     dd4:	08 95       	ret
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	08 95       	ret

00000dda <I2C_init>:
     dda:	11 b8       	out	0x01, r1	; 1
     ddc:	8f ef       	ldi	r24, 0xFF	; 255
     dde:	80 b9       	out	0x00, r24	; 0
     de0:	08 95       	ret

00000de2 <I2C_start>:
     de2:	84 ea       	ldi	r24, 0xA4	; 164
     de4:	86 bf       	out	0x36, r24	; 54
     de6:	06 b6       	in	r0, 0x36	; 54
     de8:	07 fe       	sbrs	r0, 7
     dea:	fd cf       	rjmp	.-6      	; 0xde6 <I2C_start+0x4>
     dec:	0e 94 c7 06 	call	0xd8e	; 0xd8e <getCurrentStatus>
     df0:	08 95       	ret

00000df2 <I2C_write>:

EN_I2CMasterStatusCode_t I2C_write(u8 data) {
  TWDR = data;
     df2:	83 b9       	out	0x03, r24	; 3
  TWCR = (1 << TWEN) | (1 << TWINT);
     df4:	84 e8       	ldi	r24, 0x84	; 132
     df6:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWINT) == 0);
     df8:	06 b6       	in	r0, 0x36	; 54
     dfa:	07 fe       	sbrs	r0, 7
     dfc:	fd cf       	rjmp	.-6      	; 0xdf8 <I2C_write+0x6>
  return getCurrentStatus();
     dfe:	0e 94 c7 06 	call	0xd8e	; 0xd8e <getCurrentStatus>
  }
     e02:	08 95       	ret

00000e04 <I2C_read_Ack>:

EN_I2CMasterStatusCode_t I2C_read_Ack(u8* data) {
  TWCR = (1 << TWEA) | (1 << TWEN) | (1 << TWINT);
     e04:	24 ec       	ldi	r18, 0xC4	; 196
     e06:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     e08:	06 b6       	in	r0, 0x36	; 54
     e0a:	07 fe       	sbrs	r0, 7
     e0c:	fd cf       	rjmp	.-6      	; 0xe08 <I2C_read_Ack+0x4>
  *data = TWDR;
     e0e:	23 b1       	in	r18, 0x03	; 3
     e10:	fc 01       	movw	r30, r24
     e12:	20 83       	st	Z, r18
  return getCurrentStatus();
     e14:	0e 94 c7 06 	call	0xd8e	; 0xd8e <getCurrentStatus>
  }
     e18:	08 95       	ret

00000e1a <I2C_read_Nack>:

EN_I2CMasterStatusCode_t I2C_read_Nack(u8* data) {
  TWCR = (1 << TWEN) | (1 << TWINT);
     e1a:	24 e8       	ldi	r18, 0x84	; 132
     e1c:	26 bf       	out	0x36, r18	; 54
  while (read_bit(TWCR, TWINT) == 0);
     e1e:	06 b6       	in	r0, 0x36	; 54
     e20:	07 fe       	sbrs	r0, 7
     e22:	fd cf       	rjmp	.-6      	; 0xe1e <I2C_read_Nack+0x4>
  *data = TWDR;
     e24:	23 b1       	in	r18, 0x03	; 3
     e26:	fc 01       	movw	r30, r24
     e28:	20 83       	st	Z, r18
  return getCurrentStatus();
     e2a:	0e 94 c7 06 	call	0xd8e	; 0xd8e <getCurrentStatus>
  }
     e2e:	08 95       	ret

00000e30 <I2C_stop>:

void I2C_stop(void) {
  TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
     e30:	84 e9       	ldi	r24, 0x94	; 148
     e32:	86 bf       	out	0x36, r24	; 54
  while (read_bit(TWCR, TWSTO));	// Wait until stop condition finishes
     e34:	06 b6       	in	r0, 0x36	; 54
     e36:	04 fc       	sbrc	r0, 4
     e38:	fd cf       	rjmp	.-6      	; 0xe34 <I2C_stop+0x4>
  }
     e3a:	08 95       	ret

00000e3c <INT0_init>:
        break;
    }
  // Enable the external interrupt 
  set_bit(GICR, INT2);
  return INTERRUPT_INIT_OK;
  }
     e3c:	84 30       	cpi	r24, 0x04	; 4
     e3e:	c8 f4       	brcc	.+50     	; 0xe72 <INT0_init+0x36>
     e40:	82 30       	cpi	r24, 0x02	; 2
     e42:	41 f0       	breq	.+16     	; 0xe54 <INT0_init+0x18>
     e44:	83 30       	cpi	r24, 0x03	; 3
     e46:	51 f0       	breq	.+20     	; 0xe5c <INT0_init+0x20>
     e48:	81 30       	cpi	r24, 0x01	; 1
     e4a:	71 f4       	brne	.+28     	; 0xe68 <INT0_init+0x2c>
     e4c:	85 b7       	in	r24, 0x35	; 53
     e4e:	81 60       	ori	r24, 0x01	; 1
     e50:	85 bf       	out	0x35, r24	; 53
     e52:	0a c0       	rjmp	.+20     	; 0xe68 <INT0_init+0x2c>
     e54:	85 b7       	in	r24, 0x35	; 53
     e56:	82 60       	ori	r24, 0x02	; 2
     e58:	85 bf       	out	0x35, r24	; 53
     e5a:	06 c0       	rjmp	.+12     	; 0xe68 <INT0_init+0x2c>
     e5c:	85 b7       	in	r24, 0x35	; 53
     e5e:	81 60       	ori	r24, 0x01	; 1
     e60:	85 bf       	out	0x35, r24	; 53
     e62:	85 b7       	in	r24, 0x35	; 53
     e64:	82 60       	ori	r24, 0x02	; 2
     e66:	85 bf       	out	0x35, r24	; 53
     e68:	8b b7       	in	r24, 0x3b	; 59
     e6a:	80 64       	ori	r24, 0x40	; 64
     e6c:	8b bf       	out	0x3b, r24	; 59
     e6e:	80 e0       	ldi	r24, 0x00	; 0
     e70:	08 95       	ret
     e72:	81 e0       	ldi	r24, 0x01	; 1
     e74:	08 95       	ret

00000e76 <ADC_INT_init>:

// Initialize the ADC conversion complete interrupt
EN_INT_init_Status_t ADC_INT_init(void) {
  // Enable the ADC conversion complete interrupt
  set_bit(ADCSRA, ADIE);
     e76:	86 b1       	in	r24, 0x06	; 6
     e78:	88 60       	ori	r24, 0x08	; 8
     e7a:	86 b9       	out	0x06, r24	; 6
  return INTERRUPT_INIT_OK;
  }
     e7c:	80 e0       	ldi	r24, 0x00	; 0
     e7e:	08 95       	ret

00000e80 <UART_RXC_INT_init>:

// Initialize the UART RX complete interrupt
EN_INT_init_Status_t UART_RXC_INT_init(void) {
  // Enable the UART RX complete interrupt
  set_bit(UCSRB, RXCIE);
     e80:	8a b1       	in	r24, 0x0a	; 10
     e82:	80 68       	ori	r24, 0x80	; 128
     e84:	8a b9       	out	0x0a, r24	; 10
  return INTERRUPT_INIT_OK;
     e86:	80 e0       	ldi	r24, 0x00	; 0
     e88:	08 95       	ret

00000e8a <isValidTimer>:
        clear_bit(TCCR2, COM21);
        set_prescalar(TIMER_2, 0);
        break;
    }
  return TIMER_OK;
  }
     e8a:	83 30       	cpi	r24, 0x03	; 3
     e8c:	10 f4       	brcc	.+4      	; 0xe92 <isValidTimer+0x8>
     e8e:	81 e0       	ldi	r24, 0x01	; 1
     e90:	08 95       	ret
     e92:	80 e0       	ldi	r24, 0x00	; 0
     e94:	08 95       	ret

00000e96 <set_prescalar>:
     e96:	1f 93       	push	r17
     e98:	cf 93       	push	r28
     e9a:	df 93       	push	r29
     e9c:	18 2f       	mov	r17, r24
     e9e:	eb 01       	movw	r28, r22
     ea0:	0e 94 45 07 	call	0xe8a	; 0xe8a <isValidTimer>
     ea4:	88 23       	and	r24, r24
     ea6:	09 f4       	brne	.+2      	; 0xeaa <set_prescalar+0x14>
     ea8:	6a c1       	rjmp	.+724    	; 0x117e <set_prescalar+0x2e8>
     eaa:	11 30       	cpi	r17, 0x01	; 1
     eac:	09 f4       	brne	.+2      	; 0xeb0 <set_prescalar+0x1a>
     eae:	6f c0       	rjmp	.+222    	; 0xf8e <set_prescalar+0xf8>
     eb0:	20 f0       	brcs	.+8      	; 0xeba <set_prescalar+0x24>
     eb2:	12 30       	cpi	r17, 0x02	; 2
     eb4:	09 f4       	brne	.+2      	; 0xeb8 <set_prescalar+0x22>
     eb6:	d5 c0       	rjmp	.+426    	; 0x1062 <set_prescalar+0x1cc>
     eb8:	64 c1       	rjmp	.+712    	; 0x1182 <set_prescalar+0x2ec>
     eba:	c2 30       	cpi	r28, 0x02	; 2
     ebc:	d1 05       	cpc	r29, r1
     ebe:	78 f0       	brcs	.+30     	; 0xede <set_prescalar+0x48>
     ec0:	c8 30       	cpi	r28, 0x08	; 8
     ec2:	d1 05       	cpc	r29, r1
     ec4:	61 f0       	breq	.+24     	; 0xede <set_prescalar+0x48>
     ec6:	c0 34       	cpi	r28, 0x40	; 64
     ec8:	d1 05       	cpc	r29, r1
     eca:	49 f0       	breq	.+18     	; 0xede <set_prescalar+0x48>
     ecc:	c1 15       	cp	r28, r1
     ece:	81 e0       	ldi	r24, 0x01	; 1
     ed0:	d8 07       	cpc	r29, r24
     ed2:	29 f0       	breq	.+10     	; 0xede <set_prescalar+0x48>
     ed4:	c1 15       	cp	r28, r1
     ed6:	84 e0       	ldi	r24, 0x04	; 4
     ed8:	d8 07       	cpc	r29, r24
     eda:	09 f0       	breq	.+2      	; 0xede <set_prescalar+0x48>
     edc:	54 c1       	rjmp	.+680    	; 0x1186 <set_prescalar+0x2f0>
     ede:	c8 30       	cpi	r28, 0x08	; 8
     ee0:	d1 05       	cpc	r29, r1
     ee2:	49 f1       	breq	.+82     	; 0xf36 <set_prescalar+0xa0>
     ee4:	28 f4       	brcc	.+10     	; 0xef0 <set_prescalar+0x5a>
     ee6:	20 97       	sbiw	r28, 0x00	; 0
     ee8:	81 f0       	breq	.+32     	; 0xf0a <set_prescalar+0x74>
     eea:	21 97       	sbiw	r28, 0x01	; 1
     eec:	c9 f0       	breq	.+50     	; 0xf20 <set_prescalar+0x8a>
     eee:	4d c1       	rjmp	.+666    	; 0x118a <set_prescalar+0x2f4>
     ef0:	c1 15       	cp	r28, r1
     ef2:	81 e0       	ldi	r24, 0x01	; 1
     ef4:	d8 07       	cpc	r29, r24
     ef6:	a9 f1       	breq	.+106    	; 0xf62 <set_prescalar+0xcc>
     ef8:	c1 15       	cp	r28, r1
     efa:	84 e0       	ldi	r24, 0x04	; 4
     efc:	d8 07       	cpc	r29, r24
     efe:	e1 f1       	breq	.+120    	; 0xf78 <set_prescalar+0xe2>
     f00:	c0 34       	cpi	r28, 0x40	; 64
     f02:	d1 05       	cpc	r29, r1
     f04:	09 f0       	breq	.+2      	; 0xf08 <set_prescalar+0x72>
     f06:	41 c1       	rjmp	.+642    	; 0x118a <set_prescalar+0x2f4>
     f08:	21 c0       	rjmp	.+66     	; 0xf4c <set_prescalar+0xb6>
     f0a:	83 b7       	in	r24, 0x33	; 51
     f0c:	8e 7f       	andi	r24, 0xFE	; 254
     f0e:	83 bf       	out	0x33, r24	; 51
     f10:	83 b7       	in	r24, 0x33	; 51
     f12:	8d 7f       	andi	r24, 0xFD	; 253
     f14:	83 bf       	out	0x33, r24	; 51
     f16:	83 b7       	in	r24, 0x33	; 51
     f18:	8b 7f       	andi	r24, 0xFB	; 251
     f1a:	83 bf       	out	0x33, r24	; 51
     f1c:	80 e0       	ldi	r24, 0x00	; 0
     f1e:	3e c1       	rjmp	.+636    	; 0x119c <set_prescalar+0x306>
     f20:	83 b7       	in	r24, 0x33	; 51
     f22:	81 60       	ori	r24, 0x01	; 1
     f24:	83 bf       	out	0x33, r24	; 51
     f26:	83 b7       	in	r24, 0x33	; 51
     f28:	8d 7f       	andi	r24, 0xFD	; 253
     f2a:	83 bf       	out	0x33, r24	; 51
     f2c:	83 b7       	in	r24, 0x33	; 51
     f2e:	8b 7f       	andi	r24, 0xFB	; 251
     f30:	83 bf       	out	0x33, r24	; 51
     f32:	80 e0       	ldi	r24, 0x00	; 0
     f34:	33 c1       	rjmp	.+614    	; 0x119c <set_prescalar+0x306>
     f36:	83 b7       	in	r24, 0x33	; 51
     f38:	8e 7f       	andi	r24, 0xFE	; 254
     f3a:	83 bf       	out	0x33, r24	; 51
     f3c:	83 b7       	in	r24, 0x33	; 51
     f3e:	82 60       	ori	r24, 0x02	; 2
     f40:	83 bf       	out	0x33, r24	; 51
     f42:	83 b7       	in	r24, 0x33	; 51
     f44:	8b 7f       	andi	r24, 0xFB	; 251
     f46:	83 bf       	out	0x33, r24	; 51
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	28 c1       	rjmp	.+592    	; 0x119c <set_prescalar+0x306>
     f4c:	83 b7       	in	r24, 0x33	; 51
     f4e:	81 60       	ori	r24, 0x01	; 1
     f50:	83 bf       	out	0x33, r24	; 51
     f52:	83 b7       	in	r24, 0x33	; 51
     f54:	82 60       	ori	r24, 0x02	; 2
     f56:	83 bf       	out	0x33, r24	; 51
     f58:	83 b7       	in	r24, 0x33	; 51
     f5a:	8b 7f       	andi	r24, 0xFB	; 251
     f5c:	83 bf       	out	0x33, r24	; 51
     f5e:	80 e0       	ldi	r24, 0x00	; 0
     f60:	1d c1       	rjmp	.+570    	; 0x119c <set_prescalar+0x306>
     f62:	83 b7       	in	r24, 0x33	; 51
     f64:	8e 7f       	andi	r24, 0xFE	; 254
     f66:	83 bf       	out	0x33, r24	; 51
     f68:	83 b7       	in	r24, 0x33	; 51
     f6a:	8d 7f       	andi	r24, 0xFD	; 253
     f6c:	83 bf       	out	0x33, r24	; 51
     f6e:	83 b7       	in	r24, 0x33	; 51
     f70:	84 60       	ori	r24, 0x04	; 4
     f72:	83 bf       	out	0x33, r24	; 51
     f74:	80 e0       	ldi	r24, 0x00	; 0
     f76:	12 c1       	rjmp	.+548    	; 0x119c <set_prescalar+0x306>
     f78:	83 b7       	in	r24, 0x33	; 51
     f7a:	81 60       	ori	r24, 0x01	; 1
     f7c:	83 bf       	out	0x33, r24	; 51
     f7e:	83 b7       	in	r24, 0x33	; 51
     f80:	8d 7f       	andi	r24, 0xFD	; 253
     f82:	83 bf       	out	0x33, r24	; 51
     f84:	83 b7       	in	r24, 0x33	; 51
     f86:	84 60       	ori	r24, 0x04	; 4
     f88:	83 bf       	out	0x33, r24	; 51
     f8a:	80 e0       	ldi	r24, 0x00	; 0
     f8c:	07 c1       	rjmp	.+526    	; 0x119c <set_prescalar+0x306>
     f8e:	c2 30       	cpi	r28, 0x02	; 2
     f90:	d1 05       	cpc	r29, r1
     f92:	78 f0       	brcs	.+30     	; 0xfb2 <set_prescalar+0x11c>
     f94:	c8 30       	cpi	r28, 0x08	; 8
     f96:	d1 05       	cpc	r29, r1
     f98:	61 f0       	breq	.+24     	; 0xfb2 <set_prescalar+0x11c>
     f9a:	c0 34       	cpi	r28, 0x40	; 64
     f9c:	d1 05       	cpc	r29, r1
     f9e:	49 f0       	breq	.+18     	; 0xfb2 <set_prescalar+0x11c>
     fa0:	c1 15       	cp	r28, r1
     fa2:	81 e0       	ldi	r24, 0x01	; 1
     fa4:	d8 07       	cpc	r29, r24
     fa6:	29 f0       	breq	.+10     	; 0xfb2 <set_prescalar+0x11c>
     fa8:	c1 15       	cp	r28, r1
     faa:	84 e0       	ldi	r24, 0x04	; 4
     fac:	d8 07       	cpc	r29, r24
     fae:	09 f0       	breq	.+2      	; 0xfb2 <set_prescalar+0x11c>
     fb0:	ee c0       	rjmp	.+476    	; 0x118e <set_prescalar+0x2f8>
     fb2:	c8 30       	cpi	r28, 0x08	; 8
     fb4:	d1 05       	cpc	r29, r1
     fb6:	49 f1       	breq	.+82     	; 0x100a <set_prescalar+0x174>
     fb8:	28 f4       	brcc	.+10     	; 0xfc4 <set_prescalar+0x12e>
     fba:	20 97       	sbiw	r28, 0x00	; 0
     fbc:	81 f0       	breq	.+32     	; 0xfde <set_prescalar+0x148>
     fbe:	21 97       	sbiw	r28, 0x01	; 1
     fc0:	c9 f0       	breq	.+50     	; 0xff4 <set_prescalar+0x15e>
     fc2:	e7 c0       	rjmp	.+462    	; 0x1192 <set_prescalar+0x2fc>
     fc4:	c1 15       	cp	r28, r1
     fc6:	81 e0       	ldi	r24, 0x01	; 1
     fc8:	d8 07       	cpc	r29, r24
     fca:	a9 f1       	breq	.+106    	; 0x1036 <set_prescalar+0x1a0>
     fcc:	c1 15       	cp	r28, r1
     fce:	84 e0       	ldi	r24, 0x04	; 4
     fd0:	d8 07       	cpc	r29, r24
     fd2:	e1 f1       	breq	.+120    	; 0x104c <set_prescalar+0x1b6>
     fd4:	c0 34       	cpi	r28, 0x40	; 64
     fd6:	d1 05       	cpc	r29, r1
     fd8:	09 f0       	breq	.+2      	; 0xfdc <set_prescalar+0x146>
     fda:	db c0       	rjmp	.+438    	; 0x1192 <set_prescalar+0x2fc>
     fdc:	21 c0       	rjmp	.+66     	; 0x1020 <set_prescalar+0x18a>
     fde:	8e b5       	in	r24, 0x2e	; 46
     fe0:	8e 7f       	andi	r24, 0xFE	; 254
     fe2:	8e bd       	out	0x2e, r24	; 46
     fe4:	8e b5       	in	r24, 0x2e	; 46
     fe6:	8d 7f       	andi	r24, 0xFD	; 253
     fe8:	8e bd       	out	0x2e, r24	; 46
     fea:	8e b5       	in	r24, 0x2e	; 46
     fec:	8b 7f       	andi	r24, 0xFB	; 251
     fee:	8e bd       	out	0x2e, r24	; 46
     ff0:	80 e0       	ldi	r24, 0x00	; 0
     ff2:	d4 c0       	rjmp	.+424    	; 0x119c <set_prescalar+0x306>
     ff4:	8e b5       	in	r24, 0x2e	; 46
     ff6:	81 60       	ori	r24, 0x01	; 1
     ff8:	8e bd       	out	0x2e, r24	; 46
     ffa:	8e b5       	in	r24, 0x2e	; 46
     ffc:	8d 7f       	andi	r24, 0xFD	; 253
     ffe:	8e bd       	out	0x2e, r24	; 46
    1000:	8e b5       	in	r24, 0x2e	; 46
    1002:	8b 7f       	andi	r24, 0xFB	; 251
    1004:	8e bd       	out	0x2e, r24	; 46
    1006:	80 e0       	ldi	r24, 0x00	; 0
    1008:	c9 c0       	rjmp	.+402    	; 0x119c <set_prescalar+0x306>
    100a:	8e b5       	in	r24, 0x2e	; 46
    100c:	8e 7f       	andi	r24, 0xFE	; 254
    100e:	8e bd       	out	0x2e, r24	; 46
    1010:	8e b5       	in	r24, 0x2e	; 46
    1012:	82 60       	ori	r24, 0x02	; 2
    1014:	8e bd       	out	0x2e, r24	; 46
    1016:	8e b5       	in	r24, 0x2e	; 46
    1018:	8b 7f       	andi	r24, 0xFB	; 251
    101a:	8e bd       	out	0x2e, r24	; 46
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	be c0       	rjmp	.+380    	; 0x119c <set_prescalar+0x306>
    1020:	8e b5       	in	r24, 0x2e	; 46
    1022:	81 60       	ori	r24, 0x01	; 1
    1024:	8e bd       	out	0x2e, r24	; 46
    1026:	8e b5       	in	r24, 0x2e	; 46
    1028:	82 60       	ori	r24, 0x02	; 2
    102a:	8e bd       	out	0x2e, r24	; 46
    102c:	8e b5       	in	r24, 0x2e	; 46
    102e:	8b 7f       	andi	r24, 0xFB	; 251
    1030:	8e bd       	out	0x2e, r24	; 46
    1032:	80 e0       	ldi	r24, 0x00	; 0
    1034:	b3 c0       	rjmp	.+358    	; 0x119c <set_prescalar+0x306>
    1036:	8e b5       	in	r24, 0x2e	; 46
    1038:	8e 7f       	andi	r24, 0xFE	; 254
    103a:	8e bd       	out	0x2e, r24	; 46
    103c:	8e b5       	in	r24, 0x2e	; 46
    103e:	8d 7f       	andi	r24, 0xFD	; 253
    1040:	8e bd       	out	0x2e, r24	; 46
    1042:	8e b5       	in	r24, 0x2e	; 46
    1044:	84 60       	ori	r24, 0x04	; 4
    1046:	8e bd       	out	0x2e, r24	; 46
    1048:	80 e0       	ldi	r24, 0x00	; 0
    104a:	a8 c0       	rjmp	.+336    	; 0x119c <set_prescalar+0x306>
    104c:	8e b5       	in	r24, 0x2e	; 46
    104e:	81 60       	ori	r24, 0x01	; 1
    1050:	8e bd       	out	0x2e, r24	; 46
    1052:	8e b5       	in	r24, 0x2e	; 46
    1054:	8d 7f       	andi	r24, 0xFD	; 253
    1056:	8e bd       	out	0x2e, r24	; 46
    1058:	8e b5       	in	r24, 0x2e	; 46
    105a:	84 60       	ori	r24, 0x04	; 4
    105c:	8e bd       	out	0x2e, r24	; 46
    105e:	80 e0       	ldi	r24, 0x00	; 0
    1060:	9d c0       	rjmp	.+314    	; 0x119c <set_prescalar+0x306>
    1062:	c2 30       	cpi	r28, 0x02	; 2
    1064:	d1 05       	cpc	r29, r1
    1066:	a8 f0       	brcs	.+42     	; 0x1092 <set_prescalar+0x1fc>
    1068:	c8 30       	cpi	r28, 0x08	; 8
    106a:	d1 05       	cpc	r29, r1
    106c:	91 f0       	breq	.+36     	; 0x1092 <set_prescalar+0x1fc>
    106e:	c0 32       	cpi	r28, 0x20	; 32
    1070:	d1 05       	cpc	r29, r1
    1072:	79 f0       	breq	.+30     	; 0x1092 <set_prescalar+0x1fc>
    1074:	c0 34       	cpi	r28, 0x40	; 64
    1076:	d1 05       	cpc	r29, r1
    1078:	61 f0       	breq	.+24     	; 0x1092 <set_prescalar+0x1fc>
    107a:	c0 38       	cpi	r28, 0x80	; 128
    107c:	d1 05       	cpc	r29, r1
    107e:	49 f0       	breq	.+18     	; 0x1092 <set_prescalar+0x1fc>
    1080:	c1 15       	cp	r28, r1
    1082:	81 e0       	ldi	r24, 0x01	; 1
    1084:	d8 07       	cpc	r29, r24
    1086:	29 f0       	breq	.+10     	; 0x1092 <set_prescalar+0x1fc>
    1088:	c1 15       	cp	r28, r1
    108a:	84 e0       	ldi	r24, 0x04	; 4
    108c:	d8 07       	cpc	r29, r24
    108e:	09 f0       	breq	.+2      	; 0x1092 <set_prescalar+0x1fc>
    1090:	82 c0       	rjmp	.+260    	; 0x1196 <set_prescalar+0x300>
    1092:	c0 32       	cpi	r28, 0x20	; 32
    1094:	d1 05       	cpc	r29, r1
    1096:	e1 f1       	breq	.+120    	; 0x1110 <set_prescalar+0x27a>
    1098:	38 f4       	brcc	.+14     	; 0x10a8 <set_prescalar+0x212>
    109a:	c1 30       	cpi	r28, 0x01	; 1
    109c:	d1 05       	cpc	r29, r1
    109e:	11 f1       	breq	.+68     	; 0x10e4 <set_prescalar+0x24e>
    10a0:	b0 f0       	brcs	.+44     	; 0x10ce <set_prescalar+0x238>
    10a2:	28 97       	sbiw	r28, 0x08	; 8
    10a4:	51 f1       	breq	.+84     	; 0x10fa <set_prescalar+0x264>
    10a6:	79 c0       	rjmp	.+242    	; 0x119a <set_prescalar+0x304>
    10a8:	c0 38       	cpi	r28, 0x80	; 128
    10aa:	d1 05       	cpc	r29, r1
    10ac:	09 f4       	brne	.+2      	; 0x10b0 <set_prescalar+0x21a>
    10ae:	46 c0       	rjmp	.+140    	; 0x113c <set_prescalar+0x2a6>
    10b0:	20 f4       	brcc	.+8      	; 0x10ba <set_prescalar+0x224>
    10b2:	c0 34       	cpi	r28, 0x40	; 64
    10b4:	d1 05       	cpc	r29, r1
    10b6:	b9 f1       	breq	.+110    	; 0x1126 <set_prescalar+0x290>
    10b8:	70 c0       	rjmp	.+224    	; 0x119a <set_prescalar+0x304>
    10ba:	c1 15       	cp	r28, r1
    10bc:	81 e0       	ldi	r24, 0x01	; 1
    10be:	d8 07       	cpc	r29, r24
    10c0:	09 f4       	brne	.+2      	; 0x10c4 <set_prescalar+0x22e>
    10c2:	47 c0       	rjmp	.+142    	; 0x1152 <set_prescalar+0x2bc>
    10c4:	c1 15       	cp	r28, r1
    10c6:	d4 40       	sbci	r29, 0x04	; 4
    10c8:	09 f4       	brne	.+2      	; 0x10cc <set_prescalar+0x236>
    10ca:	4e c0       	rjmp	.+156    	; 0x1168 <set_prescalar+0x2d2>
    10cc:	66 c0       	rjmp	.+204    	; 0x119a <set_prescalar+0x304>
    10ce:	85 b5       	in	r24, 0x25	; 37
    10d0:	8e 7f       	andi	r24, 0xFE	; 254
    10d2:	85 bd       	out	0x25, r24	; 37
    10d4:	85 b5       	in	r24, 0x25	; 37
    10d6:	8d 7f       	andi	r24, 0xFD	; 253
    10d8:	85 bd       	out	0x25, r24	; 37
    10da:	85 b5       	in	r24, 0x25	; 37
    10dc:	8b 7f       	andi	r24, 0xFB	; 251
    10de:	85 bd       	out	0x25, r24	; 37
    10e0:	80 e0       	ldi	r24, 0x00	; 0
    10e2:	5c c0       	rjmp	.+184    	; 0x119c <set_prescalar+0x306>
    10e4:	85 b5       	in	r24, 0x25	; 37
    10e6:	81 60       	ori	r24, 0x01	; 1
    10e8:	85 bd       	out	0x25, r24	; 37
    10ea:	85 b5       	in	r24, 0x25	; 37
    10ec:	8d 7f       	andi	r24, 0xFD	; 253
    10ee:	85 bd       	out	0x25, r24	; 37
    10f0:	85 b5       	in	r24, 0x25	; 37
    10f2:	8b 7f       	andi	r24, 0xFB	; 251
    10f4:	85 bd       	out	0x25, r24	; 37
    10f6:	80 e0       	ldi	r24, 0x00	; 0
    10f8:	51 c0       	rjmp	.+162    	; 0x119c <set_prescalar+0x306>
    10fa:	85 b5       	in	r24, 0x25	; 37
    10fc:	8e 7f       	andi	r24, 0xFE	; 254
    10fe:	85 bd       	out	0x25, r24	; 37
    1100:	85 b5       	in	r24, 0x25	; 37
    1102:	82 60       	ori	r24, 0x02	; 2
    1104:	85 bd       	out	0x25, r24	; 37
    1106:	85 b5       	in	r24, 0x25	; 37
    1108:	8b 7f       	andi	r24, 0xFB	; 251
    110a:	85 bd       	out	0x25, r24	; 37
    110c:	80 e0       	ldi	r24, 0x00	; 0
    110e:	46 c0       	rjmp	.+140    	; 0x119c <set_prescalar+0x306>
    1110:	85 b5       	in	r24, 0x25	; 37
    1112:	81 60       	ori	r24, 0x01	; 1
    1114:	85 bd       	out	0x25, r24	; 37
    1116:	85 b5       	in	r24, 0x25	; 37
    1118:	82 60       	ori	r24, 0x02	; 2
    111a:	85 bd       	out	0x25, r24	; 37
    111c:	85 b5       	in	r24, 0x25	; 37
    111e:	8b 7f       	andi	r24, 0xFB	; 251
    1120:	85 bd       	out	0x25, r24	; 37
    1122:	80 e0       	ldi	r24, 0x00	; 0
    1124:	3b c0       	rjmp	.+118    	; 0x119c <set_prescalar+0x306>
    1126:	85 b5       	in	r24, 0x25	; 37
    1128:	8e 7f       	andi	r24, 0xFE	; 254
    112a:	85 bd       	out	0x25, r24	; 37
    112c:	85 b5       	in	r24, 0x25	; 37
    112e:	8d 7f       	andi	r24, 0xFD	; 253
    1130:	85 bd       	out	0x25, r24	; 37
    1132:	85 b5       	in	r24, 0x25	; 37
    1134:	84 60       	ori	r24, 0x04	; 4
    1136:	85 bd       	out	0x25, r24	; 37
    1138:	80 e0       	ldi	r24, 0x00	; 0
    113a:	30 c0       	rjmp	.+96     	; 0x119c <set_prescalar+0x306>
    113c:	85 b5       	in	r24, 0x25	; 37
    113e:	81 60       	ori	r24, 0x01	; 1
    1140:	85 bd       	out	0x25, r24	; 37
    1142:	85 b5       	in	r24, 0x25	; 37
    1144:	8d 7f       	andi	r24, 0xFD	; 253
    1146:	85 bd       	out	0x25, r24	; 37
    1148:	85 b5       	in	r24, 0x25	; 37
    114a:	84 60       	ori	r24, 0x04	; 4
    114c:	85 bd       	out	0x25, r24	; 37
    114e:	80 e0       	ldi	r24, 0x00	; 0
    1150:	25 c0       	rjmp	.+74     	; 0x119c <set_prescalar+0x306>
    1152:	85 b5       	in	r24, 0x25	; 37
    1154:	8e 7f       	andi	r24, 0xFE	; 254
    1156:	85 bd       	out	0x25, r24	; 37
    1158:	85 b5       	in	r24, 0x25	; 37
    115a:	82 60       	ori	r24, 0x02	; 2
    115c:	85 bd       	out	0x25, r24	; 37
    115e:	85 b5       	in	r24, 0x25	; 37
    1160:	84 60       	ori	r24, 0x04	; 4
    1162:	85 bd       	out	0x25, r24	; 37
    1164:	80 e0       	ldi	r24, 0x00	; 0
    1166:	1a c0       	rjmp	.+52     	; 0x119c <set_prescalar+0x306>
    1168:	85 b5       	in	r24, 0x25	; 37
    116a:	81 60       	ori	r24, 0x01	; 1
    116c:	85 bd       	out	0x25, r24	; 37
    116e:	85 b5       	in	r24, 0x25	; 37
    1170:	82 60       	ori	r24, 0x02	; 2
    1172:	85 bd       	out	0x25, r24	; 37
    1174:	85 b5       	in	r24, 0x25	; 37
    1176:	84 60       	ori	r24, 0x04	; 4
    1178:	85 bd       	out	0x25, r24	; 37
    117a:	80 e0       	ldi	r24, 0x00	; 0
    117c:	0f c0       	rjmp	.+30     	; 0x119c <set_prescalar+0x306>
    117e:	81 e0       	ldi	r24, 0x01	; 1
    1180:	0d c0       	rjmp	.+26     	; 0x119c <set_prescalar+0x306>
    1182:	80 e0       	ldi	r24, 0x00	; 0
    1184:	0b c0       	rjmp	.+22     	; 0x119c <set_prescalar+0x306>
    1186:	82 e0       	ldi	r24, 0x02	; 2
    1188:	09 c0       	rjmp	.+18     	; 0x119c <set_prescalar+0x306>
    118a:	80 e0       	ldi	r24, 0x00	; 0
    118c:	07 c0       	rjmp	.+14     	; 0x119c <set_prescalar+0x306>
    118e:	82 e0       	ldi	r24, 0x02	; 2
    1190:	05 c0       	rjmp	.+10     	; 0x119c <set_prescalar+0x306>
    1192:	80 e0       	ldi	r24, 0x00	; 0
    1194:	03 c0       	rjmp	.+6      	; 0x119c <set_prescalar+0x306>
    1196:	82 e0       	ldi	r24, 0x02	; 2
    1198:	01 c0       	rjmp	.+2      	; 0x119c <set_prescalar+0x306>
    119a:	80 e0       	ldi	r24, 0x00	; 0
    119c:	df 91       	pop	r29
    119e:	cf 91       	pop	r28
    11a0:	1f 91       	pop	r17
    11a2:	08 95       	ret

000011a4 <Timer_normal_init>:
    11a4:	0f 93       	push	r16
    11a6:	1f 93       	push	r17
    11a8:	cf 93       	push	r28
    11aa:	c8 2f       	mov	r28, r24
    11ac:	8b 01       	movw	r16, r22
    11ae:	0e 94 45 07 	call	0xe8a	; 0xe8a <isValidTimer>
    11b2:	88 23       	and	r24, r24
    11b4:	81 f1       	breq	.+96     	; 0x1216 <Timer_normal_init+0x72>
    11b6:	cc 23       	and	r28, r28
    11b8:	11 f0       	breq	.+4      	; 0x11be <Timer_normal_init+0x1a>
    11ba:	c2 30       	cpi	r28, 0x02	; 2
    11bc:	21 f4       	brne	.+8      	; 0x11c6 <Timer_normal_init+0x22>
    11be:	0f 3f       	cpi	r16, 0xFF	; 255
    11c0:	11 05       	cpc	r17, r1
    11c2:	09 f0       	breq	.+2      	; 0x11c6 <Timer_normal_init+0x22>
    11c4:	50 f5       	brcc	.+84     	; 0x121a <Timer_normal_init+0x76>
    11c6:	c1 30       	cpi	r28, 0x01	; 1
    11c8:	69 f0       	breq	.+26     	; 0x11e4 <Timer_normal_init+0x40>
    11ca:	18 f0       	brcs	.+6      	; 0x11d2 <Timer_normal_init+0x2e>
    11cc:	c2 30       	cpi	r28, 0x02	; 2
    11ce:	d1 f0       	breq	.+52     	; 0x1204 <Timer_normal_init+0x60>
    11d0:	26 c0       	rjmp	.+76     	; 0x121e <Timer_normal_init+0x7a>
    11d2:	83 b7       	in	r24, 0x33	; 51
    11d4:	87 7f       	andi	r24, 0xF7	; 247
    11d6:	83 bf       	out	0x33, r24	; 51
    11d8:	83 b7       	in	r24, 0x33	; 51
    11da:	8f 7b       	andi	r24, 0xBF	; 191
    11dc:	83 bf       	out	0x33, r24	; 51
    11de:	02 bf       	out	0x32, r16	; 50
    11e0:	80 e0       	ldi	r24, 0x00	; 0
    11e2:	1e c0       	rjmp	.+60     	; 0x1220 <Timer_normal_init+0x7c>
    11e4:	8f b5       	in	r24, 0x2f	; 47
    11e6:	8e 7f       	andi	r24, 0xFE	; 254
    11e8:	8f bd       	out	0x2f, r24	; 47
    11ea:	8f b5       	in	r24, 0x2f	; 47
    11ec:	8d 7f       	andi	r24, 0xFD	; 253
    11ee:	8f bd       	out	0x2f, r24	; 47
    11f0:	8e b5       	in	r24, 0x2e	; 46
    11f2:	87 7f       	andi	r24, 0xF7	; 247
    11f4:	8e bd       	out	0x2e, r24	; 46
    11f6:	8e b5       	in	r24, 0x2e	; 46
    11f8:	8f 7e       	andi	r24, 0xEF	; 239
    11fa:	8e bd       	out	0x2e, r24	; 46
    11fc:	1d bd       	out	0x2d, r17	; 45
    11fe:	0c bd       	out	0x2c, r16	; 44
    1200:	80 e0       	ldi	r24, 0x00	; 0
    1202:	0e c0       	rjmp	.+28     	; 0x1220 <Timer_normal_init+0x7c>
    1204:	85 b5       	in	r24, 0x25	; 37
    1206:	87 7f       	andi	r24, 0xF7	; 247
    1208:	85 bd       	out	0x25, r24	; 37
    120a:	85 b5       	in	r24, 0x25	; 37
    120c:	8f 7b       	andi	r24, 0xBF	; 191
    120e:	85 bd       	out	0x25, r24	; 37
    1210:	04 bd       	out	0x24, r16	; 36
    1212:	80 e0       	ldi	r24, 0x00	; 0
    1214:	05 c0       	rjmp	.+10     	; 0x1220 <Timer_normal_init+0x7c>
    1216:	81 e0       	ldi	r24, 0x01	; 1
    1218:	03 c0       	rjmp	.+6      	; 0x1220 <Timer_normal_init+0x7c>
    121a:	83 e0       	ldi	r24, 0x03	; 3
    121c:	01 c0       	rjmp	.+2      	; 0x1220 <Timer_normal_init+0x7c>
    121e:	80 e0       	ldi	r24, 0x00	; 0
    1220:	cf 91       	pop	r28
    1222:	1f 91       	pop	r17
    1224:	0f 91       	pop	r16
    1226:	08 95       	ret

00001228 <Timer_start>:
    1228:	0f 93       	push	r16
    122a:	1f 93       	push	r17
    122c:	cf 93       	push	r28
    122e:	c8 2f       	mov	r28, r24
    1230:	8b 01       	movw	r16, r22
    1232:	0e 94 45 07 	call	0xe8a	; 0xe8a <isValidTimer>
    1236:	88 23       	and	r24, r24
    1238:	31 f0       	breq	.+12     	; 0x1246 <Timer_start+0x1e>
    123a:	b8 01       	movw	r22, r16
    123c:	8c 2f       	mov	r24, r28
    123e:	0e 94 4b 07 	call	0xe96	; 0xe96 <set_prescalar>
    1242:	80 e0       	ldi	r24, 0x00	; 0
    1244:	01 c0       	rjmp	.+2      	; 0x1248 <Timer_start+0x20>
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	cf 91       	pop	r28
    124a:	1f 91       	pop	r17
    124c:	0f 91       	pop	r16
    124e:	08 95       	ret

00001250 <PWM_OCP_disconnect>:

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    1250:	84 30       	cpi	r24, 0x04	; 4
    1252:	40 f5       	brcc	.+80     	; 0x12a4 <PWM_OCP_disconnect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    1254:	81 30       	cpi	r24, 0x01	; 1
    1256:	71 f0       	breq	.+28     	; 0x1274 <PWM_OCP_disconnect+0x24>
    1258:	28 f0       	brcs	.+10     	; 0x1264 <PWM_OCP_disconnect+0x14>
    125a:	82 30       	cpi	r24, 0x02	; 2
    125c:	99 f0       	breq	.+38     	; 0x1284 <PWM_OCP_disconnect+0x34>
    125e:	83 30       	cpi	r24, 0x03	; 3
    1260:	c9 f0       	breq	.+50     	; 0x1294 <PWM_OCP_disconnect+0x44>
    1262:	22 c0       	rjmp	.+68     	; 0x12a8 <PWM_OCP_disconnect+0x58>
      case OC_0:
        clear_bit(TCCR0, COM00);
    1264:	83 b7       	in	r24, 0x33	; 51
    1266:	8f 7e       	andi	r24, 0xEF	; 239
    1268:	83 bf       	out	0x33, r24	; 51
        clear_bit(TCCR0, COM01);
    126a:	83 b7       	in	r24, 0x33	; 51
    126c:	8f 7d       	andi	r24, 0xDF	; 223
    126e:	83 bf       	out	0x33, r24	; 51
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1270:	80 e0       	ldi	r24, 0x00	; 0
    }
  switch (pwmPin) {
      case OC_0:
        clear_bit(TCCR0, COM00);
        clear_bit(TCCR0, COM01);
        break;
    1272:	08 95       	ret
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
    1274:	8f b5       	in	r24, 0x2f	; 47
    1276:	8f 7b       	andi	r24, 0xBF	; 191
    1278:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1A1);
    127a:	8f b5       	in	r24, 0x2f	; 47
    127c:	8f 77       	andi	r24, 0x7F	; 127
    127e:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1280:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR0, COM01);
        break;
      case OC_1A:
        clear_bit(TCCR1A, COM1A0);
        clear_bit(TCCR1A, COM1A1);
        break;
    1282:	08 95       	ret
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
    1284:	8f b5       	in	r24, 0x2f	; 47
    1286:	8f 7e       	andi	r24, 0xEF	; 239
    1288:	8f bd       	out	0x2f, r24	; 47
        clear_bit(TCCR1A, COM1B1);
    128a:	8f b5       	in	r24, 0x2f	; 47
    128c:	8f 7d       	andi	r24, 0xDF	; 223
    128e:	8f bd       	out	0x2f, r24	; 47
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    1290:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1A1);
        break;
      case OC_1B:
        clear_bit(TCCR1A, COM1B0);
        clear_bit(TCCR1A, COM1B1);
        break;
    1292:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
    1294:	85 b5       	in	r24, 0x25	; 37
    1296:	8f 7e       	andi	r24, 0xEF	; 239
    1298:	85 bd       	out	0x25, r24	; 37
        clear_bit(TCCR2, COM21);
    129a:	85 b5       	in	r24, 0x25	; 37
    129c:	8f 7d       	andi	r24, 0xDF	; 223
    129e:	85 bd       	out	0x25, r24	; 37
        break;
    }
  return TIMER_OK;
    12a0:	80 e0       	ldi	r24, 0x00	; 0
        clear_bit(TCCR1A, COM1B1);
        break;
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    12a2:	08 95       	ret
  }

// disconnects the OC pins.
EN_timerError_t PWM_OCP_disconnect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    12a4:	87 e0       	ldi	r24, 0x07	; 7
    12a6:	08 95       	ret
      case OC_2:
        clear_bit(TCCR2, COM20);
        clear_bit(TCCR2, COM21);
        break;
    }
  return TIMER_OK;
    12a8:	80 e0       	ldi	r24, 0x00	; 0
  }
    12aa:	08 95       	ret

000012ac <PWM_OCP_connect>:

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    12ac:	84 30       	cpi	r24, 0x04	; 4
    12ae:	40 f5       	brcc	.+80     	; 0x1300 <PWM_OCP_connect+0x54>
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    12b0:	81 30       	cpi	r24, 0x01	; 1
    12b2:	71 f0       	breq	.+28     	; 0x12d0 <PWM_OCP_connect+0x24>
    12b4:	28 f0       	brcs	.+10     	; 0x12c0 <PWM_OCP_connect+0x14>
    12b6:	82 30       	cpi	r24, 0x02	; 2
    12b8:	99 f0       	breq	.+38     	; 0x12e0 <PWM_OCP_connect+0x34>
    12ba:	83 30       	cpi	r24, 0x03	; 3
    12bc:	c9 f0       	breq	.+50     	; 0x12f0 <PWM_OCP_connect+0x44>
    12be:	22 c0       	rjmp	.+68     	; 0x1304 <PWM_OCP_connect+0x58>
      case OC_0:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR0, COM00);
    12c0:	83 b7       	in	r24, 0x33	; 51
    12c2:	8f 7e       	andi	r24, 0xEF	; 239
    12c4:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR0, COM01);
    12c6:	83 b7       	in	r24, 0x33	; 51
    12c8:	80 62       	ori	r24, 0x20	; 32
    12ca:	83 bf       	out	0x33, r24	; 51
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    12cc:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR0, COM01);
#else 
        set_bit(TCCR0, COM00);
        set_bit(TCCR0, COM01);
#endif
        break;
    12ce:	08 95       	ret
      case OC_1A:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1A0);
    12d0:	8f b5       	in	r24, 0x2f	; 47
    12d2:	8f 7b       	andi	r24, 0xBF	; 191
    12d4:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1A1);
    12d6:	8f b5       	in	r24, 0x2f	; 47
    12d8:	80 68       	ori	r24, 0x80	; 128
    12da:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    12dc:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1A1);
#else 
        set_bit(TCCR1A, COM1A0);
        set_bit(TCCR1A, COM1A1);
#endif
        break;
    12de:	08 95       	ret
      case OC_1B:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR1A, COM1B0);
    12e0:	8f b5       	in	r24, 0x2f	; 47
    12e2:	8f 7e       	andi	r24, 0xEF	; 239
    12e4:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR1A, COM1B1);
    12e6:	8f b5       	in	r24, 0x2f	; 47
    12e8:	80 62       	ori	r24, 0x20	; 32
    12ea:	8f bd       	out	0x2f, r24	; 47
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    12ec:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR1A, COM1B1);
#else 
        set_bit(TCCR1A, COM1B0);
        set_bit(TCCR1A, COM1B1);
#endif
        break;
    12ee:	08 95       	ret
      case OC_2:
#if PWM_SIGNAL_INVERSION == PWM_NON_INVERTED_MODE
        clear_bit(TCCR2, COM20);
    12f0:	85 b5       	in	r24, 0x25	; 37
    12f2:	8f 7e       	andi	r24, 0xEF	; 239
    12f4:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM21);
    12f6:	85 b5       	in	r24, 0x25	; 37
    12f8:	80 62       	ori	r24, 0x20	; 32
    12fa:	85 bd       	out	0x25, r24	; 37
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    12fc:	80 e0       	ldi	r24, 0x00	; 0
        set_bit(TCCR2, COM21);
#else 
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    12fe:	08 95       	ret
  }

// Connects the OC pins.
EN_timerError_t PWM_OCP_connect(u8 pwmPin) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    1300:	87 e0       	ldi	r24, 0x07	; 7
    1302:	08 95       	ret
        set_bit(TCCR2, COM20);
        set_bit(TCCR2, COM21);
#endif
        break;
    }
  return TIMER_OK;
    1304:	80 e0       	ldi	r24, 0x00	; 0
  }
    1306:	08 95       	ret

00001308 <PWM_init>:
  return TIMER_OK;
  }

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
    1308:	cf 92       	push	r12
    130a:	df 92       	push	r13
    130c:	ef 92       	push	r14
    130e:	ff 92       	push	r15
    1310:	cf 93       	push	r28
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    1312:	84 30       	cpi	r24, 0x04	; 4
    1314:	08 f0       	brcs	.+2      	; 0x1318 <PWM_init+0x10>
    1316:	96 c0       	rjmp	.+300    	; 0x1444 <PWM_init+0x13c>
    return WRONG_PWM_PIN;
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    1318:	9f ef       	ldi	r25, 0xFF	; 255
    131a:	92 0f       	add	r25, r18
    131c:	92 30       	cpi	r25, 0x02	; 2
    131e:	08 f0       	brcs	.+2      	; 0x1322 <PWM_init+0x1a>
    1320:	93 c0       	rjmp	.+294    	; 0x1448 <PWM_init+0x140>
    1322:	6a 01       	movw	r12, r20
    1324:	7b 01       	movw	r14, r22
    1326:	c8 2f       	mov	r28, r24
    return WRONG_PWM_MODE;
    }
  switch (pwmPin) {
    1328:	83 30       	cpi	r24, 0x03	; 3
    132a:	18 f4       	brcc	.+6      	; 0x1332 <PWM_init+0x2a>
    132c:	81 30       	cpi	r24, 0x01	; 1
    132e:	28 f0       	brcs	.+10     	; 0x133a <PWM_init+0x32>
    1330:	22 c0       	rjmp	.+68     	; 0x1376 <PWM_init+0x6e>
    1332:	83 30       	cpi	r24, 0x03	; 3
    1334:	09 f4       	brne	.+2      	; 0x1338 <PWM_init+0x30>
    1336:	64 c0       	rjmp	.+200    	; 0x1400 <PWM_init+0xf8>
    1338:	80 c0       	rjmp	.+256    	; 0x143a <PWM_init+0x132>
      case OC_0:
        switch (mode) {
    133a:	21 30       	cpi	r18, 0x01	; 1
    133c:	19 f0       	breq	.+6      	; 0x1344 <PWM_init+0x3c>
    133e:	22 30       	cpi	r18, 0x02	; 2
    1340:	41 f0       	breq	.+16     	; 0x1352 <PWM_init+0x4a>
    1342:	0d c0       	rjmp	.+26     	; 0x135e <PWM_init+0x56>
            case PWM_FAST:
              set_bit(TCCR0, WGM00);
    1344:	83 b7       	in	r24, 0x33	; 51
    1346:	80 64       	ori	r24, 0x40	; 64
    1348:	83 bf       	out	0x33, r24	; 51
              set_bit(TCCR0, WGM01);
    134a:	83 b7       	in	r24, 0x33	; 51
    134c:	88 60       	ori	r24, 0x08	; 8
    134e:	83 bf       	out	0x33, r24	; 51
              break;
    1350:	06 c0       	rjmp	.+12     	; 0x135e <PWM_init+0x56>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR0, WGM00);
    1352:	83 b7       	in	r24, 0x33	; 51
    1354:	80 64       	ori	r24, 0x40	; 64
    1356:	83 bf       	out	0x33, r24	; 51
              clear_bit(TCCR0, WGM01);
    1358:	83 b7       	in	r24, 0x33	; 51
    135a:	87 7f       	andi	r24, 0xF7	; 247
    135c:	83 bf       	out	0x33, r24	; 51
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR0 = (u8)(dutyCycle * 255);
    135e:	20 e0       	ldi	r18, 0x00	; 0
    1360:	30 e0       	ldi	r19, 0x00	; 0
    1362:	4f e7       	ldi	r20, 0x7F	; 127
    1364:	53 e4       	ldi	r21, 0x43	; 67
    1366:	c7 01       	movw	r24, r14
    1368:	b6 01       	movw	r22, r12
    136a:	0e 94 51 18 	call	0x30a2	; 0x30a2 <__mulsf3>
    136e:	0e 94 94 17 	call	0x2f28	; 0x2f28 <__fixunssfsi>
    1372:	6c bf       	out	0x3c, r22	; 60
        break;
    1374:	62 c0       	rjmp	.+196    	; 0x143a <PWM_init+0x132>
        //? The fix for this issue is to use ICR1 as TOP instead (mode 14 in fast pwm), thus allowing OCR1A and OCR1B to be used to set the duty cycle while ICR1 is used tyo set the frequency.
        //? Mode 15 can be used at the cost of disabling PWM on OC1A, but we get more glitch-free variable frequency PWM signal on OC1B due to the double buffering of OC1A, which ICR1 doesn't have.
        //? Since I don't need a variable frequency pwm signal, ICR1 will be used as TOP by default and set to MAX.
      case OC_1A:
      case OC_1B:
        switch (mode) {
    1376:	21 30       	cpi	r18, 0x01	; 1
    1378:	19 f0       	breq	.+6      	; 0x1380 <PWM_init+0x78>
    137a:	22 30       	cpi	r18, 0x02	; 2
    137c:	91 f0       	breq	.+36     	; 0x13a2 <PWM_init+0x9a>
    137e:	21 c0       	rjmp	.+66     	; 0x13c2 <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
    1380:	8f b5       	in	r24, 0x2f	; 47
    1382:	8e 7f       	andi	r24, 0xFE	; 254
    1384:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
    1386:	8f b5       	in	r24, 0x2f	; 47
    1388:	82 60       	ori	r24, 0x02	; 2
    138a:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1B, WGM12);
    138c:	8e b5       	in	r24, 0x2e	; 46
    138e:	88 60       	ori	r24, 0x08	; 8
    1390:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
    1392:	8e b5       	in	r24, 0x2e	; 46
    1394:	80 61       	ori	r24, 0x10	; 16
    1396:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
    1398:	80 e2       	ldi	r24, 0x20	; 32
    139a:	9e e4       	ldi	r25, 0x4E	; 78
    139c:	97 bd       	out	0x27, r25	; 39
    139e:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              set_bit(TCCR1B, WGM12);
              set_bit(TCCR1B, WGM13);
#endif
              break;
    13a0:	10 c0       	rjmp	.+32     	; 0x13c2 <PWM_init+0xba>
              set_bit(TCCR1A, WGM10);
              set_bit(TCCR1A, WGM11);
              clear_bit(TCCR1B, WGM12);
              clear_bit(TCCR1B, WGM13);
#elif TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1
              clear_bit(TCCR1A, WGM10);
    13a2:	8f b5       	in	r24, 0x2f	; 47
    13a4:	8e 7f       	andi	r24, 0xFE	; 254
    13a6:	8f bd       	out	0x2f, r24	; 47
              set_bit(TCCR1A, WGM11);
    13a8:	8f b5       	in	r24, 0x2f	; 47
    13aa:	82 60       	ori	r24, 0x02	; 2
    13ac:	8f bd       	out	0x2f, r24	; 47
              clear_bit(TCCR1B, WGM12);
    13ae:	8e b5       	in	r24, 0x2e	; 46
    13b0:	87 7f       	andi	r24, 0xF7	; 247
    13b2:	8e bd       	out	0x2e, r24	; 46
              set_bit(TCCR1B, WGM13);
    13b4:	8e b5       	in	r24, 0x2e	; 46
    13b6:	80 61       	ori	r24, 0x10	; 16
    13b8:	8e bd       	out	0x2e, r24	; 46
              ICR1 = TIMER_1_PWM_TOP_ICR1_VALUE;
    13ba:	80 e2       	ldi	r24, 0x20	; 32
    13bc:	9e e4       	ldi	r25, 0x4E	; 78
    13be:	97 bd       	out	0x27, r25	; 39
    13c0:	86 bd       	out	0x26, r24	; 38
              set_bit(TCCR1B, WGM13);
#endif
              break;
          }
        // Enable the PWM function of the OC pin.
        switch (pwmPin) {
    13c2:	c1 30       	cpi	r28, 0x01	; 1
    13c4:	19 f0       	breq	.+6      	; 0x13cc <PWM_init+0xc4>
    13c6:	c2 30       	cpi	r28, 0x02	; 2
    13c8:	71 f0       	breq	.+28     	; 0x13e6 <PWM_init+0xde>
    13ca:	37 c0       	rjmp	.+110    	; 0x143a <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    13cc:	20 e0       	ldi	r18, 0x00	; 0
    13ce:	30 e4       	ldi	r19, 0x40	; 64
    13d0:	4c e9       	ldi	r20, 0x9C	; 156
    13d2:	56 e4       	ldi	r21, 0x46	; 70
    13d4:	c7 01       	movw	r24, r14
    13d6:	b6 01       	movw	r22, r12
    13d8:	0e 94 51 18 	call	0x30a2	; 0x30a2 <__mulsf3>
    13dc:	0e 94 94 17 	call	0x2f28	; 0x2f28 <__fixunssfsi>
    13e0:	7b bd       	out	0x2b, r23	; 43
    13e2:	6a bd       	out	0x2a, r22	; 42
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1A = (u16)(dutyCycle * 65535);
#endif
              break;
    13e4:	2a c0       	rjmp	.+84     	; 0x143a <PWM_init+0x132>
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
              OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
              OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
              OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    13e6:	20 e0       	ldi	r18, 0x00	; 0
    13e8:	30 e4       	ldi	r19, 0x40	; 64
    13ea:	4c e9       	ldi	r20, 0x9C	; 156
    13ec:	56 e4       	ldi	r21, 0x46	; 70
    13ee:	c7 01       	movw	r24, r14
    13f0:	b6 01       	movw	r22, r12
    13f2:	0e 94 51 18 	call	0x30a2	; 0x30a2 <__mulsf3>
    13f6:	0e 94 94 17 	call	0x2f28	; 0x2f28 <__fixunssfsi>
    13fa:	79 bd       	out	0x29, r23	; 41
    13fc:	68 bd       	out	0x28, r22	; 40
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
              OCR1B = (u16)(dutyCycle * 65535);
#endif
              break;
    13fe:	1d c0       	rjmp	.+58     	; 0x143a <PWM_init+0x132>
          }
        break;
      case OC_2:
        switch (mode) {
    1400:	21 30       	cpi	r18, 0x01	; 1
    1402:	19 f0       	breq	.+6      	; 0x140a <PWM_init+0x102>
    1404:	22 30       	cpi	r18, 0x02	; 2
    1406:	41 f0       	breq	.+16     	; 0x1418 <PWM_init+0x110>
    1408:	0d c0       	rjmp	.+26     	; 0x1424 <PWM_init+0x11c>
            case PWM_FAST:
              set_bit(TCCR2, WGM20);
    140a:	85 b5       	in	r24, 0x25	; 37
    140c:	80 64       	ori	r24, 0x40	; 64
    140e:	85 bd       	out	0x25, r24	; 37
              set_bit(TCCR2, WGM21);
    1410:	85 b5       	in	r24, 0x25	; 37
    1412:	88 60       	ori	r24, 0x08	; 8
    1414:	85 bd       	out	0x25, r24	; 37
              break;
    1416:	06 c0       	rjmp	.+12     	; 0x1424 <PWM_init+0x11c>
            case PWM_PHASE_CORRECT:
              set_bit(TCCR2, WGM20);
    1418:	85 b5       	in	r24, 0x25	; 37
    141a:	80 64       	ori	r24, 0x40	; 64
    141c:	85 bd       	out	0x25, r24	; 37
              clear_bit(TCCR2, WGM21);
    141e:	85 b5       	in	r24, 0x25	; 37
    1420:	87 7f       	andi	r24, 0xF7	; 247
    1422:	85 bd       	out	0x25, r24	; 37
              break;
          }
        // The value in the OCR determines the duty cycle
        OCR2 = (u8)(dutyCycle * 255);
    1424:	20 e0       	ldi	r18, 0x00	; 0
    1426:	30 e0       	ldi	r19, 0x00	; 0
    1428:	4f e7       	ldi	r20, 0x7F	; 127
    142a:	53 e4       	ldi	r21, 0x43	; 67
    142c:	c7 01       	movw	r24, r14
    142e:	b6 01       	movw	r22, r12
    1430:	0e 94 51 18 	call	0x30a2	; 0x30a2 <__mulsf3>
    1434:	0e 94 94 17 	call	0x2f28	; 0x2f28 <__fixunssfsi>
    1438:	63 bd       	out	0x23, r22	; 35
        break;
    }
  PWM_OCP_connect(pwmPin);
    143a:	8c 2f       	mov	r24, r28
    143c:	0e 94 56 09 	call	0x12ac	; 0x12ac <PWM_OCP_connect>
  return TIMER_OK;
    1440:	80 e0       	ldi	r24, 0x00	; 0
    1442:	03 c0       	rjmp	.+6      	; 0x144a <PWM_init+0x142>

// *The pwm frequency can be calculated from the equation: (F_CPU/(N*256)) for fast pwm and (F_CPU/(N*510)) for phase correct pwm
// Initialize the timers to start in pwm mode
EN_timerError_t PWM_init(u8 pwmPin, double dutyCycle, u8 mode) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    1444:	87 e0       	ldi	r24, 0x07	; 7
    1446:	01 c0       	rjmp	.+2      	; 0x144a <PWM_init+0x142>
    }
  if (mode != PWM_FAST && mode != PWM_PHASE_CORRECT) {
    return WRONG_PWM_MODE;
    1448:	86 e0       	ldi	r24, 0x06	; 6
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  PWM_OCP_connect(pwmPin);
  return TIMER_OK;
  }
    144a:	cf 91       	pop	r28
    144c:	ff 90       	pop	r15
    144e:	ef 90       	pop	r14
    1450:	df 90       	pop	r13
    1452:	cf 90       	pop	r12
    1454:	08 95       	ret

00001456 <PWM_set_DC>:
    }
  return TIMER_OK;
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
    1456:	28 2f       	mov	r18, r24
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    1458:	84 30       	cpi	r24, 0x04	; 4
    145a:	c0 f5       	brcc	.+112    	; 0x14cc <PWM_set_DC+0x76>
    145c:	cb 01       	movw	r24, r22
    145e:	ba 01       	movw	r22, r20
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
    1460:	21 30       	cpi	r18, 0x01	; 1
    1462:	89 f0       	breq	.+34     	; 0x1486 <PWM_set_DC+0x30>
    1464:	28 f0       	brcs	.+10     	; 0x1470 <PWM_set_DC+0x1a>
    1466:	22 30       	cpi	r18, 0x02	; 2
    1468:	d1 f0       	breq	.+52     	; 0x149e <PWM_set_DC+0x48>
    146a:	23 30       	cpi	r18, 0x03	; 3
    146c:	21 f1       	breq	.+72     	; 0x14b6 <PWM_set_DC+0x60>
    146e:	30 c0       	rjmp	.+96     	; 0x14d0 <PWM_set_DC+0x7a>
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
    1470:	20 e0       	ldi	r18, 0x00	; 0
    1472:	30 e0       	ldi	r19, 0x00	; 0
    1474:	4f e7       	ldi	r20, 0x7F	; 127
    1476:	53 e4       	ldi	r21, 0x43	; 67
    1478:	0e 94 51 18 	call	0x30a2	; 0x30a2 <__mulsf3>
    147c:	0e 94 94 17 	call	0x2f28	; 0x2f28 <__fixunssfsi>
    1480:	6c bf       	out	0x3c, r22	; 60
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    1482:	80 e0       	ldi	r24, 0x00	; 0
    return WRONG_PWM_PIN;
    }
  switch (pwmPin) {
      case OC_0:
        OCR0 = (u8)(dutyCycle * 255);
        break;
    1484:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1A = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1A = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    1486:	20 e0       	ldi	r18, 0x00	; 0
    1488:	30 e4       	ldi	r19, 0x40	; 64
    148a:	4c e9       	ldi	r20, 0x9C	; 156
    148c:	56 e4       	ldi	r21, 0x46	; 70
    148e:	0e 94 51 18 	call	0x30a2	; 0x30a2 <__mulsf3>
    1492:	0e 94 94 17 	call	0x2f28	; 0x2f28 <__fixunssfsi>
    1496:	7b bd       	out	0x2b, r23	; 43
    1498:	6a bd       	out	0x2a, r22	; 42
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    149a:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1A = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1A = (u16)(dutyCycle * 65535);
#endif
        break;
    149c:	08 95       	ret
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_9_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_9_BIT)
        OCR1B = (u16)(dutyCycle * 0x01FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_10_BIT || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_10_BIT)
        OCR1B = (u16)(dutyCycle * 0x03FF);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
    149e:	20 e0       	ldi	r18, 0x00	; 0
    14a0:	30 e4       	ldi	r19, 0x40	; 64
    14a2:	4c e9       	ldi	r20, 0x9C	; 156
    14a4:	56 e4       	ldi	r21, 0x46	; 70
    14a6:	0e 94 51 18 	call	0x30a2	; 0x30a2 <__mulsf3>
    14aa:	0e 94 94 17 	call	0x2f28	; 0x2f28 <__fixunssfsi>
    14ae:	79 bd       	out	0x29, r23	; 41
    14b0:	68 bd       	out	0x28, r22	; 40
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    14b2:	80 e0       	ldi	r24, 0x00	; 0
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_ICR1 || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_ICR1)
        OCR1B = (u16)(dutyCycle * TIMER_1_PWM_TOP_ICR1_VALUE);
#elif (TIMER_1_FAST_PWM_MODE == TIMER_1_FAST_PWM_TOP_OCR1A || TIMER_1_PHASE_CORRECT_PWM_MODE == TIMER_1_PHASE_CORRECT_PWM_TOP_OCR1A)
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
    14b4:	08 95       	ret
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
    14b6:	20 e0       	ldi	r18, 0x00	; 0
    14b8:	30 e0       	ldi	r19, 0x00	; 0
    14ba:	4f e7       	ldi	r20, 0x7F	; 127
    14bc:	53 e4       	ldi	r21, 0x43	; 67
    14be:	0e 94 51 18 	call	0x30a2	; 0x30a2 <__mulsf3>
    14c2:	0e 94 94 17 	call	0x2f28	; 0x2f28 <__fixunssfsi>
    14c6:	63 bd       	out	0x23, r22	; 35
        break;
    }
  return TIMER_OK;
    14c8:	80 e0       	ldi	r24, 0x00	; 0
        OCR1B = (u16)(dutyCycle * 65535);
#endif
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    14ca:	08 95       	ret
  }

// Change the duty cycle of a timer
EN_timerError_t PWM_set_DC(u8 pwmPin, double dutyCycle) {
  if (pwmPin != OC_0 && pwmPin != OC_1A && pwmPin != OC_1B && pwmPin != OC_2) {
    return WRONG_PWM_PIN;
    14cc:	87 e0       	ldi	r24, 0x07	; 7
    14ce:	08 95       	ret
        break;
      case OC_2:
        OCR2 = (u8)(dutyCycle * 255);
        break;
    }
  return TIMER_OK;
    14d0:	80 e0       	ldi	r24, 0x00	; 0
  }
    14d2:	08 95       	ret

000014d4 <UART_init>:
  }

// Receive a Char using UART
void UART_receiveChar(s8* x) {
  while (!read_bit(UCSRA, RXC)); // Wait for the data to be received.
  *x = UDR;
    14d4:	61 15       	cp	r22, r1
    14d6:	26 e9       	ldi	r18, 0x96	; 150
    14d8:	72 07       	cpc	r23, r18
    14da:	81 05       	cpc	r24, r1
    14dc:	91 05       	cpc	r25, r1
    14de:	09 f4       	brne	.+2      	; 0x14e2 <UART_init+0xe>
    14e0:	72 c0       	rjmp	.+228    	; 0x15c6 <UART_init+0xf2>
    14e2:	58 f5       	brcc	.+86     	; 0x153a <UART_init+0x66>
    14e4:	60 38       	cpi	r22, 0x80	; 128
    14e6:	25 e2       	ldi	r18, 0x25	; 37
    14e8:	72 07       	cpc	r23, r18
    14ea:	81 05       	cpc	r24, r1
    14ec:	91 05       	cpc	r25, r1
    14ee:	09 f4       	brne	.+2      	; 0x14f2 <UART_init+0x1e>
    14f0:	5e c0       	rjmp	.+188    	; 0x15ae <UART_init+0xda>
    14f2:	70 f4       	brcc	.+28     	; 0x1510 <UART_init+0x3c>
    14f4:	60 36       	cpi	r22, 0x60	; 96
    14f6:	29 e0       	ldi	r18, 0x09	; 9
    14f8:	72 07       	cpc	r23, r18
    14fa:	81 05       	cpc	r24, r1
    14fc:	91 05       	cpc	r25, r1
    14fe:	09 f4       	brne	.+2      	; 0x1502 <UART_init+0x2e>
    1500:	4e c0       	rjmp	.+156    	; 0x159e <UART_init+0xca>
    1502:	60 3c       	cpi	r22, 0xC0	; 192
    1504:	72 41       	sbci	r23, 0x12	; 18
    1506:	81 05       	cpc	r24, r1
    1508:	91 05       	cpc	r25, r1
    150a:	09 f4       	brne	.+2      	; 0x150e <UART_init+0x3a>
    150c:	4d c0       	rjmp	.+154    	; 0x15a8 <UART_init+0xd4>
    150e:	82 c0       	rjmp	.+260    	; 0x1614 <UART_init+0x140>
    1510:	61 15       	cp	r22, r1
    1512:	2b e4       	ldi	r18, 0x4B	; 75
    1514:	72 07       	cpc	r23, r18
    1516:	81 05       	cpc	r24, r1
    1518:	91 05       	cpc	r25, r1
    151a:	09 f4       	brne	.+2      	; 0x151e <UART_init+0x4a>
    151c:	4e c0       	rjmp	.+156    	; 0x15ba <UART_init+0xe6>
    151e:	60 38       	cpi	r22, 0x80	; 128
    1520:	20 e7       	ldi	r18, 0x70	; 112
    1522:	72 07       	cpc	r23, r18
    1524:	81 05       	cpc	r24, r1
    1526:	91 05       	cpc	r25, r1
    1528:	09 f4       	brne	.+2      	; 0x152c <UART_init+0x58>
    152a:	4a c0       	rjmp	.+148    	; 0x15c0 <UART_init+0xec>
    152c:	60 34       	cpi	r22, 0x40	; 64
    152e:	78 43       	sbci	r23, 0x38	; 56
    1530:	81 05       	cpc	r24, r1
    1532:	91 05       	cpc	r25, r1
    1534:	09 f0       	breq	.+2      	; 0x1538 <UART_init+0x64>
    1536:	6e c0       	rjmp	.+220    	; 0x1614 <UART_init+0x140>
    1538:	3d c0       	rjmp	.+122    	; 0x15b4 <UART_init+0xe0>
    153a:	61 15       	cp	r22, r1
    153c:	24 e8       	ldi	r18, 0x84	; 132
    153e:	72 07       	cpc	r23, r18
    1540:	23 e0       	ldi	r18, 0x03	; 3
    1542:	82 07       	cpc	r24, r18
    1544:	91 05       	cpc	r25, r1
    1546:	09 f4       	brne	.+2      	; 0x154a <UART_init+0x76>
    1548:	4a c0       	rjmp	.+148    	; 0x15de <UART_init+0x10a>
    154a:	a8 f4       	brcc	.+42     	; 0x1576 <UART_init+0xa2>
    154c:	61 15       	cp	r22, r1
    154e:	2c e2       	ldi	r18, 0x2C	; 44
    1550:	72 07       	cpc	r23, r18
    1552:	21 e0       	ldi	r18, 0x01	; 1
    1554:	82 07       	cpc	r24, r18
    1556:	91 05       	cpc	r25, r1
    1558:	e1 f1       	breq	.+120    	; 0x15d2 <UART_init+0xfe>
    155a:	61 15       	cp	r22, r1
    155c:	22 ec       	ldi	r18, 0xC2	; 194
    155e:	72 07       	cpc	r23, r18
    1560:	21 e0       	ldi	r18, 0x01	; 1
    1562:	82 07       	cpc	r24, r18
    1564:	91 05       	cpc	r25, r1
    1566:	c1 f1       	breq	.+112    	; 0x15d8 <UART_init+0x104>
    1568:	61 15       	cp	r22, r1
    156a:	71 4e       	sbci	r23, 0xE1	; 225
    156c:	81 05       	cpc	r24, r1
    156e:	91 05       	cpc	r25, r1
    1570:	09 f0       	breq	.+2      	; 0x1574 <UART_init+0xa0>
    1572:	50 c0       	rjmp	.+160    	; 0x1614 <UART_init+0x140>
    1574:	2b c0       	rjmp	.+86     	; 0x15cc <UART_init+0xf8>
    1576:	60 32       	cpi	r22, 0x20	; 32
    1578:	21 ea       	ldi	r18, 0xA1	; 161
    157a:	72 07       	cpc	r23, r18
    157c:	27 e0       	ldi	r18, 0x07	; 7
    157e:	82 07       	cpc	r24, r18
    1580:	91 05       	cpc	r25, r1
    1582:	99 f1       	breq	.+102    	; 0x15ea <UART_init+0x116>
    1584:	60 34       	cpi	r22, 0x40	; 64
    1586:	22 e4       	ldi	r18, 0x42	; 66
    1588:	72 07       	cpc	r23, r18
    158a:	2f e0       	ldi	r18, 0x0F	; 15
    158c:	82 07       	cpc	r24, r18
    158e:	91 05       	cpc	r25, r1
    1590:	79 f1       	breq	.+94     	; 0x15f0 <UART_init+0x11c>
    1592:	60 39       	cpi	r22, 0x90	; 144
    1594:	70 4d       	sbci	r23, 0xD0	; 208
    1596:	83 40       	sbci	r24, 0x03	; 3
    1598:	91 05       	cpc	r25, r1
    159a:	e1 f5       	brne	.+120    	; 0x1614 <UART_init+0x140>
    159c:	23 c0       	rjmp	.+70     	; 0x15e4 <UART_init+0x110>
    159e:	81 e0       	ldi	r24, 0x01	; 1
    15a0:	80 bd       	out	0x20, r24	; 32
    15a2:	80 ea       	ldi	r24, 0xA0	; 160
    15a4:	89 b9       	out	0x09, r24	; 9
    15a6:	25 c0       	rjmp	.+74     	; 0x15f2 <UART_init+0x11e>
    15a8:	8f ec       	ldi	r24, 0xCF	; 207
    15aa:	89 b9       	out	0x09, r24	; 9
    15ac:	22 c0       	rjmp	.+68     	; 0x15f2 <UART_init+0x11e>
    15ae:	87 e6       	ldi	r24, 0x67	; 103
    15b0:	89 b9       	out	0x09, r24	; 9
    15b2:	1f c0       	rjmp	.+62     	; 0x15f2 <UART_init+0x11e>
    15b4:	84 e4       	ldi	r24, 0x44	; 68
    15b6:	89 b9       	out	0x09, r24	; 9
    15b8:	1c c0       	rjmp	.+56     	; 0x15f2 <UART_init+0x11e>
    15ba:	83 e3       	ldi	r24, 0x33	; 51
    15bc:	89 b9       	out	0x09, r24	; 9
    15be:	19 c0       	rjmp	.+50     	; 0x15f2 <UART_init+0x11e>
    15c0:	82 e2       	ldi	r24, 0x22	; 34
    15c2:	89 b9       	out	0x09, r24	; 9
    15c4:	16 c0       	rjmp	.+44     	; 0x15f2 <UART_init+0x11e>
    15c6:	89 e1       	ldi	r24, 0x19	; 25
    15c8:	89 b9       	out	0x09, r24	; 9
    15ca:	13 c0       	rjmp	.+38     	; 0x15f2 <UART_init+0x11e>
    15cc:	80 e1       	ldi	r24, 0x10	; 16
    15ce:	89 b9       	out	0x09, r24	; 9
    15d0:	10 c0       	rjmp	.+32     	; 0x15f2 <UART_init+0x11e>
    15d2:	8c e0       	ldi	r24, 0x0C	; 12
    15d4:	89 b9       	out	0x09, r24	; 9
    15d6:	0d c0       	rjmp	.+26     	; 0x15f2 <UART_init+0x11e>
    15d8:	88 e0       	ldi	r24, 0x08	; 8
    15da:	89 b9       	out	0x09, r24	; 9
    15dc:	0a c0       	rjmp	.+20     	; 0x15f2 <UART_init+0x11e>
    15de:	83 e0       	ldi	r24, 0x03	; 3
    15e0:	89 b9       	out	0x09, r24	; 9
    15e2:	07 c0       	rjmp	.+14     	; 0x15f2 <UART_init+0x11e>
    15e4:	83 e0       	ldi	r24, 0x03	; 3
    15e6:	89 b9       	out	0x09, r24	; 9
    15e8:	04 c0       	rjmp	.+8      	; 0x15f2 <UART_init+0x11e>
    15ea:	81 e0       	ldi	r24, 0x01	; 1
    15ec:	89 b9       	out	0x09, r24	; 9
    15ee:	01 c0       	rjmp	.+2      	; 0x15f2 <UART_init+0x11e>
    15f0:	19 b8       	out	0x09, r1	; 9
    15f2:	8a b1       	in	r24, 0x0a	; 10
    15f4:	88 60       	ori	r24, 0x08	; 8
    15f6:	8a b9       	out	0x0a, r24	; 10
    15f8:	8a b1       	in	r24, 0x0a	; 10
    15fa:	80 61       	ori	r24, 0x10	; 16
    15fc:	8a b9       	out	0x0a, r24	; 10
    15fe:	80 b5       	in	r24, 0x20	; 32
    1600:	80 68       	ori	r24, 0x80	; 128
    1602:	80 bd       	out	0x20, r24	; 32
    1604:	80 b5       	in	r24, 0x20	; 32
    1606:	82 60       	ori	r24, 0x02	; 2
    1608:	80 bd       	out	0x20, r24	; 32
    160a:	80 b5       	in	r24, 0x20	; 32
    160c:	84 60       	ori	r24, 0x04	; 4
    160e:	80 bd       	out	0x20, r24	; 32
    1610:	80 e0       	ldi	r24, 0x00	; 0
    1612:	08 95       	ret
    1614:	81 e0       	ldi	r24, 0x01	; 1
    1616:	08 95       	ret

00001618 <UART_sendChar>:
    1618:	5d 9b       	sbis	0x0b, 5	; 11
    161a:	fe cf       	rjmp	.-4      	; 0x1618 <UART_sendChar>
    161c:	8c b9       	out	0x0c, r24	; 12
    161e:	5e 9b       	sbis	0x0b, 6	; 11
    1620:	fe cf       	rjmp	.-4      	; 0x161e <UART_sendChar+0x6>
    1622:	08 95       	ret

00001624 <UART_sendString>:
  }

void UART_sendString(s8* str) {
    1624:	cf 92       	push	r12
    1626:	df 92       	push	r13
    1628:	ef 92       	push	r14
    162a:	ff 92       	push	r15
    162c:	cf 93       	push	r28
    162e:	df 93       	push	r29
    1630:	ec 01       	movw	r28, r24
  u32 i = 0;
    1632:	c1 2c       	mov	r12, r1
    1634:	d1 2c       	mov	r13, r1
    1636:	76 01       	movw	r14, r12
  while (str[i] != 0) {
    1638:	07 c0       	rjmp	.+14     	; 0x1648 <UART_sendString+0x24>
    UART_sendChar(str[i]);
    163a:	0e 94 0c 0b 	call	0x1618	; 0x1618 <UART_sendChar>
    i++;
    163e:	8f ef       	ldi	r24, 0xFF	; 255
    1640:	c8 1a       	sub	r12, r24
    1642:	d8 0a       	sbc	r13, r24
    1644:	e8 0a       	sbc	r14, r24
    1646:	f8 0a       	sbc	r15, r24
  *x = UDR;
  }

void UART_sendString(s8* str) {
  u32 i = 0;
  while (str[i] != 0) {
    1648:	fe 01       	movw	r30, r28
    164a:	ec 0d       	add	r30, r12
    164c:	fd 1d       	adc	r31, r13
    164e:	80 81       	ld	r24, Z
    1650:	81 11       	cpse	r24, r1
    1652:	f3 cf       	rjmp	.-26     	; 0x163a <UART_sendString+0x16>
    UART_sendChar(str[i]);
    i++;
    }
  UART_sendChar(0); // Send null to terminate the string
    1654:	0e 94 0c 0b 	call	0x1618	; 0x1618 <UART_sendChar>
  }
    1658:	df 91       	pop	r29
    165a:	cf 91       	pop	r28
    165c:	ff 90       	pop	r15
    165e:	ef 90       	pop	r14
    1660:	df 90       	pop	r13
    1662:	cf 90       	pop	r12
    1664:	08 95       	ret

00001666 <Door_init>:

#include "door.h"

 // Initialize the servo for the door
void Door_init(void) {
  Servo_init();
    1666:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <Servo_init>
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    166a:	80 e0       	ldi	r24, 0x00	; 0
    166c:	0e 94 6d 04 	call	0x8da	; 0x8da <Servo_move_to_angle>
    1670:	08 95       	ret

00001672 <Door_open>:
  }

// Open the door by moving the servo to the open angle
void Door_open(void) {
  Servo_move_to_angle(DOOR_OPEN_ANGLE);
    1672:	84 eb       	ldi	r24, 0xB4	; 180
    1674:	0e 94 6d 04 	call	0x8da	; 0x8da <Servo_move_to_angle>
    1678:	08 95       	ret

0000167a <Door_close>:
  }

// Close the door by moving the servo to the close angle
void Door_close(void) {
  Servo_move_to_angle(DOOR_CLOSE_ANGLE);
    167a:	80 e0       	ldi	r24, 0x00	; 0
    167c:	0e 94 6d 04 	call	0x8da	; 0x8da <Servo_move_to_angle>
    1680:	08 95       	ret

00001682 <Lamps_init>:

#include "lights.h"

 // Initializes all six lamps
void Lamps_init(void) {
  LED_init(LAMP_1_PORT, LAMP_1_PIN);
    1682:	62 e0       	ldi	r22, 0x02	; 2
    1684:	83 e4       	ldi	r24, 0x43	; 67
    1686:	0e 94 26 04 	call	0x84c	; 0x84c <LED_init>
  LED_init(LAMP_2_PORT, LAMP_2_PIN);
    168a:	63 e0       	ldi	r22, 0x03	; 3
    168c:	83 e4       	ldi	r24, 0x43	; 67
    168e:	0e 94 26 04 	call	0x84c	; 0x84c <LED_init>
  LED_init(LAMP_3_PORT, LAMP_3_PIN);
    1692:	64 e0       	ldi	r22, 0x04	; 4
    1694:	83 e4       	ldi	r24, 0x43	; 67
    1696:	0e 94 26 04 	call	0x84c	; 0x84c <LED_init>
  LED_init(LAMP_4_PORT, LAMP_4_PIN);
    169a:	65 e0       	ldi	r22, 0x05	; 5
    169c:	83 e4       	ldi	r24, 0x43	; 67
    169e:	0e 94 26 04 	call	0x84c	; 0x84c <LED_init>
  LED_init(LAMP_5_PORT, LAMP_5_PIN);
    16a2:	66 e0       	ldi	r22, 0x06	; 6
    16a4:	83 e4       	ldi	r24, 0x43	; 67
    16a6:	0e 94 26 04 	call	0x84c	; 0x84c <LED_init>
  LED_init(LAMP_6_DIMMABLE_PORT, LAMP_6_DIMMABLE_PIN);
    16aa:	67 e0       	ldi	r22, 0x07	; 7
    16ac:	84 e4       	ldi	r24, 0x44	; 68
    16ae:	0e 94 26 04 	call	0x84c	; 0x84c <LED_init>
  // Initialize the pwm pin which lamp6 is on for brightness control
  PWM_init(LAMP_6_DIMMABLE_PWM_PIN, 0, PWM_FAST);
    16b2:	21 e0       	ldi	r18, 0x01	; 1
    16b4:	40 e0       	ldi	r20, 0x00	; 0
    16b6:	50 e0       	ldi	r21, 0x00	; 0
    16b8:	ba 01       	movw	r22, r20
    16ba:	83 e0       	ldi	r24, 0x03	; 3
    16bc:	0e 94 84 09 	call	0x1308	; 0x1308 <PWM_init>

  Timer_start(TIMER_2, LAMP_6_DIMMABLE_PRESCALAR);
    16c0:	60 e0       	ldi	r22, 0x00	; 0
    16c2:	71 e0       	ldi	r23, 0x01	; 1
    16c4:	82 e0       	ldi	r24, 0x02	; 2
    16c6:	0e 94 14 09 	call	0x1228	; 0x1228 <Timer_start>
    16ca:	08 95       	ret

000016cc <Lamp_on>:
  }

// Turn on a lamp
void Lamp_on(u8 lampNumber) {
  switch (lampNumber) {
    16cc:	83 30       	cpi	r24, 0x03	; 3
    16ce:	b1 f0       	breq	.+44     	; 0x16fc <Lamp_on+0x30>
    16d0:	28 f4       	brcc	.+10     	; 0x16dc <Lamp_on+0x10>
    16d2:	81 30       	cpi	r24, 0x01	; 1
    16d4:	49 f0       	breq	.+18     	; 0x16e8 <Lamp_on+0x1c>
    16d6:	82 30       	cpi	r24, 0x02	; 2
    16d8:	61 f0       	breq	.+24     	; 0x16f2 <Lamp_on+0x26>
    16da:	08 95       	ret
    16dc:	85 30       	cpi	r24, 0x05	; 5
    16de:	c1 f0       	breq	.+48     	; 0x1710 <Lamp_on+0x44>
    16e0:	90 f0       	brcs	.+36     	; 0x1706 <Lamp_on+0x3a>
    16e2:	86 30       	cpi	r24, 0x06	; 6
    16e4:	d1 f0       	breq	.+52     	; 0x171a <Lamp_on+0x4e>
    16e6:	08 95       	ret
      case LAMP_1:
        LED_on(LAMP_1_PORT, LAMP_1_PIN);
    16e8:	62 e0       	ldi	r22, 0x02	; 2
    16ea:	83 e4       	ldi	r24, 0x43	; 67
    16ec:	0e 94 2f 04 	call	0x85e	; 0x85e <LED_on>
        break;
    16f0:	08 95       	ret
      case LAMP_2:
        LED_on(LAMP_2_PORT, LAMP_2_PIN);
    16f2:	63 e0       	ldi	r22, 0x03	; 3
    16f4:	83 e4       	ldi	r24, 0x43	; 67
    16f6:	0e 94 2f 04 	call	0x85e	; 0x85e <LED_on>
        break;
    16fa:	08 95       	ret
      case LAMP_3:
        LED_on(LAMP_3_PORT, LAMP_3_PIN);
    16fc:	64 e0       	ldi	r22, 0x04	; 4
    16fe:	83 e4       	ldi	r24, 0x43	; 67
    1700:	0e 94 2f 04 	call	0x85e	; 0x85e <LED_on>
        break;
    1704:	08 95       	ret
      case LAMP_4:
        LED_on(LAMP_4_PORT, LAMP_4_PIN);
    1706:	65 e0       	ldi	r22, 0x05	; 5
    1708:	83 e4       	ldi	r24, 0x43	; 67
    170a:	0e 94 2f 04 	call	0x85e	; 0x85e <LED_on>
        break;
    170e:	08 95       	ret
      case LAMP_5:
        LED_on(LAMP_5_PORT, LAMP_5_PIN);
    1710:	66 e0       	ldi	r22, 0x06	; 6
    1712:	83 e4       	ldi	r24, 0x43	; 67
    1714:	0e 94 2f 04 	call	0x85e	; 0x85e <LED_on>
        break;
    1718:	08 95       	ret
      case LAMP_6:
        PWM_OCP_connect(LAMP_6_DIMMABLE_PWM_PIN);
    171a:	83 e0       	ldi	r24, 0x03	; 3
    171c:	0e 94 56 09 	call	0x12ac	; 0x12ac <PWM_OCP_connect>
    1720:	08 95       	ret

00001722 <Lamp_off>:
    }
  }

// Turn off a lamp
void Lamp_off(u8 lampNumber) {
  switch (lampNumber) {
    1722:	83 30       	cpi	r24, 0x03	; 3
    1724:	b1 f0       	breq	.+44     	; 0x1752 <Lamp_off+0x30>
    1726:	28 f4       	brcc	.+10     	; 0x1732 <Lamp_off+0x10>
    1728:	81 30       	cpi	r24, 0x01	; 1
    172a:	49 f0       	breq	.+18     	; 0x173e <Lamp_off+0x1c>
    172c:	82 30       	cpi	r24, 0x02	; 2
    172e:	61 f0       	breq	.+24     	; 0x1748 <Lamp_off+0x26>
    1730:	08 95       	ret
    1732:	85 30       	cpi	r24, 0x05	; 5
    1734:	c1 f0       	breq	.+48     	; 0x1766 <Lamp_off+0x44>
    1736:	90 f0       	brcs	.+36     	; 0x175c <Lamp_off+0x3a>
    1738:	86 30       	cpi	r24, 0x06	; 6
    173a:	d1 f0       	breq	.+52     	; 0x1770 <Lamp_off+0x4e>
    173c:	08 95       	ret
      case LAMP_1:
        LED_off(LAMP_1_PORT, LAMP_1_PIN);
    173e:	62 e0       	ldi	r22, 0x02	; 2
    1740:	83 e4       	ldi	r24, 0x43	; 67
    1742:	0e 94 38 04 	call	0x870	; 0x870 <LED_off>
        break;
    1746:	08 95       	ret
      case LAMP_2:
        LED_off(LAMP_2_PORT, LAMP_2_PIN);
    1748:	63 e0       	ldi	r22, 0x03	; 3
    174a:	83 e4       	ldi	r24, 0x43	; 67
    174c:	0e 94 38 04 	call	0x870	; 0x870 <LED_off>
        break;
    1750:	08 95       	ret
      case LAMP_3:
        LED_off(LAMP_3_PORT, LAMP_3_PIN);
    1752:	64 e0       	ldi	r22, 0x04	; 4
    1754:	83 e4       	ldi	r24, 0x43	; 67
    1756:	0e 94 38 04 	call	0x870	; 0x870 <LED_off>
        break;
    175a:	08 95       	ret
      case LAMP_4:
        LED_off(LAMP_4_PORT, LAMP_4_PIN);
    175c:	65 e0       	ldi	r22, 0x05	; 5
    175e:	83 e4       	ldi	r24, 0x43	; 67
    1760:	0e 94 38 04 	call	0x870	; 0x870 <LED_off>
        break;
    1764:	08 95       	ret
      case LAMP_5:
        LED_off(LAMP_5_PORT, LAMP_5_PIN);
    1766:	66 e0       	ldi	r22, 0x06	; 6
    1768:	83 e4       	ldi	r24, 0x43	; 67
    176a:	0e 94 38 04 	call	0x870	; 0x870 <LED_off>
        break;
    176e:	08 95       	ret
      case LAMP_6:
        PWM_OCP_disconnect(LAMP_6_DIMMABLE_PWM_PIN);
    1770:	83 e0       	ldi	r24, 0x03	; 3
    1772:	0e 94 28 09 	call	0x1250	; 0x1250 <PWM_OCP_disconnect>
    1776:	08 95       	ret

00001778 <Lamp_toggle>:
    }
  }

// Toggle a lamp
void Lamp_toggle(u8 lampNumber) {
  switch (lampNumber) {
    1778:	83 30       	cpi	r24, 0x03	; 3
    177a:	b1 f0       	breq	.+44     	; 0x17a8 <Lamp_toggle+0x30>
    177c:	28 f4       	brcc	.+10     	; 0x1788 <Lamp_toggle+0x10>
    177e:	81 30       	cpi	r24, 0x01	; 1
    1780:	49 f0       	breq	.+18     	; 0x1794 <Lamp_toggle+0x1c>
    1782:	82 30       	cpi	r24, 0x02	; 2
    1784:	61 f0       	breq	.+24     	; 0x179e <Lamp_toggle+0x26>
    1786:	08 95       	ret
    1788:	85 30       	cpi	r24, 0x05	; 5
    178a:	c1 f0       	breq	.+48     	; 0x17bc <Lamp_toggle+0x44>
    178c:	90 f0       	brcs	.+36     	; 0x17b2 <Lamp_toggle+0x3a>
    178e:	86 30       	cpi	r24, 0x06	; 6
    1790:	d1 f0       	breq	.+52     	; 0x17c6 <Lamp_toggle+0x4e>
    1792:	08 95       	ret
      case LAMP_1:
        LED_toggle(LAMP_1_PORT, LAMP_1_PIN);
    1794:	62 e0       	ldi	r22, 0x02	; 2
    1796:	83 e4       	ldi	r24, 0x43	; 67
    1798:	0e 94 41 04 	call	0x882	; 0x882 <LED_toggle>
        break;
    179c:	08 95       	ret
      case LAMP_2:
        LED_toggle(LAMP_2_PORT, LAMP_2_PIN);
    179e:	63 e0       	ldi	r22, 0x03	; 3
    17a0:	83 e4       	ldi	r24, 0x43	; 67
    17a2:	0e 94 41 04 	call	0x882	; 0x882 <LED_toggle>
        break;
    17a6:	08 95       	ret
      case LAMP_3:
        LED_toggle(LAMP_3_PORT, LAMP_3_PIN);
    17a8:	64 e0       	ldi	r22, 0x04	; 4
    17aa:	83 e4       	ldi	r24, 0x43	; 67
    17ac:	0e 94 41 04 	call	0x882	; 0x882 <LED_toggle>
        break;
    17b0:	08 95       	ret
      case LAMP_4:
        LED_toggle(LAMP_4_PORT, LAMP_4_PIN);
    17b2:	65 e0       	ldi	r22, 0x05	; 5
    17b4:	83 e4       	ldi	r24, 0x43	; 67
    17b6:	0e 94 41 04 	call	0x882	; 0x882 <LED_toggle>
        break;
    17ba:	08 95       	ret
      case LAMP_5:
        LED_toggle(LAMP_5_PORT, LAMP_5_PIN);
    17bc:	66 e0       	ldi	r22, 0x06	; 6
    17be:	83 e4       	ldi	r24, 0x43	; 67
    17c0:	0e 94 41 04 	call	0x882	; 0x882 <LED_toggle>
        break;
    17c4:	08 95       	ret
      case LAMP_6:
        if (read_bit(TCCR2, COM21)) { // OC pin is connected and lamp6 is on
    17c6:	05 b4       	in	r0, 0x25	; 37
    17c8:	05 fe       	sbrs	r0, 5
    17ca:	04 c0       	rjmp	.+8      	; 0x17d4 <Lamp_toggle+0x5c>
          Lamp_off(6);
    17cc:	86 e0       	ldi	r24, 0x06	; 6
    17ce:	0e 94 91 0b 	call	0x1722	; 0x1722 <Lamp_off>
    17d2:	08 95       	ret
          }
        else {
          Lamp_on(6);
    17d4:	86 e0       	ldi	r24, 0x06	; 6
    17d6:	0e 94 66 0b 	call	0x16cc	; 0x16cc <Lamp_on>
    17da:	08 95       	ret

000017dc <Lamp_dimmable_set_brightness>:
        break;
    }
  }

// Adjust the brightness of the dimmable lamp
void Lamp_dimmable_set_brightness(double brightness) {
    17dc:	ab 01       	movw	r20, r22
    17de:	bc 01       	movw	r22, r24
  PWM_set_DC(LAMP_6_DIMMABLE_PWM_PIN, brightness);
    17e0:	83 e0       	ldi	r24, 0x03	; 3
    17e2:	0e 94 2b 0a 	call	0x1456	; 0x1456 <PWM_set_DC>
    17e6:	08 95       	ret

000017e8 <Local_access_init>:

ST_User_t local_user;

// Initialize the local control system
void Local_access_init(void) {
  LCD_init();
    17e8:	0e 94 af 03 	call	0x75e	; 0x75e <LCD_init>
  Keypad_init();
    17ec:	0e 94 29 02 	call	0x452	; 0x452 <Keypad_init>
  User_DB_init();
    17f0:	0e 94 66 14 	call	0x28cc	; 0x28cc <User_DB_init>
    17f4:	08 95       	ret

000017f6 <Get_running_devices>:
  }

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
    17f6:	cf 93       	push	r28
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    17f8:	c0 e0       	ldi	r28, 0x00	; 0
    17fa:	0a c0       	rjmp	.+20     	; 0x1810 <Get_running_devices+0x1a>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
    17fc:	4c 2f       	mov	r20, r28
    17fe:	50 e0       	ldi	r21, 0x00	; 0
    1800:	45 52       	subi	r20, 0x25	; 37
    1802:	58 4f       	sbci	r21, 0xF8	; 248
    1804:	63 e4       	ldi	r22, 0x43	; 67
    1806:	82 e0       	ldi	r24, 0x02	; 2
    1808:	8c 0f       	add	r24, r28
    180a:	0e 94 20 06 	call	0xc40	; 0xc40 <DIO_Read>

// Updates the logical states (in/off) of the running devices' array
void Get_running_devices(void) {
  // Check the on/off lamps
  u8 lamp;
  for (lamp = 0; lamp < 5; lamp++) {
    180e:	cf 5f       	subi	r28, 0xFF	; 255
    1810:	c5 30       	cpi	r28, 0x05	; 5
    1812:	a0 f3       	brcs	.-24     	; 0x17fc <Get_running_devices+0x6>
    DIO_Read(lamp + 2, PORT_C, &running_devices[lamp]);
    }
  // Check the dimmable lamp
  running_devices[5] = read_bit(TCCR2, COM21); // To see if the OC pins are connected
    1814:	85 b5       	in	r24, 0x25	; 37
    1816:	85 fb       	bst	r24, 5
    1818:	88 27       	eor	r24, r24
    181a:	80 f9       	bld	r24, 0
    181c:	80 93 e0 07 	sts	0x07E0, r24	; 0x8007e0 <running_devices+0x5>
  // Check the AC
  DIO_Read(7, PORT_D, &running_devices[6]);
    1820:	41 ee       	ldi	r20, 0xE1	; 225
    1822:	57 e0       	ldi	r21, 0x07	; 7
    1824:	64 e4       	ldi	r22, 0x44	; 68
    1826:	87 e0       	ldi	r24, 0x07	; 7
    1828:	0e 94 20 06 	call	0xc40	; 0xc40 <DIO_Read>
  // The value in OCR2 determine the brightness of the led
  dimmer_brightness = OCR2;
    182c:	83 b5       	in	r24, 0x23	; 35
    182e:	90 e0       	ldi	r25, 0x00	; 0
    1830:	90 93 d9 07 	sts	0x07D9, r25	; 0x8007d9 <dimmer_brightness+0x1>
    1834:	80 93 d8 07 	sts	0x07D8, r24	; 0x8007d8 <dimmer_brightness>
  }
    1838:	cf 91       	pop	r28
    183a:	08 95       	ret

0000183c <Show_bottom_options_menu>:

// Shows the bottom line options on the LCD
void Show_bottom_options_menu(u8 menu) {
  switch (menu) {
    183c:	90 e0       	ldi	r25, 0x00	; 0
    183e:	fc 01       	movw	r30, r24
    1840:	31 97       	sbiw	r30, 0x01	; 1
    1842:	ea 30       	cpi	r30, 0x0A	; 10
    1844:	f1 05       	cpc	r31, r1
    1846:	08 f0       	brcs	.+2      	; 0x184a <Show_bottom_options_menu+0xe>
    1848:	49 c0       	rjmp	.+146    	; 0x18dc <Show_bottom_options_menu+0xa0>
    184a:	ee 57       	subi	r30, 0x7E	; 126
    184c:	ff 4f       	sbci	r31, 0xFF	; 255
    184e:	0c 94 be 18 	jmp	0x317c	; 0x317c <__tablejump2__>
      case 1:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_1);
    1852:	40 e7       	ldi	r20, 0x70	; 112
    1854:	50 e0       	ldi	r21, 0x00	; 0
    1856:	61 e0       	ldi	r22, 0x01	; 1
    1858:	80 e0       	ldi	r24, 0x00	; 0
    185a:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
        break;
    185e:	08 95       	ret
      case 2:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_2);
    1860:	41 e8       	ldi	r20, 0x81	; 129
    1862:	50 e0       	ldi	r21, 0x00	; 0
    1864:	61 e0       	ldi	r22, 0x01	; 1
    1866:	80 e0       	ldi	r24, 0x00	; 0
    1868:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
        break;
    186c:	08 95       	ret
      case 3:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_3);
    186e:	42 e9       	ldi	r20, 0x92	; 146
    1870:	50 e0       	ldi	r21, 0x00	; 0
    1872:	61 e0       	ldi	r22, 0x01	; 1
    1874:	80 e0       	ldi	r24, 0x00	; 0
    1876:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
        break;
    187a:	08 95       	ret
      case 4:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_4);
    187c:	43 ea       	ldi	r20, 0xA3	; 163
    187e:	50 e0       	ldi	r21, 0x00	; 0
    1880:	61 e0       	ldi	r22, 0x01	; 1
    1882:	80 e0       	ldi	r24, 0x00	; 0
    1884:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
        break;
    1888:	08 95       	ret
      case 5:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_5);
    188a:	44 eb       	ldi	r20, 0xB4	; 180
    188c:	50 e0       	ldi	r21, 0x00	; 0
    188e:	61 e0       	ldi	r22, 0x01	; 1
    1890:	80 e0       	ldi	r24, 0x00	; 0
    1892:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
        break;
    1896:	08 95       	ret
      case 6:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_6);
    1898:	45 ec       	ldi	r20, 0xC5	; 197
    189a:	50 e0       	ldi	r21, 0x00	; 0
    189c:	61 e0       	ldi	r22, 0x01	; 1
    189e:	80 e0       	ldi	r24, 0x00	; 0
    18a0:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
        break;
    18a4:	08 95       	ret
      case 7:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_7);
    18a6:	46 ed       	ldi	r20, 0xD6	; 214
    18a8:	50 e0       	ldi	r21, 0x00	; 0
    18aa:	61 e0       	ldi	r22, 0x01	; 1
    18ac:	80 e0       	ldi	r24, 0x00	; 0
    18ae:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
        break;
    18b2:	08 95       	ret
      case 8:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_8);
    18b4:	47 ee       	ldi	r20, 0xE7	; 231
    18b6:	50 e0       	ldi	r21, 0x00	; 0
    18b8:	61 e0       	ldi	r22, 0x01	; 1
    18ba:	80 e0       	ldi	r24, 0x00	; 0
    18bc:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
        break;
    18c0:	08 95       	ret
      case 9:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_9);
    18c2:	48 ef       	ldi	r20, 0xF8	; 248
    18c4:	50 e0       	ldi	r21, 0x00	; 0
    18c6:	61 e0       	ldi	r22, 0x01	; 1
    18c8:	80 e0       	ldi	r24, 0x00	; 0
    18ca:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
        break;
    18ce:	08 95       	ret
      case 10:
        LCD_write_string_xy(0, 1, OPTIONS_MENU_10);
    18d0:	49 e0       	ldi	r20, 0x09	; 9
    18d2:	51 e0       	ldi	r21, 0x01	; 1
    18d4:	61 e0       	ldi	r22, 0x01	; 1
    18d6:	80 e0       	ldi	r24, 0x00	; 0
    18d8:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
    18dc:	08 95       	ret

000018de <Show_side_options_menu>:
    }
  }

// Shows the side options list on the LCD
void Show_side_options_menu(void) {
  LCD_write_string_xy(12, 0, BACKSPACE_OPTION);
    18de:	4a e1       	ldi	r20, 0x1A	; 26
    18e0:	51 e0       	ldi	r21, 0x01	; 1
    18e2:	60 e0       	ldi	r22, 0x00	; 0
    18e4:	8c e0       	ldi	r24, 0x0C	; 12
    18e6:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
  LCD_write_string_xy(12, 1, ENTER_OPTION);
    18ea:	4f e1       	ldi	r20, 0x1F	; 31
    18ec:	51 e0       	ldi	r21, 0x01	; 1
    18ee:	61 e0       	ldi	r22, 0x01	; 1
    18f0:	8c e0       	ldi	r24, 0x0C	; 12
    18f2:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
    18f6:	08 95       	ret

000018f8 <Show_running_devices>:
  }

// Shows the currently running devices with the appropriate control menu appended (Screen controls and login- no device controls)
void Show_running_devices(u8 screen) {
    18f8:	ef 92       	push	r14
    18fa:	ff 92       	push	r15
    18fc:	1f 93       	push	r17
    18fe:	cf 93       	push	r28
    1900:	df 93       	push	r29
    1902:	00 d0       	rcall	.+0      	; 0x1904 <Show_running_devices+0xc>
    1904:	00 d0       	rcall	.+0      	; 0x1906 <Show_running_devices+0xe>
    1906:	cd b7       	in	r28, 0x3d	; 61
    1908:	de b7       	in	r29, 0x3e	; 62
    190a:	18 2f       	mov	r17, r24
  // Do nothing if the correct screen is shown.
  // if (screen == running_devices_screen) return;
  LCD_clear_screen();
    190c:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
  // Write device name
  switch (screen) {
    1910:	17 30       	cpi	r17, 0x07	; 7
    1912:	39 f4       	brne	.+14     	; 0x1922 <Show_running_devices+0x2a>
      case 7:
        LCD_write_string_xy(0, 0, "AC: ");
    1914:	44 e2       	ldi	r20, 0x24	; 36
    1916:	51 e0       	ldi	r21, 0x01	; 1
    1918:	60 e0       	ldi	r22, 0x00	; 0
    191a:	80 e0       	ldi	r24, 0x00	; 0
    191c:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
        break;
    1920:	0e c0       	rjmp	.+28     	; 0x193e <Show_running_devices+0x46>
      default:
        LCD_write_string_xy(0, 0, "Lamp");
    1922:	49 e2       	ldi	r20, 0x29	; 41
    1924:	51 e0       	ldi	r21, 0x01	; 1
    1926:	60 e0       	ldi	r22, 0x00	; 0
    1928:	80 e0       	ldi	r24, 0x00	; 0
    192a:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
        LCD_sendData(screen + 48);
    192e:	80 e3       	ldi	r24, 0x30	; 48
    1930:	81 0f       	add	r24, r17
    1932:	0e 94 79 03 	call	0x6f2	; 0x6f2 <LCD_sendData>
        LCD_write_string(":  ");
    1936:	8e e2       	ldi	r24, 0x2E	; 46
    1938:	91 e0       	ldi	r25, 0x01	; 1
    193a:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_write_string>
        break;
    }
  if (screen == 6) {
    193e:	16 30       	cpi	r17, 0x06	; 6
    1940:	49 f5       	brne	.+82     	; 0x1994 <Show_running_devices+0x9c>
    s8 brightness[4];
    sprintf(brightness, "%d%%", (u8)((double)dimmer_brightness / 2.55));
    1942:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1946:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    194a:	07 2e       	mov	r0, r23
    194c:	00 0c       	add	r0, r0
    194e:	88 0b       	sbc	r24, r24
    1950:	99 0b       	sbc	r25, r25
    1952:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <__floatsisf>
    1956:	23 e3       	ldi	r18, 0x33	; 51
    1958:	33 e3       	ldi	r19, 0x33	; 51
    195a:	43 e2       	ldi	r20, 0x23	; 35
    195c:	50 e4       	ldi	r21, 0x40	; 64
    195e:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__divsf3>
    1962:	0e 94 94 17 	call	0x2f28	; 0x2f28 <__fixunssfsi>
    1966:	1f 92       	push	r1
    1968:	6f 93       	push	r22
    196a:	82 e3       	ldi	r24, 0x32	; 50
    196c:	91 e0       	ldi	r25, 0x01	; 1
    196e:	9f 93       	push	r25
    1970:	8f 93       	push	r24
    1972:	ce 01       	movw	r24, r28
    1974:	01 96       	adiw	r24, 0x01	; 1
    1976:	7c 01       	movw	r14, r24
    1978:	9f 93       	push	r25
    197a:	8f 93       	push	r24
    197c:	0e 94 d4 18 	call	0x31a8	; 0x31a8 <sprintf>
    LCD_write_string(brightness);
    1980:	c7 01       	movw	r24, r14
    1982:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_write_string>
    1986:	0f 90       	pop	r0
    1988:	0f 90       	pop	r0
    198a:	0f 90       	pop	r0
    198c:	0f 90       	pop	r0
    198e:	0f 90       	pop	r0
    1990:	0f 90       	pop	r0
    1992:	10 c0       	rjmp	.+32     	; 0x19b4 <Show_running_devices+0xbc>
    }
  else {// Write the device state
    if (running_devices[screen - 1])
    1994:	e1 2f       	mov	r30, r17
    1996:	f0 e0       	ldi	r31, 0x00	; 0
    1998:	e6 52       	subi	r30, 0x26	; 38
    199a:	f8 4f       	sbci	r31, 0xF8	; 248
    199c:	80 81       	ld	r24, Z
    199e:	88 23       	and	r24, r24
    19a0:	29 f0       	breq	.+10     	; 0x19ac <Show_running_devices+0xb4>
      LCD_write_string("On");
    19a2:	87 e3       	ldi	r24, 0x37	; 55
    19a4:	91 e0       	ldi	r25, 0x01	; 1
    19a6:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_write_string>
    19aa:	04 c0       	rjmp	.+8      	; 0x19b4 <Show_running_devices+0xbc>
    else
      LCD_write_string("Off");
    19ac:	8a e3       	ldi	r24, 0x3A	; 58
    19ae:	91 e0       	ldi	r25, 0x01	; 1
    19b0:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_write_string>
    }
  // Show the options menu
  switch (screen) {
    19b4:	11 30       	cpi	r17, 0x01	; 1
    19b6:	19 f0       	breq	.+6      	; 0x19be <Show_running_devices+0xc6>
    19b8:	17 30       	cpi	r17, 0x07	; 7
    19ba:	29 f0       	breq	.+10     	; 0x19c6 <Show_running_devices+0xce>
    19bc:	08 c0       	rjmp	.+16     	; 0x19ce <Show_running_devices+0xd6>
      case 1:
        Show_bottom_options_menu(3);
    19be:	83 e0       	ldi	r24, 0x03	; 3
    19c0:	0e 94 1e 0c 	call	0x183c	; 0x183c <Show_bottom_options_menu>
        break;
    19c4:	07 c0       	rjmp	.+14     	; 0x19d4 <Show_running_devices+0xdc>
      case 7:
        Show_bottom_options_menu(2);
    19c6:	82 e0       	ldi	r24, 0x02	; 2
    19c8:	0e 94 1e 0c 	call	0x183c	; 0x183c <Show_bottom_options_menu>
        break;
    19cc:	03 c0       	rjmp	.+6      	; 0x19d4 <Show_running_devices+0xdc>
      default:
        Show_bottom_options_menu(1);
    19ce:	81 e0       	ldi	r24, 0x01	; 1
    19d0:	0e 94 1e 0c 	call	0x183c	; 0x183c <Show_bottom_options_menu>
        break;
    }
  }
    19d4:	0f 90       	pop	r0
    19d6:	0f 90       	pop	r0
    19d8:	0f 90       	pop	r0
    19da:	0f 90       	pop	r0
    19dc:	df 91       	pop	r29
    19de:	cf 91       	pop	r28
    19e0:	1f 91       	pop	r17
    19e2:	ff 90       	pop	r15
    19e4:	ef 90       	pop	r14
    19e6:	08 95       	ret

000019e8 <Show_devices_controls>:

// Shows the currently running devices with the appropriate control menu appended (Devices' controls)
void Show_devices_controls(u8 screen) {
    19e8:	ef 92       	push	r14
    19ea:	ff 92       	push	r15
    19ec:	1f 93       	push	r17
    19ee:	cf 93       	push	r28
    19f0:	df 93       	push	r29
    19f2:	00 d0       	rcall	.+0      	; 0x19f4 <Show_devices_controls+0xc>
    19f4:	00 d0       	rcall	.+0      	; 0x19f6 <Show_devices_controls+0xe>
    19f6:	cd b7       	in	r28, 0x3d	; 61
    19f8:	de b7       	in	r29, 0x3e	; 62
    19fa:	18 2f       	mov	r17, r24
  // Do nothing if the correct screen is shown.
  // if (screen == control_devices_screen) return;
  LCD_clear_screen();
    19fc:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
  LCD_write_string_xy(0, 0, "Lamp");
    1a00:	49 e2       	ldi	r20, 0x29	; 41
    1a02:	51 e0       	ldi	r21, 0x01	; 1
    1a04:	60 e0       	ldi	r22, 0x00	; 0
    1a06:	80 e0       	ldi	r24, 0x00	; 0
    1a08:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
  LCD_sendData(screen + 48);
    1a0c:	80 e3       	ldi	r24, 0x30	; 48
    1a0e:	81 0f       	add	r24, r17
    1a10:	0e 94 79 03 	call	0x6f2	; 0x6f2 <LCD_sendData>
  LCD_write_string(":  ");
    1a14:	8e e2       	ldi	r24, 0x2E	; 46
    1a16:	91 e0       	ldi	r25, 0x01	; 1
    1a18:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_write_string>

  if (screen < 6) {
    1a1c:	16 30       	cpi	r17, 0x06	; 6
    1a1e:	88 f4       	brcc	.+34     	; 0x1a42 <Show_devices_controls+0x5a>
    // Write the device state
    if (running_devices[screen - 1])
    1a20:	e1 2f       	mov	r30, r17
    1a22:	f0 e0       	ldi	r31, 0x00	; 0
    1a24:	e6 52       	subi	r30, 0x26	; 38
    1a26:	f8 4f       	sbci	r31, 0xF8	; 248
    1a28:	80 81       	ld	r24, Z
    1a2a:	88 23       	and	r24, r24
    1a2c:	29 f0       	breq	.+10     	; 0x1a38 <Show_devices_controls+0x50>
      LCD_write_string("On");
    1a2e:	87 e3       	ldi	r24, 0x37	; 55
    1a30:	91 e0       	ldi	r25, 0x01	; 1
    1a32:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_write_string>
    1a36:	38 c0       	rjmp	.+112    	; 0x1aa8 <Show_devices_controls+0xc0>
    else
      LCD_write_string("Off");
    1a38:	8a e3       	ldi	r24, 0x3A	; 58
    1a3a:	91 e0       	ldi	r25, 0x01	; 1
    1a3c:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_write_string>
    1a40:	33 c0       	rjmp	.+102    	; 0x1aa8 <Show_devices_controls+0xc0>
    }
  else if (screen == 6) { // Dimmer
    1a42:	16 30       	cpi	r17, 0x06	; 6
    1a44:	49 f5       	brne	.+82     	; 0x1a98 <Show_devices_controls+0xb0>
    s8 brightness[4];
    sprintf(brightness, "%d%%", (u8)((double)dimmer_brightness / 2.55));
    1a46:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1a4a:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1a4e:	07 2e       	mov	r0, r23
    1a50:	00 0c       	add	r0, r0
    1a52:	88 0b       	sbc	r24, r24
    1a54:	99 0b       	sbc	r25, r25
    1a56:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <__floatsisf>
    1a5a:	23 e3       	ldi	r18, 0x33	; 51
    1a5c:	33 e3       	ldi	r19, 0x33	; 51
    1a5e:	43 e2       	ldi	r20, 0x23	; 35
    1a60:	50 e4       	ldi	r21, 0x40	; 64
    1a62:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__divsf3>
    1a66:	0e 94 94 17 	call	0x2f28	; 0x2f28 <__fixunssfsi>
    1a6a:	1f 92       	push	r1
    1a6c:	6f 93       	push	r22
    1a6e:	82 e3       	ldi	r24, 0x32	; 50
    1a70:	91 e0       	ldi	r25, 0x01	; 1
    1a72:	9f 93       	push	r25
    1a74:	8f 93       	push	r24
    1a76:	ce 01       	movw	r24, r28
    1a78:	01 96       	adiw	r24, 0x01	; 1
    1a7a:	7c 01       	movw	r14, r24
    1a7c:	9f 93       	push	r25
    1a7e:	8f 93       	push	r24
    1a80:	0e 94 d4 18 	call	0x31a8	; 0x31a8 <sprintf>
    LCD_write_string(brightness);
    1a84:	c7 01       	movw	r24, r14
    1a86:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_write_string>
    1a8a:	0f 90       	pop	r0
    1a8c:	0f 90       	pop	r0
    1a8e:	0f 90       	pop	r0
    1a90:	0f 90       	pop	r0
    1a92:	0f 90       	pop	r0
    1a94:	0f 90       	pop	r0
    1a96:	08 c0       	rjmp	.+16     	; 0x1aa8 <Show_devices_controls+0xc0>
    }
  else {  // Logout screen
    LCD_clear_screen();
    1a98:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
    LCD_write_string_xy(4, 0, "Log out?");
    1a9c:	4e e3       	ldi	r20, 0x3E	; 62
    1a9e:	51 e0       	ldi	r21, 0x01	; 1
    1aa0:	60 e0       	ldi	r22, 0x00	; 0
    1aa2:	84 e0       	ldi	r24, 0x04	; 4
    1aa4:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
    }
  // Show the options menu
  switch (screen) {
    1aa8:	16 30       	cpi	r17, 0x06	; 6
    1aaa:	81 f0       	breq	.+32     	; 0x1acc <Show_devices_controls+0xe4>
    1aac:	17 30       	cpi	r17, 0x07	; 7
    1aae:	91 f0       	breq	.+36     	; 0x1ad4 <Show_devices_controls+0xec>
    1ab0:	11 30       	cpi	r17, 0x01	; 1
    1ab2:	a1 f4       	brne	.+40     	; 0x1adc <Show_devices_controls+0xf4>
      case 1:
        if (running_devices[0])
    1ab4:	80 91 db 07 	lds	r24, 0x07DB	; 0x8007db <running_devices>
    1ab8:	88 23       	and	r24, r24
    1aba:	21 f0       	breq	.+8      	; 0x1ac4 <Show_devices_controls+0xdc>
          Show_bottom_options_menu(8);
    1abc:	88 e0       	ldi	r24, 0x08	; 8
    1abe:	0e 94 1e 0c 	call	0x183c	; 0x183c <Show_bottom_options_menu>
    1ac2:	1a c0       	rjmp	.+52     	; 0x1af8 <Show_devices_controls+0x110>
        else
          Show_bottom_options_menu(7);
    1ac4:	87 e0       	ldi	r24, 0x07	; 7
    1ac6:	0e 94 1e 0c 	call	0x183c	; 0x183c <Show_bottom_options_menu>
    1aca:	16 c0       	rjmp	.+44     	; 0x1af8 <Show_devices_controls+0x110>
        break;
      case 6:
        Show_bottom_options_menu(9);
    1acc:	89 e0       	ldi	r24, 0x09	; 9
    1ace:	0e 94 1e 0c 	call	0x183c	; 0x183c <Show_bottom_options_menu>
        break;
    1ad2:	12 c0       	rjmp	.+36     	; 0x1af8 <Show_devices_controls+0x110>
      case 7:
        Show_bottom_options_menu(10);
    1ad4:	8a e0       	ldi	r24, 0x0A	; 10
    1ad6:	0e 94 1e 0c 	call	0x183c	; 0x183c <Show_bottom_options_menu>
        break;
    1ada:	0e c0       	rjmp	.+28     	; 0x1af8 <Show_devices_controls+0x110>
      default:
        if (running_devices[screen - 1])
    1adc:	e1 2f       	mov	r30, r17
    1ade:	f0 e0       	ldi	r31, 0x00	; 0
    1ae0:	e6 52       	subi	r30, 0x26	; 38
    1ae2:	f8 4f       	sbci	r31, 0xF8	; 248
    1ae4:	80 81       	ld	r24, Z
    1ae6:	88 23       	and	r24, r24
    1ae8:	21 f0       	breq	.+8      	; 0x1af2 <Show_devices_controls+0x10a>
          Show_bottom_options_menu(6);
    1aea:	86 e0       	ldi	r24, 0x06	; 6
    1aec:	0e 94 1e 0c 	call	0x183c	; 0x183c <Show_bottom_options_menu>
    1af0:	03 c0       	rjmp	.+6      	; 0x1af8 <Show_devices_controls+0x110>
        else
          Show_bottom_options_menu(5);
    1af2:	85 e0       	ldi	r24, 0x05	; 5
    1af4:	0e 94 1e 0c 	call	0x183c	; 0x183c <Show_bottom_options_menu>
        break;
    }
  }
    1af8:	0f 90       	pop	r0
    1afa:	0f 90       	pop	r0
    1afc:	0f 90       	pop	r0
    1afe:	0f 90       	pop	r0
    1b00:	df 91       	pop	r29
    1b02:	cf 91       	pop	r28
    1b04:	1f 91       	pop	r17
    1b06:	ff 90       	pop	r15
    1b08:	ef 90       	pop	r14
    1b0a:	08 95       	ret

00001b0c <invalid_local_login_attempt>:

// Handles setting the alarm and halting the system when the user enters invalid credentials during login
void invalid_local_login_attempt(void) {
  invalid_trails++;
    1b0c:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <invalid_trails>
    1b10:	8f 5f       	subi	r24, 0xFF	; 255
    1b12:	80 93 aa 07 	sts	0x07AA, r24	; 0x8007aa <invalid_trails>
  if (invalid_trails < 3) {
    1b16:	83 30       	cpi	r24, 0x03	; 3
    1b18:	00 f5       	brcc	.+64     	; 0x1b5a <invalid_local_login_attempt+0x4e>
    LCD_clear_screen();
    1b1a:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
    LCD_move_cursor_xy(3, 0);
    1b1e:	60 e0       	ldi	r22, 0x00	; 0
    1b20:	83 e0       	ldi	r24, 0x03	; 3
    1b22:	0e 94 0e 04 	call	0x81c	; 0x81c <LCD_move_cursor_xy>
    LCD_sendData((3 - invalid_trails) + 48);
    1b26:	90 91 aa 07 	lds	r25, 0x07AA	; 0x8007aa <invalid_trails>
    1b2a:	83 e3       	ldi	r24, 0x33	; 51
    1b2c:	89 1b       	sub	r24, r25
    1b2e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <LCD_sendData>
    LCD_write_string(" attempts");
    1b32:	87 e4       	ldi	r24, 0x47	; 71
    1b34:	91 e0       	ldi	r25, 0x01	; 1
    1b36:	0e 94 ef 03 	call	0x7de	; 0x7de <LCD_write_string>
    LCD_write_string_xy(3, 1, "remaining !");
    1b3a:	41 e5       	ldi	r20, 0x51	; 81
    1b3c:	51 e0       	ldi	r21, 0x01	; 1
    1b3e:	61 e0       	ldi	r22, 0x01	; 1
    1b40:	83 e0       	ldi	r24, 0x03	; 3
    1b42:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
    1b46:	2f ef       	ldi	r18, 0xFF	; 255
    1b48:	83 ed       	ldi	r24, 0xD3	; 211
    1b4a:	90 e3       	ldi	r25, 0x30	; 48
    1b4c:	21 50       	subi	r18, 0x01	; 1
    1b4e:	80 40       	sbci	r24, 0x00	; 0
    1b50:	90 40       	sbci	r25, 0x00	; 0
    1b52:	e1 f7       	brne	.-8      	; 0x1b4c <invalid_local_login_attempt+0x40>
    1b54:	00 c0       	rjmp	.+0      	; 0x1b56 <invalid_local_login_attempt+0x4a>
    1b56:	00 00       	nop
    1b58:	08 95       	ret
    _delay_ms(1000);
    return;
    }
  LCD_clear_screen();
    1b5a:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
  LCD_write_string_xy(4, 0, "Too many");
    1b5e:	4d e5       	ldi	r20, 0x5D	; 93
    1b60:	51 e0       	ldi	r21, 0x01	; 1
    1b62:	60 e0       	ldi	r22, 0x00	; 0
    1b64:	84 e0       	ldi	r24, 0x04	; 4
    1b66:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
  LCD_write_string_xy(0, 1, "wrong attempts!");
    1b6a:	46 e6       	ldi	r20, 0x66	; 102
    1b6c:	51 e0       	ldi	r21, 0x01	; 1
    1b6e:	61 e0       	ldi	r22, 0x01	; 1
    1b70:	80 e0       	ldi	r24, 0x00	; 0
    1b72:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
    1b76:	2f ef       	ldi	r18, 0xFF	; 255
    1b78:	83 ed       	ldi	r24, 0xD3	; 211
    1b7a:	90 e3       	ldi	r25, 0x30	; 48
    1b7c:	21 50       	subi	r18, 0x01	; 1
    1b7e:	80 40       	sbci	r24, 0x00	; 0
    1b80:	90 40       	sbci	r25, 0x00	; 0
    1b82:	e1 f7       	brne	.-8      	; 0x1b7c <invalid_local_login_attempt+0x70>
    1b84:	00 c0       	rjmp	.+0      	; 0x1b86 <invalid_local_login_attempt+0x7a>
    1b86:	00 00       	nop
  _delay_ms(1000);
  LCD_clear_screen();
    1b88:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
  LCD_write_string_xy(3, 0, "- System -");
    1b8c:	46 e7       	ldi	r20, 0x76	; 118
    1b8e:	51 e0       	ldi	r21, 0x01	; 1
    1b90:	60 e0       	ldi	r22, 0x00	; 0
    1b92:	83 e0       	ldi	r24, 0x03	; 3
    1b94:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
  LCD_write_string_xy(2, 1, "- Suspended -");
    1b98:	41 e8       	ldi	r20, 0x81	; 129
    1b9a:	51 e0       	ldi	r21, 0x01	; 1
    1b9c:	61 e0       	ldi	r22, 0x01	; 1
    1b9e:	82 e0       	ldi	r24, 0x02	; 2
    1ba0:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
  run_system = false;
    1ba4:	10 92 a9 07 	sts	0x07A9, r1	; 0x8007a9 <run_system>
    1ba8:	08 95       	ret

00001baa <Local_control_input_handler>:
  }

// Used in the super loop for getting the user input and handling it.
void Local_control_input_handler(void) {
    1baa:	1f 93       	push	r17
    1bac:	cf 93       	push	r28
    1bae:	df 93       	push	r29
    1bb0:	1f 92       	push	r1
    1bb2:	cd b7       	in	r28, 0x3d	; 61
    1bb4:	de b7       	in	r29, 0x3e	; 62
  u8 pressed_key;
  EN_KeypadStatusCode_t keypad_stat = Keypad_getPressedKey(&pressed_key);
    1bb6:	ce 01       	movw	r24, r28
    1bb8:	01 96       	adiw	r24, 0x01	; 1
    1bba:	0e 94 d7 02 	call	0x5ae	; 0x5ae <Keypad_getPressedKey>
    1bbe:	18 2f       	mov	r17, r24
  switch (local_control_running_task) {
    1bc0:	80 91 ab 07 	lds	r24, 0x07AB	; 0x8007ab <local_control_running_task>
    1bc4:	81 30       	cpi	r24, 0x01	; 1
    1bc6:	a9 f1       	breq	.+106    	; 0x1c32 <Local_control_input_handler+0x88>
    1bc8:	20 f0       	brcs	.+8      	; 0x1bd2 <Local_control_input_handler+0x28>
    1bca:	82 30       	cpi	r24, 0x02	; 2
    1bcc:	09 f4       	brne	.+2      	; 0x1bd0 <Local_control_input_handler+0x26>
    1bce:	48 c1       	rjmp	.+656    	; 0x1e60 <Local_control_input_handler+0x2b6>
    1bd0:	30 c2       	rjmp	.+1120   	; 0x2032 <Local_control_input_handler+0x488>
    // Show running devices
      case 0:
        Get_running_devices();
    1bd2:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <Get_running_devices>
        if (running_devices_screen == 0) {  // First run
    1bd6:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    1bda:	81 11       	cpse	r24, r1
    1bdc:	08 c0       	rjmp	.+16     	; 0x1bee <Local_control_input_handler+0x44>
          Show_running_devices(1);
    1bde:	81 e0       	ldi	r24, 0x01	; 1
    1be0:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <Show_running_devices>
          running_devices_screen++;
    1be4:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    1be8:	8f 5f       	subi	r24, 0xFF	; 255
    1bea:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <running_devices_screen>
          }
        if (keypad_stat == NO_KEY_PRESSED) return;
    1bee:	12 30       	cpi	r17, 0x02	; 2
    1bf0:	09 f4       	brne	.+2      	; 0x1bf4 <Local_control_input_handler+0x4a>
    1bf2:	1f c2       	rjmp	.+1086   	; 0x2032 <Local_control_input_handler+0x488>
        switch (pressed_key) {
    1bf4:	89 81       	ldd	r24, Y+1	; 0x01
    1bf6:	82 33       	cpi	r24, 0x32	; 50
    1bf8:	61 f0       	breq	.+24     	; 0x1c12 <Local_control_input_handler+0x68>
    1bfa:	83 33       	cpi	r24, 0x33	; 51
    1bfc:	71 f0       	breq	.+28     	; 0x1c1a <Local_control_input_handler+0x70>
    1bfe:	81 33       	cpi	r24, 0x31	; 49
    1c00:	99 f4       	brne	.+38     	; 0x1c28 <Local_control_input_handler+0x7e>
            case '1':
              if (running_devices_screen > 1) running_devices_screen--;
    1c02:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    1c06:	82 30       	cpi	r24, 0x02	; 2
    1c08:	78 f0       	brcs	.+30     	; 0x1c28 <Local_control_input_handler+0x7e>
    1c0a:	81 50       	subi	r24, 0x01	; 1
    1c0c:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <running_devices_screen>
    1c10:	0b c0       	rjmp	.+22     	; 0x1c28 <Local_control_input_handler+0x7e>
              break;
            case '2':
              local_control_running_task = 1;
    1c12:	81 e0       	ldi	r24, 0x01	; 1
    1c14:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <local_control_running_task>
              break;
    1c18:	07 c0       	rjmp	.+14     	; 0x1c28 <Local_control_input_handler+0x7e>
            case '3':
              if (running_devices_screen < 7) running_devices_screen++;
    1c1a:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    1c1e:	87 30       	cpi	r24, 0x07	; 7
    1c20:	18 f4       	brcc	.+6      	; 0x1c28 <Local_control_input_handler+0x7e>
    1c22:	8f 5f       	subi	r24, 0xFF	; 255
    1c24:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <running_devices_screen>
              break;
          }
        Show_running_devices(running_devices_screen);
    1c28:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <running_devices_screen>
    1c2c:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <Show_running_devices>
        break;
    1c30:	00 c2       	rjmp	.+1024   	; 0x2032 <Local_control_input_handler+0x488>
        // Logging in
      case 1:
        switch (login_stage) {
    1c32:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <login_stage>
    1c36:	88 23       	and	r24, r24
    1c38:	21 f0       	breq	.+8      	; 0x1c42 <Local_control_input_handler+0x98>
    1c3a:	81 30       	cpi	r24, 0x01	; 1
    1c3c:	09 f4       	brne	.+2      	; 0x1c40 <Local_control_input_handler+0x96>
    1c3e:	73 c0       	rjmp	.+230    	; 0x1d26 <Local_control_input_handler+0x17c>
    1c40:	f8 c1       	rjmp	.+1008   	; 0x2032 <Local_control_input_handler+0x488>
          // Entering the user code
            case 0:
              if (!login_stage_started) {
    1c42:	80 91 e2 07 	lds	r24, 0x07E2	; 0x8007e2 <login_stage_started>
    1c46:	81 11       	cpse	r24, r1
    1c48:	13 c0       	rjmp	.+38     	; 0x1c70 <Local_control_input_handler+0xc6>
                LCD_clear_screen();
    1c4a:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
                Show_side_options_menu();
    1c4e:	0e 94 6f 0c 	call	0x18de	; 0x18de <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "User Code:");
    1c52:	4f e8       	ldi	r20, 0x8F	; 143
    1c54:	51 e0       	ldi	r21, 0x01	; 1
    1c56:	60 e0       	ldi	r22, 0x00	; 0
    1c58:	80 e0       	ldi	r24, 0x00	; 0
    1c5a:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    1c5e:	61 e0       	ldi	r22, 0x01	; 1
    1c60:	80 e0       	ldi	r24, 0x00	; 0
    1c62:	0e 94 0e 04 	call	0x81c	; 0x81c <LCD_move_cursor_xy>
                login_stage_started = true;
    1c66:	81 e0       	ldi	r24, 0x01	; 1
    1c68:	80 93 e2 07 	sts	0x07E2, r24	; 0x8007e2 <login_stage_started>
                input_buffer_pointer = 0;
    1c6c:	10 92 ac 07 	sts	0x07AC, r1	; 0x8007ac <input_buffer_pointer>
                }
              if (keypad_stat == NO_KEY_PRESSED) return;
    1c70:	12 30       	cpi	r17, 0x02	; 2
    1c72:	09 f4       	brne	.+2      	; 0x1c76 <Local_control_input_handler+0xcc>
    1c74:	de c1       	rjmp	.+956    	; 0x2032 <Local_control_input_handler+0x488>
              if (pressed_key == '-') { // Delete last input number
    1c76:	89 81       	ldd	r24, Y+1	; 0x01
    1c78:	8d 32       	cpi	r24, 0x2D	; 45
    1c7a:	a1 f4       	brne	.+40     	; 0x1ca4 <Local_control_input_handler+0xfa>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    1c7c:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1c80:	88 23       	and	r24, r24
    1c82:	19 f0       	breq	.+6      	; 0x1c8a <Local_control_input_handler+0xe0>
    1c84:	81 50       	subi	r24, 0x01	; 1
    1c86:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    1c8a:	40 e3       	ldi	r20, 0x30	; 48
    1c8c:	51 e0       	ldi	r21, 0x01	; 1
    1c8e:	61 e0       	ldi	r22, 0x01	; 1
    1c90:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1c94:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    1c98:	61 e0       	ldi	r22, 0x01	; 1
    1c9a:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1c9e:	0e 94 0e 04 	call	0x81c	; 0x81c <LCD_move_cursor_xy>
    1ca2:	c7 c1       	rjmp	.+910    	; 0x2032 <Local_control_input_handler+0x488>
                }
              else if (pressed_key == '=') {
    1ca4:	8d 33       	cpi	r24, 0x3D	; 61
    1ca6:	39 f5       	brne	.+78     	; 0x1cf6 <Local_control_input_handler+0x14c>
                input_buffer[input_buffer_pointer] = 0;
    1ca8:	e0 91 ac 07 	lds	r30, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1cac:	f0 e0       	ldi	r31, 0x00	; 0
    1cae:	e3 53       	subi	r30, 0x33	; 51
    1cb0:	f8 4f       	sbci	r31, 0xF8	; 248
    1cb2:	10 82       	st	Z, r1
                // Validate user code
                EN_UserStatusCode_t codeExists = getUserByCode(input_buffer, &local_user);
    1cb4:	6d ea       	ldi	r22, 0xAD	; 173
    1cb6:	77 e0       	ldi	r23, 0x07	; 7
    1cb8:	8d ec       	ldi	r24, 0xCD	; 205
    1cba:	97 e0       	ldi	r25, 0x07	; 7
    1cbc:	0e 94 03 15 	call	0x2a06	; 0x2a06 <getUserByCode>
                if (codeExists == USER_FOUND) {
    1cc0:	82 30       	cpi	r24, 0x02	; 2
    1cc2:	31 f4       	brne	.+12     	; 0x1cd0 <Local_control_input_handler+0x126>
                  login_stage_started = false;
    1cc4:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
                  login_stage = 1;
    1cc8:	81 e0       	ldi	r24, 0x01	; 1
    1cca:	80 93 e3 07 	sts	0x07E3, r24	; 0x8007e3 <login_stage>
    1cce:	b1 c1       	rjmp	.+866    	; 0x2032 <Local_control_input_handler+0x488>
                  }
                else {
                  LCD_clear_screen();
    1cd0:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    1cd4:	4a e9       	ldi	r20, 0x9A	; 154
    1cd6:	51 e0       	ldi	r21, 0x01	; 1
    1cd8:	60 e0       	ldi	r22, 0x00	; 0
    1cda:	85 e0       	ldi	r24, 0x05	; 5
    1cdc:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
                  LCD_write_string_xy(2, 1, "User Code !");
    1ce0:	40 ea       	ldi	r20, 0xA0	; 160
    1ce2:	51 e0       	ldi	r21, 0x01	; 1
    1ce4:	61 e0       	ldi	r22, 0x01	; 1
    1ce6:	82 e0       	ldi	r24, 0x02	; 2
    1ce8:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
                  invalid_local_login_attempt();
    1cec:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <invalid_local_login_attempt>
                  login_stage_started = false;
    1cf0:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
    1cf4:	9e c1       	rjmp	.+828    	; 0x2032 <Local_control_input_handler+0x488>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    1cf6:	90 ed       	ldi	r25, 0xD0	; 208
    1cf8:	98 0f       	add	r25, r24
    1cfa:	9a 30       	cpi	r25, 0x0A	; 10
    1cfc:	08 f0       	brcs	.+2      	; 0x1d00 <Local_control_input_handler+0x156>
    1cfe:	99 c1       	rjmp	.+818    	; 0x2032 <Local_control_input_handler+0x488>
                if (input_buffer_pointer < 6) {
    1d00:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1d04:	96 30       	cpi	r25, 0x06	; 6
    1d06:	08 f0       	brcs	.+2      	; 0x1d0a <Local_control_input_handler+0x160>
    1d08:	94 c1       	rjmp	.+808    	; 0x2032 <Local_control_input_handler+0x488>
                  // Echo the input on the LCD
                  LCD_sendData(pressed_key);
    1d0a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <LCD_sendData>
                  input_buffer[input_buffer_pointer] = pressed_key;
    1d0e:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1d12:	e8 2f       	mov	r30, r24
    1d14:	f0 e0       	ldi	r31, 0x00	; 0
    1d16:	e3 53       	subi	r30, 0x33	; 51
    1d18:	f8 4f       	sbci	r31, 0xF8	; 248
    1d1a:	99 81       	ldd	r25, Y+1	; 0x01
    1d1c:	90 83       	st	Z, r25
                  input_buffer_pointer++;
    1d1e:	8f 5f       	subi	r24, 0xFF	; 255
    1d20:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
    1d24:	86 c1       	rjmp	.+780    	; 0x2032 <Local_control_input_handler+0x488>
                  }
                }
              break;
              //  Entering the password
            case 1:
              if (!login_stage_started) {
    1d26:	80 91 e2 07 	lds	r24, 0x07E2	; 0x8007e2 <login_stage_started>
    1d2a:	81 11       	cpse	r24, r1
    1d2c:	13 c0       	rjmp	.+38     	; 0x1d54 <Local_control_input_handler+0x1aa>
                LCD_clear_screen();
    1d2e:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
                Show_side_options_menu();
    1d32:	0e 94 6f 0c 	call	0x18de	; 0x18de <Show_side_options_menu>
                LCD_write_string_xy(0, 0, "Password:");
    1d36:	4c ea       	ldi	r20, 0xAC	; 172
    1d38:	51 e0       	ldi	r21, 0x01	; 1
    1d3a:	60 e0       	ldi	r22, 0x00	; 0
    1d3c:	80 e0       	ldi	r24, 0x00	; 0
    1d3e:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
                LCD_move_cursor_xy(0, 1);
    1d42:	61 e0       	ldi	r22, 0x01	; 1
    1d44:	80 e0       	ldi	r24, 0x00	; 0
    1d46:	0e 94 0e 04 	call	0x81c	; 0x81c <LCD_move_cursor_xy>
                login_stage_started = true;
    1d4a:	81 e0       	ldi	r24, 0x01	; 1
    1d4c:	80 93 e2 07 	sts	0x07E2, r24	; 0x8007e2 <login_stage_started>
                input_buffer_pointer = 0;
    1d50:	10 92 ac 07 	sts	0x07AC, r1	; 0x8007ac <input_buffer_pointer>
                }
              if (pressed_key == '-') { // Delete last input number
    1d54:	89 81       	ldd	r24, Y+1	; 0x01
    1d56:	8d 32       	cpi	r24, 0x2D	; 45
    1d58:	a1 f4       	brne	.+40     	; 0x1d82 <Local_control_input_handler+0x1d8>
                if (input_buffer_pointer > 0) input_buffer_pointer--;
    1d5a:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1d5e:	88 23       	and	r24, r24
    1d60:	19 f0       	breq	.+6      	; 0x1d68 <Local_control_input_handler+0x1be>
    1d62:	81 50       	subi	r24, 0x01	; 1
    1d64:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
                LCD_write_string_xy(input_buffer_pointer, 1, " ");
    1d68:	40 e3       	ldi	r20, 0x30	; 48
    1d6a:	51 e0       	ldi	r21, 0x01	; 1
    1d6c:	61 e0       	ldi	r22, 0x01	; 1
    1d6e:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1d72:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
                LCD_move_cursor_xy(input_buffer_pointer, 1);
    1d76:	61 e0       	ldi	r22, 0x01	; 1
    1d78:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1d7c:	0e 94 0e 04 	call	0x81c	; 0x81c <LCD_move_cursor_xy>
    1d80:	58 c1       	rjmp	.+688    	; 0x2032 <Local_control_input_handler+0x488>
                }
              else if (pressed_key == '=') {
    1d82:	8d 33       	cpi	r24, 0x3D	; 61
    1d84:	09 f0       	breq	.+2      	; 0x1d88 <Local_control_input_handler+0x1de>
    1d86:	54 c0       	rjmp	.+168    	; 0x1e30 <Local_control_input_handler+0x286>
                input_buffer[input_buffer_pointer] = 0;
    1d88:	e0 91 ac 07 	lds	r30, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1d8c:	f0 e0       	ldi	r31, 0x00	; 0
    1d8e:	e3 53       	subi	r30, 0x33	; 51
    1d90:	f8 4f       	sbci	r31, 0xF8	; 248
    1d92:	10 82       	st	Z, r1
                // Validate user password
                if (strcmp(input_buffer, local_user.password) == 0) { // Password is correct
    1d94:	62 ec       	ldi	r22, 0xC2	; 194
    1d96:	77 e0       	ldi	r23, 0x07	; 7
    1d98:	8d ec       	ldi	r24, 0xCD	; 205
    1d9a:	97 e0       	ldi	r25, 0x07	; 7
    1d9c:	0e 94 c4 18 	call	0x3188	; 0x3188 <strcmp>
    1da0:	89 2b       	or	r24, r25
    1da2:	99 f5       	brne	.+102    	; 0x1e0a <Local_control_input_handler+0x260>
                  login_stage_started = false;
    1da4:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
                  login_stage = 0;
    1da8:	10 92 e3 07 	sts	0x07E3, r1	; 0x8007e3 <login_stage>
                  local_control_running_task = 2;
    1dac:	82 e0       	ldi	r24, 0x02	; 2
    1dae:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <local_control_running_task>
                  local_user_loggedin = true;
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <__data_end>
                  LCD_clear_screen();
    1db8:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
                  LCD_write_string_xy(4, 0, "Welcome");
    1dbc:	46 eb       	ldi	r20, 0xB6	; 182
    1dbe:	51 e0       	ldi	r21, 0x01	; 1
    1dc0:	60 e0       	ldi	r22, 0x00	; 0
    1dc2:	84 e0       	ldi	r24, 0x04	; 4
    1dc4:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
                  LCD_write_string_xy((16 - strlen(local_user.name)) / 2 - 1, 1, local_user.name);
    1dc8:	ee ea       	ldi	r30, 0xAE	; 174
    1dca:	f7 e0       	ldi	r31, 0x07	; 7
    1dcc:	01 90       	ld	r0, Z+
    1dce:	00 20       	and	r0, r0
    1dd0:	e9 f7       	brne	.-6      	; 0x1dcc <Local_control_input_handler+0x222>
    1dd2:	9f 01       	movw	r18, r30
    1dd4:	2f 5a       	subi	r18, 0xAF	; 175
    1dd6:	37 40       	sbci	r19, 0x07	; 7
    1dd8:	80 e1       	ldi	r24, 0x10	; 16
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	82 1b       	sub	r24, r18
    1dde:	93 0b       	sbc	r25, r19
    1de0:	96 95       	lsr	r25
    1de2:	87 95       	ror	r24
    1de4:	4e ea       	ldi	r20, 0xAE	; 174
    1de6:	57 e0       	ldi	r21, 0x07	; 7
    1de8:	61 e0       	ldi	r22, 0x01	; 1
    1dea:	81 50       	subi	r24, 0x01	; 1
    1dec:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
                  LCD_sendData('!');
    1df0:	81 e2       	ldi	r24, 0x21	; 33
    1df2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <LCD_sendData>
    1df6:	2f ef       	ldi	r18, 0xFF	; 255
    1df8:	83 ed       	ldi	r24, 0xD3	; 211
    1dfa:	90 e3       	ldi	r25, 0x30	; 48
    1dfc:	21 50       	subi	r18, 0x01	; 1
    1dfe:	80 40       	sbci	r24, 0x00	; 0
    1e00:	90 40       	sbci	r25, 0x00	; 0
    1e02:	e1 f7       	brne	.-8      	; 0x1dfc <Local_control_input_handler+0x252>
    1e04:	00 c0       	rjmp	.+0      	; 0x1e06 <Local_control_input_handler+0x25c>
    1e06:	00 00       	nop
    1e08:	14 c1       	rjmp	.+552    	; 0x2032 <Local_control_input_handler+0x488>
                  _delay_ms(1000);
                  }
                else {
                  LCD_clear_screen();
    1e0a:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
                  LCD_write_string_xy(5, 0, "Wrong");
    1e0e:	4a e9       	ldi	r20, 0x9A	; 154
    1e10:	51 e0       	ldi	r21, 0x01	; 1
    1e12:	60 e0       	ldi	r22, 0x00	; 0
    1e14:	85 e0       	ldi	r24, 0x05	; 5
    1e16:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
                  LCD_write_string_xy(3, 1, "Password !");
    1e1a:	4e eb       	ldi	r20, 0xBE	; 190
    1e1c:	51 e0       	ldi	r21, 0x01	; 1
    1e1e:	61 e0       	ldi	r22, 0x01	; 1
    1e20:	83 e0       	ldi	r24, 0x03	; 3
    1e22:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
                  login_stage_started = false;
    1e26:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <login_stage_started>
                  invalid_local_login_attempt();
    1e2a:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <invalid_local_login_attempt>
    1e2e:	01 c1       	rjmp	.+514    	; 0x2032 <Local_control_input_handler+0x488>
                  }
                }
              else if (pressed_key >= '0' && pressed_key <= '9') { // Ignoring invalid options
    1e30:	90 ed       	ldi	r25, 0xD0	; 208
    1e32:	98 0f       	add	r25, r24
    1e34:	9a 30       	cpi	r25, 0x0A	; 10
    1e36:	08 f0       	brcs	.+2      	; 0x1e3a <Local_control_input_handler+0x290>
    1e38:	fc c0       	rjmp	.+504    	; 0x2032 <Local_control_input_handler+0x488>
                // Limit the input length
                if (input_buffer_pointer < 10) {
    1e3a:	90 91 ac 07 	lds	r25, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1e3e:	9a 30       	cpi	r25, 0x0A	; 10
    1e40:	08 f0       	brcs	.+2      	; 0x1e44 <Local_control_input_handler+0x29a>
    1e42:	f7 c0       	rjmp	.+494    	; 0x2032 <Local_control_input_handler+0x488>
                  // Echo the input on the LCD
                  LCD_sendData(pressed_key);
    1e44:	0e 94 79 03 	call	0x6f2	; 0x6f2 <LCD_sendData>
                  input_buffer[input_buffer_pointer] = pressed_key;
    1e48:	80 91 ac 07 	lds	r24, 0x07AC	; 0x8007ac <input_buffer_pointer>
    1e4c:	e8 2f       	mov	r30, r24
    1e4e:	f0 e0       	ldi	r31, 0x00	; 0
    1e50:	e3 53       	subi	r30, 0x33	; 51
    1e52:	f8 4f       	sbci	r31, 0xF8	; 248
    1e54:	99 81       	ldd	r25, Y+1	; 0x01
    1e56:	90 83       	st	Z, r25
                  input_buffer_pointer++;
    1e58:	8f 5f       	subi	r24, 0xFF	; 255
    1e5a:	80 93 ac 07 	sts	0x07AC, r24	; 0x8007ac <input_buffer_pointer>
    1e5e:	e9 c0       	rjmp	.+466    	; 0x2032 <Local_control_input_handler+0x488>
              break;
          }
        break;
        // Devices control
      case 2:
        if (remote_user_loggedin && !local_control_permission_granted) {
    1e60:	80 91 a8 07 	lds	r24, 0x07A8	; 0x8007a8 <remote_user_loggedin>
    1e64:	88 23       	and	r24, r24
    1e66:	99 f0       	breq	.+38     	; 0x1e8e <Local_control_input_handler+0x2e4>
    1e68:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <local_control_permission_granted>
    1e6c:	81 11       	cpse	r24, r1
    1e6e:	0f c0       	rjmp	.+30     	; 0x1e8e <Local_control_input_handler+0x2e4>
          LCD_clear_screen();
    1e70:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
          LCD_write_string_xy(0, 0, "Admin Permission");
    1e74:	49 ec       	ldi	r20, 0xC9	; 201
    1e76:	51 e0       	ldi	r21, 0x01	; 1
    1e78:	60 e0       	ldi	r22, 0x00	; 0
    1e7a:	80 e0       	ldi	r24, 0x00	; 0
    1e7c:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
          LCD_write_string_xy(3, 1, "Required !");
    1e80:	4a ed       	ldi	r20, 0xDA	; 218
    1e82:	51 e0       	ldi	r21, 0x01	; 1
    1e84:	61 e0       	ldi	r22, 0x01	; 1
    1e86:	83 e0       	ldi	r24, 0x03	; 3
    1e88:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
    1e8c:	d2 c0       	rjmp	.+420    	; 0x2032 <Local_control_input_handler+0x488>
          //~ Controls can be added to allow the user to go back and view the running devices if needed.
          }
        else {
          Get_running_devices();
    1e8e:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <Get_running_devices>
          if (control_devices_screen == 0) {  // First run
    1e92:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1e96:	81 11       	cpse	r24, r1
    1e98:	08 c0       	rjmp	.+16     	; 0x1eaa <Local_control_input_handler+0x300>
            Show_devices_controls(1);
    1e9a:	81 e0       	ldi	r24, 0x01	; 1
    1e9c:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <Show_devices_controls>
            control_devices_screen++;
    1ea0:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1ea4:	8f 5f       	subi	r24, 0xFF	; 255
    1ea6:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
            }
          if (keypad_stat == NO_KEY_PRESSED) return;
    1eaa:	12 30       	cpi	r17, 0x02	; 2
    1eac:	09 f4       	brne	.+2      	; 0x1eb0 <Local_control_input_handler+0x306>
    1eae:	c1 c0       	rjmp	.+386    	; 0x2032 <Local_control_input_handler+0x488>
          switch (pressed_key) {
    1eb0:	89 81       	ldd	r24, Y+1	; 0x01
    1eb2:	82 33       	cpi	r24, 0x32	; 50
    1eb4:	a1 f0       	breq	.+40     	; 0x1ede <Local_control_input_handler+0x334>
    1eb6:	18 f4       	brcc	.+6      	; 0x1ebe <Local_control_input_handler+0x314>
    1eb8:	81 33       	cpi	r24, 0x31	; 49
    1eba:	41 f0       	breq	.+16     	; 0x1ecc <Local_control_input_handler+0x322>
    1ebc:	b6 c0       	rjmp	.+364    	; 0x202a <Local_control_input_handler+0x480>
    1ebe:	83 33       	cpi	r24, 0x33	; 51
    1ec0:	09 f4       	brne	.+2      	; 0x1ec4 <Local_control_input_handler+0x31a>
    1ec2:	73 c0       	rjmp	.+230    	; 0x1faa <Local_control_input_handler+0x400>
    1ec4:	84 33       	cpi	r24, 0x34	; 52
    1ec6:	09 f4       	brne	.+2      	; 0x1eca <Local_control_input_handler+0x320>
    1ec8:	a9 c0       	rjmp	.+338    	; 0x201c <Local_control_input_handler+0x472>
    1eca:	af c0       	rjmp	.+350    	; 0x202a <Local_control_input_handler+0x480>
              case '1':
                if (control_devices_screen > 1) control_devices_screen--;
    1ecc:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1ed0:	82 30       	cpi	r24, 0x02	; 2
    1ed2:	08 f4       	brcc	.+2      	; 0x1ed6 <Local_control_input_handler+0x32c>
    1ed4:	aa c0       	rjmp	.+340    	; 0x202a <Local_control_input_handler+0x480>
    1ed6:	81 50       	subi	r24, 0x01	; 1
    1ed8:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
    1edc:	a6 c0       	rjmp	.+332    	; 0x202a <Local_control_input_handler+0x480>
                break;
              case '2':
                switch (control_devices_screen) {
    1ede:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1ee2:	86 30       	cpi	r24, 0x06	; 6
    1ee4:	19 f0       	breq	.+6      	; 0x1eec <Local_control_input_handler+0x342>
    1ee6:	87 30       	cpi	r24, 0x07	; 7
    1ee8:	a1 f1       	breq	.+104    	; 0x1f52 <Local_control_input_handler+0x3a8>
    1eea:	53 c0       	rjmp	.+166    	; 0x1f92 <Local_control_input_handler+0x3e8>
                    case 6:
                      // Increment the brightness
                      // Floor the brightness
                      dimmer_brightness += ((double)LAMP_6_BRIGHTNESS_PERCENTAGE_STEP * 2.55);
    1eec:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1ef0:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1ef4:	07 2e       	mov	r0, r23
    1ef6:	00 0c       	add	r0, r0
    1ef8:	88 0b       	sbc	r24, r24
    1efa:	99 0b       	sbc	r25, r25
    1efc:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <__floatsisf>
    1f00:	20 e0       	ldi	r18, 0x00	; 0
    1f02:	30 e0       	ldi	r19, 0x00	; 0
    1f04:	4c e4       	ldi	r20, 0x4C	; 76
    1f06:	52 e4       	ldi	r21, 0x42	; 66
    1f08:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <__addsf3>
    1f0c:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <__fixsfsi>
    1f10:	70 93 d9 07 	sts	0x07D9, r23	; 0x8007d9 <dimmer_brightness+0x1>
    1f14:	60 93 d8 07 	sts	0x07D8, r22	; 0x8007d8 <dimmer_brightness>
                      if (dimmer_brightness > 255) dimmer_brightness = 255;
    1f18:	6f 3f       	cpi	r22, 0xFF	; 255
    1f1a:	71 05       	cpc	r23, r1
    1f1c:	39 f0       	breq	.+14     	; 0x1f2c <Local_control_input_handler+0x382>
    1f1e:	34 f0       	brlt	.+12     	; 0x1f2c <Local_control_input_handler+0x382>
    1f20:	8f ef       	ldi	r24, 0xFF	; 255
    1f22:	90 e0       	ldi	r25, 0x00	; 0
    1f24:	90 93 d9 07 	sts	0x07D9, r25	; 0x8007d9 <dimmer_brightness+0x1>
    1f28:	80 93 d8 07 	sts	0x07D8, r24	; 0x8007d8 <dimmer_brightness>
                      Lamp_dimmable_set_brightness(((double)dimmer_brightness / 255.0));
    1f2c:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1f30:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1f34:	07 2e       	mov	r0, r23
    1f36:	00 0c       	add	r0, r0
    1f38:	88 0b       	sbc	r24, r24
    1f3a:	99 0b       	sbc	r25, r25
    1f3c:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <__floatsisf>
    1f40:	20 e0       	ldi	r18, 0x00	; 0
    1f42:	30 e0       	ldi	r19, 0x00	; 0
    1f44:	4f e7       	ldi	r20, 0x7F	; 127
    1f46:	53 e4       	ldi	r21, 0x43	; 67
    1f48:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__divsf3>
    1f4c:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <Lamp_dimmable_set_brightness>
                      break;
    1f50:	6c c0       	rjmp	.+216    	; 0x202a <Local_control_input_handler+0x480>
                    case 7:
                      // Logout
                      local_user_loggedin = false;
    1f52:	10 92 a6 07 	sts	0x07A6, r1	; 0x8007a6 <__data_end>
                      control_devices_screen = 0;
    1f56:	10 92 da 07 	sts	0x07DA, r1	; 0x8007da <control_devices_screen>
                      running_devices_screen = 0;
    1f5a:	10 92 e4 07 	sts	0x07E4, r1	; 0x8007e4 <running_devices_screen>
                      local_control_running_task = 0;
    1f5e:	10 92 ab 07 	sts	0x07AB, r1	; 0x8007ab <local_control_running_task>
                      LCD_clear_screen();
    1f62:	0e 94 ab 03 	call	0x756	; 0x756 <LCD_clear_screen>
                      LCD_write_string_xy(1, 0, "logging out...");
    1f66:	45 ee       	ldi	r20, 0xE5	; 229
    1f68:	51 e0       	ldi	r21, 0x01	; 1
    1f6a:	60 e0       	ldi	r22, 0x00	; 0
    1f6c:	81 e0       	ldi	r24, 0x01	; 1
    1f6e:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
                      LCD_write_string_xy(4, 1, "Good Bye!");
    1f72:	44 ef       	ldi	r20, 0xF4	; 244
    1f74:	51 e0       	ldi	r21, 0x01	; 1
    1f76:	61 e0       	ldi	r22, 0x01	; 1
    1f78:	84 e0       	ldi	r24, 0x04	; 4
    1f7a:	0e 94 1b 04 	call	0x836	; 0x836 <LCD_write_string_xy>
    1f7e:	2f ef       	ldi	r18, 0xFF	; 255
    1f80:	83 ed       	ldi	r24, 0xD3	; 211
    1f82:	90 e3       	ldi	r25, 0x30	; 48
    1f84:	21 50       	subi	r18, 0x01	; 1
    1f86:	80 40       	sbci	r24, 0x00	; 0
    1f88:	90 40       	sbci	r25, 0x00	; 0
    1f8a:	e1 f7       	brne	.-8      	; 0x1f84 <Local_control_input_handler+0x3da>
    1f8c:	00 c0       	rjmp	.+0      	; 0x1f8e <Local_control_input_handler+0x3e4>
    1f8e:	00 00       	nop
    1f90:	4c c0       	rjmp	.+152    	; 0x202a <Local_control_input_handler+0x480>
                      _delay_ms(1000);
                      break;
                    default:
                      Lamp_toggle(control_devices_screen);
    1f92:	0e 94 bc 0b 	call	0x1778	; 0x1778 <Lamp_toggle>
                      running_devices[control_devices_screen - 1] = !running_devices[control_devices_screen - 1];
    1f96:	e0 91 da 07 	lds	r30, 0x07DA	; 0x8007da <control_devices_screen>
    1f9a:	f0 e0       	ldi	r31, 0x00	; 0
    1f9c:	e6 52       	subi	r30, 0x26	; 38
    1f9e:	f8 4f       	sbci	r31, 0xF8	; 248
    1fa0:	90 81       	ld	r25, Z
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	89 27       	eor	r24, r25
    1fa6:	80 83       	st	Z, r24
                      break;
    1fa8:	40 c0       	rjmp	.+128    	; 0x202a <Local_control_input_handler+0x480>
                  }
                break;
              case '3':
                switch (control_devices_screen) {
    1faa:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    1fae:	86 30       	cpi	r24, 0x06	; 6
    1fb0:	79 f5       	brne	.+94     	; 0x2010 <Local_control_input_handler+0x466>
                    case 6:
                      // Decrement the brightness
                      // Ceil the brightness
                      dimmer_brightness -= ((double)LAMP_6_BRIGHTNESS_PERCENTAGE_STEP * 2.55);
    1fb2:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1fb6:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1fba:	07 2e       	mov	r0, r23
    1fbc:	00 0c       	add	r0, r0
    1fbe:	88 0b       	sbc	r24, r24
    1fc0:	99 0b       	sbc	r25, r25
    1fc2:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <__floatsisf>
    1fc6:	20 e0       	ldi	r18, 0x00	; 0
    1fc8:	30 e0       	ldi	r19, 0x00	; 0
    1fca:	4c e4       	ldi	r20, 0x4C	; 76
    1fcc:	52 e4       	ldi	r21, 0x42	; 66
    1fce:	0e 94 ae 16 	call	0x2d5c	; 0x2d5c <__subsf3>
    1fd2:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <__fixsfsi>
    1fd6:	70 93 d9 07 	sts	0x07D9, r23	; 0x8007d9 <dimmer_brightness+0x1>
    1fda:	60 93 d8 07 	sts	0x07D8, r22	; 0x8007d8 <dimmer_brightness>
                      if (dimmer_brightness < 0) dimmer_brightness = 0;
    1fde:	77 23       	and	r23, r23
    1fe0:	24 f4       	brge	.+8      	; 0x1fea <Local_control_input_handler+0x440>
    1fe2:	10 92 d9 07 	sts	0x07D9, r1	; 0x8007d9 <dimmer_brightness+0x1>
    1fe6:	10 92 d8 07 	sts	0x07D8, r1	; 0x8007d8 <dimmer_brightness>
                      Lamp_dimmable_set_brightness(((double)dimmer_brightness / 255.0));
    1fea:	60 91 d8 07 	lds	r22, 0x07D8	; 0x8007d8 <dimmer_brightness>
    1fee:	70 91 d9 07 	lds	r23, 0x07D9	; 0x8007d9 <dimmer_brightness+0x1>
    1ff2:	07 2e       	mov	r0, r23
    1ff4:	00 0c       	add	r0, r0
    1ff6:	88 0b       	sbc	r24, r24
    1ff8:	99 0b       	sbc	r25, r25
    1ffa:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <__floatsisf>
    1ffe:	20 e0       	ldi	r18, 0x00	; 0
    2000:	30 e0       	ldi	r19, 0x00	; 0
    2002:	4f e7       	ldi	r20, 0x7F	; 127
    2004:	53 e4       	ldi	r21, 0x43	; 67
    2006:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__divsf3>
    200a:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <Lamp_dimmable_set_brightness>
                      break;
    200e:	0d c0       	rjmp	.+26     	; 0x202a <Local_control_input_handler+0x480>
                    default:
                      if (control_devices_screen < 7) control_devices_screen++;
    2010:	87 30       	cpi	r24, 0x07	; 7
    2012:	58 f4       	brcc	.+22     	; 0x202a <Local_control_input_handler+0x480>
    2014:	8f 5f       	subi	r24, 0xFF	; 255
    2016:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
    201a:	07 c0       	rjmp	.+14     	; 0x202a <Local_control_input_handler+0x480>
                      break;
                  }
                break;
              case '4':
                // Moving to logout screen
                if (control_devices_screen == 6) control_devices_screen++;
    201c:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    2020:	86 30       	cpi	r24, 0x06	; 6
    2022:	19 f4       	brne	.+6      	; 0x202a <Local_control_input_handler+0x480>
    2024:	8f 5f       	subi	r24, 0xFF	; 255
    2026:	80 93 da 07 	sts	0x07DA, r24	; 0x8007da <control_devices_screen>
                break;
            }
          Show_devices_controls(control_devices_screen);
    202a:	80 91 da 07 	lds	r24, 0x07DA	; 0x8007da <control_devices_screen>
    202e:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <Show_devices_controls>
          }
        break;
    }
    2032:	0f 90       	pop	r0
    2034:	df 91       	pop	r29
    2036:	cf 91       	pop	r28
    2038:	1f 91       	pop	r17
    203a:	08 95       	ret

0000203c <Remote_init>:

void delete_user_prompt(void);

// ***************************************************************************

void Remote_init(u32 baudRate) {
    203c:	cf 92       	push	r12
    203e:	df 92       	push	r13
    2040:	ef 92       	push	r14
    2042:	ff 92       	push	r15
    2044:	6b 01       	movw	r12, r22
    2046:	7c 01       	movw	r14, r24
  User_DB_init();
    2048:	0e 94 66 14 	call	0x28cc	; 0x28cc <User_DB_init>
  BT_init(baudRate);
    204c:	c7 01       	movw	r24, r14
    204e:	b6 01       	movw	r22, r12
    2050:	0e 94 0f 02 	call	0x41e	; 0x41e <BT_init>
  INT0_init(RISING_EDGE_INTERRUPT_REQUEST);
    2054:	83 e0       	ldi	r24, 0x03	; 3
    2056:	0e 94 1e 07 	call	0xe3c	; 0xe3c <INT0_init>
  UART_RXC_INT_init();
    205a:	0e 94 40 07 	call	0xe80	; 0xe80 <UART_RXC_INT_init>
  }
    205e:	ff 90       	pop	r15
    2060:	ef 90       	pop	r14
    2062:	df 90       	pop	r13
    2064:	cf 90       	pop	r12
    2066:	08 95       	ret

00002068 <println_msg>:

void println_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    2068:	0e 94 26 02 	call	0x44c	; 0x44c <BT_sendString>
  // Send CRLF - carriage return + new line
  BT_sendString("\r\n");
    206c:	8e ef       	ldi	r24, 0xFE	; 254
    206e:	91 e0       	ldi	r25, 0x01	; 1
    2070:	0e 94 26 02 	call	0x44c	; 0x44c <BT_sendString>
    2074:	08 95       	ret

00002076 <print_msg>:
  }

void print_msg(s8* msg) {
  // Send the msg
  BT_sendString(msg);
    2076:	0e 94 26 02 	call	0x44c	; 0x44c <BT_sendString>
    207a:	08 95       	ret

0000207c <callFunWhenBufferReady>:
  }

void callFunWhenBufferReady(void) {
  requesting_function();
    207c:	e0 91 59 08 	lds	r30, 0x0859	; 0x800859 <requesting_function>
    2080:	f0 91 5a 08 	lds	r31, 0x085A	; 0x80085a <requesting_function+0x1>
    2084:	09 95       	icall
    2086:	08 95       	ret

00002088 <request_user_input>:
  }

void request_user_input(void (*requestingFunction)(void), u8 msgLength, bool numericalInputOnly) {
  requesting_function = requestingFunction;
    2088:	90 93 5a 08 	sts	0x085A, r25	; 0x80085a <requesting_function+0x1>
    208c:	80 93 59 08 	sts	0x0859, r24	; 0x800859 <requesting_function>
  msg_length = msgLength;
    2090:	60 93 36 08 	sts	0x0836, r22	; 0x800836 <msg_length>
  numerical_input_mode = numericalInputOnly;
    2094:	40 93 e6 07 	sts	0x07E6, r20	; 0x8007e6 <numerical_input_mode>
    2098:	08 95       	ret

0000209a <get_lamp_state>:
  }

void get_lamp_state(u8 lamp, u8* state) {
    209a:	ab 01       	movw	r20, r22
  DIO_Read(lamp + 2, PORT_C, state);
    209c:	63 e4       	ldi	r22, 0x43	; 67
    209e:	8e 5f       	subi	r24, 0xFE	; 254
    20a0:	0e 94 20 06 	call	0xc40	; 0xc40 <DIO_Read>
    20a4:	08 95       	ret

000020a6 <print_remote_control_menu>:
    initial_options_menu();
    }
  }

void print_remote_control_menu(void) {
  println_msg("Select one of the following devices to control:\t");
    20a6:	81 e0       	ldi	r24, 0x01	; 1
    20a8:	92 e0       	ldi	r25, 0x02	; 2
    20aa:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
  println_msg("[1] Lamp 1");
    20ae:	82 e3       	ldi	r24, 0x32	; 50
    20b0:	92 e0       	ldi	r25, 0x02	; 2
    20b2:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
  println_msg("[2] Lamp 2");
    20b6:	8d e3       	ldi	r24, 0x3D	; 61
    20b8:	92 e0       	ldi	r25, 0x02	; 2
    20ba:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
  println_msg("[3] Lamp 3");
    20be:	88 e4       	ldi	r24, 0x48	; 72
    20c0:	92 e0       	ldi	r25, 0x02	; 2
    20c2:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
  println_msg("[4] Lamp 4");
    20c6:	83 e5       	ldi	r24, 0x53	; 83
    20c8:	92 e0       	ldi	r25, 0x02	; 2
    20ca:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
  println_msg("[5] Lamp 5");
    20ce:	8e e5       	ldi	r24, 0x5E	; 94
    20d0:	92 e0       	ldi	r25, 0x02	; 2
    20d2:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
  println_msg("[6] Lamp 6 (dimmable)");
    20d6:	89 e6       	ldi	r24, 0x69	; 105
    20d8:	92 e0       	ldi	r25, 0x02	; 2
    20da:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
  if (remote_user.isAdmin) {
    20de:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    20e2:	88 23       	and	r24, r24
    20e4:	49 f0       	breq	.+18     	; 0x20f8 <print_remote_control_menu+0x52>
    println_msg("[7] The Door");
    20e6:	8f e7       	ldi	r24, 0x7F	; 127
    20e8:	92 e0       	ldi	r25, 0x02	; 2
    20ea:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    println_msg("[8] Go back to main menu");
    20ee:	8c e8       	ldi	r24, 0x8C	; 140
    20f0:	92 e0       	ldi	r25, 0x02	; 2
    20f2:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    20f6:	08 95       	ret
    }
  else {
    println_msg("[7] Go back to main menu");
    20f8:	85 ea       	ldi	r24, 0xA5	; 165
    20fa:	92 e0       	ldi	r25, 0x02	; 2
    20fc:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    2100:	08 95       	ret

00002102 <print_initial_options_menu>:
      }
    }
  }

void print_initial_options_menu(void) {
  if (remote_user.isAdmin) {
    2102:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    2106:	88 23       	and	r24, r24
    2108:	e9 f0       	breq	.+58     	; 0x2144 <print_initial_options_menu+0x42>
    println_msg("Select one of the following options(by entering its number):\t");
    210a:	8e eb       	ldi	r24, 0xBE	; 190
    210c:	92 e0       	ldi	r25, 0x02	; 2
    210e:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    println_msg("[1] Add user\t");
    2112:	8c ef       	ldi	r24, 0xFC	; 252
    2114:	92 e0       	ldi	r25, 0x02	; 2
    2116:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    println_msg("[2] Delete user\t");
    211a:	8a e0       	ldi	r24, 0x0A	; 10
    211c:	93 e0       	ldi	r25, 0x03	; 3
    211e:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    println_msg("[3] Control a device\t");
    2122:	8b e1       	ldi	r24, 0x1B	; 27
    2124:	93 e0       	ldi	r25, 0x03	; 3
    2126:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    println_msg("[4] Log out\t");
    212a:	81 e3       	ldi	r24, 0x31	; 49
    212c:	93 e0       	ldi	r25, 0x03	; 3
    212e:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    if (local_user_loggedin) {
    2132:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <__data_end>
    2136:	88 23       	and	r24, r24
    2138:	89 f0       	breq	.+34     	; 0x215c <print_initial_options_menu+0x5a>
      println_msg("[5] Allow local user control\t");
    213a:	8e e3       	ldi	r24, 0x3E	; 62
    213c:	93 e0       	ldi	r25, 0x03	; 3
    213e:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    2142:	08 95       	ret
      }
    }
  else {
    println_msg("Select one of the following options(by entering its number):\t");
    2144:	8e eb       	ldi	r24, 0xBE	; 190
    2146:	92 e0       	ldi	r25, 0x02	; 2
    2148:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    println_msg("[1] Control a device\t");
    214c:	8c e5       	ldi	r24, 0x5C	; 92
    214e:	93 e0       	ldi	r25, 0x03	; 3
    2150:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    println_msg("[2] Log out\t");
    2154:	82 e7       	ldi	r24, 0x72	; 114
    2156:	93 e0       	ldi	r25, 0x03	; 3
    2158:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    215c:	08 95       	ret

0000215e <grant_local_control_permission>:
    }
  }

void grant_local_control_permission(void) {
  local_control_permission_granted = true;
    215e:	81 e0       	ldi	r24, 0x01	; 1
    2160:	80 93 a7 07 	sts	0x07A7, r24	; 0x8007a7 <local_control_permission_granted>
    2164:	08 95       	ret

00002166 <logout>:
      }
    }
  }

void logout(void) {
  remote_user_loggedin = false;
    2166:	10 92 a8 07 	sts	0x07A8, r1	; 0x8007a8 <remote_user_loggedin>
  println_msg("To login again you have to disconnect and reconnect to the BT module...");
    216a:	8f e7       	ldi	r24, 0x7F	; 127
    216c:	93 e0       	ldi	r25, 0x03	; 3
    216e:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
  println_msg("You have successfully logged out...");
    2172:	87 ec       	ldi	r24, 0xC7	; 199
    2174:	93 e0       	ldi	r25, 0x03	; 3
    2176:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
  msg_length = 0;
    217a:	10 92 36 08 	sts	0x0836, r1	; 0x800836 <msg_length>
    217e:	08 95       	ret

00002180 <initial_options_menu>:
void grant_local_control_permission(void) {
  local_control_permission_granted = true;
  }

void initial_options_menu(void) {
  if (!user_input_accepted) {
    2180:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    2184:	81 11       	cpse	r24, r1
    2186:	0c c0       	rjmp	.+24     	; 0x21a0 <initial_options_menu+0x20>
    print_initial_options_menu();
    2188:	0e 94 81 10 	call	0x2102	; 0x2102 <print_initial_options_menu>
    request_user_input(initial_options_menu, 2, true);
    218c:	41 e0       	ldi	r20, 0x01	; 1
    218e:	62 e0       	ldi	r22, 0x02	; 2
    2190:	80 ec       	ldi	r24, 0xC0	; 192
    2192:	90 e1       	ldi	r25, 0x10	; 16
    2194:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
    user_input_accepted = true;
    2198:	81 e0       	ldi	r24, 0x01	; 1
    219a:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    219e:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    21a0:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (remote_user.isAdmin) {
    21a4:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    21a8:	88 23       	and	r24, r24
    21aa:	49 f1       	breq	.+82     	; 0x21fe <initial_options_menu+0x7e>
      u8 option = msg_buffer[0];
    21ac:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <msg_buffer>
      if (option < '1' || option > '5') {
    21b0:	9f ec       	ldi	r25, 0xCF	; 207
    21b2:	98 0f       	add	r25, r24
    21b4:	95 30       	cpi	r25, 0x05	; 5
    21b6:	38 f0       	brcs	.+14     	; 0x21c6 <initial_options_menu+0x46>
        println_msg("Invalid option!\t");
    21b8:	8b ee       	ldi	r24, 0xEB	; 235
    21ba:	93 e0       	ldi	r25, 0x03	; 3
    21bc:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
        initial_options_menu();
    21c0:	0e 94 c0 10 	call	0x2180	; 0x2180 <initial_options_menu>
    21c4:	08 95       	ret
        }
      else {
        switch (option) {
    21c6:	83 33       	cpi	r24, 0x33	; 51
    21c8:	89 f0       	breq	.+34     	; 0x21ec <initial_options_menu+0x6c>
    21ca:	28 f4       	brcc	.+10     	; 0x21d6 <initial_options_menu+0x56>
    21cc:	81 33       	cpi	r24, 0x31	; 49
    21ce:	41 f0       	breq	.+16     	; 0x21e0 <initial_options_menu+0x60>
    21d0:	82 33       	cpi	r24, 0x32	; 50
    21d2:	49 f0       	breq	.+18     	; 0x21e6 <initial_options_menu+0x66>
    21d4:	08 95       	ret
    21d6:	84 33       	cpi	r24, 0x34	; 52
    21d8:	61 f0       	breq	.+24     	; 0x21f2 <initial_options_menu+0x72>
    21da:	85 33       	cpi	r24, 0x35	; 53
    21dc:	69 f0       	breq	.+26     	; 0x21f8 <initial_options_menu+0x78>
    21de:	08 95       	ret
            case '1':
              add_user_prompt();
    21e0:	0e 94 8b 12 	call	0x2516	; 0x2516 <add_user_prompt>
              break;
    21e4:	08 95       	ret
            case '2':
              delete_user_prompt();
    21e6:	0e 94 17 11 	call	0x222e	; 0x222e <delete_user_prompt>
              break;
    21ea:	08 95       	ret
            case '3':
              remote_control();
    21ec:	0e 94 43 11 	call	0x2286	; 0x2286 <remote_control>
              break;
    21f0:	08 95       	ret
            case '4':
              logout();
    21f2:	0e 94 b3 10 	call	0x2166	; 0x2166 <logout>
              break;
    21f6:	08 95       	ret
            case '5':
              grant_local_control_permission();
    21f8:	0e 94 af 10 	call	0x215e	; 0x215e <grant_local_control_permission>
              break;
    21fc:	08 95       	ret
          }
        }
      }
    else {
      u8 option = msg_buffer[0];
    21fe:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <msg_buffer>
      if (option < '1' || option > '2') {
    2202:	9f ec       	ldi	r25, 0xCF	; 207
    2204:	98 0f       	add	r25, r24
    2206:	92 30       	cpi	r25, 0x02	; 2
    2208:	38 f0       	brcs	.+14     	; 0x2218 <initial_options_menu+0x98>
        println_msg("Invalid option!\t");
    220a:	8b ee       	ldi	r24, 0xEB	; 235
    220c:	93 e0       	ldi	r25, 0x03	; 3
    220e:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
        initial_options_menu();
    2212:	0e 94 c0 10 	call	0x2180	; 0x2180 <initial_options_menu>
    2216:	08 95       	ret
        }
      else {
        switch (option) {
    2218:	81 33       	cpi	r24, 0x31	; 49
    221a:	19 f0       	breq	.+6      	; 0x2222 <initial_options_menu+0xa2>
    221c:	82 33       	cpi	r24, 0x32	; 50
    221e:	21 f0       	breq	.+8      	; 0x2228 <initial_options_menu+0xa8>
    2220:	08 95       	ret
            case '1':
              remote_control();
    2222:	0e 94 43 11 	call	0x2286	; 0x2286 <remote_control>
              break;
    2226:	08 95       	ret
            case '2':
              logout();
    2228:	0e 94 b3 10 	call	0x2166	; 0x2166 <logout>
    222c:	08 95       	ret

0000222e <delete_user_prompt>:
void get_lamp_state(u8 lamp, u8* state) {
  DIO_Read(lamp + 2, PORT_C, state);
  }

void delete_user_prompt(void) {
  if (!user_input_accepted) {
    222e:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    2232:	81 11       	cpse	r24, r1
    2234:	0e c0       	rjmp	.+28     	; 0x2252 <delete_user_prompt+0x24>
    print_msg("Enter the user name of the user you want to delete: ");
    2236:	8c ef       	ldi	r24, 0xFC	; 252
    2238:	93 e0       	ldi	r25, 0x03	; 3
    223a:	0e 94 3b 10 	call	0x2076	; 0x2076 <print_msg>
    request_user_input(delete_user_prompt, 13, false);
    223e:	40 e0       	ldi	r20, 0x00	; 0
    2240:	6d e0       	ldi	r22, 0x0D	; 13
    2242:	87 e1       	ldi	r24, 0x17	; 23
    2244:	91 e1       	ldi	r25, 0x11	; 17
    2246:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
    user_input_accepted = true;
    224a:	81 e0       	ldi	r24, 0x01	; 1
    224c:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    2250:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    2252:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    2256:	67 e0       	ldi	r22, 0x07	; 7
    2258:	78 e0       	ldi	r23, 0x08	; 8
    225a:	87 e2       	ldi	r24, 0x27	; 39
    225c:	98 e0       	ldi	r25, 0x08	; 8
    225e:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    2262:	83 30       	cpi	r24, 0x03	; 3
    2264:	29 f4       	brne	.+10     	; 0x2270 <delete_user_prompt+0x42>
      println_msg("\rError! User not found. Returning to the main menu...");
    2266:	81 e3       	ldi	r24, 0x31	; 49
    2268:	94 e0       	ldi	r25, 0x04	; 4
    226a:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    226e:	08 c0       	rjmp	.+16     	; 0x2280 <delete_user_prompt+0x52>
      }
    else {
      // Delete the user
      delete_user(&temp_user);
    2270:	87 e0       	ldi	r24, 0x07	; 7
    2272:	98 e0       	ldi	r25, 0x08	; 8
    2274:	0e 94 3b 16 	call	0x2c76	; 0x2c76 <delete_user>
      println_msg("The user has been deleted successfully!\t");
    2278:	87 e6       	ldi	r24, 0x67	; 103
    227a:	94 e0       	ldi	r25, 0x04	; 4
    227c:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
      }
    initial_options_menu();
    2280:	0e 94 c0 10 	call	0x2180	; 0x2180 <initial_options_menu>
    2284:	08 95       	ret

00002286 <remote_control>:
    }
  remote_control();
  }

// Prints the state of the device and prompts the user if he wants to change it.
void remote_control(void) {
    2286:	0f 93       	push	r16
    2288:	1f 93       	push	r17
    228a:	cf 93       	push	r28
    228c:	df 93       	push	r29
    228e:	1f 92       	push	r1
    2290:	cd b7       	in	r28, 0x3d	; 61
    2292:	de b7       	in	r29, 0x3e	; 62
  if (!user_input_accepted) {
    2294:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    2298:	81 11       	cpse	r24, r1
    229a:	0c c0       	rjmp	.+24     	; 0x22b4 <remote_control+0x2e>
    print_remote_control_menu();
    229c:	0e 94 53 10 	call	0x20a6	; 0x20a6 <print_remote_control_menu>
    request_user_input(remote_control, 2, true);
    22a0:	41 e0       	ldi	r20, 0x01	; 1
    22a2:	62 e0       	ldi	r22, 0x02	; 2
    22a4:	83 e4       	ldi	r24, 0x43	; 67
    22a6:	91 e1       	ldi	r25, 0x11	; 17
    22a8:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
    user_input_accepted = true;
    22ac:	81 e0       	ldi	r24, 0x01	; 1
    22ae:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    22b2:	4b c0       	rjmp	.+150    	; 0x234a <remote_control+0xc4>
    }
  else {
    user_input_accepted = false;
    22b4:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    u8 option = msg_buffer[0];
    22b8:	10 91 27 08 	lds	r17, 0x0827	; 0x800827 <msg_buffer>
    if ((!remote_user.isAdmin && option > '7') || option < '1' || option > '8') {
    22bc:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    22c0:	81 11       	cpse	r24, r1
    22c2:	02 c0       	rjmp	.+4      	; 0x22c8 <remote_control+0x42>
    22c4:	18 33       	cpi	r17, 0x38	; 56
    22c6:	20 f4       	brcc	.+8      	; 0x22d0 <remote_control+0x4a>
    22c8:	11 33       	cpi	r17, 0x31	; 49
    22ca:	10 f0       	brcs	.+4      	; 0x22d0 <remote_control+0x4a>
    22cc:	19 33       	cpi	r17, 0x39	; 57
    22ce:	38 f0       	brcs	.+14     	; 0x22de <remote_control+0x58>
      println_msg("Invalid option!\t");
    22d0:	8b ee       	ldi	r24, 0xEB	; 235
    22d2:	93 e0       	ldi	r25, 0x03	; 3
    22d4:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
      remote_control();
    22d8:	0e 94 43 11 	call	0x2286	; 0x2286 <remote_control>
    22dc:	36 c0       	rjmp	.+108    	; 0x234a <remote_control+0xc4>
      }
    else {
      u8 state;
      get_lamp_state(option - 48, &state);
    22de:	be 01       	movw	r22, r28
    22e0:	6f 5f       	subi	r22, 0xFF	; 255
    22e2:	7f 4f       	sbci	r23, 0xFF	; 255
    22e4:	00 ed       	ldi	r16, 0xD0	; 208
    22e6:	01 0f       	add	r16, r17
    22e8:	80 2f       	mov	r24, r16
    22ea:	0e 94 4d 10 	call	0x209a	; 0x209a <get_lamp_state>
      device_number = option - 48;
    22ee:	00 93 38 08 	sts	0x0838, r16	; 0x800838 <device_number>
      switch (option) {
    22f2:	17 33       	cpi	r17, 0x37	; 55
    22f4:	79 f0       	breq	.+30     	; 0x2314 <remote_control+0x8e>
    22f6:	18 33       	cpi	r17, 0x38	; 56
    22f8:	f9 f0       	breq	.+62     	; 0x2338 <remote_control+0xb2>
    22fa:	16 33       	cpi	r17, 0x36	; 54
    22fc:	01 f5       	brne	.+64     	; 0x233e <remote_control+0xb8>
          case '6':
            print_msg("Enter the brightness level for the lamp(from 0(off) to 9(max)): ");
    22fe:	80 e9       	ldi	r24, 0x90	; 144
    2300:	94 e0       	ldi	r25, 0x04	; 4
    2302:	0e 94 3b 10 	call	0x2076	; 0x2076 <print_msg>
            request_user_input(control_device, 2, true);
    2306:	41 e0       	ldi	r20, 0x01	; 1
    2308:	62 e0       	ldi	r22, 0x02	; 2
    230a:	8b ea       	ldi	r24, 0xAB	; 171
    230c:	91 e1       	ldi	r25, 0x11	; 17
    230e:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
            break;
    2312:	1b c0       	rjmp	.+54     	; 0x234a <remote_control+0xc4>
          case '7':
            if (remote_user.isAdmin) {
    2314:	80 91 e7 07 	lds	r24, 0x07E7	; 0x8007e7 <remote_user>
    2318:	88 23       	and	r24, r24
    231a:	59 f0       	breq	.+22     	; 0x2332 <remote_control+0xac>
              println_msg("Enter 1 to open the door and 0 to close it: ");
    231c:	81 ed       	ldi	r24, 0xD1	; 209
    231e:	94 e0       	ldi	r25, 0x04	; 4
    2320:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
              request_user_input(control_device, 2, true);
    2324:	41 e0       	ldi	r20, 0x01	; 1
    2326:	62 e0       	ldi	r22, 0x02	; 2
    2328:	8b ea       	ldi	r24, 0xAB	; 171
    232a:	91 e1       	ldi	r25, 0x11	; 17
    232c:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
    2330:	0c c0       	rjmp	.+24     	; 0x234a <remote_control+0xc4>
              }
            else {
              initial_options_menu();
    2332:	0e 94 c0 10 	call	0x2180	; 0x2180 <initial_options_menu>
    2336:	09 c0       	rjmp	.+18     	; 0x234a <remote_control+0xc4>
              }
            break;
          case '8':
            initial_options_menu();
    2338:	0e 94 c0 10 	call	0x2180	; 0x2180 <initial_options_menu>
            break;
    233c:	06 c0       	rjmp	.+12     	; 0x234a <remote_control+0xc4>
            // else {
            //   print_msg("Lamp ");
            //   // BT_sendChar(device_number);
            //   println_msg(" is off. Turn it on? (Y/N)");
            //   }
            request_user_input(control_device, 2, false);
    233e:	40 e0       	ldi	r20, 0x00	; 0
    2340:	62 e0       	ldi	r22, 0x02	; 2
    2342:	8b ea       	ldi	r24, 0xAB	; 171
    2344:	91 e1       	ldi	r25, 0x11	; 17
    2346:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
            break;
        }
      }
    }
  }
    234a:	0f 90       	pop	r0
    234c:	df 91       	pop	r29
    234e:	cf 91       	pop	r28
    2350:	1f 91       	pop	r17
    2352:	0f 91       	pop	r16
    2354:	08 95       	ret

00002356 <control_device>:
    println_msg("[7] Go back to main menu");
    }
  }

void control_device(void) {
  u8 option = msg_buffer[0];
    2356:	60 91 27 08 	lds	r22, 0x0827	; 0x800827 <msg_buffer>
  switch (device_number) {
    235a:	80 91 38 08 	lds	r24, 0x0838	; 0x800838 <device_number>
    235e:	86 30       	cpi	r24, 0x06	; 6
    2360:	19 f0       	breq	.+6      	; 0x2368 <control_device+0x12>
    2362:	87 30       	cpi	r24, 0x07	; 7
    2364:	d9 f0       	breq	.+54     	; 0x239c <control_device+0x46>
    2366:	33 c0       	rjmp	.+102    	; 0x23ce <control_device+0x78>
      case 6:
        if (option < '0' || option > '9') {
    2368:	60 53       	subi	r22, 0x30	; 48
    236a:	6a 30       	cpi	r22, 0x0A	; 10
    236c:	28 f0       	brcs	.+10     	; 0x2378 <control_device+0x22>
          println_msg("\r\nInvalid input!!\t");
    236e:	8e ef       	ldi	r24, 0xFE	; 254
    2370:	94 e0       	ldi	r25, 0x04	; 4
    2372:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    2376:	37 c0       	rjmp	.+110    	; 0x23e6 <control_device+0x90>
          }
        else {
          option -= 48; // Convert to int
          Lamp_dimmable_set_brightness((double)option / 9.0);
    2378:	70 e0       	ldi	r23, 0x00	; 0
    237a:	80 e0       	ldi	r24, 0x00	; 0
    237c:	90 e0       	ldi	r25, 0x00	; 0
    237e:	0e 94 c3 17 	call	0x2f86	; 0x2f86 <__floatunsisf>
    2382:	20 e0       	ldi	r18, 0x00	; 0
    2384:	30 e0       	ldi	r19, 0x00	; 0
    2386:	40 e1       	ldi	r20, 0x10	; 16
    2388:	51 e4       	ldi	r21, 0x41	; 65
    238a:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <__divsf3>
    238e:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <Lamp_dimmable_set_brightness>
          println_msg("The brightness has been adjusted!");
    2392:	81 e1       	ldi	r24, 0x11	; 17
    2394:	95 e0       	ldi	r25, 0x05	; 5
    2396:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    239a:	25 c0       	rjmp	.+74     	; 0x23e6 <control_device+0x90>
          }
        break;
      case 7:
        if (option != '0' && option != '1') {
    239c:	80 ed       	ldi	r24, 0xD0	; 208
    239e:	86 0f       	add	r24, r22
    23a0:	82 30       	cpi	r24, 0x02	; 2
    23a2:	28 f0       	brcs	.+10     	; 0x23ae <control_device+0x58>
          println_msg("\r\nInvalid input!!\t");
    23a4:	8e ef       	ldi	r24, 0xFE	; 254
    23a6:	94 e0       	ldi	r25, 0x04	; 4
    23a8:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    23ac:	1c c0       	rjmp	.+56     	; 0x23e6 <control_device+0x90>
          }
        else {
          if (option == '0') {
    23ae:	60 33       	cpi	r22, 0x30	; 48
    23b0:	39 f4       	brne	.+14     	; 0x23c0 <control_device+0x6a>
            Door_close();
    23b2:	0e 94 3d 0b 	call	0x167a	; 0x167a <Door_close>
            println_msg("The Door is closed now.");
    23b6:	83 e3       	ldi	r24, 0x33	; 51
    23b8:	95 e0       	ldi	r25, 0x05	; 5
    23ba:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    23be:	13 c0       	rjmp	.+38     	; 0x23e6 <control_device+0x90>
            }
          else {
            Door_open();
    23c0:	0e 94 39 0b 	call	0x1672	; 0x1672 <Door_open>
            println_msg("The Door is open now.");
    23c4:	8b e4       	ldi	r24, 0x4B	; 75
    23c6:	95 e0       	ldi	r25, 0x05	; 5
    23c8:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    23cc:	0c c0       	rjmp	.+24     	; 0x23e6 <control_device+0x90>
            }
          }
        break;
      default:
        if (option != 'Y' && option != 'y' && option != 'n' && option != 'N') {
    23ce:	69 35       	cpi	r22, 0x59	; 89
    23d0:	51 f0       	breq	.+20     	; 0x23e6 <control_device+0x90>
    23d2:	69 37       	cpi	r22, 0x79	; 121
    23d4:	41 f0       	breq	.+16     	; 0x23e6 <control_device+0x90>
    23d6:	6e 36       	cpi	r22, 0x6E	; 110
    23d8:	31 f0       	breq	.+12     	; 0x23e6 <control_device+0x90>
    23da:	6e 34       	cpi	r22, 0x4E	; 78
    23dc:	21 f0       	breq	.+8      	; 0x23e6 <control_device+0x90>
          println_msg("\r\nInvalid input!!\t");
    23de:	8e ef       	ldi	r24, 0xFE	; 254
    23e0:	94 e0       	ldi	r25, 0x04	; 4
    23e2:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
          //   println_msg("The Lamp is now off!");
          //   }
          }
        break;
    }
  remote_control();
    23e6:	0e 94 43 11 	call	0x2286	; 0x2286 <remote_control>
    23ea:	08 95       	ret

000023ec <add_user_isAdmin_prompt>:
  println_msg("You have successfully logged out...");
  msg_length = 0;
  }

void add_user_isAdmin_prompt(void) {
  if (!user_input_accepted) {
    23ec:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    23f0:	81 11       	cpse	r24, r1
    23f2:	0e c0       	rjmp	.+28     	; 0x2410 <add_user_isAdmin_prompt+0x24>
    println_msg("Do you want to make the new user an admin? (y/n) ");
    23f4:	81 e6       	ldi	r24, 0x61	; 97
    23f6:	95 e0       	ldi	r25, 0x05	; 5
    23f8:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    request_user_input(add_user_isAdmin_prompt, 2, false);
    23fc:	40 e0       	ldi	r20, 0x00	; 0
    23fe:	62 e0       	ldi	r22, 0x02	; 2
    2400:	86 ef       	ldi	r24, 0xF6	; 246
    2402:	91 e1       	ldi	r25, 0x11	; 17
    2404:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
    user_input_accepted = true;
    2408:	81 e0       	ldi	r24, 0x01	; 1
    240a:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    240e:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    2410:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    new_user.isAdmin = (msg_buffer[0] == 'y' || msg_buffer[0] == 'Y');
    2414:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <msg_buffer>
    2418:	89 37       	cpi	r24, 0x79	; 121
    241a:	21 f0       	breq	.+8      	; 0x2424 <add_user_isAdmin_prompt+0x38>
    241c:	89 35       	cpi	r24, 0x59	; 89
    241e:	21 f4       	brne	.+8      	; 0x2428 <add_user_isAdmin_prompt+0x3c>
    2420:	81 e0       	ldi	r24, 0x01	; 1
    2422:	03 c0       	rjmp	.+6      	; 0x242a <add_user_isAdmin_prompt+0x3e>
    2424:	81 e0       	ldi	r24, 0x01	; 1
    2426:	01 c0       	rjmp	.+2      	; 0x242a <add_user_isAdmin_prompt+0x3e>
    2428:	80 e0       	ldi	r24, 0x00	; 0
    242a:	80 93 39 08 	sts	0x0839, r24	; 0x800839 <new_user>
    add_user(&new_user);
    242e:	89 e3       	ldi	r24, 0x39	; 57
    2430:	98 e0       	ldi	r25, 0x08	; 8
    2432:	0e 94 00 16 	call	0x2c00	; 0x2c00 <add_user>
    println_msg("User has been added successfully!");
    2436:	83 e9       	ldi	r24, 0x93	; 147
    2438:	95 e0       	ldi	r25, 0x05	; 5
    243a:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    // Return to the main menu
    initial_options_menu();
    243e:	0e 94 c0 10 	call	0x2180	; 0x2180 <initial_options_menu>
    2442:	08 95       	ret

00002444 <add_user_password_prompt>:
    }
  }

void add_user_password_prompt(void) {
  if (!user_input_accepted) {
    2444:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    2448:	81 11       	cpse	r24, r1
    244a:	0e c0       	rjmp	.+28     	; 0x2468 <add_user_password_prompt+0x24>
    println_msg("Enter the new user's password(The password can only consist of numbers and 4 digits at least, 10 at max): ");
    244c:	85 eb       	ldi	r24, 0xB5	; 181
    244e:	95 e0       	ldi	r25, 0x05	; 5
    2450:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    request_user_input(add_user_password_prompt, 11, true);
    2454:	41 e0       	ldi	r20, 0x01	; 1
    2456:	6b e0       	ldi	r22, 0x0B	; 11
    2458:	82 e2       	ldi	r24, 0x22	; 34
    245a:	92 e1       	ldi	r25, 0x12	; 18
    245c:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
    user_input_accepted = true;
    2460:	81 e0       	ldi	r24, 0x01	; 1
    2462:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    2466:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    2468:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (strlen(msg_buffer) < 4) {
    246c:	e7 e2       	ldi	r30, 0x27	; 39
    246e:	f8 e0       	ldi	r31, 0x08	; 8
    2470:	01 90       	ld	r0, Z+
    2472:	00 20       	and	r0, r0
    2474:	e9 f7       	brne	.-6      	; 0x2470 <add_user_password_prompt+0x2c>
    2476:	31 97       	sbiw	r30, 0x01	; 1
    2478:	e7 52       	subi	r30, 0x27	; 39
    247a:	f8 40       	sbci	r31, 0x08	; 8
    247c:	34 97       	sbiw	r30, 0x04	; 4
    247e:	38 f4       	brcc	.+14     	; 0x248e <add_user_password_prompt+0x4a>
      println_msg("Password too short!!\t");
    2480:	80 e2       	ldi	r24, 0x20	; 32
    2482:	96 e0       	ldi	r25, 0x06	; 6
    2484:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
      add_user_password_prompt();
    2488:	0e 94 22 12 	call	0x2444	; 0x2444 <add_user_password_prompt>
    248c:	08 95       	ret
      }
    else {
      strcpy(new_user.password, msg_buffer);
    248e:	67 e2       	ldi	r22, 0x27	; 39
    2490:	78 e0       	ldi	r23, 0x08	; 8
    2492:	8e e4       	ldi	r24, 0x4E	; 78
    2494:	98 e0       	ldi	r25, 0x08	; 8
    2496:	0e 94 cd 18 	call	0x319a	; 0x319a <strcpy>
      add_user_isAdmin_prompt();
    249a:	0e 94 f6 11 	call	0x23ec	; 0x23ec <add_user_isAdmin_prompt>
    249e:	08 95       	ret

000024a0 <add_user_code_prompt>:
      }
    }
  }

void add_user_code_prompt(void) {
  if (!user_input_accepted) {
    24a0:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    24a4:	81 11       	cpse	r24, r1
    24a6:	0e c0       	rjmp	.+28     	; 0x24c4 <add_user_code_prompt+0x24>
    print_msg("Enter the new user's code(must be a unique six digit code): ");
    24a8:	86 e3       	ldi	r24, 0x36	; 54
    24aa:	96 e0       	ldi	r25, 0x06	; 6
    24ac:	0e 94 3b 10 	call	0x2076	; 0x2076 <print_msg>
    request_user_input(add_user_code_prompt, 7, true);
    24b0:	41 e0       	ldi	r20, 0x01	; 1
    24b2:	67 e0       	ldi	r22, 0x07	; 7
    24b4:	80 e5       	ldi	r24, 0x50	; 80
    24b6:	92 e1       	ldi	r25, 0x12	; 18
    24b8:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
    user_input_accepted = true;
    24bc:	81 e0       	ldi	r24, 0x01	; 1
    24be:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    24c2:	08 95       	ret
    }
  else {// Validating the length of the user code. It can't be more than 6 digits by the input limitations. But the input can be smaller
    user_input_accepted = false;
    24c4:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (strlen(msg_buffer) != 6) {
    24c8:	e7 e2       	ldi	r30, 0x27	; 39
    24ca:	f8 e0       	ldi	r31, 0x08	; 8
    24cc:	01 90       	ld	r0, Z+
    24ce:	00 20       	and	r0, r0
    24d0:	e9 f7       	brne	.-6      	; 0x24cc <add_user_code_prompt+0x2c>
    24d2:	ee 52       	subi	r30, 0x2E	; 46
    24d4:	f8 40       	sbci	r31, 0x08	; 8
    24d6:	39 f0       	breq	.+14     	; 0x24e6 <add_user_code_prompt+0x46>
      println_msg("User code too short!");
    24d8:	83 e7       	ldi	r24, 0x73	; 115
    24da:	96 e0       	ldi	r25, 0x06	; 6
    24dc:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
      add_user_code_prompt();
    24e0:	0e 94 50 12 	call	0x24a0	; 0x24a0 <add_user_code_prompt>
    24e4:	08 95       	ret
      }
    else {
      EN_UserStatusCode_t userExists = getUserByCode(msg_buffer, &temp_user);
    24e6:	67 e0       	ldi	r22, 0x07	; 7
    24e8:	78 e0       	ldi	r23, 0x08	; 8
    24ea:	87 e2       	ldi	r24, 0x27	; 39
    24ec:	98 e0       	ldi	r25, 0x08	; 8
    24ee:	0e 94 03 15 	call	0x2a06	; 0x2a06 <getUserByCode>
      if (userExists == USER_NOT_FOUND) {
    24f2:	83 30       	cpi	r24, 0x03	; 3
    24f4:	49 f4       	brne	.+18     	; 0x2508 <add_user_code_prompt+0x68>
        strcpy(new_user.code, msg_buffer);
    24f6:	67 e2       	ldi	r22, 0x27	; 39
    24f8:	78 e0       	ldi	r23, 0x08	; 8
    24fa:	87 e4       	ldi	r24, 0x47	; 71
    24fc:	98 e0       	ldi	r25, 0x08	; 8
    24fe:	0e 94 cd 18 	call	0x319a	; 0x319a <strcpy>
        add_user_password_prompt();
    2502:	0e 94 22 12 	call	0x2444	; 0x2444 <add_user_password_prompt>
    2506:	08 95       	ret
        }
      else {
        println_msg("\rThe user code already exists!\t");
    2508:	88 e8       	ldi	r24, 0x88	; 136
    250a:	96 e0       	ldi	r25, 0x06	; 6
    250c:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
        add_user_code_prompt();
    2510:	0e 94 50 12 	call	0x24a0	; 0x24a0 <add_user_code_prompt>
    2514:	08 95       	ret

00002516 <add_user_prompt>:
      }
    }
  }

void add_user_prompt(void) {
  if (!user_input_accepted) {
    2516:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    251a:	81 11       	cpse	r24, r1
    251c:	0e c0       	rjmp	.+28     	; 0x253a <add_user_prompt+0x24>
    print_msg("Enter the new user's name: ");
    251e:	88 ea       	ldi	r24, 0xA8	; 168
    2520:	96 e0       	ldi	r25, 0x06	; 6
    2522:	0e 94 3b 10 	call	0x2076	; 0x2076 <print_msg>
    request_user_input(add_user_prompt, 13, false);
    2526:	40 e0       	ldi	r20, 0x00	; 0
    2528:	6d e0       	ldi	r22, 0x0D	; 13
    252a:	8b e8       	ldi	r24, 0x8B	; 139
    252c:	92 e1       	ldi	r25, 0x12	; 18
    252e:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
    user_input_accepted = true;
    2532:	81 e0       	ldi	r24, 0x01	; 1
    2534:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    2538:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    253a:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &temp_user);
    253e:	67 e0       	ldi	r22, 0x07	; 7
    2540:	78 e0       	ldi	r23, 0x08	; 8
    2542:	87 e2       	ldi	r24, 0x27	; 39
    2544:	98 e0       	ldi	r25, 0x08	; 8
    2546:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <getUserByName>
    if (userExists == USER_NOT_FOUND) {
    254a:	83 30       	cpi	r24, 0x03	; 3
    254c:	49 f4       	brne	.+18     	; 0x2560 <add_user_prompt+0x4a>
      strcpy(new_user.name, msg_buffer);
    254e:	67 e2       	ldi	r22, 0x27	; 39
    2550:	78 e0       	ldi	r23, 0x08	; 8
    2552:	8a e3       	ldi	r24, 0x3A	; 58
    2554:	98 e0       	ldi	r25, 0x08	; 8
    2556:	0e 94 cd 18 	call	0x319a	; 0x319a <strcpy>
      add_user_code_prompt();
    255a:	0e 94 50 12 	call	0x24a0	; 0x24a0 <add_user_code_prompt>
    255e:	08 95       	ret
      }
    else {
      // Prompt the user to enter the user code
      println_msg("\rThe user already exists!\t");
    2560:	84 ec       	ldi	r24, 0xC4	; 196
    2562:	96 e0       	ldi	r25, 0x06	; 6
    2564:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
      //! Return to the main menu
      initial_options_menu();
    2568:	0e 94 c0 10 	call	0x2180	; 0x2180 <initial_options_menu>
    256c:	08 95       	ret

0000256e <invalid_remote_login_attempt>:
  // // Show the options menu
  // initial_options_menu();
  // }
  }

void invalid_remote_login_attempt(void) {
    256e:	0f 93       	push	r16
    2570:	1f 93       	push	r17
    2572:	cf 93       	push	r28
    2574:	df 93       	push	r29
    2576:	cd b7       	in	r28, 0x3d	; 61
    2578:	de b7       	in	r29, 0x3e	; 62
    257a:	e2 97       	sbiw	r28, 0x32	; 50
    257c:	0f b6       	in	r0, 0x3f	; 63
    257e:	f8 94       	cli
    2580:	de bf       	out	0x3e, r29	; 62
    2582:	0f be       	out	0x3f, r0	; 63
    2584:	cd bf       	out	0x3d, r28	; 61
  invalid_trails++;
    2586:	80 91 aa 07 	lds	r24, 0x07AA	; 0x8007aa <invalid_trails>
    258a:	8f 5f       	subi	r24, 0xFF	; 255
    258c:	80 93 aa 07 	sts	0x07AA, r24	; 0x8007aa <invalid_trails>
  s8 msg[50];
  if (invalid_trails < 3) {
    2590:	83 30       	cpi	r24, 0x03	; 3
    2592:	e8 f4       	brcc	.+58     	; 0x25ce <invalid_remote_login_attempt+0x60>
    sprintf(msg, "Invalid login attempt! \r\n%d attempts remaining.", 3 - invalid_trails);
    2594:	23 e0       	ldi	r18, 0x03	; 3
    2596:	30 e0       	ldi	r19, 0x00	; 0
    2598:	a9 01       	movw	r20, r18
    259a:	48 1b       	sub	r20, r24
    259c:	51 09       	sbc	r21, r1
    259e:	ca 01       	movw	r24, r20
    25a0:	9f 93       	push	r25
    25a2:	4f 93       	push	r20
    25a4:	8f ed       	ldi	r24, 0xDF	; 223
    25a6:	96 e0       	ldi	r25, 0x06	; 6
    25a8:	9f 93       	push	r25
    25aa:	8f 93       	push	r24
    25ac:	8e 01       	movw	r16, r28
    25ae:	0f 5f       	subi	r16, 0xFF	; 255
    25b0:	1f 4f       	sbci	r17, 0xFF	; 255
    25b2:	1f 93       	push	r17
    25b4:	0f 93       	push	r16
    25b6:	0e 94 d4 18 	call	0x31a8	; 0x31a8 <sprintf>
    println_msg(msg);
    25ba:	c8 01       	movw	r24, r16
    25bc:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
    return;
    25c0:	0f 90       	pop	r0
    25c2:	0f 90       	pop	r0
    25c4:	0f 90       	pop	r0
    25c6:	0f 90       	pop	r0
    25c8:	0f 90       	pop	r0
    25ca:	0f 90       	pop	r0
    25cc:	0f c0       	rjmp	.+30     	; 0x25ec <invalid_remote_login_attempt+0x7e>
    }
  strcpy(msg, "Too many login attempts! \r--- System Suspended! ---");
    25ce:	84 e3       	ldi	r24, 0x34	; 52
    25d0:	ef e0       	ldi	r30, 0x0F	; 15
    25d2:	f7 e0       	ldi	r31, 0x07	; 7
    25d4:	de 01       	movw	r26, r28
    25d6:	11 96       	adiw	r26, 0x01	; 1
    25d8:	01 90       	ld	r0, Z+
    25da:	0d 92       	st	X+, r0
    25dc:	8a 95       	dec	r24
    25de:	e1 f7       	brne	.-8      	; 0x25d8 <invalid_remote_login_attempt+0x6a>
  println_msg(msg);
    25e0:	ce 01       	movw	r24, r28
    25e2:	01 96       	adiw	r24, 0x01	; 1
    25e4:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
  run_system = false;
    25e8:	10 92 a9 07 	sts	0x07A9, r1	; 0x8007a9 <run_system>
  }
    25ec:	e2 96       	adiw	r28, 0x32	; 50
    25ee:	0f b6       	in	r0, 0x3f	; 63
    25f0:	f8 94       	cli
    25f2:	de bf       	out	0x3e, r29	; 62
    25f4:	0f be       	out	0x3f, r0	; 63
    25f6:	cd bf       	out	0x3d, r28	; 61
    25f8:	df 91       	pop	r29
    25fa:	cf 91       	pop	r28
    25fc:	1f 91       	pop	r17
    25fe:	0f 91       	pop	r16
    2600:	08 95       	ret

00002602 <userPassword_prompt_handler>:
      }
    }
  }

void userPassword_prompt_handler(void) {
  if (!user_input_accepted) {
    2602:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    2606:	81 11       	cpse	r24, r1
    2608:	0e c0       	rjmp	.+28     	; 0x2626 <userPassword_prompt_handler+0x24>
    print_msg("Enter your password:\t");
    260a:	83 e4       	ldi	r24, 0x43	; 67
    260c:	97 e0       	ldi	r25, 0x07	; 7
    260e:	0e 94 3b 10 	call	0x2076	; 0x2076 <print_msg>
    request_user_input(userPassword_prompt_handler, 11, true);
    2612:	41 e0       	ldi	r20, 0x01	; 1
    2614:	6b e0       	ldi	r22, 0x0B	; 11
    2616:	81 e0       	ldi	r24, 0x01	; 1
    2618:	93 e1       	ldi	r25, 0x13	; 19
    261a:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
    user_input_accepted = true;
    261e:	81 e0       	ldi	r24, 0x01	; 1
    2620:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    2624:	08 95       	ret
    }
  else {
    user_input_accepted = false;
    2626:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (strcmp(remote_user.password, msg_buffer)) { // Wrong password
    262a:	67 e2       	ldi	r22, 0x27	; 39
    262c:	78 e0       	ldi	r23, 0x08	; 8
    262e:	8c ef       	ldi	r24, 0xFC	; 252
    2630:	97 e0       	ldi	r25, 0x07	; 7
    2632:	0e 94 c4 18 	call	0x3188	; 0x3188 <strcmp>
    2636:	89 2b       	or	r24, r25
    2638:	49 f0       	breq	.+18     	; 0x264c <userPassword_prompt_handler+0x4a>
      println_msg("Wrong password!");
    263a:	89 e5       	ldi	r24, 0x59	; 89
    263c:	97 e0       	ldi	r25, 0x07	; 7
    263e:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
      invalid_remote_login_attempt();
    2642:	0e 94 b7 12 	call	0x256e	; 0x256e <invalid_remote_login_attempt>
      userPassword_prompt_handler();
    2646:	0e 94 01 13 	call	0x2602	; 0x2602 <userPassword_prompt_handler>
    264a:	08 95       	ret
      }
    else {
      remote_user_loggedin = true;
    264c:	81 e0       	ldi	r24, 0x01	; 1
    264e:	80 93 a8 07 	sts	0x07A8, r24	; 0x8007a8 <remote_user_loggedin>
      print_msg("Welcome ");
    2652:	89 e6       	ldi	r24, 0x69	; 105
    2654:	97 e0       	ldi	r25, 0x07	; 7
    2656:	0e 94 3b 10 	call	0x2076	; 0x2076 <print_msg>
      print_msg(remote_user.name);
    265a:	88 ee       	ldi	r24, 0xE8	; 232
    265c:	97 e0       	ldi	r25, 0x07	; 7
    265e:	0e 94 3b 10 	call	0x2076	; 0x2076 <print_msg>
      println_msg("!");
    2662:	83 ee       	ldi	r24, 0xE3	; 227
    2664:	91 e0       	ldi	r25, 0x01	; 1
    2666:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
      // Show the options menu
      initial_options_menu();
    266a:	0e 94 c0 10 	call	0x2180	; 0x2180 <initial_options_menu>
    266e:	08 95       	ret

00002670 <userName_prompt_handler>:
    }
  }

void userName_prompt_handler(void) {
  // Request user input for the first time and in case of wrong input
  if (!user_input_accepted) {
    2670:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <user_input_accepted>
    2674:	81 11       	cpse	r24, r1
    2676:	0e c0       	rjmp	.+28     	; 0x2694 <userName_prompt_handler+0x24>
    print_msg("Enter your user name:\t");
    2678:	82 e7       	ldi	r24, 0x72	; 114
    267a:	97 e0       	ldi	r25, 0x07	; 7
    267c:	0e 94 3b 10 	call	0x2076	; 0x2076 <print_msg>
    request_user_input(userName_prompt_handler, 13, false);
    2680:	40 e0       	ldi	r20, 0x00	; 0
    2682:	6d e0       	ldi	r22, 0x0D	; 13
    2684:	88 e3       	ldi	r24, 0x38	; 56
    2686:	93 e1       	ldi	r25, 0x13	; 19
    2688:	0e 94 44 10 	call	0x2088	; 0x2088 <request_user_input>
    user_input_accepted = true;
    268c:	81 e0       	ldi	r24, 0x01	; 1
    268e:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <user_input_accepted>
    2692:	08 95       	ret
    }
  else {
    EN_UserStatusCode_t userExists = getUserByName(msg_buffer, &remote_user);
    2694:	67 ee       	ldi	r22, 0xE7	; 231
    2696:	77 e0       	ldi	r23, 0x07	; 7
    2698:	87 e2       	ldi	r24, 0x27	; 39
    269a:	98 e0       	ldi	r25, 0x08	; 8
    269c:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <getUserByName>
    user_input_accepted = false;
    26a0:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <user_input_accepted>
    if (userExists == USER_NOT_FOUND) {
    26a4:	83 30       	cpi	r24, 0x03	; 3
    26a6:	49 f4       	brne	.+18     	; 0x26ba <userName_prompt_handler+0x4a>
      println_msg("User doesn't exist!");
    26a8:	89 e8       	ldi	r24, 0x89	; 137
    26aa:	97 e0       	ldi	r25, 0x07	; 7
    26ac:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
      invalid_remote_login_attempt();
    26b0:	0e 94 b7 12 	call	0x256e	; 0x256e <invalid_remote_login_attempt>
      userName_prompt_handler();
    26b4:	0e 94 38 13 	call	0x2670	; 0x2670 <userName_prompt_handler>
    26b8:	08 95       	ret
      }
    else {
      // Prompt the user to enter the password
      userPassword_prompt_handler();
    26ba:	0e 94 01 13 	call	0x2602	; 0x2602 <userPassword_prompt_handler>
    26be:	08 95       	ret

000026c0 <remote_login_prompt>:
  }

void remote_login_prompt(void) {
  //! for some reason this part causes a compilation error related to .bss section in memory!!!! 
  // if (!remote_user_loggedin) {
  println_msg("Welcome!");
    26c0:	8d e9       	ldi	r24, 0x9D	; 157
    26c2:	97 e0       	ldi	r25, 0x07	; 7
    26c4:	0e 94 34 10 	call	0x2068	; 0x2068 <println_msg>
  // println_msg("Welcome to the Smart Home System!");
  // println_msg("To proceed, please login.");
  userName_prompt_handler();
    26c8:	0e 94 38 13 	call	0x2670	; 0x2670 <userName_prompt_handler>
    26cc:	08 95       	ret

000026ce <__vector_13>:
  println_msg(msg);
  run_system = false;
  }

// Handles the user input asynchronously.
ISR(USART_RXC_vect) {
    26ce:	1f 92       	push	r1
    26d0:	0f 92       	push	r0
    26d2:	0f b6       	in	r0, 0x3f	; 63
    26d4:	0f 92       	push	r0
    26d6:	11 24       	eor	r1, r1
    26d8:	2f 93       	push	r18
    26da:	3f 93       	push	r19
    26dc:	4f 93       	push	r20
    26de:	5f 93       	push	r21
    26e0:	6f 93       	push	r22
    26e2:	7f 93       	push	r23
    26e4:	8f 93       	push	r24
    26e6:	9f 93       	push	r25
    26e8:	af 93       	push	r26
    26ea:	bf 93       	push	r27
    26ec:	ef 93       	push	r30
    26ee:	ff 93       	push	r31
#if UART_COMMUNICATION_INTERFACE ==  PROTEUS_VIRTUAL_TERMINAL
  // Read the UDR to clear the RXC bit
  udr_temp = UDR;
    26f0:	8c b1       	in	r24, 0x0c	; 12
    26f2:	80 93 37 08 	sts	0x0837, r24	; 0x800837 <udr_temp>

  // If no input requested, ignore the input. No input requested is indicated by msg length of zero
  if (msg_length == 0) return;
    26f6:	90 91 36 08 	lds	r25, 0x0836	; 0x800836 <msg_length>
    26fa:	99 23       	and	r25, r25
    26fc:	09 f4       	brne	.+2      	; 0x2700 <__vector_13+0x32>
    26fe:	5b c0       	rjmp	.+182    	; 0x27b6 <__vector_13+0xe8>

  // Accept numbers only in the numerical input mode
  if (numerical_input_mode) {
    2700:	90 91 e6 07 	lds	r25, 0x07E6	; 0x8007e6 <numerical_input_mode>
    2704:	99 23       	and	r25, r25
    2706:	59 f0       	breq	.+22     	; 0x271e <__vector_13+0x50>
    if (!((udr_temp >= '0' && udr_temp <= '9') || udr_temp == '\b' || udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER || udr_temp == '\n')) {
    2708:	90 ed       	ldi	r25, 0xD0	; 208
    270a:	98 0f       	add	r25, r24
    270c:	9a 30       	cpi	r25, 0x0A	; 10
    270e:	38 f0       	brcs	.+14     	; 0x271e <__vector_13+0x50>
    2710:	88 30       	cpi	r24, 0x08	; 8
    2712:	29 f0       	breq	.+10     	; 0x271e <__vector_13+0x50>
    2714:	8d 30       	cpi	r24, 0x0D	; 13
    2716:	19 f0       	breq	.+6      	; 0x271e <__vector_13+0x50>
    2718:	8a 30       	cpi	r24, 0x0A	; 10
    271a:	09 f0       	breq	.+2      	; 0x271e <__vector_13+0x50>
    271c:	4c c0       	rjmp	.+152    	; 0x27b6 <__vector_13+0xe8>
      return;
      }
    }

  // Handling backspaces
  if (udr_temp == '\b') {
    271e:	88 30       	cpi	r24, 0x08	; 8
    2720:	59 f4       	brne	.+22     	; 0x2738 <__vector_13+0x6a>
    if (msg_buffer_pointer > 0) {
    2722:	90 91 e5 07 	lds	r25, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    2726:	99 23       	and	r25, r25
    2728:	09 f4       	brne	.+2      	; 0x272c <__vector_13+0x5e>
    272a:	45 c0       	rjmp	.+138    	; 0x27b6 <__vector_13+0xe8>
      msg_buffer_pointer--;
    272c:	91 50       	subi	r25, 0x01	; 1
    272e:	90 93 e5 07 	sts	0x07E5, r25	; 0x8007e5 <msg_buffer_pointer>
      BT_sendChar(udr_temp);
    2732:	0e 94 23 02 	call	0x446	; 0x446 <BT_sendChar>
    2736:	3f c0       	rjmp	.+126    	; 0x27b6 <__vector_13+0xe8>
      }
    return;
    }

  msg_buffer[msg_buffer_pointer] = udr_temp;
    2738:	90 91 e5 07 	lds	r25, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    273c:	e9 2f       	mov	r30, r25
    273e:	f0 e0       	ldi	r31, 0x00	; 0
    2740:	e9 5d       	subi	r30, 0xD9	; 217
    2742:	f7 4f       	sbci	r31, 0xF7	; 247
    2744:	80 83       	st	Z, r24
  msg_buffer_pointer++;
    2746:	9f 5f       	subi	r25, 0xFF	; 255
    2748:	90 93 e5 07 	sts	0x07E5, r25	; 0x8007e5 <msg_buffer_pointer>

  // Msg is empty
  // Ignore null msgs
  if (msg_buffer_pointer == 1) {
    274c:	91 30       	cpi	r25, 0x01	; 1
    274e:	39 f4       	brne	.+14     	; 0x275e <__vector_13+0x90>
    if (msg_buffer[0] == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    2750:	90 91 27 08 	lds	r25, 0x0827	; 0x800827 <msg_buffer>
    2754:	9d 30       	cpi	r25, 0x0D	; 13
    2756:	19 f4       	brne	.+6      	; 0x275e <__vector_13+0x90>
      msg_buffer_pointer = 0;
    2758:	10 92 e5 07 	sts	0x07E5, r1	; 0x8007e5 <msg_buffer_pointer>
      return;
    275c:	2c c0       	rjmp	.+88     	; 0x27b6 <__vector_13+0xe8>
      }
    }

  // Echo the sent char on the terminal
  //! Proteus virtual terminal doesn't send a line feed char (ASCII code: 10). Instead it sends a carriage return (ASCII code: 13).
  if (udr_temp != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER)
    275e:	8d 30       	cpi	r24, 0x0D	; 13
    2760:	11 f0       	breq	.+4      	; 0x2766 <__vector_13+0x98>
    BT_sendChar(udr_temp);
    2762:	0e 94 23 02 	call	0x446	; 0x446 <BT_sendChar>

  // Msg is longer than required
  // Delete the last input char. Don't allow the user to enter longer input than the maximum required
  if (msg_buffer_pointer == msg_length) {
    2766:	80 91 e5 07 	lds	r24, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    276a:	90 91 36 08 	lds	r25, 0x0836	; 0x800836 <msg_length>
    276e:	89 13       	cpse	r24, r25
    2770:	0d c0       	rjmp	.+26     	; 0x278c <__vector_13+0xbe>
    if (msg_buffer[msg_buffer_pointer - 1] != PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    2772:	e8 2f       	mov	r30, r24
    2774:	f0 e0       	ldi	r31, 0x00	; 0
    2776:	ea 5d       	subi	r30, 0xDA	; 218
    2778:	f7 4f       	sbci	r31, 0xF7	; 247
    277a:	90 81       	ld	r25, Z
    277c:	9d 30       	cpi	r25, 0x0D	; 13
    277e:	31 f0       	breq	.+12     	; 0x278c <__vector_13+0xbe>
      msg_buffer_pointer--;
    2780:	81 50       	subi	r24, 0x01	; 1
    2782:	80 93 e5 07 	sts	0x07E5, r24	; 0x8007e5 <msg_buffer_pointer>
      BT_sendChar('\b');
    2786:	88 e0       	ldi	r24, 0x08	; 8
    2788:	0e 94 23 02 	call	0x446	; 0x446 <BT_sendChar>
      }
    }

  // Msg has ended and is within the required length
  if (udr_temp == PROTEUS_VIRTUAL_TERMINAL_STRING_DELIMITER) {
    278c:	80 91 37 08 	lds	r24, 0x0837	; 0x800837 <udr_temp>
    2790:	8d 30       	cpi	r24, 0x0D	; 13
    2792:	89 f4       	brne	.+34     	; 0x27b6 <__vector_13+0xe8>
    if (msg_buffer_pointer <= msg_length) {
    2794:	e0 91 e5 07 	lds	r30, 0x07E5	; 0x8007e5 <msg_buffer_pointer>
    2798:	80 91 36 08 	lds	r24, 0x0836	; 0x800836 <msg_length>
    279c:	8e 17       	cp	r24, r30
    279e:	58 f0       	brcs	.+22     	; 0x27b6 <__vector_13+0xe8>
      // Replace the carriage return with null to terminate the string correctly
      msg_buffer[msg_buffer_pointer - 1] = '\0';
    27a0:	f0 e0       	ldi	r31, 0x00	; 0
    27a2:	ea 5d       	subi	r30, 0xDA	; 218
    27a4:	f7 4f       	sbci	r31, 0xF7	; 247
    27a6:	10 82       	st	Z, r1
      BT_sendChar('\r');
    27a8:	8d e0       	ldi	r24, 0x0D	; 13
    27aa:	0e 94 23 02 	call	0x446	; 0x446 <BT_sendChar>
      callFunWhenBufferReady();
    27ae:	0e 94 3e 10 	call	0x207c	; 0x207c <callFunWhenBufferReady>
      msg_buffer_pointer = 0;
    27b2:	10 92 e5 07 	sts	0x07E5, r1	; 0x8007e5 <msg_buffer_pointer>
      callFunWhenBufferReady();
      msg_buffer_pointer = 0;
      }
    }
#endif
  }
    27b6:	ff 91       	pop	r31
    27b8:	ef 91       	pop	r30
    27ba:	bf 91       	pop	r27
    27bc:	af 91       	pop	r26
    27be:	9f 91       	pop	r25
    27c0:	8f 91       	pop	r24
    27c2:	7f 91       	pop	r23
    27c4:	6f 91       	pop	r22
    27c6:	5f 91       	pop	r21
    27c8:	4f 91       	pop	r20
    27ca:	3f 91       	pop	r19
    27cc:	2f 91       	pop	r18
    27ce:	0f 90       	pop	r0
    27d0:	0f be       	out	0x3f, r0	; 63
    27d2:	0f 90       	pop	r0
    27d4:	1f 90       	pop	r1
    27d6:	18 95       	reti

000027d8 <__vector_1>:

ISR(INT0_vect) {
    27d8:	1f 92       	push	r1
    27da:	0f 92       	push	r0
    27dc:	0f b6       	in	r0, 0x3f	; 63
    27de:	0f 92       	push	r0
    27e0:	11 24       	eor	r1, r1
    27e2:	2f 93       	push	r18
    27e4:	3f 93       	push	r19
    27e6:	4f 93       	push	r20
    27e8:	5f 93       	push	r21
    27ea:	6f 93       	push	r22
    27ec:	7f 93       	push	r23
    27ee:	8f 93       	push	r24
    27f0:	9f 93       	push	r25
    27f2:	af 93       	push	r26
    27f4:	bf 93       	push	r27
    27f6:	ef 93       	push	r30
    27f8:	ff 93       	push	r31
  // Initialize communication with the user
  // Request user login credentials
  remote_login_prompt();
    27fa:	0e 94 60 13 	call	0x26c0	; 0x26c0 <remote_login_prompt>
  }
    27fe:	ff 91       	pop	r31
    2800:	ef 91       	pop	r30
    2802:	bf 91       	pop	r27
    2804:	af 91       	pop	r26
    2806:	9f 91       	pop	r25
    2808:	8f 91       	pop	r24
    280a:	7f 91       	pop	r23
    280c:	6f 91       	pop	r22
    280e:	5f 91       	pop	r21
    2810:	4f 91       	pop	r20
    2812:	3f 91       	pop	r19
    2814:	2f 91       	pop	r18
    2816:	0f 90       	pop	r0
    2818:	0f be       	out	0x3f, r0	; 63
    281a:	0f 90       	pop	r0
    281c:	1f 90       	pop	r1
    281e:	18 95       	reti

00002820 <AC_auto_control_service_start>:
  DIO_write(AC_PIN, AC_PORT, LOW);
  // Turn off the timer
#if AC_ADC_TRIGGER == TIMER_0_COMPARE_MATCH_TRIGGER
  Timer_stop(TIMER_0);
#elif AC_ADC_TRIGGER == TIMER_0_OVF_TRIGGER
  Timer_stop(TIMER_0);
    2820:	64 e0       	ldi	r22, 0x04	; 4
    2822:	87 e0       	ldi	r24, 0x07	; 7
    2824:	0e 94 49 04 	call	0x892	; 0x892 <LM35_init_INT>
    2828:	41 e0       	ldi	r20, 0x01	; 1
    282a:	63 e4       	ldi	r22, 0x43	; 67
    282c:	87 e0       	ldi	r24, 0x07	; 7
    282e:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <DIO_init>
    2832:	0e 94 3b 07 	call	0xe76	; 0xe76 <ADC_INT_init>
    2836:	60 e0       	ldi	r22, 0x00	; 0
    2838:	70 e0       	ldi	r23, 0x00	; 0
    283a:	80 e0       	ldi	r24, 0x00	; 0
    283c:	0e 94 d2 08 	call	0x11a4	; 0x11a4 <Timer_normal_init>
    2840:	60 e0       	ldi	r22, 0x00	; 0
    2842:	74 e0       	ldi	r23, 0x04	; 4
    2844:	80 e0       	ldi	r24, 0x00	; 0
    2846:	0e 94 14 09 	call	0x1228	; 0x1228 <Timer_start>
    284a:	08 95       	ret

0000284c <__vector_16>:
#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_BY_ACTIVATING_TIMER0_OVF_INT
// To reset the TOV0 flag. Alternatively, it can be reset in the ADC complete interrupt.
ISR(TIMER0_OVF_vect) {}
#endif

ISR(ADC_vect) {
    284c:	1f 92       	push	r1
    284e:	0f 92       	push	r0
    2850:	0f b6       	in	r0, 0x3f	; 63
    2852:	0f 92       	push	r0
    2854:	11 24       	eor	r1, r1
    2856:	2f 93       	push	r18
    2858:	3f 93       	push	r19
    285a:	4f 93       	push	r20
    285c:	5f 93       	push	r21
    285e:	6f 93       	push	r22
    2860:	7f 93       	push	r23
    2862:	8f 93       	push	r24
    2864:	9f 93       	push	r25
    2866:	af 93       	push	r26
    2868:	bf 93       	push	r27
    286a:	cf 93       	push	r28
    286c:	df 93       	push	r29
    286e:	ef 93       	push	r30
    2870:	ff 93       	push	r31
  u16 temperature;
  temperature = ADCL + (ADCH << 8);
    2872:	84 b1       	in	r24, 0x04	; 4
    2874:	c5 b1       	in	r28, 0x05	; 5
    2876:	d0 e0       	ldi	r29, 0x00	; 0
    2878:	dc 2f       	mov	r29, r28
    287a:	cc 27       	eor	r28, r28
    287c:	c8 0f       	add	r28, r24
    287e:	d1 1d       	adc	r29, r1
  // Since the ADC is set to use the internal VREF of 2.56 V, the resolution of the ADC is 2.5 mV. This resolution allows to measure the temperature
  // out of the LM35 with a resolution of 0.25 degree celsius, since each 10mV  increment on the LM35 output is 1 degree C.
  // If the temperature is higher than the maximum specified temperature, turn on the AC.
  if (temperature > AMBIENT_HIGH_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, HIGH);
    2880:	c1 37       	cpi	r28, 0x71	; 113
    2882:	d1 05       	cpc	r29, r1
    2884:	28 f0       	brcs	.+10     	; 0x2890 <__vector_16+0x44>
    2886:	41 e0       	ldi	r20, 0x01	; 1
    2888:	63 e4       	ldi	r22, 0x43	; 67
    288a:	87 e0       	ldi	r24, 0x07	; 7
    288c:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>
  // If the temperature became below the minimum specified temperature turn off the AC.
  if (temperature < AMBIENT_LOW_TEMP_ADC_VAL) DIO_write(AC_PIN, AC_PORT, LOW);
    2890:	c4 35       	cpi	r28, 0x54	; 84
    2892:	d1 05       	cpc	r29, r1
    2894:	28 f4       	brcc	.+10     	; 0x28a0 <__vector_16+0x54>
    2896:	40 e0       	ldi	r20, 0x00	; 0
    2898:	63 e4       	ldi	r22, 0x43	; 67
    289a:	87 e0       	ldi	r24, 0x07	; 7
    289c:	0e 94 86 05 	call	0xb0c	; 0xb0c <DIO_write>

#if TIMER_0_TOV_RESET_METHOD == TIMER_0_TOV_RESET_VIA_ADC_COMPLETE_INTERRUPT
  // Since the ADC is configured in auto trigger mode with timer 0 overflow as the trigger, 
  // The overflow interrupt flag bit must be cleared by software if timer 0 overflow interrupt isn't used. 
  // Otherwise the triggering won't work and the ADC will halt.
  set_bit(TIFR, TOV0);
    28a0:	88 b7       	in	r24, 0x38	; 56
    28a2:	81 60       	ori	r24, 0x01	; 1
    28a4:	88 bf       	out	0x38, r24	; 56
#endif
    28a6:	ff 91       	pop	r31
    28a8:	ef 91       	pop	r30
    28aa:	df 91       	pop	r29
    28ac:	cf 91       	pop	r28
    28ae:	bf 91       	pop	r27
    28b0:	af 91       	pop	r26
    28b2:	9f 91       	pop	r25
    28b4:	8f 91       	pop	r24
    28b6:	7f 91       	pop	r23
    28b8:	6f 91       	pop	r22
    28ba:	5f 91       	pop	r21
    28bc:	4f 91       	pop	r20
    28be:	3f 91       	pop	r19
    28c0:	2f 91       	pop	r18
    28c2:	0f 90       	pop	r0
    28c4:	0f be       	out	0x3f, r0	; 63
    28c6:	0f 90       	pop	r0
    28c8:	1f 90       	pop	r1
    28ca:	18 95       	reti

000028cc <User_DB_init>:
    return getUserByName(user_code_or_name, user);
    }
  else {
    return getUserByCode(user_code_or_name, user);
    }
  }
    28cc:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <EEPROM_init>
    28d0:	88 e0       	ldi	r24, 0x08	; 8
    28d2:	08 95       	ret

000028d4 <getUserByName>:
    28d4:	9f 92       	push	r9
    28d6:	af 92       	push	r10
    28d8:	bf 92       	push	r11
    28da:	cf 92       	push	r12
    28dc:	df 92       	push	r13
    28de:	ef 92       	push	r14
    28e0:	ff 92       	push	r15
    28e2:	0f 93       	push	r16
    28e4:	1f 93       	push	r17
    28e6:	cf 93       	push	r28
    28e8:	df 93       	push	r29
    28ea:	cd b7       	in	r28, 0x3d	; 61
    28ec:	de b7       	in	r29, 0x3e	; 62
    28ee:	6d 97       	sbiw	r28, 0x1d	; 29
    28f0:	0f b6       	in	r0, 0x3f	; 63
    28f2:	f8 94       	cli
    28f4:	de bf       	out	0x3e, r29	; 62
    28f6:	0f be       	out	0x3f, r0	; 63
    28f8:	cd bf       	out	0x3d, r28	; 61
    28fa:	7c 01       	movw	r14, r24
    28fc:	6b 01       	movw	r12, r22
    28fe:	91 2c       	mov	r9, r1
    2900:	6b c0       	rjmp	.+214    	; 0x29d8 <getUserByName+0x104>
    2902:	ae 01       	movw	r20, r28
    2904:	4f 5f       	subi	r20, 0xFF	; 255
    2906:	5f 4f       	sbci	r21, 0xFF	; 255
    2908:	60 e0       	ldi	r22, 0x00	; 0
    290a:	89 2d       	mov	r24, r9
    290c:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <EEPROM_read_byte>
    2910:	ae 01       	movw	r20, r28
    2912:	4e 5f       	subi	r20, 0xFE	; 254
    2914:	5f 4f       	sbci	r21, 0xFF	; 255
    2916:	61 e0       	ldi	r22, 0x01	; 1
    2918:	89 2d       	mov	r24, r9
    291a:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <EEPROM_read_byte>
    291e:	b1 2c       	mov	r11, r1
    2920:	56 c0       	rjmp	.+172    	; 0x29ce <getUserByName+0xfa>
    2922:	89 81       	ldd	r24, Y+1	; 0x01
    2924:	90 e0       	ldi	r25, 0x00	; 0
    2926:	0b 2c       	mov	r0, r11
    2928:	02 c0       	rjmp	.+4      	; 0x292e <getUserByName+0x5a>
    292a:	95 95       	asr	r25
    292c:	87 95       	ror	r24
    292e:	0a 94       	dec	r0
    2930:	e2 f7       	brpl	.-8      	; 0x292a <getUserByName+0x56>
    2932:	80 ff       	sbrs	r24, 0
    2934:	4b c0       	rjmp	.+150    	; 0x29cc <getUserByName+0xf8>
    2936:	6f e1       	ldi	r22, 0x1F	; 31
    2938:	b6 9e       	mul	r11, r22
    293a:	a0 2c       	mov	r10, r0
    293c:	11 24       	eor	r1, r1
    293e:	68 e0       	ldi	r22, 0x08	; 8
    2940:	6a 0d       	add	r22, r10
    2942:	9e 01       	movw	r18, r28
    2944:	2d 5f       	subi	r18, 0xFD	; 253
    2946:	3f 4f       	sbci	r19, 0xFF	; 255
    2948:	4d e0       	ldi	r20, 0x0D	; 13
    294a:	50 e0       	ldi	r21, 0x00	; 0
    294c:	89 2d       	mov	r24, r9
    294e:	0e 94 05 01 	call	0x20a	; 0x20a <EEPROM_read_block>
    2952:	be 01       	movw	r22, r28
    2954:	6d 5f       	subi	r22, 0xFD	; 253
    2956:	7f 4f       	sbci	r23, 0xFF	; 255
    2958:	c7 01       	movw	r24, r14
    295a:	0e 94 c4 18 	call	0x3188	; 0x3188 <strcmp>
    295e:	89 2b       	or	r24, r25
    2960:	a9 f5       	brne	.+106    	; 0x29cc <getUserByName+0xf8>
    2962:	65 e1       	ldi	r22, 0x15	; 21
    2964:	6a 0d       	add	r22, r10
    2966:	9e 01       	movw	r18, r28
    2968:	20 5f       	subi	r18, 0xF0	; 240
    296a:	3f 4f       	sbci	r19, 0xFF	; 255
    296c:	47 e0       	ldi	r20, 0x07	; 7
    296e:	50 e0       	ldi	r21, 0x00	; 0
    2970:	89 2d       	mov	r24, r9
    2972:	0e 94 05 01 	call	0x20a	; 0x20a <EEPROM_read_block>
    2976:	6c e1       	ldi	r22, 0x1C	; 28
    2978:	6a 0d       	add	r22, r10
    297a:	9e 01       	movw	r18, r28
    297c:	29 5e       	subi	r18, 0xE9	; 233
    297e:	3f 4f       	sbci	r19, 0xFF	; 255
    2980:	47 e0       	ldi	r20, 0x07	; 7
    2982:	50 e0       	ldi	r21, 0x00	; 0
    2984:	89 2d       	mov	r24, r9
    2986:	0e 94 05 01 	call	0x20a	; 0x20a <EEPROM_read_block>
    298a:	8a 81       	ldd	r24, Y+2	; 0x02
    298c:	90 e0       	ldi	r25, 0x00	; 0
    298e:	02 c0       	rjmp	.+4      	; 0x2994 <getUserByName+0xc0>
    2990:	95 95       	asr	r25
    2992:	87 95       	ror	r24
    2994:	ba 94       	dec	r11
    2996:	e2 f7       	brpl	.-8      	; 0x2990 <getUserByName+0xbc>
    2998:	98 2f       	mov	r25, r24
    299a:	91 70       	andi	r25, 0x01	; 1
    299c:	f6 01       	movw	r30, r12
    299e:	91 93       	st	Z+, r25
    29a0:	be 01       	movw	r22, r28
    29a2:	6d 5f       	subi	r22, 0xFD	; 253
    29a4:	7f 4f       	sbci	r23, 0xFF	; 255
    29a6:	cf 01       	movw	r24, r30
    29a8:	0e 94 cd 18 	call	0x319a	; 0x319a <strcpy>
    29ac:	be 01       	movw	r22, r28
    29ae:	60 5f       	subi	r22, 0xF0	; 240
    29b0:	7f 4f       	sbci	r23, 0xFF	; 255
    29b2:	c6 01       	movw	r24, r12
    29b4:	0e 96       	adiw	r24, 0x0e	; 14
    29b6:	0e 94 cd 18 	call	0x319a	; 0x319a <strcpy>
    29ba:	be 01       	movw	r22, r28
    29bc:	69 5e       	subi	r22, 0xE9	; 233
    29be:	7f 4f       	sbci	r23, 0xFF	; 255
    29c0:	c6 01       	movw	r24, r12
    29c2:	45 96       	adiw	r24, 0x15	; 21
    29c4:	0e 94 cd 18 	call	0x319a	; 0x319a <strcpy>
    29c8:	82 e0       	ldi	r24, 0x02	; 2
    29ca:	0b c0       	rjmp	.+22     	; 0x29e2 <getUserByName+0x10e>
    29cc:	b3 94       	inc	r11
    29ce:	87 e0       	ldi	r24, 0x07	; 7
    29d0:	8b 15       	cp	r24, r11
    29d2:	08 f0       	brcs	.+2      	; 0x29d6 <getUserByName+0x102>
    29d4:	a6 cf       	rjmp	.-180    	; 0x2922 <getUserByName+0x4e>
    29d6:	93 94       	inc	r9
    29d8:	87 e0       	ldi	r24, 0x07	; 7
    29da:	89 15       	cp	r24, r9
    29dc:	08 f0       	brcs	.+2      	; 0x29e0 <getUserByName+0x10c>
    29de:	91 cf       	rjmp	.-222    	; 0x2902 <getUserByName+0x2e>
    29e0:	83 e0       	ldi	r24, 0x03	; 3
    29e2:	6d 96       	adiw	r28, 0x1d	; 29
    29e4:	0f b6       	in	r0, 0x3f	; 63
    29e6:	f8 94       	cli
    29e8:	de bf       	out	0x3e, r29	; 62
    29ea:	0f be       	out	0x3f, r0	; 63
    29ec:	cd bf       	out	0x3d, r28	; 61
    29ee:	df 91       	pop	r29
    29f0:	cf 91       	pop	r28
    29f2:	1f 91       	pop	r17
    29f4:	0f 91       	pop	r16
    29f6:	ff 90       	pop	r15
    29f8:	ef 90       	pop	r14
    29fa:	df 90       	pop	r13
    29fc:	cf 90       	pop	r12
    29fe:	bf 90       	pop	r11
    2a00:	af 90       	pop	r10
    2a02:	9f 90       	pop	r9
    2a04:	08 95       	ret

00002a06 <getUserByCode>:
    2a06:	9f 92       	push	r9
    2a08:	af 92       	push	r10
    2a0a:	bf 92       	push	r11
    2a0c:	cf 92       	push	r12
    2a0e:	df 92       	push	r13
    2a10:	ef 92       	push	r14
    2a12:	ff 92       	push	r15
    2a14:	0f 93       	push	r16
    2a16:	1f 93       	push	r17
    2a18:	cf 93       	push	r28
    2a1a:	df 93       	push	r29
    2a1c:	cd b7       	in	r28, 0x3d	; 61
    2a1e:	de b7       	in	r29, 0x3e	; 62
    2a20:	6d 97       	sbiw	r28, 0x1d	; 29
    2a22:	0f b6       	in	r0, 0x3f	; 63
    2a24:	f8 94       	cli
    2a26:	de bf       	out	0x3e, r29	; 62
    2a28:	0f be       	out	0x3f, r0	; 63
    2a2a:	cd bf       	out	0x3d, r28	; 61
    2a2c:	7c 01       	movw	r14, r24
    2a2e:	6b 01       	movw	r12, r22
    2a30:	91 2c       	mov	r9, r1
    2a32:	6b c0       	rjmp	.+214    	; 0x2b0a <getUserByCode+0x104>
    2a34:	ae 01       	movw	r20, r28
    2a36:	4f 5f       	subi	r20, 0xFF	; 255
    2a38:	5f 4f       	sbci	r21, 0xFF	; 255
    2a3a:	60 e0       	ldi	r22, 0x00	; 0
    2a3c:	89 2d       	mov	r24, r9
    2a3e:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <EEPROM_read_byte>
    2a42:	ae 01       	movw	r20, r28
    2a44:	4e 5f       	subi	r20, 0xFE	; 254
    2a46:	5f 4f       	sbci	r21, 0xFF	; 255
    2a48:	61 e0       	ldi	r22, 0x01	; 1
    2a4a:	89 2d       	mov	r24, r9
    2a4c:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <EEPROM_read_byte>
    2a50:	b1 2c       	mov	r11, r1
    2a52:	56 c0       	rjmp	.+172    	; 0x2b00 <getUserByCode+0xfa>
    2a54:	89 81       	ldd	r24, Y+1	; 0x01
    2a56:	90 e0       	ldi	r25, 0x00	; 0
    2a58:	0b 2c       	mov	r0, r11
    2a5a:	02 c0       	rjmp	.+4      	; 0x2a60 <getUserByCode+0x5a>
    2a5c:	95 95       	asr	r25
    2a5e:	87 95       	ror	r24
    2a60:	0a 94       	dec	r0
    2a62:	e2 f7       	brpl	.-8      	; 0x2a5c <getUserByCode+0x56>
    2a64:	80 ff       	sbrs	r24, 0
    2a66:	4b c0       	rjmp	.+150    	; 0x2afe <getUserByCode+0xf8>
    2a68:	6f e1       	ldi	r22, 0x1F	; 31
    2a6a:	b6 9e       	mul	r11, r22
    2a6c:	a0 2c       	mov	r10, r0
    2a6e:	11 24       	eor	r1, r1
    2a70:	65 e1       	ldi	r22, 0x15	; 21
    2a72:	6a 0d       	add	r22, r10
    2a74:	9e 01       	movw	r18, r28
    2a76:	20 5f       	subi	r18, 0xF0	; 240
    2a78:	3f 4f       	sbci	r19, 0xFF	; 255
    2a7a:	47 e0       	ldi	r20, 0x07	; 7
    2a7c:	50 e0       	ldi	r21, 0x00	; 0
    2a7e:	89 2d       	mov	r24, r9
    2a80:	0e 94 05 01 	call	0x20a	; 0x20a <EEPROM_read_block>
    2a84:	be 01       	movw	r22, r28
    2a86:	60 5f       	subi	r22, 0xF0	; 240
    2a88:	7f 4f       	sbci	r23, 0xFF	; 255
    2a8a:	c7 01       	movw	r24, r14
    2a8c:	0e 94 c4 18 	call	0x3188	; 0x3188 <strcmp>
    2a90:	89 2b       	or	r24, r25
    2a92:	a9 f5       	brne	.+106    	; 0x2afe <getUserByCode+0xf8>
    2a94:	68 e0       	ldi	r22, 0x08	; 8
    2a96:	6a 0d       	add	r22, r10
    2a98:	9e 01       	movw	r18, r28
    2a9a:	2d 5f       	subi	r18, 0xFD	; 253
    2a9c:	3f 4f       	sbci	r19, 0xFF	; 255
    2a9e:	4d e0       	ldi	r20, 0x0D	; 13
    2aa0:	50 e0       	ldi	r21, 0x00	; 0
    2aa2:	89 2d       	mov	r24, r9
    2aa4:	0e 94 05 01 	call	0x20a	; 0x20a <EEPROM_read_block>
    2aa8:	6c e1       	ldi	r22, 0x1C	; 28
    2aaa:	6a 0d       	add	r22, r10
    2aac:	9e 01       	movw	r18, r28
    2aae:	29 5e       	subi	r18, 0xE9	; 233
    2ab0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ab2:	47 e0       	ldi	r20, 0x07	; 7
    2ab4:	50 e0       	ldi	r21, 0x00	; 0
    2ab6:	89 2d       	mov	r24, r9
    2ab8:	0e 94 05 01 	call	0x20a	; 0x20a <EEPROM_read_block>
    2abc:	8a 81       	ldd	r24, Y+2	; 0x02
    2abe:	90 e0       	ldi	r25, 0x00	; 0
    2ac0:	02 c0       	rjmp	.+4      	; 0x2ac6 <getUserByCode+0xc0>
    2ac2:	95 95       	asr	r25
    2ac4:	87 95       	ror	r24
    2ac6:	ba 94       	dec	r11
    2ac8:	e2 f7       	brpl	.-8      	; 0x2ac2 <getUserByCode+0xbc>
    2aca:	98 2f       	mov	r25, r24
    2acc:	91 70       	andi	r25, 0x01	; 1
    2ace:	f6 01       	movw	r30, r12
    2ad0:	91 93       	st	Z+, r25
    2ad2:	be 01       	movw	r22, r28
    2ad4:	6d 5f       	subi	r22, 0xFD	; 253
    2ad6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ad8:	cf 01       	movw	r24, r30
    2ada:	0e 94 cd 18 	call	0x319a	; 0x319a <strcpy>
    2ade:	be 01       	movw	r22, r28
    2ae0:	60 5f       	subi	r22, 0xF0	; 240
    2ae2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae4:	c6 01       	movw	r24, r12
    2ae6:	0e 96       	adiw	r24, 0x0e	; 14
    2ae8:	0e 94 cd 18 	call	0x319a	; 0x319a <strcpy>
    2aec:	be 01       	movw	r22, r28
    2aee:	69 5e       	subi	r22, 0xE9	; 233
    2af0:	7f 4f       	sbci	r23, 0xFF	; 255
    2af2:	c6 01       	movw	r24, r12
    2af4:	45 96       	adiw	r24, 0x15	; 21
    2af6:	0e 94 cd 18 	call	0x319a	; 0x319a <strcpy>
    2afa:	82 e0       	ldi	r24, 0x02	; 2
    2afc:	0b c0       	rjmp	.+22     	; 0x2b14 <getUserByCode+0x10e>
    2afe:	b3 94       	inc	r11
    2b00:	87 e0       	ldi	r24, 0x07	; 7
    2b02:	8b 15       	cp	r24, r11
    2b04:	08 f0       	brcs	.+2      	; 0x2b08 <getUserByCode+0x102>
    2b06:	a6 cf       	rjmp	.-180    	; 0x2a54 <getUserByCode+0x4e>
    2b08:	93 94       	inc	r9
    2b0a:	87 e0       	ldi	r24, 0x07	; 7
    2b0c:	89 15       	cp	r24, r9
    2b0e:	08 f0       	brcs	.+2      	; 0x2b12 <getUserByCode+0x10c>
    2b10:	91 cf       	rjmp	.-222    	; 0x2a34 <getUserByCode+0x2e>
    2b12:	83 e0       	ldi	r24, 0x03	; 3
    2b14:	6d 96       	adiw	r28, 0x1d	; 29
    2b16:	0f b6       	in	r0, 0x3f	; 63
    2b18:	f8 94       	cli
    2b1a:	de bf       	out	0x3e, r29	; 62
    2b1c:	0f be       	out	0x3f, r0	; 63
    2b1e:	cd bf       	out	0x3d, r28	; 61
    2b20:	df 91       	pop	r29
    2b22:	cf 91       	pop	r28
    2b24:	1f 91       	pop	r17
    2b26:	0f 91       	pop	r16
    2b28:	ff 90       	pop	r15
    2b2a:	ef 90       	pop	r14
    2b2c:	df 90       	pop	r13
    2b2e:	cf 90       	pop	r12
    2b30:	bf 90       	pop	r11
    2b32:	af 90       	pop	r10
    2b34:	9f 90       	pop	r9
    2b36:	08 95       	ret

00002b38 <write_user>:

void write_user(u8 userBlockIndex, ST_User_t* user) {
    2b38:	ef 92       	push	r14
    2b3a:	ff 92       	push	r15
    2b3c:	0f 93       	push	r16
    2b3e:	1f 93       	push	r17
    2b40:	cf 93       	push	r28
    2b42:	df 93       	push	r29
    2b44:	00 d0       	rcall	.+0      	; 0x2b46 <write_user+0xe>
    2b46:	cd b7       	in	r28, 0x3d	; 61
    2b48:	de b7       	in	r29, 0x3e	; 62
    2b4a:	7b 01       	movw	r14, r22
  // Get the user block location (page - index)
  u8 page = userBlockIndex / 8;
    2b4c:	08 2f       	mov	r16, r24
    2b4e:	06 95       	lsr	r16
    2b50:	06 95       	lsr	r16
    2b52:	06 95       	lsr	r16
  u8 blockNumber = userBlockIndex % 8;
    2b54:	18 2f       	mov	r17, r24
    2b56:	17 70       	andi	r17, 0x07	; 7
  // Read and update the block status (reserve the block). And update the user authority level flag if the user is admin
  u8 usersBlockStatus, usersAuthorityLevel;
  EEPROM_read_byte(page, 0, &usersBlockStatus);
    2b58:	ae 01       	movw	r20, r28
    2b5a:	4f 5f       	subi	r20, 0xFF	; 255
    2b5c:	5f 4f       	sbci	r21, 0xFF	; 255
    2b5e:	60 e0       	ldi	r22, 0x00	; 0
    2b60:	80 2f       	mov	r24, r16
    2b62:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <EEPROM_read_byte>
  EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    2b66:	ae 01       	movw	r20, r28
    2b68:	4e 5f       	subi	r20, 0xFE	; 254
    2b6a:	5f 4f       	sbci	r21, 0xFF	; 255
    2b6c:	61 e0       	ldi	r22, 0x01	; 1
    2b6e:	80 2f       	mov	r24, r16
    2b70:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <EEPROM_read_byte>
  set_bit(usersBlockStatus, blockNumber);
    2b74:	81 e0       	ldi	r24, 0x01	; 1
    2b76:	90 e0       	ldi	r25, 0x00	; 0
    2b78:	01 2e       	mov	r0, r17
    2b7a:	02 c0       	rjmp	.+4      	; 0x2b80 <write_user+0x48>
    2b7c:	88 0f       	add	r24, r24
    2b7e:	99 1f       	adc	r25, r25
    2b80:	0a 94       	dec	r0
    2b82:	e2 f7       	brpl	.-8      	; 0x2b7c <write_user+0x44>
    2b84:	49 81       	ldd	r20, Y+1	; 0x01
    2b86:	48 2b       	or	r20, r24
    2b88:	49 83       	std	Y+1, r20	; 0x01
  if (user->isAdmin) set_bit(usersAuthorityLevel, blockNumber);
    2b8a:	f7 01       	movw	r30, r14
    2b8c:	20 81       	ld	r18, Z
    2b8e:	22 23       	and	r18, r18
    2b90:	19 f0       	breq	.+6      	; 0x2b98 <write_user+0x60>
    2b92:	9a 81       	ldd	r25, Y+2	; 0x02
    2b94:	89 2b       	or	r24, r25
    2b96:	8a 83       	std	Y+2, r24	; 0x02
  EEPROM_write_byte(page, 0, usersBlockStatus);
    2b98:	60 e0       	ldi	r22, 0x00	; 0
    2b9a:	80 2f       	mov	r24, r16
    2b9c:	0e 94 3b 01 	call	0x276	; 0x276 <EEPROM_write_byte>
  EEPROM_write_byte(page, 1, usersAuthorityLevel);
    2ba0:	4a 81       	ldd	r20, Y+2	; 0x02
    2ba2:	61 e0       	ldi	r22, 0x01	; 1
    2ba4:	80 2f       	mov	r24, r16
    2ba6:	0e 94 3b 01 	call	0x276	; 0x276 <EEPROM_write_byte>
  // Write the user data
  EEPROM_write_block(page, 8 + 31 * blockNumber, 13, user->name);
    2baa:	97 01       	movw	r18, r14
    2bac:	2f 5f       	subi	r18, 0xFF	; 255
    2bae:	3f 4f       	sbci	r19, 0xFF	; 255
    2bb0:	6f e1       	ldi	r22, 0x1F	; 31
    2bb2:	16 9f       	mul	r17, r22
    2bb4:	10 2d       	mov	r17, r0
    2bb6:	11 24       	eor	r1, r1
    2bb8:	68 e0       	ldi	r22, 0x08	; 8
    2bba:	61 0f       	add	r22, r17
    2bbc:	4d e0       	ldi	r20, 0x0D	; 13
    2bbe:	50 e0       	ldi	r21, 0x00	; 0
    2bc0:	80 2f       	mov	r24, r16
    2bc2:	0e 94 5a 01 	call	0x2b4	; 0x2b4 <EEPROM_write_block>
  EEPROM_write_block(page, 21 + 31 * blockNumber, 7, user->code);
    2bc6:	97 01       	movw	r18, r14
    2bc8:	22 5f       	subi	r18, 0xF2	; 242
    2bca:	3f 4f       	sbci	r19, 0xFF	; 255
    2bcc:	65 e1       	ldi	r22, 0x15	; 21
    2bce:	61 0f       	add	r22, r17
    2bd0:	47 e0       	ldi	r20, 0x07	; 7
    2bd2:	50 e0       	ldi	r21, 0x00	; 0
    2bd4:	80 2f       	mov	r24, r16
    2bd6:	0e 94 5a 01 	call	0x2b4	; 0x2b4 <EEPROM_write_block>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
    2bda:	97 01       	movw	r18, r14
    2bdc:	2b 5e       	subi	r18, 0xEB	; 235
    2bde:	3f 4f       	sbci	r19, 0xFF	; 255
    2be0:	6c e1       	ldi	r22, 0x1C	; 28
    2be2:	61 0f       	add	r22, r17
    2be4:	4b e0       	ldi	r20, 0x0B	; 11
    2be6:	50 e0       	ldi	r21, 0x00	; 0
    2be8:	80 2f       	mov	r24, r16
    2bea:	0e 94 5a 01 	call	0x2b4	; 0x2b4 <EEPROM_write_block>
  }
    2bee:	0f 90       	pop	r0
    2bf0:	0f 90       	pop	r0
    2bf2:	df 91       	pop	r29
    2bf4:	cf 91       	pop	r28
    2bf6:	1f 91       	pop	r17
    2bf8:	0f 91       	pop	r16
    2bfa:	ff 90       	pop	r15
    2bfc:	ef 90       	pop	r14
    2bfe:	08 95       	ret

00002c00 <add_user>:

EN_UserStatusCode_t add_user(ST_User_t* user) {
    2c00:	ef 92       	push	r14
    2c02:	ff 92       	push	r15
    2c04:	1f 93       	push	r17
    2c06:	cf 93       	push	r28
    2c08:	df 93       	push	r29
    2c0a:	1f 92       	push	r1
    2c0c:	cd b7       	in	r28, 0x3d	; 61
    2c0e:	de b7       	in	r29, 0x3e	; 62
    2c10:	7c 01       	movw	r14, r24
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    2c12:	10 e0       	ldi	r17, 0x00	; 0
    2c14:	1a c0       	rjmp	.+52     	; 0x2c4a <add_user+0x4a>
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    2c16:	ae 01       	movw	r20, r28
    2c18:	4f 5f       	subi	r20, 0xFF	; 255
    2c1a:	5f 4f       	sbci	r21, 0xFF	; 255
    2c1c:	60 e0       	ldi	r22, 0x00	; 0
    2c1e:	81 2f       	mov	r24, r17
    2c20:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <EEPROM_read_byte>
    if (usersBlockStatus != 0xFF) {
    2c24:	99 81       	ldd	r25, Y+1	; 0x01
    2c26:	9f 3f       	cpi	r25, 0xFF	; 255
    2c28:	79 f0       	breq	.+30     	; 0x2c48 <add_user+0x48>
    2c2a:	02 c0       	rjmp	.+4      	; 0x2c30 <add_user+0x30>
      // Find the block number in the page
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
    2c2c:	8f 5f       	subi	r24, 0xFF	; 255
    2c2e:	01 c0       	rjmp	.+2      	; 0x2c32 <add_user+0x32>
    2c30:	80 e0       	ldi	r24, 0x00	; 0
    2c32:	29 2f       	mov	r18, r25
    2c34:	30 e0       	ldi	r19, 0x00	; 0
    2c36:	08 2e       	mov	r0, r24
    2c38:	02 c0       	rjmp	.+4      	; 0x2c3e <add_user+0x3e>
    2c3a:	35 95       	asr	r19
    2c3c:	27 95       	ror	r18
    2c3e:	0a 94       	dec	r0
    2c40:	e2 f7       	brpl	.-8      	; 0x2c3a <add_user+0x3a>
    2c42:	20 fd       	sbrc	r18, 0
    2c44:	f3 cf       	rjmp	.-26     	; 0x2c2c <add_user+0x2c>
    2c46:	04 c0       	rjmp	.+8      	; 0x2c50 <add_user+0x50>
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
  for (page = 0; page < 8; page++) {
    2c48:	1f 5f       	subi	r17, 0xFF	; 255
    2c4a:	18 30       	cpi	r17, 0x08	; 8
    2c4c:	20 f3       	brcs	.-56     	; 0x2c16 <add_user+0x16>
  EEPROM_write_block(page, 28 + 31 * blockNumber, 11, user->password);
  }

EN_UserStatusCode_t add_user(ST_User_t* user) {
  // Find an empty location to write the user data
  u8 page, usersBlockStatus, availableUserBlockIndex = 0;
    2c4e:	80 e0       	ldi	r24, 0x00	; 0
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    2c50:	18 30       	cpi	r17, 0x08	; 8
    2c52:	49 f0       	breq	.+18     	; 0x2c66 <add_user+0x66>
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
    2c54:	11 0f       	add	r17, r17
    2c56:	11 0f       	add	r17, r17
    2c58:	11 0f       	add	r17, r17
  write_user(availableUserBlockIndex, user);
    2c5a:	b7 01       	movw	r22, r14
    2c5c:	81 0f       	add	r24, r17
    2c5e:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <write_user>
  return USER_ADDED_SUCCESSFULLY;
    2c62:	8a e0       	ldi	r24, 0x0A	; 10
    2c64:	01 c0       	rjmp	.+2      	; 0x2c68 <add_user+0x68>
      while (read_bit(usersBlockStatus, availableUserBlockIndex) != 0) availableUserBlockIndex++;
      break;
      }
    }
  // If no location is found return error
  if (page == 8) return ERROR_FULL_DB;
    2c66:	8c e0       	ldi	r24, 0x0C	; 12
  // Save the user to the EEPROM
  availableUserBlockIndex += (page * 8);
  write_user(availableUserBlockIndex, user);
  return USER_ADDED_SUCCESSFULLY;
  }
    2c68:	0f 90       	pop	r0
    2c6a:	df 91       	pop	r29
    2c6c:	cf 91       	pop	r28
    2c6e:	1f 91       	pop	r17
    2c70:	ff 90       	pop	r15
    2c72:	ef 90       	pop	r14
    2c74:	08 95       	ret

00002c76 <delete_user>:

EN_UserStatusCode_t delete_user(ST_User_t* user) {
    2c76:	cf 92       	push	r12
    2c78:	df 92       	push	r13
    2c7a:	ef 92       	push	r14
    2c7c:	ff 92       	push	r15
    2c7e:	0f 93       	push	r16
    2c80:	1f 93       	push	r17
    2c82:	cf 93       	push	r28
    2c84:	df 93       	push	r29
    2c86:	cd b7       	in	r28, 0x3d	; 61
    2c88:	de b7       	in	r29, 0x3e	; 62
    2c8a:	29 97       	sbiw	r28, 0x09	; 9
    2c8c:	0f b6       	in	r0, 0x3f	; 63
    2c8e:	f8 94       	cli
    2c90:	de bf       	out	0x3e, r29	; 62
    2c92:	0f be       	out	0x3f, r0	; 63
    2c94:	cd bf       	out	0x3d, r28	; 61
    2c96:	6c 01       	movw	r12, r24
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    2c98:	00 e0       	ldi	r16, 0x00	; 0
    2c9a:	4d c0       	rjmp	.+154    	; 0x2d36 <delete_user+0xc0>
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    2c9c:	ae 01       	movw	r20, r28
    2c9e:	4f 5f       	subi	r20, 0xFF	; 255
    2ca0:	5f 4f       	sbci	r21, 0xFF	; 255
    2ca2:	60 e0       	ldi	r22, 0x00	; 0
    2ca4:	80 2f       	mov	r24, r16
    2ca6:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <EEPROM_read_byte>
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    2caa:	ae 01       	movw	r20, r28
    2cac:	4e 5f       	subi	r20, 0xFE	; 254
    2cae:	5f 4f       	sbci	r21, 0xFF	; 255
    2cb0:	61 e0       	ldi	r22, 0x01	; 1
    2cb2:	80 2f       	mov	r24, r16
    2cb4:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <EEPROM_read_byte>
    for (userIndex = 0; userIndex < 8;userIndex++) {
    2cb8:	10 e0       	ldi	r17, 0x00	; 0
    2cba:	3a c0       	rjmp	.+116    	; 0x2d30 <delete_user+0xba>
      if (read_bit(usersBlockStatus, userIndex)) {  // If the user isn't deleted
    2cbc:	89 81       	ldd	r24, Y+1	; 0x01
    2cbe:	90 e0       	ldi	r25, 0x00	; 0
    2cc0:	01 2e       	mov	r0, r17
    2cc2:	02 c0       	rjmp	.+4      	; 0x2cc8 <delete_user+0x52>
    2cc4:	95 95       	asr	r25
    2cc6:	87 95       	ror	r24
    2cc8:	0a 94       	dec	r0
    2cca:	e2 f7       	brpl	.-8      	; 0x2cc4 <delete_user+0x4e>
    2ccc:	80 ff       	sbrs	r24, 0
    2cce:	2f c0       	rjmp	.+94     	; 0x2d2e <delete_user+0xb8>
        EEPROM_read_block(page, 21 + 31 * userIndex, 7, tempUserCode);
    2cd0:	6f e1       	ldi	r22, 0x1F	; 31
    2cd2:	16 9f       	mul	r17, r22
    2cd4:	60 2d       	mov	r22, r0
    2cd6:	11 24       	eor	r1, r1
    2cd8:	6b 5e       	subi	r22, 0xEB	; 235
    2cda:	9e 01       	movw	r18, r28
    2cdc:	2d 5f       	subi	r18, 0xFD	; 253
    2cde:	3f 4f       	sbci	r19, 0xFF	; 255
    2ce0:	47 e0       	ldi	r20, 0x07	; 7
    2ce2:	50 e0       	ldi	r21, 0x00	; 0
    2ce4:	80 2f       	mov	r24, r16
    2ce6:	0e 94 05 01 	call	0x20a	; 0x20a <EEPROM_read_block>
        if (strcmp(user->code, tempUserCode) == 0) { // User has been found
    2cea:	be 01       	movw	r22, r28
    2cec:	6d 5f       	subi	r22, 0xFD	; 253
    2cee:	7f 4f       	sbci	r23, 0xFF	; 255
    2cf0:	c6 01       	movw	r24, r12
    2cf2:	0e 96       	adiw	r24, 0x0e	; 14
    2cf4:	0e 94 c4 18 	call	0x3188	; 0x3188 <strcmp>
    2cf8:	89 2b       	or	r24, r25
    2cfa:	c9 f4       	brne	.+50     	; 0x2d2e <delete_user+0xb8>
          // Mark it as deleted
          clear_bit(usersBlockStatus, userIndex);
    2cfc:	81 e0       	ldi	r24, 0x01	; 1
    2cfe:	90 e0       	ldi	r25, 0x00	; 0
    2d00:	02 c0       	rjmp	.+4      	; 0x2d06 <delete_user+0x90>
    2d02:	88 0f       	add	r24, r24
    2d04:	99 1f       	adc	r25, r25
    2d06:	1a 95       	dec	r17
    2d08:	e2 f7       	brpl	.-8      	; 0x2d02 <delete_user+0x8c>
    2d0a:	80 95       	com	r24
    2d0c:	49 81       	ldd	r20, Y+1	; 0x01
    2d0e:	48 23       	and	r20, r24
    2d10:	49 83       	std	Y+1, r20	; 0x01
          clear_bit(usersAuthorityLevel, userIndex);
    2d12:	9a 81       	ldd	r25, Y+2	; 0x02
    2d14:	89 23       	and	r24, r25
    2d16:	8a 83       	std	Y+2, r24	; 0x02
          EEPROM_write_byte(page, 0, usersBlockStatus);
    2d18:	60 e0       	ldi	r22, 0x00	; 0
    2d1a:	80 2f       	mov	r24, r16
    2d1c:	0e 94 3b 01 	call	0x276	; 0x276 <EEPROM_write_byte>
          EEPROM_write_byte(page, 1, usersAuthorityLevel);
    2d20:	4a 81       	ldd	r20, Y+2	; 0x02
    2d22:	61 e0       	ldi	r22, 0x01	; 1
    2d24:	80 2f       	mov	r24, r16
    2d26:	0e 94 3b 01 	call	0x276	; 0x276 <EEPROM_write_byte>
          return USER_DELETED_SUCCESSFULLY;
    2d2a:	8b e0       	ldi	r24, 0x0B	; 11
    2d2c:	08 c0       	rjmp	.+16     	; 0x2d3e <delete_user+0xc8>
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    // Read the first two bytes to see which users are deleted and what blocks to search in. Also save the authority level in case the user was found.
    EEPROM_read_byte(page, 0, &usersBlockStatus);
    EEPROM_read_byte(page, 1, &usersAuthorityLevel);
    for (userIndex = 0; userIndex < 8;userIndex++) {
    2d2e:	1f 5f       	subi	r17, 0xFF	; 255
    2d30:	18 30       	cpi	r17, 0x08	; 8
    2d32:	20 f2       	brcs	.-120    	; 0x2cbc <delete_user+0x46>
EN_UserStatusCode_t delete_user(ST_User_t* user) {
  // Find the user block index
  u8 page, userIndex, usersBlockStatus, usersAuthorityLevel;
  // Comparing the user code is slightly more efficient because it's shorter
  s8 tempUserCode[7];
  for (page = 0; page < 8; page++) {
    2d34:	0f 5f       	subi	r16, 0xFF	; 255
    2d36:	08 30       	cpi	r16, 0x08	; 8
    2d38:	08 f4       	brcc	.+2      	; 0x2d3c <delete_user+0xc6>
    2d3a:	b0 cf       	rjmp	.-160    	; 0x2c9c <delete_user+0x26>
          return USER_DELETED_SUCCESSFULLY;
          }
        }
      }
    }
  return USER_NOT_FOUND;
    2d3c:	83 e0       	ldi	r24, 0x03	; 3
  }
    2d3e:	29 96       	adiw	r28, 0x09	; 9
    2d40:	0f b6       	in	r0, 0x3f	; 63
    2d42:	f8 94       	cli
    2d44:	de bf       	out	0x3e, r29	; 62
    2d46:	0f be       	out	0x3f, r0	; 63
    2d48:	cd bf       	out	0x3d, r28	; 61
    2d4a:	df 91       	pop	r29
    2d4c:	cf 91       	pop	r28
    2d4e:	1f 91       	pop	r17
    2d50:	0f 91       	pop	r16
    2d52:	ff 90       	pop	r15
    2d54:	ef 90       	pop	r14
    2d56:	df 90       	pop	r13
    2d58:	cf 90       	pop	r12
    2d5a:	08 95       	ret

00002d5c <__subsf3>:
    2d5c:	50 58       	subi	r21, 0x80	; 128

00002d5e <__addsf3>:
    2d5e:	bb 27       	eor	r27, r27
    2d60:	aa 27       	eor	r26, r26
    2d62:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__addsf3x>
    2d66:	0c 94 17 18 	jmp	0x302e	; 0x302e <__fp_round>
    2d6a:	0e 94 09 18 	call	0x3012	; 0x3012 <__fp_pscA>
    2d6e:	38 f0       	brcs	.+14     	; 0x2d7e <__addsf3+0x20>
    2d70:	0e 94 10 18 	call	0x3020	; 0x3020 <__fp_pscB>
    2d74:	20 f0       	brcs	.+8      	; 0x2d7e <__addsf3+0x20>
    2d76:	39 f4       	brne	.+14     	; 0x2d86 <__addsf3+0x28>
    2d78:	9f 3f       	cpi	r25, 0xFF	; 255
    2d7a:	19 f4       	brne	.+6      	; 0x2d82 <__addsf3+0x24>
    2d7c:	26 f4       	brtc	.+8      	; 0x2d86 <__addsf3+0x28>
    2d7e:	0c 94 06 18 	jmp	0x300c	; 0x300c <__fp_nan>
    2d82:	0e f4       	brtc	.+2      	; 0x2d86 <__addsf3+0x28>
    2d84:	e0 95       	com	r30
    2d86:	e7 fb       	bst	r30, 7
    2d88:	0c 94 00 18 	jmp	0x3000	; 0x3000 <__fp_inf>

00002d8c <__addsf3x>:
    2d8c:	e9 2f       	mov	r30, r25
    2d8e:	0e 94 28 18 	call	0x3050	; 0x3050 <__fp_split3>
    2d92:	58 f3       	brcs	.-42     	; 0x2d6a <__addsf3+0xc>
    2d94:	ba 17       	cp	r27, r26
    2d96:	62 07       	cpc	r22, r18
    2d98:	73 07       	cpc	r23, r19
    2d9a:	84 07       	cpc	r24, r20
    2d9c:	95 07       	cpc	r25, r21
    2d9e:	20 f0       	brcs	.+8      	; 0x2da8 <__addsf3x+0x1c>
    2da0:	79 f4       	brne	.+30     	; 0x2dc0 <__addsf3x+0x34>
    2da2:	a6 f5       	brtc	.+104    	; 0x2e0c <__addsf3x+0x80>
    2da4:	0c 94 4a 18 	jmp	0x3094	; 0x3094 <__fp_zero>
    2da8:	0e f4       	brtc	.+2      	; 0x2dac <__addsf3x+0x20>
    2daa:	e0 95       	com	r30
    2dac:	0b 2e       	mov	r0, r27
    2dae:	ba 2f       	mov	r27, r26
    2db0:	a0 2d       	mov	r26, r0
    2db2:	0b 01       	movw	r0, r22
    2db4:	b9 01       	movw	r22, r18
    2db6:	90 01       	movw	r18, r0
    2db8:	0c 01       	movw	r0, r24
    2dba:	ca 01       	movw	r24, r20
    2dbc:	a0 01       	movw	r20, r0
    2dbe:	11 24       	eor	r1, r1
    2dc0:	ff 27       	eor	r31, r31
    2dc2:	59 1b       	sub	r21, r25
    2dc4:	99 f0       	breq	.+38     	; 0x2dec <__addsf3x+0x60>
    2dc6:	59 3f       	cpi	r21, 0xF9	; 249
    2dc8:	50 f4       	brcc	.+20     	; 0x2dde <__addsf3x+0x52>
    2dca:	50 3e       	cpi	r21, 0xE0	; 224
    2dcc:	68 f1       	brcs	.+90     	; 0x2e28 <__addsf3x+0x9c>
    2dce:	1a 16       	cp	r1, r26
    2dd0:	f0 40       	sbci	r31, 0x00	; 0
    2dd2:	a2 2f       	mov	r26, r18
    2dd4:	23 2f       	mov	r18, r19
    2dd6:	34 2f       	mov	r19, r20
    2dd8:	44 27       	eor	r20, r20
    2dda:	58 5f       	subi	r21, 0xF8	; 248
    2ddc:	f3 cf       	rjmp	.-26     	; 0x2dc4 <__addsf3x+0x38>
    2dde:	46 95       	lsr	r20
    2de0:	37 95       	ror	r19
    2de2:	27 95       	ror	r18
    2de4:	a7 95       	ror	r26
    2de6:	f0 40       	sbci	r31, 0x00	; 0
    2de8:	53 95       	inc	r21
    2dea:	c9 f7       	brne	.-14     	; 0x2dde <__addsf3x+0x52>
    2dec:	7e f4       	brtc	.+30     	; 0x2e0c <__addsf3x+0x80>
    2dee:	1f 16       	cp	r1, r31
    2df0:	ba 0b       	sbc	r27, r26
    2df2:	62 0b       	sbc	r22, r18
    2df4:	73 0b       	sbc	r23, r19
    2df6:	84 0b       	sbc	r24, r20
    2df8:	ba f0       	brmi	.+46     	; 0x2e28 <__addsf3x+0x9c>
    2dfa:	91 50       	subi	r25, 0x01	; 1
    2dfc:	a1 f0       	breq	.+40     	; 0x2e26 <__addsf3x+0x9a>
    2dfe:	ff 0f       	add	r31, r31
    2e00:	bb 1f       	adc	r27, r27
    2e02:	66 1f       	adc	r22, r22
    2e04:	77 1f       	adc	r23, r23
    2e06:	88 1f       	adc	r24, r24
    2e08:	c2 f7       	brpl	.-16     	; 0x2dfa <__addsf3x+0x6e>
    2e0a:	0e c0       	rjmp	.+28     	; 0x2e28 <__addsf3x+0x9c>
    2e0c:	ba 0f       	add	r27, r26
    2e0e:	62 1f       	adc	r22, r18
    2e10:	73 1f       	adc	r23, r19
    2e12:	84 1f       	adc	r24, r20
    2e14:	48 f4       	brcc	.+18     	; 0x2e28 <__addsf3x+0x9c>
    2e16:	87 95       	ror	r24
    2e18:	77 95       	ror	r23
    2e1a:	67 95       	ror	r22
    2e1c:	b7 95       	ror	r27
    2e1e:	f7 95       	ror	r31
    2e20:	9e 3f       	cpi	r25, 0xFE	; 254
    2e22:	08 f0       	brcs	.+2      	; 0x2e26 <__addsf3x+0x9a>
    2e24:	b0 cf       	rjmp	.-160    	; 0x2d86 <__addsf3+0x28>
    2e26:	93 95       	inc	r25
    2e28:	88 0f       	add	r24, r24
    2e2a:	08 f0       	brcs	.+2      	; 0x2e2e <__addsf3x+0xa2>
    2e2c:	99 27       	eor	r25, r25
    2e2e:	ee 0f       	add	r30, r30
    2e30:	97 95       	ror	r25
    2e32:	87 95       	ror	r24
    2e34:	08 95       	ret

00002e36 <__divsf3>:
    2e36:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <__divsf3x>
    2e3a:	0c 94 17 18 	jmp	0x302e	; 0x302e <__fp_round>
    2e3e:	0e 94 10 18 	call	0x3020	; 0x3020 <__fp_pscB>
    2e42:	58 f0       	brcs	.+22     	; 0x2e5a <__divsf3+0x24>
    2e44:	0e 94 09 18 	call	0x3012	; 0x3012 <__fp_pscA>
    2e48:	40 f0       	brcs	.+16     	; 0x2e5a <__divsf3+0x24>
    2e4a:	29 f4       	brne	.+10     	; 0x2e56 <__divsf3+0x20>
    2e4c:	5f 3f       	cpi	r21, 0xFF	; 255
    2e4e:	29 f0       	breq	.+10     	; 0x2e5a <__divsf3+0x24>
    2e50:	0c 94 00 18 	jmp	0x3000	; 0x3000 <__fp_inf>
    2e54:	51 11       	cpse	r21, r1
    2e56:	0c 94 4b 18 	jmp	0x3096	; 0x3096 <__fp_szero>
    2e5a:	0c 94 06 18 	jmp	0x300c	; 0x300c <__fp_nan>

00002e5e <__divsf3x>:
    2e5e:	0e 94 28 18 	call	0x3050	; 0x3050 <__fp_split3>
    2e62:	68 f3       	brcs	.-38     	; 0x2e3e <__divsf3+0x8>

00002e64 <__divsf3_pse>:
    2e64:	99 23       	and	r25, r25
    2e66:	b1 f3       	breq	.-20     	; 0x2e54 <__divsf3+0x1e>
    2e68:	55 23       	and	r21, r21
    2e6a:	91 f3       	breq	.-28     	; 0x2e50 <__divsf3+0x1a>
    2e6c:	95 1b       	sub	r25, r21
    2e6e:	55 0b       	sbc	r21, r21
    2e70:	bb 27       	eor	r27, r27
    2e72:	aa 27       	eor	r26, r26
    2e74:	62 17       	cp	r22, r18
    2e76:	73 07       	cpc	r23, r19
    2e78:	84 07       	cpc	r24, r20
    2e7a:	38 f0       	brcs	.+14     	; 0x2e8a <__divsf3_pse+0x26>
    2e7c:	9f 5f       	subi	r25, 0xFF	; 255
    2e7e:	5f 4f       	sbci	r21, 0xFF	; 255
    2e80:	22 0f       	add	r18, r18
    2e82:	33 1f       	adc	r19, r19
    2e84:	44 1f       	adc	r20, r20
    2e86:	aa 1f       	adc	r26, r26
    2e88:	a9 f3       	breq	.-22     	; 0x2e74 <__divsf3_pse+0x10>
    2e8a:	35 d0       	rcall	.+106    	; 0x2ef6 <__divsf3_pse+0x92>
    2e8c:	0e 2e       	mov	r0, r30
    2e8e:	3a f0       	brmi	.+14     	; 0x2e9e <__divsf3_pse+0x3a>
    2e90:	e0 e8       	ldi	r30, 0x80	; 128
    2e92:	32 d0       	rcall	.+100    	; 0x2ef8 <__divsf3_pse+0x94>
    2e94:	91 50       	subi	r25, 0x01	; 1
    2e96:	50 40       	sbci	r21, 0x00	; 0
    2e98:	e6 95       	lsr	r30
    2e9a:	00 1c       	adc	r0, r0
    2e9c:	ca f7       	brpl	.-14     	; 0x2e90 <__divsf3_pse+0x2c>
    2e9e:	2b d0       	rcall	.+86     	; 0x2ef6 <__divsf3_pse+0x92>
    2ea0:	fe 2f       	mov	r31, r30
    2ea2:	29 d0       	rcall	.+82     	; 0x2ef6 <__divsf3_pse+0x92>
    2ea4:	66 0f       	add	r22, r22
    2ea6:	77 1f       	adc	r23, r23
    2ea8:	88 1f       	adc	r24, r24
    2eaa:	bb 1f       	adc	r27, r27
    2eac:	26 17       	cp	r18, r22
    2eae:	37 07       	cpc	r19, r23
    2eb0:	48 07       	cpc	r20, r24
    2eb2:	ab 07       	cpc	r26, r27
    2eb4:	b0 e8       	ldi	r27, 0x80	; 128
    2eb6:	09 f0       	breq	.+2      	; 0x2eba <__divsf3_pse+0x56>
    2eb8:	bb 0b       	sbc	r27, r27
    2eba:	80 2d       	mov	r24, r0
    2ebc:	bf 01       	movw	r22, r30
    2ebe:	ff 27       	eor	r31, r31
    2ec0:	93 58       	subi	r25, 0x83	; 131
    2ec2:	5f 4f       	sbci	r21, 0xFF	; 255
    2ec4:	3a f0       	brmi	.+14     	; 0x2ed4 <__divsf3_pse+0x70>
    2ec6:	9e 3f       	cpi	r25, 0xFE	; 254
    2ec8:	51 05       	cpc	r21, r1
    2eca:	78 f0       	brcs	.+30     	; 0x2eea <__divsf3_pse+0x86>
    2ecc:	0c 94 00 18 	jmp	0x3000	; 0x3000 <__fp_inf>
    2ed0:	0c 94 4b 18 	jmp	0x3096	; 0x3096 <__fp_szero>
    2ed4:	5f 3f       	cpi	r21, 0xFF	; 255
    2ed6:	e4 f3       	brlt	.-8      	; 0x2ed0 <__divsf3_pse+0x6c>
    2ed8:	98 3e       	cpi	r25, 0xE8	; 232
    2eda:	d4 f3       	brlt	.-12     	; 0x2ed0 <__divsf3_pse+0x6c>
    2edc:	86 95       	lsr	r24
    2ede:	77 95       	ror	r23
    2ee0:	67 95       	ror	r22
    2ee2:	b7 95       	ror	r27
    2ee4:	f7 95       	ror	r31
    2ee6:	9f 5f       	subi	r25, 0xFF	; 255
    2ee8:	c9 f7       	brne	.-14     	; 0x2edc <__divsf3_pse+0x78>
    2eea:	88 0f       	add	r24, r24
    2eec:	91 1d       	adc	r25, r1
    2eee:	96 95       	lsr	r25
    2ef0:	87 95       	ror	r24
    2ef2:	97 f9       	bld	r25, 7
    2ef4:	08 95       	ret
    2ef6:	e1 e0       	ldi	r30, 0x01	; 1
    2ef8:	66 0f       	add	r22, r22
    2efa:	77 1f       	adc	r23, r23
    2efc:	88 1f       	adc	r24, r24
    2efe:	bb 1f       	adc	r27, r27
    2f00:	62 17       	cp	r22, r18
    2f02:	73 07       	cpc	r23, r19
    2f04:	84 07       	cpc	r24, r20
    2f06:	ba 07       	cpc	r27, r26
    2f08:	20 f0       	brcs	.+8      	; 0x2f12 <__divsf3_pse+0xae>
    2f0a:	62 1b       	sub	r22, r18
    2f0c:	73 0b       	sbc	r23, r19
    2f0e:	84 0b       	sbc	r24, r20
    2f10:	ba 0b       	sbc	r27, r26
    2f12:	ee 1f       	adc	r30, r30
    2f14:	88 f7       	brcc	.-30     	; 0x2ef8 <__divsf3_pse+0x94>
    2f16:	e0 95       	com	r30
    2f18:	08 95       	ret

00002f1a <__fixsfsi>:
    2f1a:	0e 94 94 17 	call	0x2f28	; 0x2f28 <__fixunssfsi>
    2f1e:	68 94       	set
    2f20:	b1 11       	cpse	r27, r1
    2f22:	0c 94 4b 18 	jmp	0x3096	; 0x3096 <__fp_szero>
    2f26:	08 95       	ret

00002f28 <__fixunssfsi>:
    2f28:	0e 94 30 18 	call	0x3060	; 0x3060 <__fp_splitA>
    2f2c:	88 f0       	brcs	.+34     	; 0x2f50 <__fixunssfsi+0x28>
    2f2e:	9f 57       	subi	r25, 0x7F	; 127
    2f30:	98 f0       	brcs	.+38     	; 0x2f58 <__fixunssfsi+0x30>
    2f32:	b9 2f       	mov	r27, r25
    2f34:	99 27       	eor	r25, r25
    2f36:	b7 51       	subi	r27, 0x17	; 23
    2f38:	b0 f0       	brcs	.+44     	; 0x2f66 <__fixunssfsi+0x3e>
    2f3a:	e1 f0       	breq	.+56     	; 0x2f74 <__fixunssfsi+0x4c>
    2f3c:	66 0f       	add	r22, r22
    2f3e:	77 1f       	adc	r23, r23
    2f40:	88 1f       	adc	r24, r24
    2f42:	99 1f       	adc	r25, r25
    2f44:	1a f0       	brmi	.+6      	; 0x2f4c <__fixunssfsi+0x24>
    2f46:	ba 95       	dec	r27
    2f48:	c9 f7       	brne	.-14     	; 0x2f3c <__fixunssfsi+0x14>
    2f4a:	14 c0       	rjmp	.+40     	; 0x2f74 <__fixunssfsi+0x4c>
    2f4c:	b1 30       	cpi	r27, 0x01	; 1
    2f4e:	91 f0       	breq	.+36     	; 0x2f74 <__fixunssfsi+0x4c>
    2f50:	0e 94 4a 18 	call	0x3094	; 0x3094 <__fp_zero>
    2f54:	b1 e0       	ldi	r27, 0x01	; 1
    2f56:	08 95       	ret
    2f58:	0c 94 4a 18 	jmp	0x3094	; 0x3094 <__fp_zero>
    2f5c:	67 2f       	mov	r22, r23
    2f5e:	78 2f       	mov	r23, r24
    2f60:	88 27       	eor	r24, r24
    2f62:	b8 5f       	subi	r27, 0xF8	; 248
    2f64:	39 f0       	breq	.+14     	; 0x2f74 <__fixunssfsi+0x4c>
    2f66:	b9 3f       	cpi	r27, 0xF9	; 249
    2f68:	cc f3       	brlt	.-14     	; 0x2f5c <__fixunssfsi+0x34>
    2f6a:	86 95       	lsr	r24
    2f6c:	77 95       	ror	r23
    2f6e:	67 95       	ror	r22
    2f70:	b3 95       	inc	r27
    2f72:	d9 f7       	brne	.-10     	; 0x2f6a <__fixunssfsi+0x42>
    2f74:	3e f4       	brtc	.+14     	; 0x2f84 <__fixunssfsi+0x5c>
    2f76:	90 95       	com	r25
    2f78:	80 95       	com	r24
    2f7a:	70 95       	com	r23
    2f7c:	61 95       	neg	r22
    2f7e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f80:	8f 4f       	sbci	r24, 0xFF	; 255
    2f82:	9f 4f       	sbci	r25, 0xFF	; 255
    2f84:	08 95       	ret

00002f86 <__floatunsisf>:
    2f86:	e8 94       	clt
    2f88:	09 c0       	rjmp	.+18     	; 0x2f9c <__floatsisf+0x12>

00002f8a <__floatsisf>:
    2f8a:	97 fb       	bst	r25, 7
    2f8c:	3e f4       	brtc	.+14     	; 0x2f9c <__floatsisf+0x12>
    2f8e:	90 95       	com	r25
    2f90:	80 95       	com	r24
    2f92:	70 95       	com	r23
    2f94:	61 95       	neg	r22
    2f96:	7f 4f       	sbci	r23, 0xFF	; 255
    2f98:	8f 4f       	sbci	r24, 0xFF	; 255
    2f9a:	9f 4f       	sbci	r25, 0xFF	; 255
    2f9c:	99 23       	and	r25, r25
    2f9e:	a9 f0       	breq	.+42     	; 0x2fca <__floatsisf+0x40>
    2fa0:	f9 2f       	mov	r31, r25
    2fa2:	96 e9       	ldi	r25, 0x96	; 150
    2fa4:	bb 27       	eor	r27, r27
    2fa6:	93 95       	inc	r25
    2fa8:	f6 95       	lsr	r31
    2faa:	87 95       	ror	r24
    2fac:	77 95       	ror	r23
    2fae:	67 95       	ror	r22
    2fb0:	b7 95       	ror	r27
    2fb2:	f1 11       	cpse	r31, r1
    2fb4:	f8 cf       	rjmp	.-16     	; 0x2fa6 <__floatsisf+0x1c>
    2fb6:	fa f4       	brpl	.+62     	; 0x2ff6 <__floatsisf+0x6c>
    2fb8:	bb 0f       	add	r27, r27
    2fba:	11 f4       	brne	.+4      	; 0x2fc0 <__floatsisf+0x36>
    2fbc:	60 ff       	sbrs	r22, 0
    2fbe:	1b c0       	rjmp	.+54     	; 0x2ff6 <__floatsisf+0x6c>
    2fc0:	6f 5f       	subi	r22, 0xFF	; 255
    2fc2:	7f 4f       	sbci	r23, 0xFF	; 255
    2fc4:	8f 4f       	sbci	r24, 0xFF	; 255
    2fc6:	9f 4f       	sbci	r25, 0xFF	; 255
    2fc8:	16 c0       	rjmp	.+44     	; 0x2ff6 <__floatsisf+0x6c>
    2fca:	88 23       	and	r24, r24
    2fcc:	11 f0       	breq	.+4      	; 0x2fd2 <__floatsisf+0x48>
    2fce:	96 e9       	ldi	r25, 0x96	; 150
    2fd0:	11 c0       	rjmp	.+34     	; 0x2ff4 <__floatsisf+0x6a>
    2fd2:	77 23       	and	r23, r23
    2fd4:	21 f0       	breq	.+8      	; 0x2fde <__floatsisf+0x54>
    2fd6:	9e e8       	ldi	r25, 0x8E	; 142
    2fd8:	87 2f       	mov	r24, r23
    2fda:	76 2f       	mov	r23, r22
    2fdc:	05 c0       	rjmp	.+10     	; 0x2fe8 <__floatsisf+0x5e>
    2fde:	66 23       	and	r22, r22
    2fe0:	71 f0       	breq	.+28     	; 0x2ffe <__floatsisf+0x74>
    2fe2:	96 e8       	ldi	r25, 0x86	; 134
    2fe4:	86 2f       	mov	r24, r22
    2fe6:	70 e0       	ldi	r23, 0x00	; 0
    2fe8:	60 e0       	ldi	r22, 0x00	; 0
    2fea:	2a f0       	brmi	.+10     	; 0x2ff6 <__floatsisf+0x6c>
    2fec:	9a 95       	dec	r25
    2fee:	66 0f       	add	r22, r22
    2ff0:	77 1f       	adc	r23, r23
    2ff2:	88 1f       	adc	r24, r24
    2ff4:	da f7       	brpl	.-10     	; 0x2fec <__floatsisf+0x62>
    2ff6:	88 0f       	add	r24, r24
    2ff8:	96 95       	lsr	r25
    2ffa:	87 95       	ror	r24
    2ffc:	97 f9       	bld	r25, 7
    2ffe:	08 95       	ret

00003000 <__fp_inf>:
    3000:	97 f9       	bld	r25, 7
    3002:	9f 67       	ori	r25, 0x7F	; 127
    3004:	80 e8       	ldi	r24, 0x80	; 128
    3006:	70 e0       	ldi	r23, 0x00	; 0
    3008:	60 e0       	ldi	r22, 0x00	; 0
    300a:	08 95       	ret

0000300c <__fp_nan>:
    300c:	9f ef       	ldi	r25, 0xFF	; 255
    300e:	80 ec       	ldi	r24, 0xC0	; 192
    3010:	08 95       	ret

00003012 <__fp_pscA>:
    3012:	00 24       	eor	r0, r0
    3014:	0a 94       	dec	r0
    3016:	16 16       	cp	r1, r22
    3018:	17 06       	cpc	r1, r23
    301a:	18 06       	cpc	r1, r24
    301c:	09 06       	cpc	r0, r25
    301e:	08 95       	ret

00003020 <__fp_pscB>:
    3020:	00 24       	eor	r0, r0
    3022:	0a 94       	dec	r0
    3024:	12 16       	cp	r1, r18
    3026:	13 06       	cpc	r1, r19
    3028:	14 06       	cpc	r1, r20
    302a:	05 06       	cpc	r0, r21
    302c:	08 95       	ret

0000302e <__fp_round>:
    302e:	09 2e       	mov	r0, r25
    3030:	03 94       	inc	r0
    3032:	00 0c       	add	r0, r0
    3034:	11 f4       	brne	.+4      	; 0x303a <__fp_round+0xc>
    3036:	88 23       	and	r24, r24
    3038:	52 f0       	brmi	.+20     	; 0x304e <__fp_round+0x20>
    303a:	bb 0f       	add	r27, r27
    303c:	40 f4       	brcc	.+16     	; 0x304e <__fp_round+0x20>
    303e:	bf 2b       	or	r27, r31
    3040:	11 f4       	brne	.+4      	; 0x3046 <__fp_round+0x18>
    3042:	60 ff       	sbrs	r22, 0
    3044:	04 c0       	rjmp	.+8      	; 0x304e <__fp_round+0x20>
    3046:	6f 5f       	subi	r22, 0xFF	; 255
    3048:	7f 4f       	sbci	r23, 0xFF	; 255
    304a:	8f 4f       	sbci	r24, 0xFF	; 255
    304c:	9f 4f       	sbci	r25, 0xFF	; 255
    304e:	08 95       	ret

00003050 <__fp_split3>:
    3050:	57 fd       	sbrc	r21, 7
    3052:	90 58       	subi	r25, 0x80	; 128
    3054:	44 0f       	add	r20, r20
    3056:	55 1f       	adc	r21, r21
    3058:	59 f0       	breq	.+22     	; 0x3070 <__fp_splitA+0x10>
    305a:	5f 3f       	cpi	r21, 0xFF	; 255
    305c:	71 f0       	breq	.+28     	; 0x307a <__fp_splitA+0x1a>
    305e:	47 95       	ror	r20

00003060 <__fp_splitA>:
    3060:	88 0f       	add	r24, r24
    3062:	97 fb       	bst	r25, 7
    3064:	99 1f       	adc	r25, r25
    3066:	61 f0       	breq	.+24     	; 0x3080 <__fp_splitA+0x20>
    3068:	9f 3f       	cpi	r25, 0xFF	; 255
    306a:	79 f0       	breq	.+30     	; 0x308a <__fp_splitA+0x2a>
    306c:	87 95       	ror	r24
    306e:	08 95       	ret
    3070:	12 16       	cp	r1, r18
    3072:	13 06       	cpc	r1, r19
    3074:	14 06       	cpc	r1, r20
    3076:	55 1f       	adc	r21, r21
    3078:	f2 cf       	rjmp	.-28     	; 0x305e <__fp_split3+0xe>
    307a:	46 95       	lsr	r20
    307c:	f1 df       	rcall	.-30     	; 0x3060 <__fp_splitA>
    307e:	08 c0       	rjmp	.+16     	; 0x3090 <__fp_splitA+0x30>
    3080:	16 16       	cp	r1, r22
    3082:	17 06       	cpc	r1, r23
    3084:	18 06       	cpc	r1, r24
    3086:	99 1f       	adc	r25, r25
    3088:	f1 cf       	rjmp	.-30     	; 0x306c <__fp_splitA+0xc>
    308a:	86 95       	lsr	r24
    308c:	71 05       	cpc	r23, r1
    308e:	61 05       	cpc	r22, r1
    3090:	08 94       	sec
    3092:	08 95       	ret

00003094 <__fp_zero>:
    3094:	e8 94       	clt

00003096 <__fp_szero>:
    3096:	bb 27       	eor	r27, r27
    3098:	66 27       	eor	r22, r22
    309a:	77 27       	eor	r23, r23
    309c:	cb 01       	movw	r24, r22
    309e:	97 f9       	bld	r25, 7
    30a0:	08 95       	ret

000030a2 <__mulsf3>:
    30a2:	0e 94 64 18 	call	0x30c8	; 0x30c8 <__mulsf3x>
    30a6:	0c 94 17 18 	jmp	0x302e	; 0x302e <__fp_round>
    30aa:	0e 94 09 18 	call	0x3012	; 0x3012 <__fp_pscA>
    30ae:	38 f0       	brcs	.+14     	; 0x30be <__mulsf3+0x1c>
    30b0:	0e 94 10 18 	call	0x3020	; 0x3020 <__fp_pscB>
    30b4:	20 f0       	brcs	.+8      	; 0x30be <__mulsf3+0x1c>
    30b6:	95 23       	and	r25, r21
    30b8:	11 f0       	breq	.+4      	; 0x30be <__mulsf3+0x1c>
    30ba:	0c 94 00 18 	jmp	0x3000	; 0x3000 <__fp_inf>
    30be:	0c 94 06 18 	jmp	0x300c	; 0x300c <__fp_nan>
    30c2:	11 24       	eor	r1, r1
    30c4:	0c 94 4b 18 	jmp	0x3096	; 0x3096 <__fp_szero>

000030c8 <__mulsf3x>:
    30c8:	0e 94 28 18 	call	0x3050	; 0x3050 <__fp_split3>
    30cc:	70 f3       	brcs	.-36     	; 0x30aa <__mulsf3+0x8>

000030ce <__mulsf3_pse>:
    30ce:	95 9f       	mul	r25, r21
    30d0:	c1 f3       	breq	.-16     	; 0x30c2 <__mulsf3+0x20>
    30d2:	95 0f       	add	r25, r21
    30d4:	50 e0       	ldi	r21, 0x00	; 0
    30d6:	55 1f       	adc	r21, r21
    30d8:	62 9f       	mul	r22, r18
    30da:	f0 01       	movw	r30, r0
    30dc:	72 9f       	mul	r23, r18
    30de:	bb 27       	eor	r27, r27
    30e0:	f0 0d       	add	r31, r0
    30e2:	b1 1d       	adc	r27, r1
    30e4:	63 9f       	mul	r22, r19
    30e6:	aa 27       	eor	r26, r26
    30e8:	f0 0d       	add	r31, r0
    30ea:	b1 1d       	adc	r27, r1
    30ec:	aa 1f       	adc	r26, r26
    30ee:	64 9f       	mul	r22, r20
    30f0:	66 27       	eor	r22, r22
    30f2:	b0 0d       	add	r27, r0
    30f4:	a1 1d       	adc	r26, r1
    30f6:	66 1f       	adc	r22, r22
    30f8:	82 9f       	mul	r24, r18
    30fa:	22 27       	eor	r18, r18
    30fc:	b0 0d       	add	r27, r0
    30fe:	a1 1d       	adc	r26, r1
    3100:	62 1f       	adc	r22, r18
    3102:	73 9f       	mul	r23, r19
    3104:	b0 0d       	add	r27, r0
    3106:	a1 1d       	adc	r26, r1
    3108:	62 1f       	adc	r22, r18
    310a:	83 9f       	mul	r24, r19
    310c:	a0 0d       	add	r26, r0
    310e:	61 1d       	adc	r22, r1
    3110:	22 1f       	adc	r18, r18
    3112:	74 9f       	mul	r23, r20
    3114:	33 27       	eor	r19, r19
    3116:	a0 0d       	add	r26, r0
    3118:	61 1d       	adc	r22, r1
    311a:	23 1f       	adc	r18, r19
    311c:	84 9f       	mul	r24, r20
    311e:	60 0d       	add	r22, r0
    3120:	21 1d       	adc	r18, r1
    3122:	82 2f       	mov	r24, r18
    3124:	76 2f       	mov	r23, r22
    3126:	6a 2f       	mov	r22, r26
    3128:	11 24       	eor	r1, r1
    312a:	9f 57       	subi	r25, 0x7F	; 127
    312c:	50 40       	sbci	r21, 0x00	; 0
    312e:	9a f0       	brmi	.+38     	; 0x3156 <__mulsf3_pse+0x88>
    3130:	f1 f0       	breq	.+60     	; 0x316e <__mulsf3_pse+0xa0>
    3132:	88 23       	and	r24, r24
    3134:	4a f0       	brmi	.+18     	; 0x3148 <__mulsf3_pse+0x7a>
    3136:	ee 0f       	add	r30, r30
    3138:	ff 1f       	adc	r31, r31
    313a:	bb 1f       	adc	r27, r27
    313c:	66 1f       	adc	r22, r22
    313e:	77 1f       	adc	r23, r23
    3140:	88 1f       	adc	r24, r24
    3142:	91 50       	subi	r25, 0x01	; 1
    3144:	50 40       	sbci	r21, 0x00	; 0
    3146:	a9 f7       	brne	.-22     	; 0x3132 <__mulsf3_pse+0x64>
    3148:	9e 3f       	cpi	r25, 0xFE	; 254
    314a:	51 05       	cpc	r21, r1
    314c:	80 f0       	brcs	.+32     	; 0x316e <__mulsf3_pse+0xa0>
    314e:	0c 94 00 18 	jmp	0x3000	; 0x3000 <__fp_inf>
    3152:	0c 94 4b 18 	jmp	0x3096	; 0x3096 <__fp_szero>
    3156:	5f 3f       	cpi	r21, 0xFF	; 255
    3158:	e4 f3       	brlt	.-8      	; 0x3152 <__mulsf3_pse+0x84>
    315a:	98 3e       	cpi	r25, 0xE8	; 232
    315c:	d4 f3       	brlt	.-12     	; 0x3152 <__mulsf3_pse+0x84>
    315e:	86 95       	lsr	r24
    3160:	77 95       	ror	r23
    3162:	67 95       	ror	r22
    3164:	b7 95       	ror	r27
    3166:	f7 95       	ror	r31
    3168:	e7 95       	ror	r30
    316a:	9f 5f       	subi	r25, 0xFF	; 255
    316c:	c1 f7       	brne	.-16     	; 0x315e <__mulsf3_pse+0x90>
    316e:	fe 2b       	or	r31, r30
    3170:	88 0f       	add	r24, r24
    3172:	91 1d       	adc	r25, r1
    3174:	96 95       	lsr	r25
    3176:	87 95       	ror	r24
    3178:	97 f9       	bld	r25, 7
    317a:	08 95       	ret

0000317c <__tablejump2__>:
    317c:	ee 0f       	add	r30, r30
    317e:	ff 1f       	adc	r31, r31
    3180:	05 90       	lpm	r0, Z+
    3182:	f4 91       	lpm	r31, Z
    3184:	e0 2d       	mov	r30, r0
    3186:	09 94       	ijmp

00003188 <strcmp>:
    3188:	fb 01       	movw	r30, r22
    318a:	dc 01       	movw	r26, r24
    318c:	8d 91       	ld	r24, X+
    318e:	01 90       	ld	r0, Z+
    3190:	80 19       	sub	r24, r0
    3192:	01 10       	cpse	r0, r1
    3194:	d9 f3       	breq	.-10     	; 0x318c <strcmp+0x4>
    3196:	99 0b       	sbc	r25, r25
    3198:	08 95       	ret

0000319a <strcpy>:
    319a:	fb 01       	movw	r30, r22
    319c:	dc 01       	movw	r26, r24
    319e:	01 90       	ld	r0, Z+
    31a0:	0d 92       	st	X+, r0
    31a2:	00 20       	and	r0, r0
    31a4:	e1 f7       	brne	.-8      	; 0x319e <strcpy+0x4>
    31a6:	08 95       	ret

000031a8 <sprintf>:
    31a8:	ae e0       	ldi	r26, 0x0E	; 14
    31aa:	b0 e0       	ldi	r27, 0x00	; 0
    31ac:	ea ed       	ldi	r30, 0xDA	; 218
    31ae:	f8 e1       	ldi	r31, 0x18	; 24
    31b0:	0c 94 95 1b 	jmp	0x372a	; 0x372a <__prologue_saves__+0x1c>
    31b4:	0d 89       	ldd	r16, Y+21	; 0x15
    31b6:	1e 89       	ldd	r17, Y+22	; 0x16
    31b8:	86 e0       	ldi	r24, 0x06	; 6
    31ba:	8c 83       	std	Y+4, r24	; 0x04
    31bc:	1a 83       	std	Y+2, r17	; 0x02
    31be:	09 83       	std	Y+1, r16	; 0x01
    31c0:	8f ef       	ldi	r24, 0xFF	; 255
    31c2:	9f e7       	ldi	r25, 0x7F	; 127
    31c4:	9e 83       	std	Y+6, r25	; 0x06
    31c6:	8d 83       	std	Y+5, r24	; 0x05
    31c8:	ae 01       	movw	r20, r28
    31ca:	47 5e       	subi	r20, 0xE7	; 231
    31cc:	5f 4f       	sbci	r21, 0xFF	; 255
    31ce:	6f 89       	ldd	r22, Y+23	; 0x17
    31d0:	78 8d       	ldd	r23, Y+24	; 0x18
    31d2:	ce 01       	movw	r24, r28
    31d4:	01 96       	adiw	r24, 0x01	; 1
    31d6:	0e 94 f6 18 	call	0x31ec	; 0x31ec <vfprintf>
    31da:	ef 81       	ldd	r30, Y+7	; 0x07
    31dc:	f8 85       	ldd	r31, Y+8	; 0x08
    31de:	e0 0f       	add	r30, r16
    31e0:	f1 1f       	adc	r31, r17
    31e2:	10 82       	st	Z, r1
    31e4:	2e 96       	adiw	r28, 0x0e	; 14
    31e6:	e4 e0       	ldi	r30, 0x04	; 4
    31e8:	0c 94 b1 1b 	jmp	0x3762	; 0x3762 <__epilogue_restores__+0x1c>

000031ec <vfprintf>:
    31ec:	ab e0       	ldi	r26, 0x0B	; 11
    31ee:	b0 e0       	ldi	r27, 0x00	; 0
    31f0:	ec ef       	ldi	r30, 0xFC	; 252
    31f2:	f8 e1       	ldi	r31, 0x18	; 24
    31f4:	0c 94 87 1b 	jmp	0x370e	; 0x370e <__prologue_saves__>
    31f8:	6c 01       	movw	r12, r24
    31fa:	7b 01       	movw	r14, r22
    31fc:	8a 01       	movw	r16, r20
    31fe:	fc 01       	movw	r30, r24
    3200:	17 82       	std	Z+7, r1	; 0x07
    3202:	16 82       	std	Z+6, r1	; 0x06
    3204:	83 81       	ldd	r24, Z+3	; 0x03
    3206:	81 ff       	sbrs	r24, 1
    3208:	cc c1       	rjmp	.+920    	; 0x35a2 <vfprintf+0x3b6>
    320a:	ce 01       	movw	r24, r28
    320c:	01 96       	adiw	r24, 0x01	; 1
    320e:	3c 01       	movw	r6, r24
    3210:	f6 01       	movw	r30, r12
    3212:	93 81       	ldd	r25, Z+3	; 0x03
    3214:	f7 01       	movw	r30, r14
    3216:	93 fd       	sbrc	r25, 3
    3218:	85 91       	lpm	r24, Z+
    321a:	93 ff       	sbrs	r25, 3
    321c:	81 91       	ld	r24, Z+
    321e:	7f 01       	movw	r14, r30
    3220:	88 23       	and	r24, r24
    3222:	09 f4       	brne	.+2      	; 0x3226 <vfprintf+0x3a>
    3224:	ba c1       	rjmp	.+884    	; 0x359a <vfprintf+0x3ae>
    3226:	85 32       	cpi	r24, 0x25	; 37
    3228:	39 f4       	brne	.+14     	; 0x3238 <vfprintf+0x4c>
    322a:	93 fd       	sbrc	r25, 3
    322c:	85 91       	lpm	r24, Z+
    322e:	93 ff       	sbrs	r25, 3
    3230:	81 91       	ld	r24, Z+
    3232:	7f 01       	movw	r14, r30
    3234:	85 32       	cpi	r24, 0x25	; 37
    3236:	29 f4       	brne	.+10     	; 0x3242 <vfprintf+0x56>
    3238:	b6 01       	movw	r22, r12
    323a:	90 e0       	ldi	r25, 0x00	; 0
    323c:	0e 94 ed 1a 	call	0x35da	; 0x35da <fputc>
    3240:	e7 cf       	rjmp	.-50     	; 0x3210 <vfprintf+0x24>
    3242:	91 2c       	mov	r9, r1
    3244:	21 2c       	mov	r2, r1
    3246:	31 2c       	mov	r3, r1
    3248:	ff e1       	ldi	r31, 0x1F	; 31
    324a:	f3 15       	cp	r31, r3
    324c:	d8 f0       	brcs	.+54     	; 0x3284 <vfprintf+0x98>
    324e:	8b 32       	cpi	r24, 0x2B	; 43
    3250:	79 f0       	breq	.+30     	; 0x3270 <vfprintf+0x84>
    3252:	38 f4       	brcc	.+14     	; 0x3262 <vfprintf+0x76>
    3254:	80 32       	cpi	r24, 0x20	; 32
    3256:	79 f0       	breq	.+30     	; 0x3276 <vfprintf+0x8a>
    3258:	83 32       	cpi	r24, 0x23	; 35
    325a:	a1 f4       	brne	.+40     	; 0x3284 <vfprintf+0x98>
    325c:	23 2d       	mov	r18, r3
    325e:	20 61       	ori	r18, 0x10	; 16
    3260:	1d c0       	rjmp	.+58     	; 0x329c <vfprintf+0xb0>
    3262:	8d 32       	cpi	r24, 0x2D	; 45
    3264:	61 f0       	breq	.+24     	; 0x327e <vfprintf+0x92>
    3266:	80 33       	cpi	r24, 0x30	; 48
    3268:	69 f4       	brne	.+26     	; 0x3284 <vfprintf+0x98>
    326a:	23 2d       	mov	r18, r3
    326c:	21 60       	ori	r18, 0x01	; 1
    326e:	16 c0       	rjmp	.+44     	; 0x329c <vfprintf+0xb0>
    3270:	83 2d       	mov	r24, r3
    3272:	82 60       	ori	r24, 0x02	; 2
    3274:	38 2e       	mov	r3, r24
    3276:	e3 2d       	mov	r30, r3
    3278:	e4 60       	ori	r30, 0x04	; 4
    327a:	3e 2e       	mov	r3, r30
    327c:	2a c0       	rjmp	.+84     	; 0x32d2 <vfprintf+0xe6>
    327e:	f3 2d       	mov	r31, r3
    3280:	f8 60       	ori	r31, 0x08	; 8
    3282:	1d c0       	rjmp	.+58     	; 0x32be <vfprintf+0xd2>
    3284:	37 fc       	sbrc	r3, 7
    3286:	2d c0       	rjmp	.+90     	; 0x32e2 <vfprintf+0xf6>
    3288:	20 ed       	ldi	r18, 0xD0	; 208
    328a:	28 0f       	add	r18, r24
    328c:	2a 30       	cpi	r18, 0x0A	; 10
    328e:	40 f0       	brcs	.+16     	; 0x32a0 <vfprintf+0xb4>
    3290:	8e 32       	cpi	r24, 0x2E	; 46
    3292:	b9 f4       	brne	.+46     	; 0x32c2 <vfprintf+0xd6>
    3294:	36 fc       	sbrc	r3, 6
    3296:	81 c1       	rjmp	.+770    	; 0x359a <vfprintf+0x3ae>
    3298:	23 2d       	mov	r18, r3
    329a:	20 64       	ori	r18, 0x40	; 64
    329c:	32 2e       	mov	r3, r18
    329e:	19 c0       	rjmp	.+50     	; 0x32d2 <vfprintf+0xe6>
    32a0:	36 fe       	sbrs	r3, 6
    32a2:	06 c0       	rjmp	.+12     	; 0x32b0 <vfprintf+0xc4>
    32a4:	8a e0       	ldi	r24, 0x0A	; 10
    32a6:	98 9e       	mul	r9, r24
    32a8:	20 0d       	add	r18, r0
    32aa:	11 24       	eor	r1, r1
    32ac:	92 2e       	mov	r9, r18
    32ae:	11 c0       	rjmp	.+34     	; 0x32d2 <vfprintf+0xe6>
    32b0:	ea e0       	ldi	r30, 0x0A	; 10
    32b2:	2e 9e       	mul	r2, r30
    32b4:	20 0d       	add	r18, r0
    32b6:	11 24       	eor	r1, r1
    32b8:	22 2e       	mov	r2, r18
    32ba:	f3 2d       	mov	r31, r3
    32bc:	f0 62       	ori	r31, 0x20	; 32
    32be:	3f 2e       	mov	r3, r31
    32c0:	08 c0       	rjmp	.+16     	; 0x32d2 <vfprintf+0xe6>
    32c2:	8c 36       	cpi	r24, 0x6C	; 108
    32c4:	21 f4       	brne	.+8      	; 0x32ce <vfprintf+0xe2>
    32c6:	83 2d       	mov	r24, r3
    32c8:	80 68       	ori	r24, 0x80	; 128
    32ca:	38 2e       	mov	r3, r24
    32cc:	02 c0       	rjmp	.+4      	; 0x32d2 <vfprintf+0xe6>
    32ce:	88 36       	cpi	r24, 0x68	; 104
    32d0:	41 f4       	brne	.+16     	; 0x32e2 <vfprintf+0xf6>
    32d2:	f7 01       	movw	r30, r14
    32d4:	93 fd       	sbrc	r25, 3
    32d6:	85 91       	lpm	r24, Z+
    32d8:	93 ff       	sbrs	r25, 3
    32da:	81 91       	ld	r24, Z+
    32dc:	7f 01       	movw	r14, r30
    32de:	81 11       	cpse	r24, r1
    32e0:	b3 cf       	rjmp	.-154    	; 0x3248 <vfprintf+0x5c>
    32e2:	98 2f       	mov	r25, r24
    32e4:	9f 7d       	andi	r25, 0xDF	; 223
    32e6:	95 54       	subi	r25, 0x45	; 69
    32e8:	93 30       	cpi	r25, 0x03	; 3
    32ea:	28 f4       	brcc	.+10     	; 0x32f6 <vfprintf+0x10a>
    32ec:	0c 5f       	subi	r16, 0xFC	; 252
    32ee:	1f 4f       	sbci	r17, 0xFF	; 255
    32f0:	9f e3       	ldi	r25, 0x3F	; 63
    32f2:	99 83       	std	Y+1, r25	; 0x01
    32f4:	0d c0       	rjmp	.+26     	; 0x3310 <vfprintf+0x124>
    32f6:	83 36       	cpi	r24, 0x63	; 99
    32f8:	31 f0       	breq	.+12     	; 0x3306 <vfprintf+0x11a>
    32fa:	83 37       	cpi	r24, 0x73	; 115
    32fc:	71 f0       	breq	.+28     	; 0x331a <vfprintf+0x12e>
    32fe:	83 35       	cpi	r24, 0x53	; 83
    3300:	09 f0       	breq	.+2      	; 0x3304 <vfprintf+0x118>
    3302:	59 c0       	rjmp	.+178    	; 0x33b6 <vfprintf+0x1ca>
    3304:	21 c0       	rjmp	.+66     	; 0x3348 <vfprintf+0x15c>
    3306:	f8 01       	movw	r30, r16
    3308:	80 81       	ld	r24, Z
    330a:	89 83       	std	Y+1, r24	; 0x01
    330c:	0e 5f       	subi	r16, 0xFE	; 254
    330e:	1f 4f       	sbci	r17, 0xFF	; 255
    3310:	88 24       	eor	r8, r8
    3312:	83 94       	inc	r8
    3314:	91 2c       	mov	r9, r1
    3316:	53 01       	movw	r10, r6
    3318:	13 c0       	rjmp	.+38     	; 0x3340 <vfprintf+0x154>
    331a:	28 01       	movw	r4, r16
    331c:	f2 e0       	ldi	r31, 0x02	; 2
    331e:	4f 0e       	add	r4, r31
    3320:	51 1c       	adc	r5, r1
    3322:	f8 01       	movw	r30, r16
    3324:	a0 80       	ld	r10, Z
    3326:	b1 80       	ldd	r11, Z+1	; 0x01
    3328:	36 fe       	sbrs	r3, 6
    332a:	03 c0       	rjmp	.+6      	; 0x3332 <vfprintf+0x146>
    332c:	69 2d       	mov	r22, r9
    332e:	70 e0       	ldi	r23, 0x00	; 0
    3330:	02 c0       	rjmp	.+4      	; 0x3336 <vfprintf+0x14a>
    3332:	6f ef       	ldi	r22, 0xFF	; 255
    3334:	7f ef       	ldi	r23, 0xFF	; 255
    3336:	c5 01       	movw	r24, r10
    3338:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <strnlen>
    333c:	4c 01       	movw	r8, r24
    333e:	82 01       	movw	r16, r4
    3340:	f3 2d       	mov	r31, r3
    3342:	ff 77       	andi	r31, 0x7F	; 127
    3344:	3f 2e       	mov	r3, r31
    3346:	16 c0       	rjmp	.+44     	; 0x3374 <vfprintf+0x188>
    3348:	28 01       	movw	r4, r16
    334a:	22 e0       	ldi	r18, 0x02	; 2
    334c:	42 0e       	add	r4, r18
    334e:	51 1c       	adc	r5, r1
    3350:	f8 01       	movw	r30, r16
    3352:	a0 80       	ld	r10, Z
    3354:	b1 80       	ldd	r11, Z+1	; 0x01
    3356:	36 fe       	sbrs	r3, 6
    3358:	03 c0       	rjmp	.+6      	; 0x3360 <vfprintf+0x174>
    335a:	69 2d       	mov	r22, r9
    335c:	70 e0       	ldi	r23, 0x00	; 0
    335e:	02 c0       	rjmp	.+4      	; 0x3364 <vfprintf+0x178>
    3360:	6f ef       	ldi	r22, 0xFF	; 255
    3362:	7f ef       	ldi	r23, 0xFF	; 255
    3364:	c5 01       	movw	r24, r10
    3366:	0e 94 d7 1a 	call	0x35ae	; 0x35ae <strnlen_P>
    336a:	4c 01       	movw	r8, r24
    336c:	f3 2d       	mov	r31, r3
    336e:	f0 68       	ori	r31, 0x80	; 128
    3370:	3f 2e       	mov	r3, r31
    3372:	82 01       	movw	r16, r4
    3374:	33 fc       	sbrc	r3, 3
    3376:	1b c0       	rjmp	.+54     	; 0x33ae <vfprintf+0x1c2>
    3378:	82 2d       	mov	r24, r2
    337a:	90 e0       	ldi	r25, 0x00	; 0
    337c:	88 16       	cp	r8, r24
    337e:	99 06       	cpc	r9, r25
    3380:	b0 f4       	brcc	.+44     	; 0x33ae <vfprintf+0x1c2>
    3382:	b6 01       	movw	r22, r12
    3384:	80 e2       	ldi	r24, 0x20	; 32
    3386:	90 e0       	ldi	r25, 0x00	; 0
    3388:	0e 94 ed 1a 	call	0x35da	; 0x35da <fputc>
    338c:	2a 94       	dec	r2
    338e:	f4 cf       	rjmp	.-24     	; 0x3378 <vfprintf+0x18c>
    3390:	f5 01       	movw	r30, r10
    3392:	37 fc       	sbrc	r3, 7
    3394:	85 91       	lpm	r24, Z+
    3396:	37 fe       	sbrs	r3, 7
    3398:	81 91       	ld	r24, Z+
    339a:	5f 01       	movw	r10, r30
    339c:	b6 01       	movw	r22, r12
    339e:	90 e0       	ldi	r25, 0x00	; 0
    33a0:	0e 94 ed 1a 	call	0x35da	; 0x35da <fputc>
    33a4:	21 10       	cpse	r2, r1
    33a6:	2a 94       	dec	r2
    33a8:	21 e0       	ldi	r18, 0x01	; 1
    33aa:	82 1a       	sub	r8, r18
    33ac:	91 08       	sbc	r9, r1
    33ae:	81 14       	cp	r8, r1
    33b0:	91 04       	cpc	r9, r1
    33b2:	71 f7       	brne	.-36     	; 0x3390 <vfprintf+0x1a4>
    33b4:	e8 c0       	rjmp	.+464    	; 0x3586 <vfprintf+0x39a>
    33b6:	84 36       	cpi	r24, 0x64	; 100
    33b8:	11 f0       	breq	.+4      	; 0x33be <vfprintf+0x1d2>
    33ba:	89 36       	cpi	r24, 0x69	; 105
    33bc:	41 f5       	brne	.+80     	; 0x340e <vfprintf+0x222>
    33be:	f8 01       	movw	r30, r16
    33c0:	37 fe       	sbrs	r3, 7
    33c2:	07 c0       	rjmp	.+14     	; 0x33d2 <vfprintf+0x1e6>
    33c4:	60 81       	ld	r22, Z
    33c6:	71 81       	ldd	r23, Z+1	; 0x01
    33c8:	82 81       	ldd	r24, Z+2	; 0x02
    33ca:	93 81       	ldd	r25, Z+3	; 0x03
    33cc:	0c 5f       	subi	r16, 0xFC	; 252
    33ce:	1f 4f       	sbci	r17, 0xFF	; 255
    33d0:	08 c0       	rjmp	.+16     	; 0x33e2 <vfprintf+0x1f6>
    33d2:	60 81       	ld	r22, Z
    33d4:	71 81       	ldd	r23, Z+1	; 0x01
    33d6:	07 2e       	mov	r0, r23
    33d8:	00 0c       	add	r0, r0
    33da:	88 0b       	sbc	r24, r24
    33dc:	99 0b       	sbc	r25, r25
    33de:	0e 5f       	subi	r16, 0xFE	; 254
    33e0:	1f 4f       	sbci	r17, 0xFF	; 255
    33e2:	f3 2d       	mov	r31, r3
    33e4:	ff 76       	andi	r31, 0x6F	; 111
    33e6:	3f 2e       	mov	r3, r31
    33e8:	97 ff       	sbrs	r25, 7
    33ea:	09 c0       	rjmp	.+18     	; 0x33fe <vfprintf+0x212>
    33ec:	90 95       	com	r25
    33ee:	80 95       	com	r24
    33f0:	70 95       	com	r23
    33f2:	61 95       	neg	r22
    33f4:	7f 4f       	sbci	r23, 0xFF	; 255
    33f6:	8f 4f       	sbci	r24, 0xFF	; 255
    33f8:	9f 4f       	sbci	r25, 0xFF	; 255
    33fa:	f0 68       	ori	r31, 0x80	; 128
    33fc:	3f 2e       	mov	r3, r31
    33fe:	2a e0       	ldi	r18, 0x0A	; 10
    3400:	30 e0       	ldi	r19, 0x00	; 0
    3402:	a3 01       	movw	r20, r6
    3404:	0e 94 29 1b 	call	0x3652	; 0x3652 <__ultoa_invert>
    3408:	88 2e       	mov	r8, r24
    340a:	86 18       	sub	r8, r6
    340c:	45 c0       	rjmp	.+138    	; 0x3498 <vfprintf+0x2ac>
    340e:	85 37       	cpi	r24, 0x75	; 117
    3410:	31 f4       	brne	.+12     	; 0x341e <vfprintf+0x232>
    3412:	23 2d       	mov	r18, r3
    3414:	2f 7e       	andi	r18, 0xEF	; 239
    3416:	b2 2e       	mov	r11, r18
    3418:	2a e0       	ldi	r18, 0x0A	; 10
    341a:	30 e0       	ldi	r19, 0x00	; 0
    341c:	25 c0       	rjmp	.+74     	; 0x3468 <vfprintf+0x27c>
    341e:	93 2d       	mov	r25, r3
    3420:	99 7f       	andi	r25, 0xF9	; 249
    3422:	b9 2e       	mov	r11, r25
    3424:	8f 36       	cpi	r24, 0x6F	; 111
    3426:	c1 f0       	breq	.+48     	; 0x3458 <vfprintf+0x26c>
    3428:	18 f4       	brcc	.+6      	; 0x3430 <vfprintf+0x244>
    342a:	88 35       	cpi	r24, 0x58	; 88
    342c:	79 f0       	breq	.+30     	; 0x344c <vfprintf+0x260>
    342e:	b5 c0       	rjmp	.+362    	; 0x359a <vfprintf+0x3ae>
    3430:	80 37       	cpi	r24, 0x70	; 112
    3432:	19 f0       	breq	.+6      	; 0x343a <vfprintf+0x24e>
    3434:	88 37       	cpi	r24, 0x78	; 120
    3436:	21 f0       	breq	.+8      	; 0x3440 <vfprintf+0x254>
    3438:	b0 c0       	rjmp	.+352    	; 0x359a <vfprintf+0x3ae>
    343a:	e9 2f       	mov	r30, r25
    343c:	e0 61       	ori	r30, 0x10	; 16
    343e:	be 2e       	mov	r11, r30
    3440:	b4 fe       	sbrs	r11, 4
    3442:	0d c0       	rjmp	.+26     	; 0x345e <vfprintf+0x272>
    3444:	fb 2d       	mov	r31, r11
    3446:	f4 60       	ori	r31, 0x04	; 4
    3448:	bf 2e       	mov	r11, r31
    344a:	09 c0       	rjmp	.+18     	; 0x345e <vfprintf+0x272>
    344c:	34 fe       	sbrs	r3, 4
    344e:	0a c0       	rjmp	.+20     	; 0x3464 <vfprintf+0x278>
    3450:	29 2f       	mov	r18, r25
    3452:	26 60       	ori	r18, 0x06	; 6
    3454:	b2 2e       	mov	r11, r18
    3456:	06 c0       	rjmp	.+12     	; 0x3464 <vfprintf+0x278>
    3458:	28 e0       	ldi	r18, 0x08	; 8
    345a:	30 e0       	ldi	r19, 0x00	; 0
    345c:	05 c0       	rjmp	.+10     	; 0x3468 <vfprintf+0x27c>
    345e:	20 e1       	ldi	r18, 0x10	; 16
    3460:	30 e0       	ldi	r19, 0x00	; 0
    3462:	02 c0       	rjmp	.+4      	; 0x3468 <vfprintf+0x27c>
    3464:	20 e1       	ldi	r18, 0x10	; 16
    3466:	32 e0       	ldi	r19, 0x02	; 2
    3468:	f8 01       	movw	r30, r16
    346a:	b7 fe       	sbrs	r11, 7
    346c:	07 c0       	rjmp	.+14     	; 0x347c <vfprintf+0x290>
    346e:	60 81       	ld	r22, Z
    3470:	71 81       	ldd	r23, Z+1	; 0x01
    3472:	82 81       	ldd	r24, Z+2	; 0x02
    3474:	93 81       	ldd	r25, Z+3	; 0x03
    3476:	0c 5f       	subi	r16, 0xFC	; 252
    3478:	1f 4f       	sbci	r17, 0xFF	; 255
    347a:	06 c0       	rjmp	.+12     	; 0x3488 <vfprintf+0x29c>
    347c:	60 81       	ld	r22, Z
    347e:	71 81       	ldd	r23, Z+1	; 0x01
    3480:	80 e0       	ldi	r24, 0x00	; 0
    3482:	90 e0       	ldi	r25, 0x00	; 0
    3484:	0e 5f       	subi	r16, 0xFE	; 254
    3486:	1f 4f       	sbci	r17, 0xFF	; 255
    3488:	a3 01       	movw	r20, r6
    348a:	0e 94 29 1b 	call	0x3652	; 0x3652 <__ultoa_invert>
    348e:	88 2e       	mov	r8, r24
    3490:	86 18       	sub	r8, r6
    3492:	fb 2d       	mov	r31, r11
    3494:	ff 77       	andi	r31, 0x7F	; 127
    3496:	3f 2e       	mov	r3, r31
    3498:	36 fe       	sbrs	r3, 6
    349a:	0d c0       	rjmp	.+26     	; 0x34b6 <vfprintf+0x2ca>
    349c:	23 2d       	mov	r18, r3
    349e:	2e 7f       	andi	r18, 0xFE	; 254
    34a0:	a2 2e       	mov	r10, r18
    34a2:	89 14       	cp	r8, r9
    34a4:	58 f4       	brcc	.+22     	; 0x34bc <vfprintf+0x2d0>
    34a6:	34 fe       	sbrs	r3, 4
    34a8:	0b c0       	rjmp	.+22     	; 0x34c0 <vfprintf+0x2d4>
    34aa:	32 fc       	sbrc	r3, 2
    34ac:	09 c0       	rjmp	.+18     	; 0x34c0 <vfprintf+0x2d4>
    34ae:	83 2d       	mov	r24, r3
    34b0:	8e 7e       	andi	r24, 0xEE	; 238
    34b2:	a8 2e       	mov	r10, r24
    34b4:	05 c0       	rjmp	.+10     	; 0x34c0 <vfprintf+0x2d4>
    34b6:	b8 2c       	mov	r11, r8
    34b8:	a3 2c       	mov	r10, r3
    34ba:	03 c0       	rjmp	.+6      	; 0x34c2 <vfprintf+0x2d6>
    34bc:	b8 2c       	mov	r11, r8
    34be:	01 c0       	rjmp	.+2      	; 0x34c2 <vfprintf+0x2d6>
    34c0:	b9 2c       	mov	r11, r9
    34c2:	a4 fe       	sbrs	r10, 4
    34c4:	0f c0       	rjmp	.+30     	; 0x34e4 <vfprintf+0x2f8>
    34c6:	fe 01       	movw	r30, r28
    34c8:	e8 0d       	add	r30, r8
    34ca:	f1 1d       	adc	r31, r1
    34cc:	80 81       	ld	r24, Z
    34ce:	80 33       	cpi	r24, 0x30	; 48
    34d0:	21 f4       	brne	.+8      	; 0x34da <vfprintf+0x2ee>
    34d2:	9a 2d       	mov	r25, r10
    34d4:	99 7e       	andi	r25, 0xE9	; 233
    34d6:	a9 2e       	mov	r10, r25
    34d8:	09 c0       	rjmp	.+18     	; 0x34ec <vfprintf+0x300>
    34da:	a2 fe       	sbrs	r10, 2
    34dc:	06 c0       	rjmp	.+12     	; 0x34ea <vfprintf+0x2fe>
    34de:	b3 94       	inc	r11
    34e0:	b3 94       	inc	r11
    34e2:	04 c0       	rjmp	.+8      	; 0x34ec <vfprintf+0x300>
    34e4:	8a 2d       	mov	r24, r10
    34e6:	86 78       	andi	r24, 0x86	; 134
    34e8:	09 f0       	breq	.+2      	; 0x34ec <vfprintf+0x300>
    34ea:	b3 94       	inc	r11
    34ec:	a3 fc       	sbrc	r10, 3
    34ee:	11 c0       	rjmp	.+34     	; 0x3512 <vfprintf+0x326>
    34f0:	a0 fe       	sbrs	r10, 0
    34f2:	06 c0       	rjmp	.+12     	; 0x3500 <vfprintf+0x314>
    34f4:	b2 14       	cp	r11, r2
    34f6:	88 f4       	brcc	.+34     	; 0x351a <vfprintf+0x32e>
    34f8:	28 0c       	add	r2, r8
    34fa:	92 2c       	mov	r9, r2
    34fc:	9b 18       	sub	r9, r11
    34fe:	0e c0       	rjmp	.+28     	; 0x351c <vfprintf+0x330>
    3500:	b2 14       	cp	r11, r2
    3502:	60 f4       	brcc	.+24     	; 0x351c <vfprintf+0x330>
    3504:	b6 01       	movw	r22, r12
    3506:	80 e2       	ldi	r24, 0x20	; 32
    3508:	90 e0       	ldi	r25, 0x00	; 0
    350a:	0e 94 ed 1a 	call	0x35da	; 0x35da <fputc>
    350e:	b3 94       	inc	r11
    3510:	f7 cf       	rjmp	.-18     	; 0x3500 <vfprintf+0x314>
    3512:	b2 14       	cp	r11, r2
    3514:	18 f4       	brcc	.+6      	; 0x351c <vfprintf+0x330>
    3516:	2b 18       	sub	r2, r11
    3518:	02 c0       	rjmp	.+4      	; 0x351e <vfprintf+0x332>
    351a:	98 2c       	mov	r9, r8
    351c:	21 2c       	mov	r2, r1
    351e:	a4 fe       	sbrs	r10, 4
    3520:	10 c0       	rjmp	.+32     	; 0x3542 <vfprintf+0x356>
    3522:	b6 01       	movw	r22, r12
    3524:	80 e3       	ldi	r24, 0x30	; 48
    3526:	90 e0       	ldi	r25, 0x00	; 0
    3528:	0e 94 ed 1a 	call	0x35da	; 0x35da <fputc>
    352c:	a2 fe       	sbrs	r10, 2
    352e:	17 c0       	rjmp	.+46     	; 0x355e <vfprintf+0x372>
    3530:	a1 fc       	sbrc	r10, 1
    3532:	03 c0       	rjmp	.+6      	; 0x353a <vfprintf+0x34e>
    3534:	88 e7       	ldi	r24, 0x78	; 120
    3536:	90 e0       	ldi	r25, 0x00	; 0
    3538:	02 c0       	rjmp	.+4      	; 0x353e <vfprintf+0x352>
    353a:	88 e5       	ldi	r24, 0x58	; 88
    353c:	90 e0       	ldi	r25, 0x00	; 0
    353e:	b6 01       	movw	r22, r12
    3540:	0c c0       	rjmp	.+24     	; 0x355a <vfprintf+0x36e>
    3542:	8a 2d       	mov	r24, r10
    3544:	86 78       	andi	r24, 0x86	; 134
    3546:	59 f0       	breq	.+22     	; 0x355e <vfprintf+0x372>
    3548:	a1 fe       	sbrs	r10, 1
    354a:	02 c0       	rjmp	.+4      	; 0x3550 <vfprintf+0x364>
    354c:	8b e2       	ldi	r24, 0x2B	; 43
    354e:	01 c0       	rjmp	.+2      	; 0x3552 <vfprintf+0x366>
    3550:	80 e2       	ldi	r24, 0x20	; 32
    3552:	a7 fc       	sbrc	r10, 7
    3554:	8d e2       	ldi	r24, 0x2D	; 45
    3556:	b6 01       	movw	r22, r12
    3558:	90 e0       	ldi	r25, 0x00	; 0
    355a:	0e 94 ed 1a 	call	0x35da	; 0x35da <fputc>
    355e:	89 14       	cp	r8, r9
    3560:	38 f4       	brcc	.+14     	; 0x3570 <vfprintf+0x384>
    3562:	b6 01       	movw	r22, r12
    3564:	80 e3       	ldi	r24, 0x30	; 48
    3566:	90 e0       	ldi	r25, 0x00	; 0
    3568:	0e 94 ed 1a 	call	0x35da	; 0x35da <fputc>
    356c:	9a 94       	dec	r9
    356e:	f7 cf       	rjmp	.-18     	; 0x355e <vfprintf+0x372>
    3570:	8a 94       	dec	r8
    3572:	f3 01       	movw	r30, r6
    3574:	e8 0d       	add	r30, r8
    3576:	f1 1d       	adc	r31, r1
    3578:	80 81       	ld	r24, Z
    357a:	b6 01       	movw	r22, r12
    357c:	90 e0       	ldi	r25, 0x00	; 0
    357e:	0e 94 ed 1a 	call	0x35da	; 0x35da <fputc>
    3582:	81 10       	cpse	r8, r1
    3584:	f5 cf       	rjmp	.-22     	; 0x3570 <vfprintf+0x384>
    3586:	22 20       	and	r2, r2
    3588:	09 f4       	brne	.+2      	; 0x358c <vfprintf+0x3a0>
    358a:	42 ce       	rjmp	.-892    	; 0x3210 <vfprintf+0x24>
    358c:	b6 01       	movw	r22, r12
    358e:	80 e2       	ldi	r24, 0x20	; 32
    3590:	90 e0       	ldi	r25, 0x00	; 0
    3592:	0e 94 ed 1a 	call	0x35da	; 0x35da <fputc>
    3596:	2a 94       	dec	r2
    3598:	f6 cf       	rjmp	.-20     	; 0x3586 <vfprintf+0x39a>
    359a:	f6 01       	movw	r30, r12
    359c:	86 81       	ldd	r24, Z+6	; 0x06
    359e:	97 81       	ldd	r25, Z+7	; 0x07
    35a0:	02 c0       	rjmp	.+4      	; 0x35a6 <vfprintf+0x3ba>
    35a2:	8f ef       	ldi	r24, 0xFF	; 255
    35a4:	9f ef       	ldi	r25, 0xFF	; 255
    35a6:	2b 96       	adiw	r28, 0x0b	; 11
    35a8:	e2 e1       	ldi	r30, 0x12	; 18
    35aa:	0c 94 a3 1b 	jmp	0x3746	; 0x3746 <__epilogue_restores__>

000035ae <strnlen_P>:
    35ae:	fc 01       	movw	r30, r24
    35b0:	05 90       	lpm	r0, Z+
    35b2:	61 50       	subi	r22, 0x01	; 1
    35b4:	70 40       	sbci	r23, 0x00	; 0
    35b6:	01 10       	cpse	r0, r1
    35b8:	d8 f7       	brcc	.-10     	; 0x35b0 <strnlen_P+0x2>
    35ba:	80 95       	com	r24
    35bc:	90 95       	com	r25
    35be:	8e 0f       	add	r24, r30
    35c0:	9f 1f       	adc	r25, r31
    35c2:	08 95       	ret

000035c4 <strnlen>:
    35c4:	fc 01       	movw	r30, r24
    35c6:	61 50       	subi	r22, 0x01	; 1
    35c8:	70 40       	sbci	r23, 0x00	; 0
    35ca:	01 90       	ld	r0, Z+
    35cc:	01 10       	cpse	r0, r1
    35ce:	d8 f7       	brcc	.-10     	; 0x35c6 <strnlen+0x2>
    35d0:	80 95       	com	r24
    35d2:	90 95       	com	r25
    35d4:	8e 0f       	add	r24, r30
    35d6:	9f 1f       	adc	r25, r31
    35d8:	08 95       	ret

000035da <fputc>:
    35da:	0f 93       	push	r16
    35dc:	1f 93       	push	r17
    35de:	cf 93       	push	r28
    35e0:	df 93       	push	r29
    35e2:	fb 01       	movw	r30, r22
    35e4:	23 81       	ldd	r18, Z+3	; 0x03
    35e6:	21 fd       	sbrc	r18, 1
    35e8:	03 c0       	rjmp	.+6      	; 0x35f0 <fputc+0x16>
    35ea:	8f ef       	ldi	r24, 0xFF	; 255
    35ec:	9f ef       	ldi	r25, 0xFF	; 255
    35ee:	2c c0       	rjmp	.+88     	; 0x3648 <fputc+0x6e>
    35f0:	22 ff       	sbrs	r18, 2
    35f2:	16 c0       	rjmp	.+44     	; 0x3620 <fputc+0x46>
    35f4:	46 81       	ldd	r20, Z+6	; 0x06
    35f6:	57 81       	ldd	r21, Z+7	; 0x07
    35f8:	24 81       	ldd	r18, Z+4	; 0x04
    35fa:	35 81       	ldd	r19, Z+5	; 0x05
    35fc:	42 17       	cp	r20, r18
    35fe:	53 07       	cpc	r21, r19
    3600:	44 f4       	brge	.+16     	; 0x3612 <fputc+0x38>
    3602:	a0 81       	ld	r26, Z
    3604:	b1 81       	ldd	r27, Z+1	; 0x01
    3606:	9d 01       	movw	r18, r26
    3608:	2f 5f       	subi	r18, 0xFF	; 255
    360a:	3f 4f       	sbci	r19, 0xFF	; 255
    360c:	31 83       	std	Z+1, r19	; 0x01
    360e:	20 83       	st	Z, r18
    3610:	8c 93       	st	X, r24
    3612:	26 81       	ldd	r18, Z+6	; 0x06
    3614:	37 81       	ldd	r19, Z+7	; 0x07
    3616:	2f 5f       	subi	r18, 0xFF	; 255
    3618:	3f 4f       	sbci	r19, 0xFF	; 255
    361a:	37 83       	std	Z+7, r19	; 0x07
    361c:	26 83       	std	Z+6, r18	; 0x06
    361e:	14 c0       	rjmp	.+40     	; 0x3648 <fputc+0x6e>
    3620:	8b 01       	movw	r16, r22
    3622:	ec 01       	movw	r28, r24
    3624:	fb 01       	movw	r30, r22
    3626:	00 84       	ldd	r0, Z+8	; 0x08
    3628:	f1 85       	ldd	r31, Z+9	; 0x09
    362a:	e0 2d       	mov	r30, r0
    362c:	09 95       	icall
    362e:	89 2b       	or	r24, r25
    3630:	e1 f6       	brne	.-72     	; 0x35ea <fputc+0x10>
    3632:	d8 01       	movw	r26, r16
    3634:	16 96       	adiw	r26, 0x06	; 6
    3636:	8d 91       	ld	r24, X+
    3638:	9c 91       	ld	r25, X
    363a:	17 97       	sbiw	r26, 0x07	; 7
    363c:	01 96       	adiw	r24, 0x01	; 1
    363e:	17 96       	adiw	r26, 0x07	; 7
    3640:	9c 93       	st	X, r25
    3642:	8e 93       	st	-X, r24
    3644:	16 97       	sbiw	r26, 0x06	; 6
    3646:	ce 01       	movw	r24, r28
    3648:	df 91       	pop	r29
    364a:	cf 91       	pop	r28
    364c:	1f 91       	pop	r17
    364e:	0f 91       	pop	r16
    3650:	08 95       	ret

00003652 <__ultoa_invert>:
    3652:	fa 01       	movw	r30, r20
    3654:	aa 27       	eor	r26, r26
    3656:	28 30       	cpi	r18, 0x08	; 8
    3658:	51 f1       	breq	.+84     	; 0x36ae <__ultoa_invert+0x5c>
    365a:	20 31       	cpi	r18, 0x10	; 16
    365c:	81 f1       	breq	.+96     	; 0x36be <__ultoa_invert+0x6c>
    365e:	e8 94       	clt
    3660:	6f 93       	push	r22
    3662:	6e 7f       	andi	r22, 0xFE	; 254
    3664:	6e 5f       	subi	r22, 0xFE	; 254
    3666:	7f 4f       	sbci	r23, 0xFF	; 255
    3668:	8f 4f       	sbci	r24, 0xFF	; 255
    366a:	9f 4f       	sbci	r25, 0xFF	; 255
    366c:	af 4f       	sbci	r26, 0xFF	; 255
    366e:	b1 e0       	ldi	r27, 0x01	; 1
    3670:	3e d0       	rcall	.+124    	; 0x36ee <__ultoa_invert+0x9c>
    3672:	b4 e0       	ldi	r27, 0x04	; 4
    3674:	3c d0       	rcall	.+120    	; 0x36ee <__ultoa_invert+0x9c>
    3676:	67 0f       	add	r22, r23
    3678:	78 1f       	adc	r23, r24
    367a:	89 1f       	adc	r24, r25
    367c:	9a 1f       	adc	r25, r26
    367e:	a1 1d       	adc	r26, r1
    3680:	68 0f       	add	r22, r24
    3682:	79 1f       	adc	r23, r25
    3684:	8a 1f       	adc	r24, r26
    3686:	91 1d       	adc	r25, r1
    3688:	a1 1d       	adc	r26, r1
    368a:	6a 0f       	add	r22, r26
    368c:	71 1d       	adc	r23, r1
    368e:	81 1d       	adc	r24, r1
    3690:	91 1d       	adc	r25, r1
    3692:	a1 1d       	adc	r26, r1
    3694:	20 d0       	rcall	.+64     	; 0x36d6 <__ultoa_invert+0x84>
    3696:	09 f4       	brne	.+2      	; 0x369a <__ultoa_invert+0x48>
    3698:	68 94       	set
    369a:	3f 91       	pop	r19
    369c:	2a e0       	ldi	r18, 0x0A	; 10
    369e:	26 9f       	mul	r18, r22
    36a0:	11 24       	eor	r1, r1
    36a2:	30 19       	sub	r19, r0
    36a4:	30 5d       	subi	r19, 0xD0	; 208
    36a6:	31 93       	st	Z+, r19
    36a8:	de f6       	brtc	.-74     	; 0x3660 <__ultoa_invert+0xe>
    36aa:	cf 01       	movw	r24, r30
    36ac:	08 95       	ret
    36ae:	46 2f       	mov	r20, r22
    36b0:	47 70       	andi	r20, 0x07	; 7
    36b2:	40 5d       	subi	r20, 0xD0	; 208
    36b4:	41 93       	st	Z+, r20
    36b6:	b3 e0       	ldi	r27, 0x03	; 3
    36b8:	0f d0       	rcall	.+30     	; 0x36d8 <__ultoa_invert+0x86>
    36ba:	c9 f7       	brne	.-14     	; 0x36ae <__ultoa_invert+0x5c>
    36bc:	f6 cf       	rjmp	.-20     	; 0x36aa <__ultoa_invert+0x58>
    36be:	46 2f       	mov	r20, r22
    36c0:	4f 70       	andi	r20, 0x0F	; 15
    36c2:	40 5d       	subi	r20, 0xD0	; 208
    36c4:	4a 33       	cpi	r20, 0x3A	; 58
    36c6:	18 f0       	brcs	.+6      	; 0x36ce <__ultoa_invert+0x7c>
    36c8:	49 5d       	subi	r20, 0xD9	; 217
    36ca:	31 fd       	sbrc	r19, 1
    36cc:	40 52       	subi	r20, 0x20	; 32
    36ce:	41 93       	st	Z+, r20
    36d0:	02 d0       	rcall	.+4      	; 0x36d6 <__ultoa_invert+0x84>
    36d2:	a9 f7       	brne	.-22     	; 0x36be <__ultoa_invert+0x6c>
    36d4:	ea cf       	rjmp	.-44     	; 0x36aa <__ultoa_invert+0x58>
    36d6:	b4 e0       	ldi	r27, 0x04	; 4
    36d8:	a6 95       	lsr	r26
    36da:	97 95       	ror	r25
    36dc:	87 95       	ror	r24
    36de:	77 95       	ror	r23
    36e0:	67 95       	ror	r22
    36e2:	ba 95       	dec	r27
    36e4:	c9 f7       	brne	.-14     	; 0x36d8 <__ultoa_invert+0x86>
    36e6:	00 97       	sbiw	r24, 0x00	; 0
    36e8:	61 05       	cpc	r22, r1
    36ea:	71 05       	cpc	r23, r1
    36ec:	08 95       	ret
    36ee:	9b 01       	movw	r18, r22
    36f0:	ac 01       	movw	r20, r24
    36f2:	0a 2e       	mov	r0, r26
    36f4:	06 94       	lsr	r0
    36f6:	57 95       	ror	r21
    36f8:	47 95       	ror	r20
    36fa:	37 95       	ror	r19
    36fc:	27 95       	ror	r18
    36fe:	ba 95       	dec	r27
    3700:	c9 f7       	brne	.-14     	; 0x36f4 <__ultoa_invert+0xa2>
    3702:	62 0f       	add	r22, r18
    3704:	73 1f       	adc	r23, r19
    3706:	84 1f       	adc	r24, r20
    3708:	95 1f       	adc	r25, r21
    370a:	a0 1d       	adc	r26, r0
    370c:	08 95       	ret

0000370e <__prologue_saves__>:
    370e:	2f 92       	push	r2
    3710:	3f 92       	push	r3
    3712:	4f 92       	push	r4
    3714:	5f 92       	push	r5
    3716:	6f 92       	push	r6
    3718:	7f 92       	push	r7
    371a:	8f 92       	push	r8
    371c:	9f 92       	push	r9
    371e:	af 92       	push	r10
    3720:	bf 92       	push	r11
    3722:	cf 92       	push	r12
    3724:	df 92       	push	r13
    3726:	ef 92       	push	r14
    3728:	ff 92       	push	r15
    372a:	0f 93       	push	r16
    372c:	1f 93       	push	r17
    372e:	cf 93       	push	r28
    3730:	df 93       	push	r29
    3732:	cd b7       	in	r28, 0x3d	; 61
    3734:	de b7       	in	r29, 0x3e	; 62
    3736:	ca 1b       	sub	r28, r26
    3738:	db 0b       	sbc	r29, r27
    373a:	0f b6       	in	r0, 0x3f	; 63
    373c:	f8 94       	cli
    373e:	de bf       	out	0x3e, r29	; 62
    3740:	0f be       	out	0x3f, r0	; 63
    3742:	cd bf       	out	0x3d, r28	; 61
    3744:	09 94       	ijmp

00003746 <__epilogue_restores__>:
    3746:	2a 88       	ldd	r2, Y+18	; 0x12
    3748:	39 88       	ldd	r3, Y+17	; 0x11
    374a:	48 88       	ldd	r4, Y+16	; 0x10
    374c:	5f 84       	ldd	r5, Y+15	; 0x0f
    374e:	6e 84       	ldd	r6, Y+14	; 0x0e
    3750:	7d 84       	ldd	r7, Y+13	; 0x0d
    3752:	8c 84       	ldd	r8, Y+12	; 0x0c
    3754:	9b 84       	ldd	r9, Y+11	; 0x0b
    3756:	aa 84       	ldd	r10, Y+10	; 0x0a
    3758:	b9 84       	ldd	r11, Y+9	; 0x09
    375a:	c8 84       	ldd	r12, Y+8	; 0x08
    375c:	df 80       	ldd	r13, Y+7	; 0x07
    375e:	ee 80       	ldd	r14, Y+6	; 0x06
    3760:	fd 80       	ldd	r15, Y+5	; 0x05
    3762:	0c 81       	ldd	r16, Y+4	; 0x04
    3764:	1b 81       	ldd	r17, Y+3	; 0x03
    3766:	aa 81       	ldd	r26, Y+2	; 0x02
    3768:	b9 81       	ldd	r27, Y+1	; 0x01
    376a:	ce 0f       	add	r28, r30
    376c:	d1 1d       	adc	r29, r1
    376e:	0f b6       	in	r0, 0x3f	; 63
    3770:	f8 94       	cli
    3772:	de bf       	out	0x3e, r29	; 62
    3774:	0f be       	out	0x3f, r0	; 63
    3776:	cd bf       	out	0x3d, r28	; 61
    3778:	ed 01       	movw	r28, r26
    377a:	08 95       	ret

0000377c <_exit>:
    377c:	f8 94       	cli

0000377e <__stop_program>:
    377e:	ff cf       	rjmp	.-2      	; 0x377e <__stop_program>
